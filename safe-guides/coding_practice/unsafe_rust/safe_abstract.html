<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>安全抽象 - RustCodingGuidelines</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../../favicon.png">
        
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        
        <link rel="stylesheet" href="../../../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><li class="part-title">介绍</li><li class="chapter-item "><a href="../../../index.html"><strong aria-hidden="true">1.</strong> Rust 编码规范介绍</a></li><li class="chapter-item "><a href="../../../contribution.html"><strong aria-hidden="true">2.</strong> 贡献说明</a></li><li class="chapter-item affix "><li class="part-title">安全编码规范</li><li class="chapter-item "><a href="../../../safe-guides/intro.html"><strong aria-hidden="true">3.</strong> 前言</a></li><li class="chapter-item "><a href="../../../safe-guides/dev_env.html"><strong aria-hidden="true">4.</strong> 开发环境</a></li><li class="chapter-item "><a href="../../../safe-guides/code_style.html"><strong aria-hidden="true">5.</strong> 代码风格</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../safe-guides/code_style/naming.html"><strong aria-hidden="true">5.1.</strong> 命名</a></li><li class="chapter-item "><a href="../../../safe-guides/code_style/fmt.html"><strong aria-hidden="true">5.2.</strong> 格式</a></li><li class="chapter-item "><a href="../../../safe-guides/code_style/comments.html"><strong aria-hidden="true">5.3.</strong> 注释</a></li></ol></li><li class="chapter-item expanded "><a href="../../../safe-guides/coding_practice.html"><strong aria-hidden="true">6.</strong> 编程实践</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../safe-guides/coding_practice/consts.html"><strong aria-hidden="true">6.1.</strong> 常量</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/statics.html"><strong aria-hidden="true">6.2.</strong> 静态变量</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/variables.html"><strong aria-hidden="true">6.3.</strong> 本地变量</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/data-type.html"><strong aria-hidden="true">6.4.</strong> 数据类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../safe-guides/coding_practice/data-type/unit.html"><strong aria-hidden="true">6.4.1.</strong> 单元类型</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/data-type/bool.html"><strong aria-hidden="true">6.4.2.</strong> 布尔</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/data-type/char.html"><strong aria-hidden="true">6.4.3.</strong> 字符</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/data-type/int.html"><strong aria-hidden="true">6.4.4.</strong> 整数</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/data-type/float.html"><strong aria-hidden="true">6.4.5.</strong> 浮点数</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/data-type/ref.html"><strong aria-hidden="true">6.4.6.</strong> 引用</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/data-type/slice.html"><strong aria-hidden="true">6.4.7.</strong> 切片</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/data-type/tuple.html"><strong aria-hidden="true">6.4.8.</strong> 元组</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/data-type/array.html"><strong aria-hidden="true">6.4.9.</strong> 固定长度数组</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/data-type/vec.html"><strong aria-hidden="true">6.4.10.</strong> 动态数组</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/data-type/struct.html"><strong aria-hidden="true">6.4.11.</strong> 结构体</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/data-type/enum.html"><strong aria-hidden="true">6.4.12.</strong> 枚举体</a></li></ol></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/expr.html"><strong aria-hidden="true">6.5.</strong> 表达式</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/control-flow.html"><strong aria-hidden="true">6.6.</strong> 流程控制</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/strings.html"><strong aria-hidden="true">6.7.</strong> 字符串</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/collections.html"><strong aria-hidden="true">6.8.</strong> 集合容器</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/fn-and-closure.html"><strong aria-hidden="true">6.9.</strong> 函数与闭包</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/generic.html"><strong aria-hidden="true">6.10.</strong> 泛型</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/traits.html"><strong aria-hidden="true">6.11.</strong> 特质</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../safe-guides/coding_practice/traits/std-buildin.html"><strong aria-hidden="true">6.11.1.</strong> 标准库内置 trait</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/traits/trait-object.html"><strong aria-hidden="true">6.11.2.</strong> trait 对象</a></li></ol></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/error-handle.html"><strong aria-hidden="true">6.12.</strong> 错误处理</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/memory.html"><strong aria-hidden="true">6.13.</strong> 内存管理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../safe-guides/coding_practice/memory/lifetime.html"><strong aria-hidden="true">6.13.1.</strong> 生存期</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/memory/box.html"><strong aria-hidden="true">6.13.2.</strong> Box&lt;T&gt;</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/memory/drop.html"><strong aria-hidden="true">6.13.3.</strong> Drop 析构</a></li></ol></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/module.html"><strong aria-hidden="true">6.14.</strong> 模块</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/cargo.html"><strong aria-hidden="true">6.15.</strong> 包管理</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/macros.html"><strong aria-hidden="true">6.16.</strong> 宏</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../safe-guides/coding_practice/macros/declarative.html"><strong aria-hidden="true">6.16.1.</strong> 声明宏</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/macros/procedural.html"><strong aria-hidden="true">6.16.2.</strong> 过程宏</a></li></ol></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/threads.html"><strong aria-hidden="true">6.17.</strong> 多线程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../safe-guides/coding_practice/threads/lock.html"><strong aria-hidden="true">6.17.1.</strong> 锁同步</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/threads/lock-free.html"><strong aria-hidden="true">6.17.2.</strong> 无锁</a></li></ol></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/async-await.html"><strong aria-hidden="true">6.18.</strong> 异步编程</a></li><li class="chapter-item expanded "><a href="../../../safe-guides/coding_practice/unsafe_rust.html"><strong aria-hidden="true">6.19.</strong> Unsafe Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../safe-guides/coding_practice/unsafe_rust/safe_abstract.html" class="active"><strong aria-hidden="true">6.19.1.</strong> 安全抽象</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/unsafe_rust/raw_ptr.html"><strong aria-hidden="true">6.19.2.</strong> 裸指针操作</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/unsafe_rust/union.html"><strong aria-hidden="true">6.19.3.</strong> 联合体</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/unsafe_rust/mem.html"><strong aria-hidden="true">6.19.4.</strong> 内存</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/unsafe_rust/ffi.html"><strong aria-hidden="true">6.19.5.</strong> FFi 规范</a></li></ol></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/no-std.html"><strong aria-hidden="true">6.20.</strong> no-std</a></li><li class="chapter-item "><a href="../../../safe-guides/coding_practice/others.html"><strong aria-hidden="true">6.21.</strong> 其他</a></li></ol></li><li class="chapter-item "><a href="../../../safe-guides/Appendix/toc.html"><strong aria-hidden="true">7.</strong> 附录</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../safe-guides/Appendix/test.html"><strong aria-hidden="true">7.1.</strong> 测试</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../safe-guides/Appendix/test/unit_test.html"><strong aria-hidden="true">7.1.1.</strong> 单元测试</a></li><li class="chapter-item "><a href="../../../safe-guides/Appendix/test/benchmark.html"><strong aria-hidden="true">7.1.2.</strong> 基准测试</a></li><li class="chapter-item "><a href="../../../safe-guides/Appendix/test/fuzz.html"><strong aria-hidden="true">7.1.3.</strong> 模糊测试</a></li></ol></li><li class="chapter-item "><a href="../../../safe-guides/Appendix/terms.html"><strong aria-hidden="true">7.2.</strong> 术语解释</a></li><li class="chapter-item "><a href="../../../safe-guides/Appendix/templates/intro.html"><strong aria-hidden="true">7.3.</strong> 模板</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../safe-guides/Appendix/templates/rustfmt.toml.html"><strong aria-hidden="true">7.3.1.</strong> rustfmt 模板</a></li><li class="chapter-item "><a href="../../../safe-guides/Appendix/templates/clippy.toml.html"><strong aria-hidden="true">7.3.2.</strong> clippy 模板</a></li><li class="chapter-item "><a href="../../../safe-guides/Appendix/templates/deny.toml.html"><strong aria-hidden="true">7.3.3.</strong> deny 模板</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">领域最佳实践</li><li class="chapter-item "><a href="../../../best-practices/intro.html"><strong aria-hidden="true">8.</strong> 介绍</a></li><li class="chapter-item "><a href="../../../best-practices/embedded.html"><strong aria-hidden="true">9.</strong> 嵌入式 Rust</a></li><li class="chapter-item "><a href="../../../best-practices/databases.html"><strong aria-hidden="true">10.</strong> 数据库</a></li><li class="chapter-item "><a href="../../../best-practices/games.html"><strong aria-hidden="true">11.</strong> 游戏</a></li><li class="chapter-item "><a href="../../../best-practices/cli_app.html"><strong aria-hidden="true">12.</strong> Cli App</a></li><li class="chapter-item "><a href="../../../best-practices/gui.html"><strong aria-hidden="true">13.</strong> GUI</a></li><li class="chapter-item "><a href="../../../best-practices/web.html"><strong aria-hidden="true">14.</strong> Web 开发</a></li><li class="chapter-item "><a href="../../../best-practices/networks.html"><strong aria-hidden="true">15.</strong> 网络服务</a></li><li class="chapter-item "><a href="../../../best-practices/webassembly.html"><strong aria-hidden="true">16.</strong> WebAssembly</a></li><li class="chapter-item affix "><li class="part-title">Cheat Sheet</li><li class="chapter-item "><a href="../../../cheat-sheet/index.html"><strong aria-hidden="true">17.</strong> 介绍</a></li><li class="chapter-item affix "><li class="part-title">工具链使用指南</li><li class="chapter-item "><a href="../../../tools/intro.html"><strong aria-hidden="true">18.</strong> 介绍</a></li><li class="chapter-item "><a href="../../../tools/rustfmt.html"><strong aria-hidden="true">19.</strong> Rustfmt 配置相关说明</a></li><li class="chapter-item affix "><li class="part-title">Rust 优化指南</li><li class="chapter-item "><a href="../../../optimizing/intro.html"><strong aria-hidden="true">20.</strong> 介绍</a></li><li class="chapter-item affix "><li class="part-title">Rust 常用基础库指南</li><li class="chapter-item "><a href="../../../libs/intro.html"><strong aria-hidden="true">21.</strong> 介绍</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">RustCodingGuidelines</h1>

                    <div class="right-buttons">
                        
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/Rust-Coding-Guidelines/rust-coding-guidelines-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#安全抽象规范" id="安全抽象规范">安全抽象规范</a></h1>
<p>使用 Unsafe Rust 的一种方式是将 Unsafe 的方法或函数进行安全抽象，将其变成安全的方法或函数。</p>
<p>Unsafe Rust 中 API 的安全性设计通常有两种方式：</p>
<ol>
<li>将内部的 unsafe API 直接暴露给 API 的使用者，并且使用 <code>unsafe</code> 关键字来声明该 API 是非安全的，同时也需要对安全边界条件添加注释。</li>
<li>对 API 进行安全封装，即，安全抽象。在内部使用断言来保证当越过安全边界时可以 Panic，从而避免 UB 产生。</li>
</ol>
<p>第二种方式，对 Unsafe 代码进行安全抽象，是 Rust 生态的一种约定俗成。</p>
<hr />
<h2><a class="header" href="#punssafeabstract01---代码中要注意是否会因为恐慌panic发生而导致内存安全问题" id="punssafeabstract01---代码中要注意是否会因为恐慌panic发生而导致内存安全问题">P.UNS.SafeAbstract.01   代码中要注意是否会因为恐慌（Panic）发生而导致内存安全问题</a></h2>
<p><strong>【描述】</strong></p>
<p>恐慌一般在程序达到不可恢复的状态才用，当然在 Rust 中也可以对一些实现了 <code>UnwindSafe</code> trait 的类型捕获恐慌。</p>
<p>当 Panic 发生时，会引发栈回退（stack unwind），调用栈分配对象的析构函数，并将控制流转移给恐慌处理程序中。所以，当恐慌发生的时候，当前存活变量的析构函数将会被调用，从而导致一些内存安全问题，比如释放已经释放过的内存。</p>
<p>通常， 封装的Unsafe 代码可能会暂时绕过所有权检查，而且，安全封装的 API 在内部unsafe 代码的值返回之前，会根据安全边界条件确保它不会违反安全规则。但是，假如封装的Unsafe 代码发生了恐慌，则其外部安全检查可能不会执行。这很可能导致类似 C/C++ 中 未初始化（Uninitialized ）或双重释放（Double Free）的内存不安全问题。</p>
<p>想要正确的推理在 Unsafe 代码中的恐慌安全，是非常困难且易于出错的。即便如此，在编写代码的时候也要刻意注意此类问题发生的可能性。</p>
<p>【示例】</p>
<pre><pre class="playground"><code class="language-rust">// 标准库 `String::retain()` 曝出的 CVE-2020-36317 Panic safety bug

pub fn retain&lt;F&gt;(&amp;mut self, mut f: F)
where 
    F: FnMut(char) -&gt; bool
{
    let len = self.len();
    let mut del_bytes = 0;
 	let mut idx = 0;
 
    unsafe { self.vec.set_len(0); }    // + 修复bug 的代码
 	while idx &lt; len {
 		let ch = unsafe {
  			self.get_unchecked(idx..len).chars().next().unwrap()
 		};
 		let ch_len = ch.len_utf8();
 
 		// self is left in an inconsistent state if f() panics
        // 此处如果 f() 发生了恐慌，self 的长度就会不一致
 		if !f(ch) {
 			del_bytes += ch_len;
 		} else if del_bytes &gt; 0 {
 			unsafe {
 				ptr::copy(self.vec.as_ptr().add(idx),
 				self.vec.as_mut_ptr().add(idx - del_bytes),
 				ch_len);
 			}
 		}
 		idx += ch_len; // point idx to the next char
 	}
 	unsafe { self.vec.set_len(len - del_bytes); } // + 修复bug 的代码 ，如果 while 里发生panic，则将返回长度设置为 0 
}

fn main(){
    // PoC: creates a non-utf-8 string in the unwinding path
    // 此处传入一个 非 UTF-8 编码字符串引发恐慌
    &quot;0è0&quot;.to_string().retain(|_| {
        match the_number_of_invocation() {
            1 =&gt; false,
            2 =&gt; true,
            _ =&gt; panic!(),
        }
    });
}
</code></pre></pre>
<h2><a class="header" href="#punssafeabstract02----unsafe-代码编写者有义务检查代码是否满足安全不变式" id="punssafeabstract02----unsafe-代码编写者有义务检查代码是否满足安全不变式">P.UNS.SafeAbstract.02    Unsafe 代码编写者有义务检查代码是否满足安全不变式</a></h2>
<p><strong>【描述】</strong></p>
<p>安全不变式（见 <a href="./glossary.html">Unsafe 代码术语指南</a> ）是 Rust 里的安全函数，在任何有效输入的情况下，都不应该发生任何未定义行为。</p>
<p>可以从以下三个方面来检查：</p>
<ol>
<li>逻辑一致性。</li>
<li>纯洁性。相同的输入总是要返回相同的输出。</li>
<li>语义约束。传入的参数要合法，满足数据类型。</li>
</ol>
<p>【示例】</p>
<p>该代码是为 <code>Borrow&lt;str&gt;</code>实现 join 方法内部调用的一个函数 <code>join_generic_copy</code>的展示。 在 <code>join_generic_copy</code> 内部，会对 <code>slice</code> 进行两次转换，而在 <code>spezialize_for_lengths!</code> 宏内部，调用了<code>.borrow()</code>方法，如果第二次转换和第一次不一样，而会返回一个未初始化字节的字符串。</p>
<p>这里， <code>Borrow&lt;B&gt;</code> 是高阶类型，它内部 <code>borrow</code> 的一致性其实并没有保证，可能会返回不同的slice，如果不做处理，很可能会暴露出未初始化的字节给调用者。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// CVE-2020-36323: a higher-order invariant bug in join()
fn join_generic_copy&lt;B, T, S&gt;(slice: &amp;[S], sep: &amp;[T]) -&gt; Vec&lt;T&gt; 
where T: Copy, B: AsRef&lt;[T]&gt; + ?Sized, S: Borrow&lt;B&gt;
{
    let mut iter = slice.iter();

    // `slice`is converted for the first time
    // during the buffer size calculation.
    let len = ...;  // `slice` 在这里第一次被转换	
    let mut result = Vec::with_capacity(len);
    // ...
    unsafe {
        let pos = result.len();
        let target = result.get_unchecked_mut(pos..len);
 
        // `slice`is converted for the second time in macro
        // while copying the rest of the components.
        spezialize_for_lengths!(sep, target, iter; // `slice` 第二次被转换
        0, 1, 2, 3, 4);
 
        // Indicate that the vector is initialized
        result.set_len(len);
    }
    result
}

// PoC: a benign join() can trigger a memory safety issue
impl Borrow&lt;str&gt; for InconsistentBorrow {
    fn borrow(&amp;self) -&gt; &amp;str {
        if self.is_first_time() {
            &quot;123456&quot;
        } else {
            &quot;0&quot;
        }
    }
}

let arr: [InconsistentBorrow; 3] = Default::default();
arr.join(&quot;-&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#punssafeabstract03----unsafe-代码中手动实现-auto-trait-需要注意" id="punssafeabstract03----unsafe-代码中手动实现-auto-trait-需要注意">P.UNS.SafeAbstract.03    Unsafe 代码中手动实现 auto trait 需要注意</a></h2>
<p><strong>【描述】</strong></p>
<p>所谓 auto trait 是指 Safe Rust中由编译器自动实现的 trait，比如 <code>Send/Sync</code> 。在 Unsafe Rust中就需要手动实现这俩 trait 了。</p>
<p>所以，在手动实现的时候要充分考虑其安全性。</p>
<p>【示例】</p>
<p>Rust futures 库中发现的问题，错误的手工 <code>Send/Sync</code>实现 破坏了线程安全保证。</p>
<p>受影响的版本中，<code>MappedMutexGuard</code>的<code>Send/Sync</code>实现只考虑了<code>T</code>上的差异，而<code>MappedMutexGuard</code>则取消了对<code>U</code>的引用。</p>
<p>当<code>MutexGuard::map()</code>中使用的闭包返回与<code>T</code>无关的<code>U</code>时，这可能导致安全Rust代码中的数据竞争。</p>
<p>这个问题通过修正<code>Send/Sync</code>的实现，以及在<code>MappedMutexGuard</code>类型中添加一个<code>PhantomData&lt;&amp;'a mut U&gt;</code>标记来告诉编译器，这个防护也是在U之上。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// CVE-2020-35905: incorrect uses of Send/Sync on Rust's futures
pub struct MappedMutexGuard&lt;'a, T: ?Sized, U: ?Sized&gt; {
    mutex: &amp;'a Mutex&lt;T&gt;,
    value: *mut U,
    _marker: PhantomData&lt;&amp;'a mut U&gt;, // + 修复代码
}

impl&lt;'a, T: ?Sized&gt; MutexGuard&lt;'a, T&gt; {
    pub fn map&lt;U: ?Sized, F&gt;(this: Self, f: F)
        -&gt; MappedMutexGuard&lt;'a, T, U&gt;
        where F: FnOnce(&amp;mut T) -&gt; &amp;mut U {
            let mutex = this.mutex;
            let value = f(unsafe { &amp;mut *this.mutex.value.get() });
                mem::forget(this);
                // MappedMutexGuard { mutex, value }
                MappedMutexGuard { mutex, value, _marker: PhantomData } //  + 修复代码
    }
}

// unsafe impl&lt;T: ?Sized + Send, U: ?Sized&gt; Send
unsafe impl&lt;T: ?Sized + Send, U: ?Sized + Send&gt; Send // + 修复代码
for MappedMutexGuard&lt;'_, T, U&gt; {}
//unsafe impl&lt;T: ?Sized + Sync, U: ?Sized&gt; Sync
unsafe impl&lt;T: ?Sized + Sync, U: ?Sized + Sync&gt; Sync // + 修复代码
for MappedMutexGuard&lt;'_, T, U&gt; {}

// PoC: this safe Rust code allows race on reference counter
* MutexGuard::map(guard, |_| Box::leak(Box::new(Rc::new(true))));
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#punssafeabstract04----不要随便在公开的-api-中暴露裸指针" id="punssafeabstract04----不要随便在公开的-api-中暴露裸指针">P.UNS.SafeAbstract.04    不要随便在公开的 API 中暴露裸指针</a></h2>
<p><strong>【描述】</strong></p>
<p>在公开的API中暴露裸指针，可能会被用户修改为空指针，从而有段错误风险。</p>
<p>【示例】</p>
<pre><pre class="playground"><code class="language-rust">use cache;


/**

    `cache crate` 内部代码：

    ```rust
    pub enum Cached&lt;'a, V: 'a&gt; {
        /// Value could not be put on the cache, and is returned in a box
        /// as to be able to implement `StableDeref`
        Spilled(Box&lt;V&gt;),
        /// Value resides in cache and is read-locked.
        Cached {
            /// The readguard from a lock on the heap
            guard: RwLockReadGuard&lt;'a, ()&gt;,
            /// A pointer to a value on the heap
            // 漏洞风险
            ptr: *const ManuallyDrop&lt;V&gt;,
        },
        /// A value that was borrowed from outside the cache.
        Borrowed(&amp;'a V),
    }

    ```
**/
fn main() {
    let c = cache::Cache::new(8, 4096);
    c.insert(1, String::from(&quot;test&quot;));
    let mut e = c.get::&lt;String&gt;(&amp;1).unwrap();

    match &amp;mut e {
        cache::Cached::Cached { ptr, .. } =&gt; {
            // 将 ptr 设置为 空指针，导致段错误
            *ptr = std::ptr::null();
        },
        _ =&gt; panic!(),
    }
    // 输出：3851，段错误
    println!(&quot;Entry: {}&quot;, *e);
}
</code></pre></pre>
<h2><a class="header" href="#punssafeabstract04----不要随便在公开的-api-中暴露未初始化内存" id="punssafeabstract04----不要随便在公开的-api-中暴露未初始化内存">P.UNS.SafeAbstract.04    不要随便在公开的 API 中暴露未初始化内存</a></h2>
<p><strong>【描述】</strong></p>
<p>在公开的API中暴露未初始化内存可能导致 UB。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 修正以后的代码示例，去掉了未初始化的buf：
impl&lt;R&gt; BufRead for GreedyAccessReader&lt;R&gt;
    where
        R: Read,
{
    fn fill_buf(&amp;mut self) -&gt; IoResult&lt;&amp;[u8]&gt; {
        if self.buf.capacity() == self.consumed {
            self.reserve_up_to(self.buf.capacity() + 16);
        }

        let b = self.buf.len();
        self.buf.resize(self.buf.capacity(), 0);
        let buf = &amp;mut self.buf[b..];
        let o = self.inner.read(buf)?;

        // truncate to exclude non-written portion
        self.buf.truncate(b + o);

        Ok(&amp;self.buf[self.consumed..])
    }

    fn consume(&amp;mut self, amt: usize) {
        self.consumed += amt;
    }
}

// 另外一个已修正漏洞的代码
fn read_vec(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let len: u32 = de::Deserialize::deserialize(&amp;mut *self)?;
    // 创建了未初始化buf
    let mut buf = Vec::with_capacity(len as usize);
    // 初始化为 0；
    buf.resize(len as usize, 0);
    self.read_size(u64::from(len))?;
    // 将其传递给了用户提供的`Read`实现
    self.reader.read_exact(&amp;mut buf[..])?;
    Ok(buf)
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 以下是有安全风险的代码示例：
impl&lt;R&gt; BufRead for GreedyAccessReader&lt;R&gt;
    where
        R: Read,
{
    fn fill_buf(&amp;mut self) -&gt; IoResult&lt;&amp;[u8]&gt; {
        if self.buf.capacity() == self.consumed {
            self.reserve_up_to(self.buf.capacity() + 16);
        }

        let b = self.buf.len();
        let buf = unsafe {
            // safe because it's within the buffer's limits
            // and we won't be reading uninitialized memory
            // 这里虽然没有读取未初始化内存，但是会导致用户读取
            std::slice::from_raw_parts_mut(
                self.buf.as_mut_ptr().offset(b as isize),
                self.buf.capacity() - b)
        };

        match self.inner.read(buf) {
            Ok(o) =&gt; {
                unsafe {
                    // reset the size to include the written portion,
                    // safe because the extra data is initialized
                    self.buf.set_len(b + o);
                }

                Ok(&amp;self.buf[self.consumed..])
            }
            Err(e) =&gt; Err(e),
        }
    }

    fn consume(&amp;mut self, amt: usize) {
        self.consumed += amt;
    }
}

// 另外一个漏洞代码
fn read_vec(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let len: u32 = de::Deserialize::deserialize(&amp;mut *self)?;
    // 创建了未初始化buf
    let mut buf = Vec::with_capacity(len as usize);
    unsafe { buf.set_len(len as usize) }
    self.read_size(u64::from(len))?;
    // 将其传递给了用户提供的`Read`实现
    self.reader.read_exact(&amp;mut buf[..])?;
    Ok(buf)
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#punssafeabstract05---要考虑-panic-safety-的情况" id="punssafeabstract05---要考虑-panic-safety-的情况">P.UNS.SafeAbstract.05   要考虑 Panic Safety 的情况</a></h2>
<p><strong>【描述】</strong></p>
<p>要注意 Panic Safety 的情况，避免双重释放（double free）的问题发生。</p>
<p>在使用 <code>std::ptr</code> 模块中接口需要注意，容易产生 UB 问题，要多多查看 API 文档。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! from_event_option_array_into_event_list(
    ($e:ty, $len:expr) =&gt; (
        impl&lt;'e&gt; From&lt;[Option&lt;$e&gt;; $len]&gt; for EventList {
            fn from(events: [Option&lt;$e&gt;; $len]) -&gt; EventList {
                let mut el = ManuallyDrop::new(
                    EventList::with_capacity(events.len())
                );

                for idx in 0..events.len() {
                    let event_opt = unsafe {
                        ptr::read(events.get_unchecked(idx))
                    };

                    if let Some(event) = event_opt {
                        // Use `ManuallyDrop` to guard against
                        // potential panic within `into()`.
                        // 当 into 方法发生 panic 当时候，这里 ManuallyDrop 可以保护其不会`double free`
                        let event = ManuallyDrop::into_inner(
                            ManuallyDrop::new(event)
                            .into()
                        );
                        el.push(event);
                    }
                }
                mem::forget(events);
                ManuallyDrop::into_inner(el)
            }
        }
    )
);
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//case 1
macro_rules! from_event_option_array_into_event_list(
    ($e:ty, $len:expr) =&gt; (
        impl&lt;'e&gt; From&lt;[Option&lt;$e&gt;; $len]&gt; for EventList {
                fn from(events: [Option&lt;$e&gt;; $len]) -&gt; EventList {
                    let mut el = EventList::with_capacity(events.len());
                    for idx in 0..events.len() {
                    // 这个 unsafe 用法在 `event.into()`调用panic的时候会导致双重释放
                        let event_opt = unsafe { ptr::read(events.get_unchecked(idx)) };
                        if let Some(event) = event_opt { el.push::&lt;Event&gt;(event.into()); }
                    }
                    // 此处 mem::forget 就是为了防止 `dobule free`。
                    // 因为 `ptr::read` 也会制造一次 drop。
                    // 所以上面如果发生了panic，那就相当于注释了 `mem::forget`，导致`dobule free`
                    mem::forget(events);
                    el
                }
        }
    )
);
<span class="boring">}
</span></code></pre></pre>
<hr />
<h2><a class="header" href="#gunsabs01--在-公开的-unsafe-函数的文档中必须增加--safety-注释" id="gunsabs01--在-公开的-unsafe-函数的文档中必须增加--safety-注释">G.UNS.ABS.01  在 公开的 unsafe 函数的文档中必须增加 <code># Safety</code> 注释</a></h2>
<h3><a class="header" href="#级别必须" id="级别必须">【级别：必须】</a></h3>
<p>必须按此规范执行。</p>
<h3><a class="header" href="#lint-检测" id="lint-检测">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>默认 level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_safety_doc">missing_safety_doc</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<h3><a class="header" href="#描述" id="描述">【描述】</a></h3>
<p>在公开（pub）的 unsafe 函数文档中，必须增加 <code># Safety</code> 注释来解释该函数的安全边界，这样使用该函数的用户才可以安全地使用它。</p>
<p>说明： 该规则通过 cargo clippy 来检测。默认会发出警告。</p>
<h3><a class="header" href="#示例" id="示例">【示例】</a></h3>
<p>【正例】</p>
<p>示例来自于标准库文档： <a href="https://doc.rust-lang.org/stable/src/alloc/vec/mod.rs.html#1167">https://doc.rust-lang.org/stable/src/alloc/vec/mod.rs.html#1167</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Creates a `Vec&lt;T&gt;` directly from the raw components of another vector.
    ///
    /// # Safety
    ///
    /// This is highly unsafe, due to the number of invariants that aren't
    /// checked:
    ///
    /// * `ptr` needs to have been previously allocated via [`String`]/`Vec&lt;T&gt;`
    ///   (at least, it's highly likely to be incorrect if it wasn't).
    /// * `T` needs to have the same size and alignment as what `ptr` was allocated with.
    ///   (`T` having a less strict alignment is not sufficient, the alignment really
    ///   needs to be equal to satisfy the [`dealloc`] requirement that memory must be
    ///   allocated and deallocated with the same layout.)
    /// * `length` needs to be less than or equal to `capacity`.
    /// * `capacity` needs to be the capacity that the pointer was allocated with.
    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -&gt; Self {
        unsafe { Self::from_raw_parts_in(ptr, length, capacity, Global) }
    }
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Creates a `Vec&lt;T&gt;` directly from the raw components of another vector.
    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -&gt; Self {
        unsafe { Self::from_raw_parts_in(ptr, length, capacity, Global) }
    }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gunsabs02---在-unafe-函数中应该使用-assert-而非-debug_assert-去校验边界条件" id="gunsabs02---在-unafe-函数中应该使用-assert-而非-debug_assert-去校验边界条件">G.UNS.ABS.02   在 Unafe 函数中应该使用 <code>assert!</code> 而非 <code>debug_assert!</code> 去校验边界条件</a></h2>
<h3><a class="header" href="#级别必须-1" id="级别必须-1">【级别：必须】</a></h3>
<p>必须按此规范执行。</p>
<h3><a class="header" href="#lint-检测-1" id="lint-检测-1">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>默认 level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#debug_assert_with_mut_call">debug_assert_with_mut_call</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
</tbody></table>
<p>注意该 lint 当前是 Nursery Group，意味着可能会产生误报 Bug。</p>
<h3><a class="header" href="#描述-1" id="描述-1">【描述】</a></h3>
<p><code>assert!</code> 宏 在 Release 和 Debug 模式下都会被检查，并且不能被禁用。它通常用来在  unsafe 函数中判断传入的参数是否满足某种边界条件，以此来防止不合法的参数传入导致未定义行为。</p>
<p>但是 <code>debug_assert!</code> 则可以通过配置 <code>-C debug-assertions</code> 来禁用它， 而且 <code>debug_assert!</code>    在 Release 模式下也会被编译器优化。所以，一旦使用了 <code>debug_assert!</code> 在 unsafe 函数中用来防范不合法参数，那有可能会失效。</p>
<p>【正例】</p>
<p>来自标准库 <code>slice</code> 的代码示例。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	pub fn split_at_mut(&amp;mut self, mid: usize) -&gt; (&amp;mut [T], &amp;mut [T]) {
        assert!(mid &lt;= self.len()); // 判断边界条件，杜绝非法参数
        // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which
        // fulfills the requirements of `from_raw_parts_mut`.
        unsafe { self.split_at_mut_unchecked(mid) }
    }
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	// 使用了 debug_assert! 那就说明这个校验在 Release 模式不一定有效
    // 那么该函数就要被标记为  unsafe
	pub unsafe fn split_at_mut(&amp;mut self, mid: usize) -&gt; (&amp;mut [T], &amp;mut [T]) {
        debug_assert!(mid &lt;= self.len()); // 注意，这里是 debug_assert!
        // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which
        // fulfills the requirements of `from_raw_parts_mut`.
        unsafe { self.split_at_mut_unchecked(mid) }
    }

   // or
   // 在 debug_assert_eq! 中包含可变引用的调用，
   // 也会因为 debug_assert_ 系列的断言宏在 Release 下产生不可预料的结果，它是 unsafe 的
   debug_assert_eq!(vec![3].pop(), Some(3));
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../../safe-guides/coding_practice/unsafe_rust.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../../safe-guides/coding_practice/unsafe_rust/raw_ptr.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../../safe-guides/coding_practice/unsafe_rust.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../../safe-guides/coding_practice/unsafe_rust/raw_ptr.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../../../mermaid.min.js"></script>
        
        <script type="text/javascript" src="../../../mermaid-init.js"></script>
        

        

    </body>
</html>
