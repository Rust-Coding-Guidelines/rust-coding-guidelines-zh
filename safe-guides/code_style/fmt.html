<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>格式 - RustCodingGuidelines</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../favicon.png">
        
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        
        <link rel="stylesheet" href="../../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><li class="part-title">介绍</li><li class="chapter-item "><a href="../../index.html"><strong aria-hidden="true">1.</strong> Rust 编码规范介绍</a></li><li class="chapter-item "><a href="../../contribution.html"><strong aria-hidden="true">2.</strong> 贡献说明</a></li><li class="chapter-item affix "><li class="part-title">安全编码规范</li><li class="chapter-item "><a href="../../safe-guides/intro.html"><strong aria-hidden="true">3.</strong> 前言</a></li><li class="chapter-item "><a href="../../safe-guides/dev_env.html"><strong aria-hidden="true">4.</strong> 开发环境</a></li><li class="chapter-item expanded "><a href="../../safe-guides/code_style.html"><strong aria-hidden="true">5.</strong> 代码风格</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/code_style/naming.html"><strong aria-hidden="true">5.1.</strong> 命名</a></li><li class="chapter-item expanded "><a href="../../safe-guides/code_style/fmt.html" class="active"><strong aria-hidden="true">5.2.</strong> 格式</a></li><li class="chapter-item "><a href="../../safe-guides/code_style/comments.html"><strong aria-hidden="true">5.3.</strong> 注释</a></li></ol></li><li class="chapter-item "><a href="../../safe-guides/coding_practice.html"><strong aria-hidden="true">6.</strong> 编程实践</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/coding_practice/consts.html"><strong aria-hidden="true">6.1.</strong> 常量</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/statics.html"><strong aria-hidden="true">6.2.</strong> 静态变量</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/variables.html"><strong aria-hidden="true">6.3.</strong> 本地变量</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type.html"><strong aria-hidden="true">6.4.</strong> 数据类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/unit.html"><strong aria-hidden="true">6.4.1.</strong> 单元类型</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/bool.html"><strong aria-hidden="true">6.4.2.</strong> 布尔</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/char.html"><strong aria-hidden="true">6.4.3.</strong> 字符</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/int.html"><strong aria-hidden="true">6.4.4.</strong> 整数</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/float.html"><strong aria-hidden="true">6.4.5.</strong> 浮点数</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/ref.html"><strong aria-hidden="true">6.4.6.</strong> 引用</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/slice-and-str.html"><strong aria-hidden="true">6.4.7.</strong> 切片</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/tuple.html"><strong aria-hidden="true">6.4.8.</strong> 元组</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/array.html"><strong aria-hidden="true">6.4.9.</strong> 固定长度数组</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/vec.html"><strong aria-hidden="true">6.4.10.</strong> 动态数组</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/struct.html"><strong aria-hidden="true">6.4.11.</strong> 结构体</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/data-type/enum.html"><strong aria-hidden="true">6.4.12.</strong> 枚举体</a></li></ol></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/expr.html"><strong aria-hidden="true">6.5.</strong> 表达式</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/control-flow.html"><strong aria-hidden="true">6.6.</strong> 流程控制</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/strings.html"><strong aria-hidden="true">6.7.</strong> 字符串</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/collections.html"><strong aria-hidden="true">6.8.</strong> 集合容器</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/fn-and-closure.html"><strong aria-hidden="true">6.9.</strong> 函数与闭包</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/generic.html"><strong aria-hidden="true">6.10.</strong> 泛型</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/traits.html"><strong aria-hidden="true">6.11.</strong> 特质</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/coding_practice/traits/std-buildin.html"><strong aria-hidden="true">6.11.1.</strong> 标准库内置 trait</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/traits/trait-object.html"><strong aria-hidden="true">6.11.2.</strong> trait 对象</a></li></ol></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/error-handle.html"><strong aria-hidden="true">6.12.</strong> 错误处理</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/memory.html"><strong aria-hidden="true">6.13.</strong> 内存管理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/coding_practice/memory/lifetime.html"><strong aria-hidden="true">6.13.1.</strong> 生存期</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/memory/box.html"><strong aria-hidden="true">6.13.2.</strong> Box&lt;T&gt;</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/memory/drop.html"><strong aria-hidden="true">6.13.3.</strong> Drop 析构</a></li></ol></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/module.html"><strong aria-hidden="true">6.14.</strong> 模块</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/cargo.html"><strong aria-hidden="true">6.15.</strong> 包管理</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/macros.html"><strong aria-hidden="true">6.16.</strong> 宏</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/coding_practice/macros/declarative.html"><strong aria-hidden="true">6.16.1.</strong> 声明宏</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/macros/procedural.html"><strong aria-hidden="true">6.16.2.</strong> 过程宏</a></li></ol></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/threads.html"><strong aria-hidden="true">6.17.</strong> 多线程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/coding_practice/threads/lock.html"><strong aria-hidden="true">6.17.1.</strong> 锁同步</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/threads/lock-free.html"><strong aria-hidden="true">6.17.2.</strong> 无锁</a></li></ol></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/async-await.html"><strong aria-hidden="true">6.18.</strong> 异步编程</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/unsafe_rust.html"><strong aria-hidden="true">6.19.</strong> Unsafe Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/coding_practice/unsafe_rust/safe_abstract.html"><strong aria-hidden="true">6.19.1.</strong> 安全抽象</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/unsafe_rust/raw_ptr.html"><strong aria-hidden="true">6.19.2.</strong> 裸指针操作</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/unsafe_rust/union.html"><strong aria-hidden="true">6.19.3.</strong> 联合体</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/unsafe_rust/mem.html"><strong aria-hidden="true">6.19.4.</strong> 内存</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/unsafe_rust/ffi.html"><strong aria-hidden="true">6.19.5.</strong> FFi 规范</a></li></ol></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/no-std.html"><strong aria-hidden="true">6.20.</strong> no-std</a></li><li class="chapter-item "><a href="../../safe-guides/coding_practice/others.html"><strong aria-hidden="true">6.21.</strong> 其他</a></li></ol></li><li class="chapter-item "><a href="../../safe-guides/Appendix/toc.html"><strong aria-hidden="true">7.</strong> 附录</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/Appendix/test.html"><strong aria-hidden="true">7.1.</strong> 测试</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/Appendix/test/unit_test.html"><strong aria-hidden="true">7.1.1.</strong> 单元测试</a></li><li class="chapter-item "><a href="../../safe-guides/Appendix/test/benchmark.html"><strong aria-hidden="true">7.1.2.</strong> 基准测试</a></li><li class="chapter-item "><a href="../../safe-guides/Appendix/test/fuzz.html"><strong aria-hidden="true">7.1.3.</strong> 模糊测试</a></li></ol></li><li class="chapter-item "><a href="../../safe-guides/Appendix/terms.html"><strong aria-hidden="true">7.2.</strong> 术语解释</a></li><li class="chapter-item "><a href="../../safe-guides/Appendix/templates/intro.html"><strong aria-hidden="true">7.3.</strong> 模板</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../safe-guides/Appendix/templates/rustfmt.toml.html"><strong aria-hidden="true">7.3.1.</strong> rustfmt 模板</a></li><li class="chapter-item "><a href="../../safe-guides/Appendix/templates/clippy.toml.html"><strong aria-hidden="true">7.3.2.</strong> clippy 模板</a></li><li class="chapter-item "><a href="../../safe-guides/Appendix/templates/deny.toml.html"><strong aria-hidden="true">7.3.3.</strong> deny 模板</a></li></ol></li></ol></li><li class="chapter-item "><li class="part-title">领域最佳实践</li><li class="chapter-item "><a href="../../best-practices/intro.html"><strong aria-hidden="true">8.</strong> 介绍</a></li><li class="chapter-item "><a href="../../best-practices/embedded.html"><strong aria-hidden="true">9.</strong> 嵌入式 Rust</a></li><li class="chapter-item "><a href="../../best-practices/databases.html"><strong aria-hidden="true">10.</strong> 数据库</a></li><li class="chapter-item "><a href="../../best-practices/games.html"><strong aria-hidden="true">11.</strong> 游戏</a></li><li class="chapter-item "><a href="../../best-practices/cli_app.html"><strong aria-hidden="true">12.</strong> Cli App</a></li><li class="chapter-item "><a href="../../best-practices/gui.html"><strong aria-hidden="true">13.</strong> GUI</a></li><li class="chapter-item "><a href="../../best-practices/web.html"><strong aria-hidden="true">14.</strong> Web 开发</a></li><li class="chapter-item "><a href="../../best-practices/networks.html"><strong aria-hidden="true">15.</strong> 网络服务</a></li><li class="chapter-item "><a href="../../best-practices/webassembly.html"><strong aria-hidden="true">16.</strong> WebAssembly</a></li><li class="chapter-item affix "><li class="part-title">Cheat Sheet</li><li class="chapter-item "><a href="../../cheat-sheet/index.html"><strong aria-hidden="true">17.</strong> 介绍</a></li><li class="chapter-item affix "><li class="part-title">工具链使用指南</li><li class="chapter-item "><a href="../../tools/intro.html"><strong aria-hidden="true">18.</strong> 介绍</a></li><li class="chapter-item "><a href="../../tools/rustfmt.html"><strong aria-hidden="true">19.</strong> Rustfmt 配置相关说明</a></li><li class="chapter-item affix "><li class="part-title">Rust 优化指南</li><li class="chapter-item "><a href="../../optimizing/intro.html"><strong aria-hidden="true">20.</strong> 介绍</a></li><li class="chapter-item affix "><li class="part-title">Rust 常用基础库指南</li><li class="chapter-item "><a href="../../libs/intro.html"><strong aria-hidden="true">21.</strong> 介绍</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">RustCodingGuidelines</h1>

                    <div class="right-buttons">
                        
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/Rust-Coding-Guidelines/rust-coding-guidelines-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#格式" id="格式">格式</a></h1>
<p>Rust 有自动化格式化工具 rustfmt ，可以帮助开发者摆脱手工调整代码格式的工作，提升生产力。但是，rustfmt 遵循什么样的风格规范，作为开发者应该需要了解，在编写代码的时候可以主动按这样的风格编写。</p>
<p>说明：以下 <code>rustfmt</code> 配置中对应配置项如果 <code>Stable</code>为<code>No</code>，则表示该配置项不能用于 Stable Rust 下在 <code>rustfmt.toml</code> 中自定义，但其默认值会在<code>cargo fmt</code>时生效。在 Nightly Rust 下则都可以自定义。</p>
<p>在 Stable Rust 下使用未稳定配置项的方法、了解配置示例及其他全局配置项说明请参阅：<a href="../../tools/rustfmt.html">Rustfmt 配置相关说明</a> 。</p>
<p>注意： 以下规则 针对 rustfmt  version 1.4.36 版本。</p>
<hr />
<h2><a class="header" href="#pfmt01-始终使用-rustfmt-进行自动格式化代码" id="pfmt01-始终使用-rustfmt-进行自动格式化代码">P.FMT.01 始终使用 rustfmt 进行自动格式化代码</a></h2>
<h3><a class="header" href="#描述" id="描述">【描述】</a></h3>
<p>应该总是在项目中添加 <code>rustfmt.toml</code> 或 <code>.rustfmt.toml</code>文件，即使它是空文件。这是向潜在的合作者表明你希望代码是自动格式化的。</p>
<h3><a class="header" href="#例外" id="例外">【例外】</a></h3>
<p>在特殊的情况下，可以通过条件编译属性 <code>#[cfg_attr(rustfmt, rustfmt_skip)]</code> 或 <code>#[rustfmt::skip]</code> 来关闭自动格式化。</p>
<p>比如下面示例：</p>
<p><code>vec!</code> 中的元素排布是固定格式，这样有助于开发的便利。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let got = vec![
    		0x00, 0x05, 0x01, 0x00,
    		0xff,
    		0x00,
    		0x00,
    
    		0x01, 0x0c, 0x02, 0x00,
    		0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    		b'd', b'e', b'a', b'd', b'b', b'e', b'e', b'f', 0x00,
    		0x00,
    
    		127, 0x06, 0x03, 0x00,
    		0x01, 0x02,
    		b'a', b'b', b'c', b'd', 0x00,
    		b'1', b'2', b'3', b'4', 0x00,
            0x00,
    ];
}
</code></pre></pre>
<p>如果使用 自动格式化，会变成：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let got = vec![
        0x00, 0x05, 0x01, 0x00, 0xff, 0x00, 0x00, 0x01, 0x0c, 0x02, 0x00, 0xde, 0xad, 0xbe, 0xef,
        0xde, 0xad, 0xbe, 0xef, b'd', b'e', b'a', b'd', b'b', b'e', b'e', b'f', 0x00, 0x00, 127,
        0x06, 0x03, 0x00, 0x01, 0x02, b'a', b'b', b'c', b'd', 0x00, b'1', b'2', b'3', b'4', 0x00,
        0x00,
    ];
}
</code></pre></pre>
<p>但是加上 <code>#[rustfmt::skip]</code> 就不会被自动格式化影响：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    #[rustfmt::skip] 
    let got = vec![
    		0x00, 0x05, 0x01, 0x00,
    		0xff,
    		0x00,
    		0x00,
    
    		0x01, 0x0c, 0x02, 0x00,
    		0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
    		b'd', b'e', b'a', b'd', b'b', b'e', b'e', b'f', 0x00,
    		0x00,
    
    		127, 0x06, 0x03, 0x00,
    		0x01, 0x02,
    		b'a', b'b', b'c', b'd', 0x00,
    		b'1', b'2', b'3', b'4', 0x00,
            0x00,
    ];
}

</code></pre></pre>
<h2><a class="header" href="#pfmt02-代码格式以保证可读性为前提" id="pfmt02-代码格式以保证可读性为前提">P.FMT.02 代码格式以保证可读性为前提</a></h2>
<h3><a class="header" href="#描述-1" id="描述-1">【描述】</a></h3>
<p>制定统一的编码风格，是为了提升代码的可读性，让日常代码维护和团队之间审查代码更加方便。</p>
<hr />
<h2><a class="header" href="#gfmt01-缩进始终使用空格space而非制表符tab" id="gfmt01-缩进始终使用空格space而非制表符tab">G.FMT.01 缩进始终使用空格（space）而非制表符（tab）</a></h2>
<h3><a class="header" href="#级别必须" id="级别必须">【级别：必须】</a></h3>
<p>必须严格按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置" id="rustfmt-配置">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/#tab_spaces"><code>tab_spaces</code></a></td><td>4</td><td>yes（默认）</td><td>缩进空格数｜</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/#hard_tabs"><code>hard_tabs</code></a></td><td>false</td><td>yes（默认）</td><td>禁止使用tab缩进｜</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-2" id="描述-2">【描述】</a></h3>
<ol>
<li>缩进要使用 四个 空格，不要使用制表符（<code>\t</code>）代替。</li>
<li>通过 IDE/Editor 为缩进默认好设置值。</li>
</ol>
<h2><a class="header" href="#gfmt02-每行最大宽度为-100-个字符" id="gfmt02-每行最大宽度为-100-个字符">G.FMT.02 每行最大宽度为 100 个字符</a></h2>
<h3><a class="header" href="#级别建议" id="级别建议">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-1" id="rustfmt-配置-1">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#max_width"><code>max_width</code></a></td><td>100</td><td>yes（默认）</td><td>行最大宽度默认值</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#error_on_line_overflow"><code>error_on_line_overflow</code></a></td><td>false（默认）</td><td>No (tracking issue: #3391)</td><td>如果超过最大行宽设置则报错</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#use_small_heuristics"><code>use_small_heuristics</code></a></td><td>Default（默认）Max（推荐）</td><td>Yes</td><td>统一管理宽度设置</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-3" id="描述-3">【描述】</a></h3>
<p>代码行宽不宜过长，否则不利于阅读。
建议每行字符数不要超过 100 个字符。</p>
<p><code>rustfmt</code> 还提供很多其他宽度设置：</p>
<ul>
<li>fn_call_width, 函数调用最大宽度设置，其默认值是 <code>max_width</code>的 <code>60%</code>。</li>
<li>attr_fn_like_width, 像函数那样使用的属性宏最大宽度，其默认值是 <code>max_width</code>的 <code>70%</code>。</li>
<li>struct_lit_width,  结构体字面量最大宽度，其默认值是 <code>max_width</code>的 <code>18%</code>。</li>
<li>struct_variant_width, 结构体变量最大宽度，其默认值是 <code>max_width</code>的 <code>35%</code>。</li>
<li>array_width, 数组最大宽度，其默认值是 <code>max_width</code>的 <code>60%</code>。</li>
<li>chain_width, 链式结构最大宽度，其默认值是 <code>max_width</code>的 <code>60%</code>。</li>
<li>single_line_if_else_max_width，单行 <code>if-else</code> 最大宽度，其默认值是 <code>max_width</code>的 <code>50%</code>。</li>
</ul>
<p>这么多宽度设置管理起来比较麻烦，所以使用 <code>use_small_heuristics</code> 来管理更好。</p>
<h3><a class="header" href="#示例" id="示例">【示例】</a></h3>
<p><code>use_small_heuristics</code> 默认配置示例。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">enum Lorem {
    Ipsum,
    Dolor(bool),
    Sit { amet: Consectetur, adipiscing: Elit },
}

fn main() {
    lorem(
        &quot;lorem&quot;,
        &quot;ipsum&quot;,
        &quot;dolor&quot;,
        &quot;sit&quot;,
        &quot;amet&quot;,
        &quot;consectetur&quot;,
        &quot;adipiscing&quot;,
    );

    let lorem = Lorem {
        ipsum: dolor,
        sit: amet,
    };
    let lorem = Lorem { ipsum: dolor };

    let lorem = if ipsum { dolor } else { sit };
}
</code></pre></pre>
<p>【反例】</p>
<p>当<code>use_small_heuristics</code> 配置为 <code>Off</code> :</p>
<pre><pre class="playground"><code class="language-rust">enum Lorem {
    Ipsum,
    Dolor(bool),
    Sit {
        amet: Consectetur,
        adipiscing: Elit,
    },
}

fn main() {
    lorem(&quot;lorem&quot;, &quot;ipsum&quot;, &quot;dolor&quot;, &quot;sit&quot;, &quot;amet&quot;, &quot;consectetur&quot;, &quot;adipiscing&quot;);

    let lorem = Lorem {
        ipsum: dolor,
        sit: amet,
    };

    let lorem = if ipsum {
        dolor
    } else {
        sit
    };
}
</code></pre></pre>
<p>当<code>use_small_heuristics</code> 配置为 <code>Max</code> :</p>
<pre><pre class="playground"><code class="language-rust">enum Lorem {
    Ipsum,
    Dolor(bool),
    Sit { amet: Consectetur, adipiscing: Elit },
}

fn main() {
    lorem(&quot;lorem&quot;, &quot;ipsum&quot;, &quot;dolor&quot;, &quot;sit&quot;, &quot;amet&quot;, &quot;consectetur&quot;, &quot;adipiscing&quot;);

    let lorem = Lorem { ipsum: dolor, sit: amet };

    let lorem = if ipsum { dolor } else { sit };
}
</code></pre></pre>
<h2><a class="header" href="#gfmt03-行间距最大宽度空一行" id="gfmt03-行间距最大宽度空一行">G.FMT.03 行间距最大宽度空一行</a></h2>
<h3><a class="header" href="#级别建议-1" id="级别建议-1">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-2" id="rustfmt-配置-2">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#blank_lines_lower_bound"><code>blank_lines_lower_bound</code></a></td><td>0（默认）</td><td>No</td><td>不空行</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#blank_lines_upper_bound"><code>blank_lines_upper_bound</code></a></td><td>1（默认）</td><td>No</td><td>最大空一行</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-4" id="描述-4">【描述】</a></h3>
<p>代码行之间，最小间隔 <code>0</code> 行，最大间隔<code>1</code>行。</p>
<h3><a class="header" href="#示例-1" id="示例-1">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    println!(&quot;a&quot;);
}
// 1
fn bar() {
    println!(&quot;b&quot;);
    println!(&quot;c&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>或者</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    println!(&quot;a&quot;);
}
fn bar() {
    println!(&quot;b&quot;);
	// 1
    println!(&quot;c&quot;);
}

<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    println!(&quot;a&quot;);
}
// 1
// 2
fn bar() {
    println!(&quot;b&quot;);
// 1
// 2
    println!(&quot;c&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gfmt04-语言项item-定义时花括号brace位置应该与语言项保持同一行" id="gfmt04-语言项item-定义时花括号brace位置应该与语言项保持同一行">G.FMT.04 语言项（Item) 定义时花括号（brace）位置应该与语言项保持同一行</a></h2>
<h3><a class="header" href="#级别建议-2" id="级别建议-2">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-3" id="rustfmt-配置-3">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#brace_style"><code>brace_style</code></a></td><td>SameLineWhere （默认）</td><td>No</td><td>应该与语言项保持同一行，但是 where 语句例外</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#brace_style"><code>brace_style</code></a></td><td>AlwaysNextLine</td><td>No</td><td>应该在语言项的下一行</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#brace_style"><code>brace_style</code></a></td><td>PreferSameLine</td><td>No</td><td>总是优先与语言项保持同一行，where 语句也不例外</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#where_single_line"><code>where_single_line</code></a></td><td>false（默认）</td><td>No</td><td>强制将 <code>where</code> 子句放在同一行上</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#AlwaysSameLine"><code>brace_style</code> in control-flow</a></td><td>AlwaysSameLine （默认）</td><td>No</td><td>总在同一行上，用于控制流程中默认值</td></tr>
<tr><td>[<a href="https://rust-lang.github.io/rustfmt/?#ClosingNextLine"><code>brace_style</code> in control-flow</a></td><td>ClosingNextLine</td><td>No</td><td>用于控制流程中 else 分支在 if 分支结尾处换行</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-5" id="描述-5">【描述】</a></h3>
<p>花括号的位置风格默认使用 <code>SameLineWhere</code>，但是也根据不同的语言项略有区别。</p>
<h3><a class="header" href="#示例-2" id="示例-2">【示例】</a></h3>
<h4><a class="header" href="#函数" id="函数">函数</a></h4>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem() { // 花括号和fn定义在同一行
    // body
}

fn lorem(ipsum: usize) { // 花括号和fn定义在同一行
    // body
}

// 当有 `where` 子句的时候，花括号换行
// 并且，`where` 子句和 `where` 关键字不在同一行
fn lorem&lt;T&gt;(ipsum: T)
where
    T: Add + Sub + Mul + Div,
{
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>通过配置 <code>where_single_line</code> 为 true，方可设置 <code>where</code>子句在同一行，如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 当有 `where` 子句的时候，花括号换行
// 设置了 `where_single_line=true` ，则`where` 子句和 `where` 关键字在同一行
fn lorem&lt;T&gt;(ipsum: T)
where T: Add + Sub + Mul + Div,
{
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>如果设置 <code>brace_style = &quot;AlwaysNextLine&quot;</code>，则：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem()
{
    // body
}

fn lorem(ipsum: usize)
{
    // body
}

fn lorem&lt;T&gt;(ipsum: T)
where
    T: Add + Sub + Mul + Div,
{
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>如果设置 <code>brace_style = &quot;PreferSameLine&quot;</code>，则：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem() {
    // body
}

fn lorem(ipsum: usize) {
    // body
}

fn lorem&lt;T&gt;(ipsum: T)
where
    T: Add + Sub + Mul + Div, { // 注意这里和 `SameLineWhere`的区别
    // body
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#结构体与枚举" id="结构体与枚举">结构体与枚举</a></h4>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Lorem {
    ipsum: bool,
}

struct Dolor&lt;T&gt;
where
    T: Eq,
{
    sit: T,
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>如果设置 <code>brace_style = &quot;AlwaysNextLine&quot;</code>，则：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Lorem
{
    ipsum: bool,
}

struct Dolor&lt;T&gt;
where
    T: Eq,
{
    sit: T,
}
<span class="boring">}
</span></code></pre></pre>
<p>如果设置 <code>brace_style = &quot;PreferSameLine&quot;</code>，则：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Lorem {
    ipsum: bool,
}

struct Dolor&lt;T&gt;
where
    T: Eq, {
    sit: T,
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#流程控制" id="流程控制">流程控制</a></h4>
<p>流程控制倾向于默认使用 <code>AlwaysSameLine</code>，即，总在同一行。因为流程控制没有<code>where</code>子句。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">// &quot;AlwaysSameLine&quot; (default)
fn main() {
    if lorem {
        println!(&quot;ipsum!&quot;);
    } else {
        println!(&quot;dolor!&quot;);
    }
}
</code></pre></pre>
<p>【反例】</p>
<p>如果设置 <code>brace_style = &quot;AlwaysNextLine&quot;</code>，则：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    if lorem
    {
        println!(&quot;ipsum!&quot;);
    }
    else
    {
        println!(&quot;dolor!&quot;);
    }
}
</code></pre></pre>
<p>如果设置 <code>brace_style = &quot;ClosingNextLine&quot;</code>，则：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    if lorem {
        println!(&quot;ipsum!&quot;);
    } // 注意这里 if 分支结尾处，else 换行
    else { 
        println!(&quot;dolor!&quot;);
    }
}
</code></pre></pre>
<h2><a class="header" href="#gfmt05-单行规则" id="gfmt05-单行规则">G.FMT.05 单行规则</a></h2>
<h3><a class="header" href="#级别建议-3" id="级别建议-3">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-4" id="rustfmt-配置-4">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>默认值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#empty_item_single_line"><code>empty_item_single_line</code></a></td><td>true（默认）</td><td>No</td><td>当语言项内容为空时，要保持单行</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#empty_item_single_line"><code>fn_single_line</code></a></td><td>false（默认）</td><td>No</td><td>当函数中只有一个表达式时不要保持单行</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#struct_lit_single_line"><code>struct_lit_single_line</code></a></td><td>true（默认）</td><td>No</td><td>当函数中只有一个表达式时不要保持单行</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-6" id="描述-6">【描述】</a></h3>
<p>当语言项内容为空时，即空函数，空结构体，空实现等，要保持单独一行。但是，当函数中只有一个表达式时，请不要保持单行。</p>
<h3><a class="header" href="#示例-3" id="示例-3">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">fn lorem() {}

impl Lorem {}

fn lorem() -&gt; usize {
    42
}

fn main() {
    let lorem = Lorem { foo: bar, baz: ofo };
}

</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">fn lorem() {
}

impl Lorem {
}

fn lorem() -&gt; usize { 42 }

fn main() {
    let lorem = Lorem {
        foo: bar,
        baz: ofo,
    };
}
</code></pre></pre>
<h2><a class="header" href="#gfmt06-存在多个标识符时应该保持块状block缩进" id="gfmt06-存在多个标识符时应该保持块状block缩进">G.FMT.06 存在多个标识符时应该保持块状（Block）缩进</a></h2>
<h3><a class="header" href="#级别建议-4" id="级别建议-4">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-5" id="rustfmt-配置-5">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#indent_style"><code>indent_style</code></a></td><td>Block（默认）</td><td>No</td><td>多个标识符定义保持块状风格，但看上去可能不太工整</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#indent_style"><code>indent_style</code></a></td><td>Visual</td><td>No</td><td>多个标识符定义保持对齐风格，为了看上去工整</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-7" id="描述-7">【描述】</a></h3>
<p>当在表达式或语言项定义中出现多个标识符，则应该让其保持块状风格缩进。</p>
<h3><a class="header" href="#示例-4" id="示例-4">【示例】</a></h3>
<h4><a class="header" href="#数组" id="数组">数组</a></h4>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lorem = vec![
        &quot;ipsum&quot;,
        &quot;dolor&quot;,
        &quot;sit&quot;,
        &quot;amet&quot;,
        &quot;consectetur&quot;,
        &quot;adipiscing&quot;,
        &quot;elit&quot;,
    ];
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lorem = vec![&quot;ipsum&quot;,
                     &quot;dolor&quot;,
                     &quot;sit&quot;,
                     &quot;amet&quot;,
                     &quot;consectetur&quot;,
                     &quot;adipiscing&quot;,
                     &quot;elit&quot;];
}
</code></pre></pre>
<h4><a class="header" href="#流程控制-1" id="流程控制-1">流程控制</a></h4>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    if lorem_ipsum
        &amp;&amp; dolor_sit
        &amp;&amp; amet_consectetur
        &amp;&amp; lorem_sit
        &amp;&amp; dolor_consectetur
        &amp;&amp; amet_ipsum
        &amp;&amp; lorem_consectetur
    {
        // ...
    }
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    if lorem_ipsum
       &amp;&amp; dolor_sit // 注意：这里缩进只是三个空格，仅仅是和前一行 `lorem_ipsum`对齐
       &amp;&amp; amet_consectetur
       &amp;&amp; lorem_sit
       &amp;&amp; dolor_consectetur
       &amp;&amp; amet_ipsum
       &amp;&amp; lorem_consectetur
    {
        // ...
    }
}
</code></pre></pre>
<h4><a class="header" href="#函数参数" id="函数参数">函数参数</a></h4>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem() {}

fn lorem(ipsum: usize) {}

fn lorem(
    ipsum: usize,
    dolor: usize,
    sit: usize,
    amet: usize,
    consectetur: usize,
    adipiscing: usize,
    elit: usize,
) {
    // body
}

<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem() {}

fn lorem(ipsum: usize) {}

fn lorem(ipsum: usize,
         dolor: usize,
         sit: usize,
         amet: usize,
         consectetur: usize,
         adipiscing: usize,
         elit: usize) {
    // body
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#函数调用" id="函数调用">函数调用</a></h4>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    lorem(
        &quot;lorem&quot;,
        &quot;ipsum&quot;,
        &quot;dolor&quot;,
        &quot;sit&quot;,
        &quot;amet&quot;,
        &quot;consectetur&quot;,
        &quot;adipiscing&quot;,
        &quot;elit&quot;,
    );
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    lorem(&quot;lorem&quot;,
          &quot;ipsum&quot;,
          &quot;dolor&quot;,
          &quot;sit&quot;,
          &quot;amet&quot;,
          &quot;consectetur&quot;,
          &quot;adipiscing&quot;,
          &quot;elit&quot;);
}
</code></pre></pre>
<h4><a class="header" href="#泛型" id="泛型">泛型</a></h4>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem&lt;
    Ipsum: Eq = usize,
    Dolor: Eq = usize,
    Sit: Eq = usize,
    Amet: Eq = usize,
    Adipiscing: Eq = usize,
    Consectetur: Eq = usize,
    Elit: Eq = usize,
&gt;(
    ipsum: Ipsum,
    dolor: Dolor,
    sit: Sit,
    amet: Amet,
    adipiscing: Adipiscing,
    consectetur: Consectetur,
    elit: Elit,
) -&gt; T {
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem&lt;Ipsum: Eq = usize,
         Dolor: Eq = usize,
         Sit: Eq = usize,
         Amet: Eq = usize,
         Adipiscing: Eq = usize,
         Consectetur: Eq = usize,
         Elit: Eq = usize&gt;(
    ipsum: Ipsum,
    dolor: Dolor,
    sit: Sit,
    amet: Amet,
    adipiscing: Adipiscing,
    consectetur: Consectetur,
    elit: Elit)
    -&gt; T {
    // body
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#结构体" id="结构体">结构体</a></h4>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lorem = Lorem {
        ipsum: dolor,
        sit: amet,
    };
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lorem = Lorem { ipsum: dolor,
                        sit: amet };
}
</code></pre></pre>
<h2><a class="header" href="#gfmt07-换行样式以文件自动检测为主" id="gfmt07-换行样式以文件自动检测为主">G.FMT.07 换行样式以文件自动检测为主</a></h2>
<h3><a class="header" href="#级别建议-5" id="级别建议-5">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-6" id="rustfmt-配置-6">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#newline_style"><code>newline_style</code></a></td><td>Auto（默认）</td><td>Yes</td><td>换行样式以文件自动检测为主</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-8" id="描述-8">【描述】</a></h3>
<p>换行样式是基于每个文件自动检测的。 具有混合行尾的文件将转换为第一个检测到的行尾样式。</p>
<p>不同平台换行符不同：</p>
<ul>
<li><code>Windows</code> 以 <code>\r\n</code>结尾。</li>
<li><code>Unix</code> 以 <code>\n</code> 结尾。</li>
</ul>
<h2><a class="header" href="#gfmt08-当有多行表达式操作时操作符应该置于行首" id="gfmt08-当有多行表达式操作时操作符应该置于行首">G.FMT.08 当有多行表达式操作时，操作符应该置于行首</a></h2>
<h3><a class="header" href="#级别建议-6" id="级别建议-6">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-7" id="rustfmt-配置-7">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#binop_separator"><code>binop_separator</code></a></td><td>Front（默认）</td><td>No</td><td>换行后，操作符置于行首</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-9" id="描述-9">【描述】</a></h3>
<p>当有多行表达式操作时，操作符应该置于行首。</p>
<h3><a class="header" href="#示例-5" id="示例-5">【示例】</a></h3>
<p>【正例】</p>
<p>操作符置于行首</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let or = foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo
        || barbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar;

    let sum = 123456789012345678901234567890
        + 123456789012345678901234567890
        + 123456789012345678901234567890;

    let range = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
        ..bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;
}
</code></pre></pre>
<p>【反例】</p>
<p>操作符置于行尾</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let or = foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo ||
        barbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar;

    let sum = 123456789012345678901234567890 +
        123456789012345678901234567890 +
        123456789012345678901234567890;

    let range = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..
        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;
}
</code></pre></pre>
<h2><a class="header" href="#gfmt09-枚举变体和结构体字段相互之间默认左对齐" id="gfmt09-枚举变体和结构体字段相互之间默认左对齐">G.FMT.09 枚举变体和结构体字段相互之间默认左对齐</a></h2>
<h3><a class="header" href="#级别建议-7" id="级别建议-7">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-8" id="rustfmt-配置-8">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#enum_discrim_align_threshold"><code>enum_discrim_align_threshold</code></a></td><td>0（默认）</td><td>No</td><td>具有判别式的枚举变体与其他变体进行垂直对齐的最大长度。没有判别符的变体在对齐时将被忽略。</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#struct_field_align_threshold"><code>struct_field_align_threshold</code></a></td><td>0（默认）</td><td>No</td><td>结构体字段垂直对齐的最大长度</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-10" id="描述-10">【描述】</a></h3>
<p>对于自定义了判别式的枚举体，和有字段的结构体而言，默认只需要左对齐就可以。这个宽度可以设置为任意值，但默认是0。此宽度并不是指插入多少空格，而是指需要对齐的字符长度。</p>
<h3><a class="header" href="#示例-6" id="示例-6">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>enum Bar {
    A = 0,
    Bb = 1,
    RandomLongVariantGoesHere = 10,
    Ccc = 71,
}

enum Bar {
    VeryLongVariantNameHereA = 0,
    VeryLongVariantNameHereBb = 1,
    VeryLongVariantNameHereCcc = 2,
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>当 <code>enum_discrim_align_threshold = 20</code> 时。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    A   = 0,
    Bb  = 1,
    RandomLongVariantGoesHere = 10, // 注意，该变体长度已经超过了20，所以它不会被对齐
    Ccc = 2,
}

enum Bar {
    VeryLongVariantNameHereA = 0, // 注意，该变体长度已经超过了20，所以它不会被对齐
    VeryLongVariantNameHereBb = 1, // 注意，该变体长度已经超过了20，所以它不会被对齐
    VeryLongVariantNameHereCcc = 2,// 注意，该变体长度已经超过了20，所以它不会被对齐
}
<span class="boring">}
</span></code></pre></pre>
<p>当 <code>enum_discrim_align_threshold = 50</code> 时。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>enum Foo {
    A                         = 0,
    Bb                        = 1,
    RandomLongVariantGoesHere = 10, // 注意，该变体长度未超过50，所以它会被对齐
    Ccc                       = 2,
}

enum Bar {
    VeryLongVariantNameHereA   = 0, // 注意，该变体长度未超过50，所以它会被对齐
    VeryLongVariantNameHereBb  = 1, // 注意，该变体长度未超过50，所以它会被对齐
    VeryLongVariantNameHereCcc = 2, // 注意，该变体长度未超过50，所以它会被对齐
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gfmt10-多个函数参数和导入模块的布局" id="gfmt10-多个函数参数和导入模块的布局">G.FMT.10 多个函数参数和导入模块的布局</a></h2>
<h3><a class="header" href="#级别建议-8" id="级别建议-8">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-9" id="rustfmt-配置-9">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#fn_args_layout"><code>fn_args_layout</code></a></td><td>Tall（默认）</td><td>Yes</td><td>函数参数五个或以内可以一行，超过五个则使用块状缩进</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#imports_layout"><code>imports_layout</code></a></td><td>Mixed（默认）</td><td>No</td><td>导入模块每行超过四个则换行</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-11" id="描述-11">【描述】</a></h3>
<ol>
<li>五个以内函数参数可以置于一行，超过五个则使用「块」状缩进。</li>
<li>导入模块每行超过四个，则换行。</li>
</ol>
<h3><a class="header" href="#示例-7" id="示例-7">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>trait Lorem {
    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet, consectetur: Consectetur);

    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet) {
        // body
    }

    fn lorem(
        ipsum: Ipsum,
        dolor: Dolor,
        sit: Sit,
        amet: Amet,
        consectetur: Consectetur,
        adipiscing: Adipiscing,
        elit: Elit,
    );

    fn lorem(
        ipsum: Ipsum,
        dolor: Dolor,
        sit: Sit,
        amet: Amet,
        consectetur: Consectetur,
        adipiscing: Adipiscing,
        elit: Elit,
    ) {
        // body
    }
}

use foo::{xxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyy, zzzzzzzzzzzzzzzzzz};

use foo::{
    aaaaaaaaaaaaaaaaaa, bbbbbbbbbbbbbbbbbb, cccccccccccccccccc, dddddddddddddddddd,
    eeeeeeeeeeeeeeeeee,
};
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>当 <code>fn_args_layout</code> 和 <code>imports_layout</code> 被设置为其他值时：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Lorem {
    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet);

    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet) {
        // body
    }

    fn lorem(
        ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet, consectetur: Consectetur,
        adipiscing: Adipiscing, elit: Elit,
    );

    fn lorem(
        ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet, consectetur: Consectetur,
        adipiscing: Adipiscing, elit: Elit,
    ) {
        // body
    }
}

use foo::{xxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyy, zzzzzzzzzzzzzzzzzz};

use foo::{
    aaaaaaaaaaaaaaaaaa,
    bbbbbbbbbbbbbbbbbb,
    cccccccccccccccccc,
    dddddddddddddddddd,
    eeeeeeeeeeeeeeeeee,
    ffffffffffffffffff,
};

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gfmt11--空格使用规则" id="gfmt11--空格使用规则">G.FMT.11  空格使用规则</a></h2>
<h3><a class="header" href="#级别建议-9" id="级别建议-9">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-10" id="rustfmt-配置-10">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#space_after_colon"><code>space_after_colon</code></a></td><td>true（默认）</td><td>No</td><td>在冒号后面要加空格</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#space_before_colon"><code>space_before_colon</code></a></td><td>false（默认）</td><td>No</td><td>在冒号前面不要加空格</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#spaces_around_ranges"><code>spaces_around_ranges</code></a></td><td>false（默认）</td><td>No</td><td>在<code>..</code>和<code>..=</code>范围操作符前后不要加空格</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#type_punctuation_density"><code>type_punctuation_density</code></a></td><td>&quot;Wide&quot;（默认）</td><td>No</td><td>在 <code>+</code>或<code>=</code>操作符前后要加空格（此处特指类型签名）</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-12" id="描述-12">【描述】</a></h3>
<p>总结：</p>
<ol>
<li>在冒号之后添加空格，在冒号之前不要加空格。</li>
<li>在范围（range）操作符（<code>..</code>和<code>..=</code>）前后不要使用空格。</li>
<li>在<code>+</code>或<code>=</code>操作符前后要加空格。</li>
</ol>
<h3><a class="header" href="#示例-8" id="示例-8">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 当 `space_after_colon=true`
fn lorem&lt;T: Eq&gt;(t: T) {
    let lorem: Dolor = Lorem {
        ipsum: dolor,
        sit: amet,
    };
}

// 当 `space_before_colon=false`
fn lorem&lt;T: Eq&gt;(t: T) {
    let lorem: Dolor = Lorem {
        ipsum: dolor,
        sit: amet,
    };
}

// 当 `spaces_around_ranges=false`
let lorem = 0..10;
let ipsum = 0..=10;

// 当 `type_punctuation_density=&quot;Wide&quot;`
fn lorem&lt;Ipsum: Dolor + Sit = Amet&gt;() {
    // body
    let answer = 1 + 2;
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 当 `space_after_colon=false`
fn lorem&lt;T:Eq&gt;(t:T) {
    let lorem:Dolor = Lorem {
        ipsum:dolor,
        sit:amet,
    };
}

// 当 `space_before_colon=true`
fn lorem&lt;T : Eq&gt;(t : T) {
    let lorem : Dolor = Lorem {
        ipsum : dolor,
        sit : amet,
    };
}

// 当 `spaces_around_ranges=true`
let lorem = 0 .. 10;
let ipsum = 0 ..= 10;

// 当 `type_punctuation_density=&quot;Compressed&quot;`
fn lorem&lt;Ipsum: Dolor+Sit=Amet&gt;() {
    // body
    let answer = 1 + 2;
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gfmt12--结尾逗号规则" id="gfmt12--结尾逗号规则">G.FMT.12  结尾逗号规则</a></h2>
<h3><a class="header" href="#级别建议-10" id="级别建议-10">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-11" id="rustfmt-配置-11">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#trailing_comma"><code>trailing_comma</code></a></td><td>&quot;Vertical&quot;（默认）</td><td>No</td><td>当多个字段在不同行时，在最后一个字段结尾添加逗号，如果在同一行，则不加逗号</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#match_block_trailing_comma"><code>match_block_trailing_comma</code></a></td><td>false（默认）</td><td>No</td><td>在match分支中，如果包含了块，则不需要加逗号，否则需要加</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-13" id="描述-13">【描述】</a></h3>
<ol>
<li>当多个字段在不同行时，在最后一个字段结尾添加逗号，如果在同一行，则不加逗号。</li>
<li>在match分支中，如果包含了块，则不需要加逗号，否则需要加。</li>
</ol>
<h3><a class="header" href="#示例-9" id="示例-9">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">// 当 `trailing_comma=&quot;Vertical&quot;`
fn main() {
    let Lorem { ipsum, dolor, sit } = amet;
    let Lorem {
        ipsum,
        dolor,
        sit,
        amet,
        consectetur,
        adipiscing,
    } = elit;
}

// 当 `match_block_trailing_comma=false`
fn main() {
    match lorem {
        Lorem::Ipsum =&gt; {
            println!(&quot;ipsum&quot;);
        }
        Lorem::Dolor =&gt; println!(&quot;dolor&quot;),
    }
}

</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">// 当 `trailing_comma=&quot;Always&quot;`
fn main() {
    let Lorem { ipsum, dolor, sit, } = amet;
    let Lorem {
        ipsum,
        dolor,
        sit,
        amet,
        consectetur,
        adipiscing,
    } = elit;
}

// 当 `trailing_comma=&quot;Never&quot;`
fn main() {
    let Lorem { ipsum, dolor, sit } = amet;
    let Lorem {
        ipsum,
        dolor,
        sit,
        amet,
        consectetur,
        adipiscing
    } = elit;
}

// 当 `match_block_trailing_comma=true`
fn main() {
    match lorem {
        Lorem::Ipsum =&gt; {
            println!(&quot;ipsum&quot;);
        },
        Lorem::Dolor =&gt; println!(&quot;dolor&quot;),
    }
}

</code></pre></pre>
<h2><a class="header" href="#gfmt13--match-分支格式" id="gfmt13--match-分支格式">G.FMT.13  <code>match</code> 分支格式</a></h2>
<h3><a class="header" href="#级别建议-11" id="级别建议-11">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-12" id="rustfmt-配置-12">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#match_arm_blocks"><code>match_arm_blocks</code></a></td><td>true（默认）</td><td>No</td><td>当match分支右侧代码体太长无法和<code>=&gt;</code>置于同一行需要使用块(block)来包裹</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#match_arm_leading_pipes"><code>match_arm_leading_pipes</code></a></td><td>Never（默认）</td><td>No</td><td>在match分支左侧匹配表达式前不要增加管道符(`</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-14" id="描述-14">【描述】</a></h3>
<ol>
<li>当match分支右侧代码体太长无法和<code>=&gt;</code>置于同一行需要使用块(block)来包裹。</li>
<li>在match分支左侧匹配表达式前不要增加管道符(<code>|</code>)</li>
</ol>
<h3><a class="header" href="#示例-10" id="示例-10">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">// 当 `match_arm_blocks=true`
fn main() {
    match lorem {
        ipsum =&gt; { 
            foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo(x)
        }
        dolor =&gt; println!(&quot;{}&quot;, sit),
        sit =&gt; foo(
            &quot;foooooooooooooooooooooooo&quot;,
            &quot;baaaaaaaaaaaaaaaaaaaaaaaarr&quot;,
            &quot;baaaaaaaaaaaaaaaaaaaazzzzzzzzzzzzz&quot;,
            &quot;qqqqqqqqquuuuuuuuuuuuuuuuuuuuuuuuuuxxx&quot;,
        ),
    }
}

// 当 `match_arm_leading_pipes=&quot;Never&quot;`
fn foo() {
    match foo {
        &quot;foo&quot; | &quot;bar&quot; =&gt; {}
        &quot;baz&quot;
        | &quot;something relatively long&quot;
        | &quot;something really really really realllllllllllllly long&quot; =&gt; println!(&quot;x&quot;),
        &quot;qux&quot; =&gt; println!(&quot;y&quot;),
        _ =&gt; {}
    }
}



</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">// 当 `match_arm_blocks=false`
fn main() {
    match lorem {
        ipsum =&gt; 
            foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo(x),
        dolor =&gt; println!(&quot;{}&quot;, sit),
        sit =&gt; foo(
            &quot;foooooooooooooooooooooooo&quot;,
            &quot;baaaaaaaaaaaaaaaaaaaaaaaarr&quot;,
            &quot;baaaaaaaaaaaaaaaaaaaazzzzzzzzzzzzz&quot;,
            &quot;qqqqqqqqquuuuuuuuuuuuuuuuuuuuuuuuuuxxx&quot;,
        ),
    }
}

// 当 `match_arm_leading_pipes=&quot;Alaways&quot;`
fn foo() {
    match foo {
        | &quot;foo&quot; | &quot;bar&quot; =&gt; {}
        | &quot;baz&quot;
        | &quot;something relatively long&quot;
        | &quot;something really really really realllllllllllllly long&quot; =&gt; println!(&quot;x&quot;),
        | &quot;qux&quot; =&gt; println!(&quot;y&quot;),
        | _ =&gt; {}
    }
}

</code></pre></pre>
<h2><a class="header" href="#gfmt14--导入模块分组规则" id="gfmt14--导入模块分组规则">G.FMT.14  导入模块分组规则</a></h2>
<h3><a class="header" href="#级别建议-12" id="级别建议-12">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-13" id="rustfmt-配置-13">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#imports_granularity"><code>imports_granularity</code></a></td><td>（Preserve（默认），Crate(推荐)）</td><td>No</td><td>默认保留开发者的模块导入顺序</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#reorder_imports"><code>reorder_imports</code></a></td><td>true（默认）</td><td>No</td><td>模块分组内根据模块首字母按字典序进行排序</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#group_imports"><code>group_imports</code></a></td><td>（Preserve（默认）， StdExternalCrate（建议））</td><td>No</td><td>默认保留开发者的模块导入分组</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-15" id="描述-15">【描述】</a></h3>
<ol>
<li>导入同一模块的类型，应该置于同一个块内（<code>imports_granularity=&quot;Crate&quot;</code>）。</li>
<li>模块导入应该按以下规则进行分组（<code>group_imports=&quot;StdExternalCrate&quot;</code>）：
<ul>
<li>导入来自 <code>std</code>、<code>core</code> 和 <code>alloc</code>的模块需要置于前面一组。</li>
<li>导入来自 第三方库的模块 应该置于中间一组。</li>
<li>导入来自本地 <code>self</code>、<code>super</code>和<code>crate</code>前缀的模块，置于后面一组。</li>
</ul>
</li>
<li>分组内使用字典序进行排序（<code>reorder_imports=true</code>）。</li>
</ol>
<p>说明： 默认 rustfmt 不会对导入的模块自动分组，而是保留开发者的导入顺序。所以，这里需要修改rustfmt 默认配置，但因为这几个配置项暂时未稳定，所以需要在 Nightly 下使用。</p>
<h3><a class="header" href="#示例-11" id="示例-11">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 当 `imports_granularity=&quot;Crate&quot;`
use foo::{
    a, b,
    b::{f, g},
    c,
    d::e,
};
use qux::{h, i};


// 当 `group_imports=&quot;StdExternalCrate` 且 `reorder_imports=true`
use alloc::alloc::Layout;
use core::f32;
use std::sync::Arc;

use broker::database::PooledConnection;
use chrono::Utc;
use juniper::{FieldError, FieldResult};
use uuid::Uuid;

use super::schema::{Context, Payload};
use super::update::convert_publish_payload;
use crate::models::Event;
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// 当 `imports_granularity=&quot;Preserve&quot;`
use foo::b;
use foo::b::{f, g};
use foo::{a, c, d::e};
use qux::{h, i};


// 当按默认值设置时，模块导入比较乱，影响可读性
use super::update::convert_publish_payload;
use chrono::Utc;

use alloc::alloc::Layout;
use juniper::{FieldError, FieldResult};
use uuid::Uuid;

use std::sync::Arc;

use broker::database::PooledConnection;

use super::schema::{Context, Payload};
use crate::models::Event;
use core::f32;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gfmt15--声明宏分支格式" id="gfmt15--声明宏分支格式">G.FMT.15  声明宏分支格式</a></h2>
<h3><a class="header" href="#级别建议-13" id="级别建议-13">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-14" id="rustfmt-配置-14">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#format_macro_matchers"><code>format_macro_matchers</code></a></td><td>（false（默认），true(建议)）</td><td>No</td><td>声明宏 模式匹配分支（<code>=&gt;</code> 左侧）中要使用紧凑格式</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#format_macro_bodies"><code>format_macro_bodies</code></a></td><td>true（默认）</td><td>No</td><td>声明宏分支代码体（<code>=&gt;</code> 右侧） 使用宽松格式</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-16" id="描述-16">【描述】</a></h3>
<ol>
<li>在声明宏中，模式匹配分支（<code>=&gt;</code> 左侧）应该使用紧凑格式（<code>format_macro_matchers=true</code>）。</li>
<li>而分支代码体（<code>=&gt;</code> 右侧） 使用宽松格式。详细请看示例。</li>
</ol>
<p>一切都是为了提升可读性。</p>
<p>说明：因为这里需要修改<code>format_macro_matchers</code>的默认值，且该配置项并未 Stable ，所以需要 Nightly 下格式化。</p>
<h3><a class="header" href="#示例-12" id="示例-12">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 当 `format_macro_matchers=true` 且 `format_macro_bodies=true`
macro_rules! foo {
    // 匹配分支紧凑格式， `$a:ident` 和 `$b:ty` 各自配对
    ($a:ident : $b:ty) =&gt; {
        $a(42): $b; // 在代码体内，则宽松一点
    };
    ($a:ident $b:ident $c:ident) =&gt; {
        $a = $b + $c;
    };
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 当 `format_macro_matchers=false`且 `format_macro_bodies=true`
macro_rules! foo {
    ($a: ident : $b: ty) =&gt; {
        $a(42): $b;
    };
    ($a: ident $b: ident $c: ident) =&gt; {
        $a = $b + $c;
    };
}

// 当 `format_macro_matchers=false`且 `format_macro_bodies=false`
macro_rules! foo {
    ($a: ident : $b: ty) =&gt; {
        $a(42):$b;
    };
    ($a: ident $b: ident $c: ident) =&gt; {
        $a=$b+$c;
    };
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gfmt16--具名结构体字段初始化不要省略字段名" id="gfmt16--具名结构体字段初始化不要省略字段名">G.FMT.16  具名结构体字段初始化不要省略字段名</a></h2>
<h3><a class="header" href="#级别建议-14" id="级别建议-14">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-15" id="rustfmt-配置-15">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#use_field_init_shorthand"><code>use_field_init_shorthand</code></a></td><td>false（默认）</td><td>Yes</td><td>具名结构体字段初始化不能省略字段名</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-17" id="描述-17">【描述】</a></h3>
<p>具名结构体字段初始化不能省略字段名。</p>
<h3><a class="header" href="#示例-13" id="示例-13">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
struct Foo {
    x: u32,
    y: u32,
    z: u32,
}

fn main() {
    let x = 1;
    let y = 2;
    let z = 3;
    let a = Foo { x: x, y: y, z: z };
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    x: u32,
    y: u32,
    z: u32,
}

fn main() {
    let x = 1;
    let y = 2;
    let z = 3;
    let a = Foo { x, y, z };
}
</code></pre></pre>
<h2><a class="header" href="#gfmt17--extern-外部函数需要指定-abi" id="gfmt17--extern-外部函数需要指定-abi">G.FMT.17  extern 外部函数需要指定 ABI</a></h2>
<h3><a class="header" href="#级别建议-15" id="级别建议-15">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-16" id="rustfmt-配置-16">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#force_explicit_abi"><code>force_explicit_abi</code></a></td><td>true（默认）</td><td>Yes</td><td>extern 外部函数总是要指定 ABI</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-18" id="描述-18">【描述】</a></h3>
<p>当使用 <code>extern</code> 指定外部函数时，建议显式指定 <code>C-ABI</code>。<code>extern</code> 不指定的话默认就是 <code>C-ABI</code>，但是 Rust 语言显式指定是一种约定俗成。如果是 <code>Rust-ABI</code>则不会省略。</p>
<h3><a class="header" href="#示例-14" id="示例-14">【示例】</a></h3>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; {
    pub static lorem: c_int;
}

extern &quot;Rust&quot; {
    type MyType;
    fn f(&amp;self) -&gt; usize;
}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 省略 ABI 指定，则默认是 C-ABI
extern {
    pub static lorem: c_int;
}

// 非 C-ABI 是无法省略的
extern &quot;Rust&quot; {
    type MyType;
    fn f(&amp;self) -&gt; usize;
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#gfmt18---解构元组的时候允许使用来指代剩余元素" id="gfmt18---解构元组的时候允许使用来指代剩余元素">G.FMT.18   解构元组的时候允许使用<code>..</code>来指代剩余元素</a></h2>
<h3><a class="header" href="#级别建议-16" id="级别建议-16">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-17" id="rustfmt-配置-17">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#condense_wildcard_suffixes"><code>condense_wildcard_suffixes</code></a></td><td>false（默认） true （推荐）</td><td>No</td><td>解构元组的时候是否允许使用<code>..</code>来指代剩余元素</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-19" id="描述-19">【描述】</a></h3>
<p>默认选项是 false，表示不允许 解构元组的时候使用<code>..</code>来指代剩余元素</p>
<h3><a class="header" href="#示例-15" id="示例-15">【示例】</a></h3>
<p>【正例】</p>
<p>设置 <code>condense_wildcard_suffixes = true</code> :</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let (lorem, ipsum, ..) = (1, 2, 3, 4);
}
</code></pre></pre>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let (lorem, ipsum, _, _) = (1, 2, 3, 4);
    let (lorem, ipsum, ..) = (1, 2, 3, 4);
}
</code></pre></pre>
<h2><a class="header" href="#gfmt19----不要将多个-derive-宏合并为同一行" id="gfmt19----不要将多个-derive-宏合并为同一行">G.FMT.19    不要将多个 Derive 宏合并为同一行</a></h2>
<h3><a class="header" href="#级别建议-17" id="级别建议-17">【级别：建议】</a></h3>
<p>建议按此规范执行。</p>
<h3><a class="header" href="#rustfmt-配置-18" id="rustfmt-配置-18">【rustfmt 配置】</a></h3>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#merge_derives"><code>merge_derives</code></a></td><td>true（默认） false（推荐）</td><td>Yes</td><td>是否将多个 Derive 宏合并为同一行</td></tr>
</tbody></table>
<h3><a class="header" href="#描述-20" id="描述-20">【描述】</a></h3>
<p>不要将多个 Derive 宏合并为同一行，可以增加代码可读性，明确语义。</p>
<h3><a class="header" href="#示例-16" id="示例-16">【示例】</a></h3>
<p>【正例】</p>
<p>修改默认设置 <code>merge_derives = false</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Eq, PartialEq)]
#[derive(Debug)]
#[derive(Copy, Clone)]
pub enum Foo {}
<span class="boring">}
</span></code></pre></pre>
<p>【反例】</p>
<p>用默认设置  <code>merge_derives = true</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Eq, PartialEq, Debug, Copy, Clone)]
pub enum Foo {}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../safe-guides/code_style/naming.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../safe-guides/code_style/comments.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../safe-guides/code_style/naming.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../safe-guides/code_style/comments.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../../mermaid.min.js"></script>
        
        <script type="text/javascript" src="../../mermaid-init.js"></script>
        

        

    </body>
</html>
