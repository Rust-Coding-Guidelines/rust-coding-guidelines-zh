<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust 编码规范 V 0.2</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="overview.html"><strong aria-hidden="true">1.</strong> 概述</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/overview/why.html"><strong aria-hidden="true">1.1.</strong> 为什么需要 Rust 编码规范</a></li><li class="chapter-item "><a href="safe-guides/overview/convention.html"><strong aria-hidden="true">1.2.</strong> 编码规范基本约定</a></li></ol></li><li class="chapter-item "><a href="safe-guides/code_style.html"><strong aria-hidden="true">2.</strong> 代码风格</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/code_style/naming.html"><strong aria-hidden="true">2.1.</strong> 命名</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.01.html"><strong aria-hidden="true">2.1.1.</strong> P.NAM.01</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.02.html"><strong aria-hidden="true">2.1.2.</strong> P.NAM.02</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/G.NAM.01.html"><strong aria-hidden="true">2.1.3.</strong> G.NAM.01</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/G.NAM.02.html"><strong aria-hidden="true">2.1.4.</strong> G.NAM.02</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/G.NAM.03.html"><strong aria-hidden="true">2.1.5.</strong> G.NAM.03</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/G.NAM.04.html"><strong aria-hidden="true">2.1.6.</strong> G.NAM.04</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/G.NAM.05.html"><strong aria-hidden="true">2.1.7.</strong> G.NAM.05</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/G.NAM.06.html"><strong aria-hidden="true">2.1.8.</strong> G.NAM.06</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/G.NAM.07.html"><strong aria-hidden="true">2.1.9.</strong> G.NAM.07</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/G.NAM.08.html"><strong aria-hidden="true">2.1.10.</strong> G.NAM.08</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/G.NAM.09.html"><strong aria-hidden="true">2.1.11.</strong> G.NAM.09</a></li></ol></li><li class="chapter-item "><a href="safe-guides/code_style/fmt.html"><strong aria-hidden="true">2.2.</strong> 格式</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.01.html"><strong aria-hidden="true">2.2.1.</strong> P.FMT.01</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/G.FMT.01.html"><strong aria-hidden="true">2.2.2.</strong> G.FMT.01</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/G.FMT.02.html"><strong aria-hidden="true">2.2.3.</strong> G.FMT.02</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/G.FMT.03.html"><strong aria-hidden="true">2.2.4.</strong> G.FMT.03</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/G.FMT.04.html"><strong aria-hidden="true">2.2.5.</strong> G.FMT.04</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/G.FMT.05.html"><strong aria-hidden="true">2.2.6.</strong> G.FMT.05</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/G.FMT.06.html"><strong aria-hidden="true">2.2.7.</strong> G.FMT.06</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/G.FMT.07.html"><strong aria-hidden="true">2.2.8.</strong> G.FMT.07</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/G.FMT.08.html"><strong aria-hidden="true">2.2.9.</strong> G.FMT.08</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/G.FMT.09.html"><strong aria-hidden="true">2.2.10.</strong> G.FMT.09</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/G.FMT.10.html"><strong aria-hidden="true">2.2.11.</strong> G.FMT.10</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/G.FMT.11.html"><strong aria-hidden="true">2.2.12.</strong> G.FMT.11</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/G.FMT.12.html"><strong aria-hidden="true">2.2.13.</strong> G.FMT.12</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/G.FMT.13.html"><strong aria-hidden="true">2.2.14.</strong> G.FMT.13</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/G.FMT.14.html"><strong aria-hidden="true">2.2.15.</strong> G.FMT.14</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/G.FMT.15.html"><strong aria-hidden="true">2.2.16.</strong> G.FMT.15</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/G.FMT.16.html"><strong aria-hidden="true">2.2.17.</strong> G.FMT.16</a></li></ol></li><li class="chapter-item "><a href="safe-guides/code_style/comments.html"><strong aria-hidden="true">2.3.</strong> 注释</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/code_style/comments/P.CMT.01.html"><strong aria-hidden="true">2.3.1.</strong> P.CMT.01</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/G.CMT.01.html"><strong aria-hidden="true">2.3.2.</strong> G.CMT.01</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/G.CMT.02.html"><strong aria-hidden="true">2.3.3.</strong> G.CMT.02</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/G.CMT.03.html"><strong aria-hidden="true">2.3.4.</strong> G.CMT.03</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/G.CMT.04.html"><strong aria-hidden="true">2.3.5.</strong> G.CMT.04</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/G.CMT.05.html"><strong aria-hidden="true">2.3.6.</strong> G.CMT.05</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/G.CMT.06.html"><strong aria-hidden="true">2.3.7.</strong> G.CMT.06</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/G.CMT.07.html"><strong aria-hidden="true">2.3.8.</strong> G.CMT.07</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice.html"><strong aria-hidden="true">3.</strong> 编码实践</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/consts.html"><strong aria-hidden="true">3.1.</strong> 常量</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/consts/G.CNS.01.html"><strong aria-hidden="true">3.1.1.</strong> G.CNS.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/consts/G.CNS.02.html"><strong aria-hidden="true">3.1.2.</strong> G.CNS.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/consts/G.CNS.03.html"><strong aria-hidden="true">3.1.3.</strong> G.CNS.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/consts/G.CNS.04.html"><strong aria-hidden="true">3.1.4.</strong> G.CNS.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/consts/G.CNS.05.html"><strong aria-hidden="true">3.1.5.</strong> G.CNS.05</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/statics.html"><strong aria-hidden="true">3.2.</strong> 静态变量</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/statics/G.STV.01.html"><strong aria-hidden="true">3.2.1.</strong> G.STV.01</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/variables.html"><strong aria-hidden="true">3.3.</strong> 本地变量</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/variables/P.VAR.01.html"><strong aria-hidden="true">3.3.1.</strong> P.VAR.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/variables/P.VAR.02.html"><strong aria-hidden="true">3.3.2.</strong> P.VAR.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/variables/G.VAR.01.html"><strong aria-hidden="true">3.3.3.</strong> G.VAR.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/variables/G.VAR.02.html"><strong aria-hidden="true">3.3.4.</strong> G.VAR.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/variables/G.VAR.03.html"><strong aria-hidden="true">3.3.5.</strong> G.VAR.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/variables/G.VAR.04.html"><strong aria-hidden="true">3.3.6.</strong> G.VAR.04</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type.html"><strong aria-hidden="true">3.4.</strong> 数据类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/P.TYP.01.html"><strong aria-hidden="true">3.4.1.</strong> P.TYP.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/G.TYP.01.html"><strong aria-hidden="true">3.4.2.</strong> G.TYP.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/G.TYP.02.html"><strong aria-hidden="true">3.4.3.</strong> G.TYP.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/G.TYP.03.html"><strong aria-hidden="true">3.4.4.</strong> G.TYP.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool.html"><strong aria-hidden="true">3.4.5.</strong> 布尔</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool/G.TYP.BOL.01.html"><strong aria-hidden="true">3.4.5.1.</strong> G.TYP.BOL.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool/G.TYP.BOL.02.html"><strong aria-hidden="true">3.4.5.2.</strong> G.TYP.BOL.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool/G.TYP.BOL.03.html"><strong aria-hidden="true">3.4.5.3.</strong> G.TYP.BOL.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool/G.TYP.BOL.04.html"><strong aria-hidden="true">3.4.5.4.</strong> G.TYP.BOL.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool/G.TYP.BOL.05.html"><strong aria-hidden="true">3.4.5.5.</strong> G.TYP.BOL.05</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool/G.TYP.BOL.06.html"><strong aria-hidden="true">3.4.5.6.</strong> G.TYP.BOL.06</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/char.html"><strong aria-hidden="true">3.4.6.</strong> 字符</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/char/G.TYP.CHR.01.html"><strong aria-hidden="true">3.4.6.1.</strong> G.TYP.CHR.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/char/G.TYP.CHR.02.html"><strong aria-hidden="true">3.4.6.2.</strong> G.TYP.CHR.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/char/G.TYP.CHR.03.html"><strong aria-hidden="true">3.4.6.3.</strong> G.TYP.CHR.03</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/int.html"><strong aria-hidden="true">3.4.7.</strong> 整数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/int/G.TYP.INT.01.html"><strong aria-hidden="true">3.4.7.1.</strong> G.TYP.INT.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/int/G.TYP.INT.02.html"><strong aria-hidden="true">3.4.7.2.</strong> G.TYP.INT.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/int/G.TYP.INT.03.html"><strong aria-hidden="true">3.4.7.3.</strong> G.TYP.INT.03</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float.html"><strong aria-hidden="true">3.4.8.</strong> 浮点数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float/G.TYP.FLT.01.html"><strong aria-hidden="true">3.4.8.1.</strong> G.TYP.FLT.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float/G.TYP.FLT.02.html"><strong aria-hidden="true">3.4.8.2.</strong> G.TYP.FLT.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float/G.TYP.FLT.03.html"><strong aria-hidden="true">3.4.8.3.</strong> G.TYP.FLT.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float/G.TYP.FLT.04.html"><strong aria-hidden="true">3.4.8.4.</strong> G.TYP.FLT.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float/G.TYP.FLT.05.html"><strong aria-hidden="true">3.4.8.5.</strong> G.TYP.FLT.05</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float/G.TYP.FLT.06.html"><strong aria-hidden="true">3.4.8.6.</strong> G.TYP.FLT.06</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/slice.html"><strong aria-hidden="true">3.4.9.</strong> 切片</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/slice/P.TYP.SLC.01.html"><strong aria-hidden="true">3.4.9.1.</strong> P.TYP.SLC.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/slice/P.TYP.SLC.02.html"><strong aria-hidden="true">3.4.9.2.</strong> P.TYP.SLC.02</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/tuple.html"><strong aria-hidden="true">3.4.10.</strong> 元组</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/tuple/G.TYP.TUP.01.html"><strong aria-hidden="true">3.4.10.1.</strong> G.TYP.TUP.01</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/array.html"><strong aria-hidden="true">3.4.11.</strong> 固定长度数组</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/array/G.TYP.ARR.01.html"><strong aria-hidden="true">3.4.11.1.</strong> G.TYP.ARR.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/array/G.TYP.ARR.02.html"><strong aria-hidden="true">3.4.11.2.</strong> G.TYP.ARR.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/array/G.TYP.ARR.03.html"><strong aria-hidden="true">3.4.11.3.</strong> G.TYP.ARR.03</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/vec.html"><strong aria-hidden="true">3.4.12.</strong> 动态数组</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/vec/P.TYP.VEC.01.html"><strong aria-hidden="true">3.4.12.1.</strong> P.TYP.VEC.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/vec/P.TYP.VEC.02.html"><strong aria-hidden="true">3.4.12.2.</strong> P.TYP.VEC.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/vec/G.TYP.VEC.01.html"><strong aria-hidden="true">3.4.12.3.</strong> G.TYP.VEC.01</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/struct.html"><strong aria-hidden="true">3.4.13.</strong> 结构体</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/struct/P.TYP.SCT.01.html"><strong aria-hidden="true">3.4.13.1.</strong> P.TYP.SCT.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/struct/P.TYP.SCT.02.html"><strong aria-hidden="true">3.4.13.2.</strong> P.TYP.SCT.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/struct/G.TYP.SCT.01.html"><strong aria-hidden="true">3.4.13.3.</strong> G.TYP.SCT.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/struct/G.TYP.SCT.02.html"><strong aria-hidden="true">3.4.13.4.</strong> G.TYP.SCT.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/struct/G.TYP.SCT.03.html"><strong aria-hidden="true">3.4.13.5.</strong> G.TYP.SCT.03</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum.html"><strong aria-hidden="true">3.4.14.</strong> 枚举体</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum/G.TYP.ENM.01.html"><strong aria-hidden="true">3.4.14.1.</strong> G.TYP.ENM.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum/G.TYP.ENM.02.html"><strong aria-hidden="true">3.4.14.2.</strong> G.TYP.ENM.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum/G.TYP.ENM.03.html"><strong aria-hidden="true">3.4.14.3.</strong> G.TYP.ENM.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum/G.TYP.ENM.04.html"><strong aria-hidden="true">3.4.14.4.</strong> G.TYP.ENM.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum/G.TYP.ENM.05.html"><strong aria-hidden="true">3.4.14.5.</strong> G.TYP.ENM.05</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum/G.TYP.ENM.06.html"><strong aria-hidden="true">3.4.14.6.</strong> G.TYP.ENM.06</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/expr.html"><strong aria-hidden="true">3.5.</strong> 表达式</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/expr/G.EXP.01.html"><strong aria-hidden="true">3.5.1.</strong> G.EXP.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/expr/G.EXP.02.html"><strong aria-hidden="true">3.5.2.</strong> G.EXP.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/expr/G.EXP.03.html"><strong aria-hidden="true">3.5.3.</strong> G.EXP.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/expr/G.EXP.04.html"><strong aria-hidden="true">3.5.4.</strong> G.EXP.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/expr/G.EXP.05.html"><strong aria-hidden="true">3.5.5.</strong> G.EXP.05</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/expr/G.EXP.06.html"><strong aria-hidden="true">3.5.6.</strong> G.EXP.06</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow.html"><strong aria-hidden="true">3.6.</strong> 控制流程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow/P.CTF.01.html"><strong aria-hidden="true">3.6.1.</strong> P.CTF.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow/P.CTF.02.html"><strong aria-hidden="true">3.6.2.</strong> P.CTF.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow/G.CTF.01.html"><strong aria-hidden="true">3.6.3.</strong> G.CTF.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow/G.CTF.02.html"><strong aria-hidden="true">3.6.4.</strong> G.CTF.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow/G.CTF.03.html"><strong aria-hidden="true">3.6.5.</strong> G.CTF.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow/G.CTF.04.html"><strong aria-hidden="true">3.6.6.</strong> G.CTF.04</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings.html"><strong aria-hidden="true">3.7.</strong> 字符串</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/strings/P.STR.01.html"><strong aria-hidden="true">3.7.1.</strong> P.STR.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/P.STR.02.html"><strong aria-hidden="true">3.7.2.</strong> P.STR.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/P.STR.03.html"><strong aria-hidden="true">3.7.3.</strong> P.STR.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/P.STR.04.html"><strong aria-hidden="true">3.7.4.</strong> P.STR.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/P.STR.05.html"><strong aria-hidden="true">3.7.5.</strong> P.STR.05</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/G.STR.01.html"><strong aria-hidden="true">3.7.6.</strong> G.STR.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/G.STR.02.html"><strong aria-hidden="true">3.7.7.</strong> G.STR.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/G.STR.03.html"><strong aria-hidden="true">3.7.8.</strong> G.STR.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/G.STR.04.html"><strong aria-hidden="true">3.7.9.</strong> G.STR.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/G.STR.05.html"><strong aria-hidden="true">3.7.10.</strong> G.STR.05</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/collections.html"><strong aria-hidden="true">3.8.</strong> 集合容器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/collections/P.CLT.01.html"><strong aria-hidden="true">3.8.1.</strong> P.CLT.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/collections/G.CLT.01.html"><strong aria-hidden="true">3.8.2.</strong> G.CLT.01</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design.html"><strong aria-hidden="true">3.9.</strong> 函数设计</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/P.FUD.01.html"><strong aria-hidden="true">3.9.1.</strong> P.FUD.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/P.FUD.02.html"><strong aria-hidden="true">3.9.2.</strong> P.FUD.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/G.FUD.01.html"><strong aria-hidden="true">3.9.3.</strong> G.FUD.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/G.FUD.02.html"><strong aria-hidden="true">3.9.4.</strong> G.FUD.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/G.FUD.03.html"><strong aria-hidden="true">3.9.5.</strong> G.FUD.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/G.FUD.04.html"><strong aria-hidden="true">3.9.6.</strong> G.FUD.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/G.FUD.05.html"><strong aria-hidden="true">3.9.7.</strong> G.FUD.05</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/G.FUD.06.html"><strong aria-hidden="true">3.9.8.</strong> G.FUD.06</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic.html"><strong aria-hidden="true">3.10.</strong> 泛型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/generic/P.GEN.01.html"><strong aria-hidden="true">3.10.1.</strong> P.GEN.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic/P.GEN.02.html"><strong aria-hidden="true">3.10.2.</strong> P.GEN.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic/P.GEN.03.html"><strong aria-hidden="true">3.10.3.</strong> P.GEN.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic/P.GEN.04.html"><strong aria-hidden="true">3.10.4.</strong> P.GEN.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic/P.GEN.05.html"><strong aria-hidden="true">3.10.5.</strong> P.GEN.05</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic/G.GEN.01.html"><strong aria-hidden="true">3.10.6.</strong> G.GEN.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic/G.GEN.02.html"><strong aria-hidden="true">3.10.7.</strong> G.GEN.02</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits.html"><strong aria-hidden="true">3.11.</strong> 特质</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/traits/P.TRA.01.html"><strong aria-hidden="true">3.11.1.</strong> P.TRA.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin.html"><strong aria-hidden="true">3.11.2.</strong> 标准库内置 trait</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/P.TRA.BLN.01.html"><strong aria-hidden="true">3.11.2.1.</strong> P.TRA.BLN.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.01.html"><strong aria-hidden="true">3.11.2.2.</strong> G.TRA.BLN.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.02.html"><strong aria-hidden="true">3.11.2.3.</strong> G.TRA.BLN.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.03.html"><strong aria-hidden="true">3.11.2.4.</strong> G.TRA.BLN.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.04.html"><strong aria-hidden="true">3.11.2.5.</strong> G.TRA.BLN.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.05.html"><strong aria-hidden="true">3.11.2.6.</strong> G.TRA.BLN.05</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.06.html"><strong aria-hidden="true">3.11.2.7.</strong> G.TRA.BLN.06</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.07.html"><strong aria-hidden="true">3.11.2.8.</strong> G.TRA.BLN.07</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.08.html"><strong aria-hidden="true">3.11.2.9.</strong> G.TRA.BLN.08</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.09.html"><strong aria-hidden="true">3.11.2.10.</strong> G.TRA.BLN.09</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.10.html"><strong aria-hidden="true">3.11.2.11.</strong> G.TRA.BLN.10</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/trait-object.html"><strong aria-hidden="true">3.11.3.</strong> trait 对象</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/traits/trait-object/P.TRA.OBJ.01.html"><strong aria-hidden="true">3.11.3.1.</strong> P.TRA.OBJ.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/trait-object/P.TRA.OBJ.02.html"><strong aria-hidden="true">3.11.3.2.</strong> P.TRA.OBJ.02</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/error-handle.html"><strong aria-hidden="true">3.12.</strong> 错误处理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/error-handle/P.ERR.01.html"><strong aria-hidden="true">3.12.1.</strong> P.ERR.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/error-handle/P.ERR.02.html"><strong aria-hidden="true">3.12.2.</strong> P.ERR.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/error-handle/G.ERR.01.html"><strong aria-hidden="true">3.12.3.</strong> G.ERR.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/error-handle/G.ERR.02.html"><strong aria-hidden="true">3.12.4.</strong> G.ERR.02</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory.html"><strong aria-hidden="true">3.13.</strong> 内存管理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/memory/lifetime.html"><strong aria-hidden="true">3.13.1.</strong> 生命周期</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/memory/lifetime/P.MEM.LFT.01.html"><strong aria-hidden="true">3.13.1.1.</strong> P.MEM.LFT.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/lifetime/P.MEM.LFT.02.html"><strong aria-hidden="true">3.13.1.2.</strong> P.MEM.LFT.02</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/smart-ptr.html"><strong aria-hidden="true">3.13.2.</strong> 智能指针</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/memory/smart-ptr/P.MEM.SPT.01.html"><strong aria-hidden="true">3.13.2.1.</strong> P.MEM.SPT.01</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/box.html"><strong aria-hidden="true">3.13.3.</strong> Box 类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/memory/box/G.MEM.BOX.01.html"><strong aria-hidden="true">3.13.3.1.</strong> G.MEM.BOX.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/box/G.MEM.BOX.02.html"><strong aria-hidden="true">3.13.3.2.</strong> G.MEM.BOX.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/box/G.MEM.BOX.03.html"><strong aria-hidden="true">3.13.3.3.</strong> G.MEM.BOX.03</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/drop.html"><strong aria-hidden="true">3.13.4.</strong> Drop 析构</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/memory/drop/G.MEM.DRP.01.html"><strong aria-hidden="true">3.13.4.1.</strong> G.MEM.DRP.01</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/module.html"><strong aria-hidden="true">3.14.</strong> 模块</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/module/P.MOD.01.html"><strong aria-hidden="true">3.14.1.</strong> P.MOD.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/module/P.MOD.02.html"><strong aria-hidden="true">3.14.2.</strong> P.MOD.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/module/G.MOD.01.html"><strong aria-hidden="true">3.14.3.</strong> G.MOD.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/module/G.MOD.02.html"><strong aria-hidden="true">3.14.4.</strong> G.MOD.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/module/G.MOD.03.html"><strong aria-hidden="true">3.14.5.</strong> G.MOD.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/module/G.MOD.04.html"><strong aria-hidden="true">3.14.6.</strong> G.MOD.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/module/G.MOD.05.html"><strong aria-hidden="true">3.14.7.</strong> G.MOD.05</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo.html"><strong aria-hidden="true">3.15.</strong> 包管理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/P.CAR.01.html"><strong aria-hidden="true">3.15.1.</strong> P.CAR.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/P.CAR.02.html"><strong aria-hidden="true">3.15.2.</strong> P.CAR.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/P.CAR.03.html"><strong aria-hidden="true">3.15.3.</strong> P.CAR.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/P.CAR.04.html"><strong aria-hidden="true">3.15.4.</strong> P.CAR.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/G.CAR.01.html"><strong aria-hidden="true">3.15.5.</strong> G.CAR.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/G.CAR.02.html"><strong aria-hidden="true">3.15.6.</strong> G.CAR.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/G.CAR.03.html"><strong aria-hidden="true">3.15.7.</strong> G.CAR.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/G.CAR.04.html"><strong aria-hidden="true">3.15.8.</strong> G.CAR.04</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros.html"><strong aria-hidden="true">3.16.</strong> 宏</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/macros/P.MAC.01.html"><strong aria-hidden="true">3.16.1.</strong> P.MAC.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/P.MAC.02.html"><strong aria-hidden="true">3.16.2.</strong> P.MAC.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/G.MAC.01.html"><strong aria-hidden="true">3.16.3.</strong> G.MAC.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/G.MAC.02.html"><strong aria-hidden="true">3.16.4.</strong> G.MAC.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl.html"><strong aria-hidden="true">3.16.5.</strong> 声明宏</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.01.html"><strong aria-hidden="true">3.16.5.1.</strong> P.MAC.DCL.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.02.html"><strong aria-hidden="true">3.16.5.2.</strong> P.MAC.DCL.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.03.html"><strong aria-hidden="true">3.16.5.3.</strong> P.MAC.DCL.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.04.html"><strong aria-hidden="true">3.16.5.4.</strong> P.MAC.DCL.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.05.html"><strong aria-hidden="true">3.16.5.5.</strong> P.MAC.DCL.05</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.06.html"><strong aria-hidden="true">3.16.5.6.</strong> P.MAC.DCL.06</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.07.html"><strong aria-hidden="true">3.16.5.7.</strong> P.MAC.DCL.07</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.08.html"><strong aria-hidden="true">3.16.5.8.</strong> P.MAC.DCL.08</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc.html"><strong aria-hidden="true">3.16.6.</strong> 过程宏</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc/P.MAC.PRO.01.html"><strong aria-hidden="true">3.16.6.1.</strong> P.MAC.PRO.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc/P.MAC.PRO.02.html"><strong aria-hidden="true">3.16.6.2.</strong> P.MAC.PRO.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc/P.MAC.PRO.03.html"><strong aria-hidden="true">3.16.6.3.</strong> P.MAC.PRO.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc/P.MAC.PRO.04.html"><strong aria-hidden="true">3.16.6.4.</strong> P.MAC.PRO.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc/P.MAC.PRO.05.html"><strong aria-hidden="true">3.16.6.5.</strong> P.MAC.PRO.05</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc/P.MAC.PRO.06.html"><strong aria-hidden="true">3.16.6.6.</strong> P.MAC.PRO.06</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads.html"><strong aria-hidden="true">3.17.</strong> 多线程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock.html"><strong aria-hidden="true">3.17.1.</strong> 锁同步</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock/P.MTH.LCK.01.html"><strong aria-hidden="true">3.17.1.1.</strong> P.MTH.LCK.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock/G.MTH.LCK.01.html"><strong aria-hidden="true">3.17.1.2.</strong> G.MTH.LCK.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock/G.MTH.LCK.02.html"><strong aria-hidden="true">3.17.1.3.</strong> G.MTH.LCK.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock/G.MTH.LCK.03.html"><strong aria-hidden="true">3.17.1.4.</strong> G.MTH.LCK.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock/G.MTH.LCK.04.html"><strong aria-hidden="true">3.17.1.5.</strong> G.MTH.LCK.04</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock-free.html"><strong aria-hidden="true">3.17.2.</strong> 无锁</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock-free/P.MTH.LKF.01.html"><strong aria-hidden="true">3.17.2.1.</strong> P.MTH.LKF.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock-free/P.MTH.LKF.02.html"><strong aria-hidden="true">3.17.2.2.</strong> P.MTH.LKF.02</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/async-await.html"><strong aria-hidden="true">3.18.</strong> 异步编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/async-await/P.ASY.01.html"><strong aria-hidden="true">3.18.1.</strong> P.ASY.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/async-await/G.ASY.01.html"><strong aria-hidden="true">3.18.2.</strong> G.ASY.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/async-await/G.ASY.02.html"><strong aria-hidden="true">3.18.3.</strong> G.ASY.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/async-await/G.ASY.03.html"><strong aria-hidden="true">3.18.4.</strong> G.ASY.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/async-await/G.ASY.04.html"><strong aria-hidden="true">3.18.5.</strong> G.ASY.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/async-await/G.ASY.05.html"><strong aria-hidden="true">3.18.6.</strong> G.ASY.05</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust.html"><strong aria-hidden="true">3.19.</strong> Unsafe Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/P.UNS.01.html"><strong aria-hidden="true">3.19.1.</strong> P.UNS.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/P.UNS.02.html"><strong aria-hidden="true">3.19.2.</strong> P.UNS.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/G.UNS.01.html"><strong aria-hidden="true">3.19.3.</strong> G.UNS.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract.html"><strong aria-hidden="true">3.19.4.</strong> 安全抽象</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.01.html"><strong aria-hidden="true">3.19.4.1.</strong> P.UNS.SAS.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.02.html"><strong aria-hidden="true">3.19.4.2.</strong> P.UNS.SAS.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.03.html"><strong aria-hidden="true">3.19.4.3.</strong> P.UNS.SAS.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.04.html"><strong aria-hidden="true">3.19.4.4.</strong> P.UNS.SAS.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/G.UNS.SAS.01.html"><strong aria-hidden="true">3.19.4.5.</strong> G.UNS.SAS.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/G.UNS.SAS.02.html"><strong aria-hidden="true">3.19.4.6.</strong> G.UNS.SAS.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/G.UNS.SAS.03.html"><strong aria-hidden="true">3.19.4.7.</strong> G.UNS.SAS.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/G.UNS.SAS.04.html"><strong aria-hidden="true">3.19.4.8.</strong> G.UNS.SAS.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/G.UNS.SAS.05.html"><strong aria-hidden="true">3.19.4.9.</strong> G.UNS.SAS.05</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/G.UNS.SAS.06.html"><strong aria-hidden="true">3.19.4.10.</strong> G.UNS.SAS.06</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr.html"><strong aria-hidden="true">3.19.5.</strong> 裸指针操作</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr/P.UNS.PTR.01.html"><strong aria-hidden="true">3.19.5.1.</strong> P.UNS.PTR.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr/G.UNS.PTR.01.html"><strong aria-hidden="true">3.19.5.2.</strong> G.UNS.PTR.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr/G.UNS.PTR.02.html"><strong aria-hidden="true">3.19.5.3.</strong> G.UNS.PTR.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr/G.UNS.PTR.03.html"><strong aria-hidden="true">3.19.5.4.</strong> G.UNS.PTR.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr/G.UNS.PTR.04.html"><strong aria-hidden="true">3.19.5.5.</strong> G.UNS.PTR.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr/G.UNS.PTR.05.html"><strong aria-hidden="true">3.19.5.6.</strong> G.UNS.PTR.05</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/union.html"><strong aria-hidden="true">3.19.6.</strong> 联合体</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/union/G.UNS.UNI.01.html"><strong aria-hidden="true">3.19.6.1.</strong> G.UNS.UNI.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/union/G.UNS.UNI.02.html"><strong aria-hidden="true">3.19.6.2.</strong> G.UNS.UNI.02</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem.html"><strong aria-hidden="true">3.19.7.</strong> 内存</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem/P.UNS.MEM.01.html"><strong aria-hidden="true">3.19.7.1.</strong> P.UNS.MEM.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem/P.UNS.MEM.02.html"><strong aria-hidden="true">3.19.7.2.</strong> P.UNS.MEM.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem/P.UNS.MEM.03.html"><strong aria-hidden="true">3.19.7.3.</strong> P.UNS.MEM.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem/P.UNS.MEM.04.html"><strong aria-hidden="true">3.19.7.4.</strong> P.UNS.MEM.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem/P.UNS.MEM.05.html"><strong aria-hidden="true">3.19.7.5.</strong> P.UNS.MEM.05</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem/G.UNS.MEM.01.html"><strong aria-hidden="true">3.19.7.6.</strong> G.UNS.MEM.01</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi.html"><strong aria-hidden="true">3.19.8.</strong> FFi</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.01.html"><strong aria-hidden="true">3.19.8.1.</strong> P.UNS.FFI.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.02.html"><strong aria-hidden="true">3.19.8.2.</strong> P.UNS.FFI.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.03.html"><strong aria-hidden="true">3.19.8.3.</strong> P.UNS.FFI.03</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.04.html"><strong aria-hidden="true">3.19.8.4.</strong> P.UNS.FFI.04</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.05.html"><strong aria-hidden="true">3.19.8.5.</strong> P.UNS.FFI.05</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.06.html"><strong aria-hidden="true">3.19.8.6.</strong> P.UNS.FFI.06</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.07.html"><strong aria-hidden="true">3.19.8.7.</strong> P.UNS.FFI.07</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.08.html"><strong aria-hidden="true">3.19.8.8.</strong> P.UNS.FFI.08</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.09.html"><strong aria-hidden="true">3.19.8.9.</strong> P.UNS.FFI.09</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.10.html"><strong aria-hidden="true">3.19.8.10.</strong> P.UNS.FFI.10</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.11.html"><strong aria-hidden="true">3.19.8.11.</strong> P.UNS.FFI.11</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.12.html"><strong aria-hidden="true">3.19.8.12.</strong> P.UNS.FFI.12</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/G.UNS.FFI.01.html"><strong aria-hidden="true">3.19.8.13.</strong> G.UNS.FFI.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/G.UNS.FFI.02.html"><strong aria-hidden="true">3.19.8.14.</strong> G.UNS.FFI.02</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/G.UNS.FFI.03.html"><strong aria-hidden="true">3.19.8.15.</strong> G.UNS.FFI.03</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/io.html"><strong aria-hidden="true">3.19.9.</strong> I/O</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/io/G.UNS.FIO.01.html"><strong aria-hidden="true">3.19.9.1.</strong> G.UNS.FIO.01</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/glossary.html"><strong aria-hidden="true">3.19.10.</strong> Unsafe 代码术语指南</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/no-std.html"><strong aria-hidden="true">3.20.</strong> no-std</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/no-std/P.EMB.01.html"><strong aria-hidden="true">3.20.1.</strong> P.EMB.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/no-std/P.EMB.02.html"><strong aria-hidden="true">3.20.2.</strong> P.EMB.02</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/io.html"><strong aria-hidden="true">3.21.</strong> I/O</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/io/P.FIO.01.html"><strong aria-hidden="true">3.21.1.</strong> P.FIO.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/io/G.FIO.01.html"><strong aria-hidden="true">3.21.2.</strong> G.FIO.01</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/security.html"><strong aria-hidden="true">3.22.</strong> 信息安全</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/security/G.SEC.01.html"><strong aria-hidden="true">3.22.1.</strong> G.SEC.01</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/others.html"><strong aria-hidden="true">3.23.</strong> 其他</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/others/G.OTH.01.html"><strong aria-hidden="true">3.23.1.</strong> G.OTH.01</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/others/G.OTH.02.html"><strong aria-hidden="true">3.23.2.</strong> G.OTH.01</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/toc.html"><strong aria-hidden="true">4.</strong> 附录</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/dev_env.html"><strong aria-hidden="true">4.1.</strong> A.开发环境</a></li><li class="chapter-item "><a href="safe-guides/Appendix/test.html"><strong aria-hidden="true">4.2.</strong> B.测试</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/test/unit_test.html"><strong aria-hidden="true">4.2.1.</strong> 单元测试</a></li><li class="chapter-item "><a href="safe-guides/Appendix/test/benchmark.html"><strong aria-hidden="true">4.2.2.</strong> 基准测试</a></li><li class="chapter-item "><a href="safe-guides/Appendix/test/fuzz.html"><strong aria-hidden="true">4.2.3.</strong> 模糊测试</a></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/terms.html"><strong aria-hidden="true">4.3.</strong> C.术语解释</a></li><li class="chapter-item "><a href="safe-guides/Appendix/templates/intro.html"><strong aria-hidden="true">4.4.</strong> D.模板</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/templates/rustfmt.toml.html"><strong aria-hidden="true">4.4.1.</strong> rustfmt 模板</a></li><li class="chapter-item "><a href="safe-guides/Appendix/templates/clippy.toml.html"><strong aria-hidden="true">4.4.2.</strong> clippy 模板</a></li><li class="chapter-item "><a href="safe-guides/Appendix/templates/deny.toml.html"><strong aria-hidden="true">4.4.3.</strong> deny 模板</a></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/tools/intro.html"><strong aria-hidden="true">4.5.</strong> E.工具链</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/tools/rustfmt.html"><strong aria-hidden="true">4.5.1.</strong> rustfmt</a></li><li class="chapter-item "><a href="safe-guides/Appendix/tools/noisy-clippy.html"><strong aria-hidden="true">4.5.2.</strong> noisy-clippy</a></li><li class="chapter-item "><a href="safe-guides/Appendix/tools/cargo-udeps.html"><strong aria-hidden="true">4.5.3.</strong> cargo-udeps</a></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/cheat-sheet/index.html"><strong aria-hidden="true">4.6.</strong> F.Cheat Sheet</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/cheat-sheet/Numbers/float.html"><strong aria-hidden="true">4.6.1.</strong> 浮点数</a></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/optimizing/intro.html"><strong aria-hidden="true">4.7.</strong> G.优化指南</a></li><li class="chapter-item "><a href="safe-guides/Appendix/rustc-flag.html"><strong aria-hidden="true">4.8.</strong> H.编译参数说明</a></li><li class="chapter-item "><a href="safe-guides/Appendix/best-practice/intro.html"><strong aria-hidden="true">4.9.</strong> I.最佳实践</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/best-practice/qa.html"><strong aria-hidden="true">4.9.1.</strong> 初学者常见问题Q&amp;A</a></li><li class="chapter-item "><a href="safe-guides/Appendix/best-practice/tips.html"><strong aria-hidden="true">4.9.2.</strong> Rust 编程技巧</a></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/contribution.html"><strong aria-hidden="true">4.10.</strong> J.贡献说明</a></li><li class="chapter-item "><a href="safe-guides/Appendix/old_guidelines.html"><strong aria-hidden="true">4.11.</strong> K.淘汰的规则</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编码规范 V 0.2</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Rust-Coding-Guidelines/rust-coding-guidelines-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="1-概述"><a class="header" href="#1-概述">1. 概述</a></h1>
<h2 id="状态"><a class="header" href="#状态">状态</a></h2>
<ul>
<li>《Rust 编码规范》初稿发布 2021-10-31 (V 0.1)</li>
<li>《Rust 编码规范》经社区和公司内第一次评审版本发布 2022-02 (V 0.2) </li>
</ul>
<h2 id="详细"><a class="header" href="#详细">详细</a></h2>
<ul>
<li><a href="./overview/why.html">1.1 为什么需要 Rust 编码规范</a></li>
<li><a href="./overview/convention.html">1.2 编码规范基本约定</a></li>
</ul>
<h2 id="介绍"><a class="header" href="#介绍">介绍</a></h2>
<p>Rust 语言社区内其实分散着很多编码规范，下面罗列一部分公开信息：</p>
<ul>
<li><a href="https://rust-lang.github.io/api-guidelines/about.html">官方｜Rust API 编写指南</a></li>
<li><a href="https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md">官方 | Rust Style Guide</a></li>
<li><a href="https://rust-lang.github.io/unsafe-code-guidelines/">Rust's Unsafe Code Guidelines Reference</a></li>
<li><a href="https://anssi-fr.github.io/rust-guide">法国国家信息安全局 | Rust 安全（Security）规范</a></li>
<li><a href="https://developers.diem.com/docs/core/coding-guidelines/">Facebook Diem 项目 Rust 编码规范</a></li>
<li><a href="https://teaclave.apache.org/docs/rust-guildeline/">Apache Teaclave 安全计算平台 | Rust 开发规范</a></li>
<li><a href="https://github.com/pingcap/style-guide">PingCAP | 编码风格指南（包括 Rust 和 Go 等）</a></li>
<li><a href="https://fuchsia.dev/fuchsia-src/development/languages/rust">Google Fuchsia 操作系统 Rust 开发指南</a></li>
<li><a href="https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/style.md">RustAnalyzer 编码风格指南</a></li>
<li><a href="https://deterministic.space/elegant-apis-in-rust.html">使用 Rust 设计优雅的 API</a></li>
<li><a href="https://michael-f-bryan.github.io/rust-ffi-guide/">Rust FFI 指南</a></li>
</ul>
<p>上面这些除了 Rust 官方和法国国家信息安全局的编码规范之外，其他开源项目的编码规范主要是为了规范贡献者们遵循一个统一的编码风格。</p>
<p>所以，一个通用的，覆盖编码风格和具体编码实践的全面的编码规范，更有助于社区各个开源项目和各大公司参考去制定自己的编码规范。</p>
<p><img src="./img/org.png" alt="org" /></p>
<p>本规范致力于成为统一的 Rust 编码规范，各大公司可以依赖本规范，结合自己的业务领域和团队习惯，形成自己的编码规范，并可以在日常实践中反哺本规范，让本规范更加完善。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-为什么需要-rust-编码规范"><a class="header" href="#11-为什么需要-rust-编码规范">1.1 为什么需要 Rust 编码规范</a></h1>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>在刚学 Rust 的时候，我赞叹于 Rust 提供的工具之先进性。比如 rustfmt，可以自动格式化代码，clippy 可以帮助你规范代码中写的不地道的地方。它们确实是非常优秀的工具。当时我也认为 Rust 根本不需要像其他语言那样制定编码规范。</p>
<p>但随着对 Rust 越来越深入了解的过程中，我也逐渐发现这些工具的很多不足之处，覆盖的并不全面。比如 rustfmt 配置和使用不当会导致代码错误，而且无法识别 Rust 代码中各种命名的语义；clippy存在一些误报或lint不合理，以及无法覆盖到 Unsafe Rust 等问题。开发者，尤其是新手们，如果长期像使用一个黑盒一样去依赖rustfmt和clippy，但并不去了解其lint背后的原因，只是知其然而无法知其所以然，那在代码质量有一定要求的前提下是无法提升开发效率的。</p>
<p>所以，rutfmt和clippy并不是万能的。我们还需要一个全面且通用的编码规范，并且也能覆盖到像 rustfmt 和 clippy 这样的工具，让广大 Rust 团队通过规范化的原则和规则去了解编写地道 Rust 代码的基本框架，就可以快速落地 Rust ，增强团队间的协作与信任。</p>
<h2 id="rustfmt-和-clippy-的局限性"><a class="header" href="#rustfmt-和-clippy-的局限性">Rustfmt 和 Clippy 的局限性</a></h2>
<h3 id="rustfmt-局限性"><a class="header" href="#rustfmt-局限性">Rustfmt 局限性</a></h3>
<p>Rust 有自动化格式化工具 rustfmt ，可以帮助开发者摆脱手工调整代码格式的工作，提升生产力。但它并不能代替编码规范对 Rust 代码的编码风格进行规范。</p>
<p>rustftm主要存在以下缺陷：</p>
<ol>
<li>Rust 语言是一门非常注重语义的语言。Rust 中的变量、类型和函数等命名是非常讲究语义的，尤其是所有权语义。rustfmt 工具无法判断代码中命名的语义。这方面利用 Clippy 可以满足部分需求，但是对于开发者来说比较片面。</li>
<li>Rustfmt 如果使用不当或配置不当，会导致问题。因为rustfmt是自动格式化工具，它会自动修改代码，但是它修改的时候并不会编译代码。如果开发者配置自动保存以后自动执行rustfmt，就会导致代码被修改错误，或者，有一些rustfmt 配置选项配置错误，也可能导致代码修改错误。</li>
<li>rustfmt 工具中的配置项都比较零散，大部分开发者不会去了解其每一个配置项的含义。</li>
<li>rustfmt 没有覆盖到代码注释和文档注释的编码规范。</li>
</ol>
<p>综上所述，需要通过提供一个通用的编码规范，让开发者明确地从命名、格式和注释三方面整体上了解 Rust 遵循什么样的编码风格。其中会覆盖 rustfmt 的内容，但并不是机械地将 rustfmt 的规则都一一提取出来，而是对 rustfmt 的规则进行了统一的归类和梳理，方便开发者去理解 rustfmt 中制定的规则，方便团队去制定适合自己的代码风格。</p>
<h3 id="clippy-的局限性"><a class="header" href="#clippy-的局限性">Clippy 的局限性</a></h3>
<p>Clippy是 Rust 的 linter，是 Rust 生态系统中的主要组件之一。它对已开发的代码执行额外的静态检查，报告发现的问题并解释如何修复它们（有时它甚至可以自动修复它们）。使用它能对 Rust 初学者甚至专业人士都带来好处。</p>
<p>但使用 Clippy 并不是意味着它能代替编码规范，它也存在很多缺陷：</p>
<ol>
<li>Clippy 缺乏很多  Unsafe Rust 相关的 lint 检测。Unsafe Rust 是 Rust 非常重要的一部分，需要一个完整的编码规范来覆盖，帮助开发者编写安全的 Unsafe 代码。</li>
<li>Clippy 中的 lint 截止目前有 500多条，而且还有不断增长的趋势，开发者不可能一条条去了解每个 lint，所以需要一个编码规范帮助开发者对lint进行一个梳理归类。</li>
<li>Clippy 中的lint 的建议和分级 （allow/warning/deny）有些争议。其中有些 lint 默认是 allow，但不代表在一些场景下，它就是合理的写法；同样，有些 lint 是 warning，但不代表在一些场景下是不合理的。为此，dtolnay 还特意创造了这个仓库：<a href="https://github.com/dtolnay/noisy-clippy">https://github.com/dtolnay/noisy-clippy</a> ，用于分析社区中crate有多少 Clippy lint 的建议并不符合实际场景，从而达到改进 Clippy 的目的。</li>
</ol>
<p>综上所述，Clippy 虽然是一个十分有用的工具，但它无法替代编码规范。</p>
<h2 id="编码规范作用"><a class="header" href="#编码规范作用">编码规范作用</a></h2>
<p>Rust 编码规范的作用主要是如下方面：</p>
<ol>
<li>遵循 Rust 语言特性，提高代码的可读性、可维护性、健壮性和可移植性。</li>
<li>提高 Unsafe Rust 代码编写的规范性和安全性。</li>
<li>编程规范条款力争系统化、易应用、易检查，帮助开发者提升开发效率。</li>
<li>给开发者一个明确的且全局的视野，在其开发代码的过程中就能遵循好的代码规范，而非等写完代码以后再通过rustfmt和clippy这类的工具，一条一条去修改warning。</li>
<li>规范不等于教程，但是开发人员水平参差不齐，对于一些因为知识盲点而可能导致程序错误的地方，规范也将覆盖到。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-编码规范基本约定"><a class="header" href="#12-编码规范基本约定">1.2 编码规范基本约定</a></h1>
<h2 id="编码规范的内容组织说明"><a class="header" href="#编码规范的内容组织说明">编码规范的内容组织说明</a></h2>
<p><strong>编程规范绝不是为了增加开发者的负担而编写的，目的是为了帮助开发者写出高质量的 Rust 代码。</strong></p>
<p>为了达成这个目的，规范条款分为原则和规则两个类别：<strong>原则</strong> 与 <strong>规则</strong>。</p>
<ul>
<li>
<p>原则，就是编程开发时指导的一个大方向，或是指一类情况。也有少部分原则是 Rust 编译器可检测的情况，但是因为编译器诊断信息比较迷惑，所以增加了原则，帮助开发者去避免这类情况。</p>
</li>
<li>
<p>规则，相对原则来说，更加具体，包含正例和反例来进一步说明。有些规则也会增加例外的情况。规则基本都是可以通过 lint 进行检测的。</p>
</li>
</ul>
<h4 id="规则内容-与-rustfmt-和-clippy-的关系"><a class="header" href="#规则内容-与-rustfmt-和-clippy-的关系">规则内容 与 rustfmt 和 clippy 的关系</a></h4>
<p>规范主要分为两大部分内容：代码风格 和 代码实践。</p>
<p><strong>代码风格</strong></p>
<p>在代码风格中包含代码命名、格式和注释：</p>
<ul>
<li>命名部分，主要是通过 clippy lint 来检查，有些命名规则 clippy lint未提供检测，则需要自定义lint来支持。</li>
<li>格式部分，主要用 rustfmt 来自动修改，编码规范中的规则对 rustfmt 的大部分配置项进行了分类描述，为了方便开发者进行参考，制定自己的配置项。编码规范中也提供了配置模版。</li>
<li>注释部分，其中包括普通注释和文档注释，规则条目通过 rustfmt 和 clippy 合作来进行规范。</li>
</ul>
<p><strong>代码实践</strong></p>
<p>代码实践的内容是按照 Rust 语言特性进行分类，每个语言特性都尽量针对日常编码最佳实践进行总结，提取为一条条的原则和规则，方便开发者进行参考。其中大部分规则都是建议，涉及要求的规则基本都是和安全相关。</p>
<p>这部分内容的规则条目基本都依赖 Clippy lint 去检测，但并非是把 Clippy 500 多条 lint 都一一对应为规则。Clippy lint 中涉及很多技巧类的lint，就没有放到规范中。</p>
<p><strong>规则主要是侧重于通用场景下，代码可读性、维护性、安全性、性能这四方面的考量，它仅仅覆盖一小部分（不到 1/5）clippy lint</strong>。另外还有一些规则是clippy lint没有的，需要自定义lint。</p>
<p>代码实践内容的重点在于 Unsafe Rust 的编码规范，其中编码原则多于规则，并且 Clippy lint 也很少能检测这部分内容。其中要求类的规则更多一些。</p>
<p>希望通过这部分内容，让开发者在编写 Rust 代码过程中，避开一些常见的坑。</p>
<h2 id="编码规范内容约定"><a class="header" href="#编码规范内容约定">编码规范内容约定</a></h2>
<p>通过标题前的编号来标识：</p>
<ul>
<li>标识为<code>P</code>为原则（Principle）。编号方式为<code>P.Element.Number</code>。</li>
<li>标识为<code>G</code>为规则（Guideline）。编号方式为<code>G.Element.Number</code>。</li>
<li>当有子目录时。编号方式为 <code>P.Element.SubElement.Number</code> 或 <code>G.Element.SubElement.Number</code>。</li>
</ul>
<p>Number 从<code>01</code>开始递增。其中 <code>Element</code> 为领域知识中关键元素（本规范中对应的二级目录）的三位英文字母缩略语。（术语参考： <a href="https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard">SEI CERT C Coding Standard</a>）</p>
<table><thead><tr><th>Element</th><th>解释</th><th>Element</th><th>解释</th></tr></thead><tbody>
<tr><td>NAM</td><td>命名 (Naming)</td><td>CMT</td><td>注释 (Comment)</td></tr>
<tr><td>FMT</td><td>格式 (Format)</td><td>TYP</td><td>数据类型 (Data Type)</td></tr>
<tr><td>CNS</td><td>常量 (Const)</td><td>VAR</td><td>变量  (Variables)</td></tr>
<tr><td>EXP</td><td>表达式 (Expression)</td><td>CTF</td><td>控制流程 (Control Flow)</td></tr>
<tr><td>RFE</td><td>引用 (Reference)</td><td>PTR</td><td>指针  (Pointer)</td></tr>
<tr><td>STR</td><td>字符串 (String)</td><td>INT</td><td>整数 (Integer)</td></tr>
<tr><td>MOD</td><td>模块  (Module)</td><td>CAR</td><td>包管理  (Cargo)</td></tr>
<tr><td>MEM</td><td>内存 (Memory)</td><td>FUD</td><td>函数设计 (Function Design)</td></tr>
<tr><td>MAC</td><td>宏  (Macro)</td><td>STV</td><td>静态变量 (Static Variables)</td></tr>
<tr><td>GEN</td><td>泛型 (Generic)</td><td>TRA</td><td>特质 (Trait)</td></tr>
<tr><td>ASY</td><td>异步 (Async)</td><td>UNS</td><td>非安全 (Unsafe Rust)</td></tr>
<tr><td>SAS</td><td>安全抽象 (Safety Abstract)</td><td>FFI</td><td>外部函数调用接口 ( Foreign Function Interface )</td></tr>
<tr><td>LAY</td><td>内存布局 (Layout)</td><td>ERR</td><td>错误处理 (Error Handle)</td></tr>
<tr><td>CLT</td><td>集合  (Collection)</td><td>MTH</td><td>多线程 (Multi Threads)</td></tr>
<tr><td>EMB</td><td>嵌入式Rust (Embedded Rust)</td><td>FIO</td><td>输入输出 (In/Out)</td></tr>
<tr><td>SEC</td><td>信息安全 (Security)</td><td>SPT</td><td>智能指针 (Smart Pointer)</td></tr>
<tr><td>UNT</td><td>单元类型 (Unit)</td><td>BOL</td><td>布尔 (Bool)</td></tr>
<tr><td>CHR</td><td>字符类型 (Char)</td><td>FLT</td><td>浮点数 (Float)</td></tr>
<tr><td>SLC</td><td>切片类型 (Slice)</td><td>TUP</td><td>元组 (Tuple)</td></tr>
<tr><td>ARR</td><td>固定长度数组类型 (Array)</td><td>VEC</td><td>动态长度数组 (Vector)</td></tr>
<tr><td>SCT</td><td>结构体 (Struct)</td><td>ENM</td><td>枚举体 (Enum)</td></tr>
<tr><td>UNI</td><td>联合体 (Union)</td><td>BLN</td><td>标准库内置（BuiltIn）</td></tr>
<tr><td>OBJ</td><td>Trait 对象 (Trait Object)</td><td>LFT</td><td>生命周期 (Lifetime)</td></tr>
<tr><td>BOX</td><td><code>Box&lt;T&gt;</code> 类型</td><td>DRP</td><td>析构函数 (Drop)</td></tr>
<tr><td>DCL</td><td>声明宏 (Declarative)</td><td>PRO</td><td>过程宏 (Procedural)</td></tr>
<tr><td>LCK</td><td>锁同步 (Lock)</td><td>LKF</td><td>无锁 (Lock Free)</td></tr>
<tr><td></td><td></td><td>OTH</td><td>其他 (Ohters)</td></tr>
</tbody></table>
<h2 id="引用代码开源许可证说明"><a class="header" href="#引用代码开源许可证说明">引用代码开源许可证说明</a></h2>
<p>本规范中引用外部代码，均满足 <code>MIT/Apache/Mozilla public licenses</code> 开源许可证！</p>
<h2 id="特别鸣谢"><a class="header" href="#特别鸣谢">特别鸣谢</a></h2>
<p>本指南参考《华为 C 语言编程指南 V 1.0》，感谢华为 开源能力中心 提供编程指南规范协助！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-代码风格"><a class="header" href="#2-代码风格">2. 代码风格</a></h1>
<p>代码风格包含标识符的命名风格、排版与格式风格、注释风格等。一致的编码习惯与风格，可以提高代码可读性和可维护性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="21-命名"><a class="header" href="#21-命名">2.1 命名</a></h1>
<p>好的命名风格能让我们快速地了解某个名字代表的含义（类型、变量、函数、常量、宏等），甚至能凸显其在整个代码上下文中的语义。命名管理对提升代码的可读性和维护性相当重要。</p>
<h2 id="列表"><a class="header" href="#列表">列表</a></h2>
<ul>
<li><a href="safe-guides/code_style/./naming/P.NAM.01.html">P.NAM.01 类型名称应该使用统一的词序</a></li>
<li><a href="safe-guides/code_style/./naming/P.NAM.02.html">P.NAM.02 cargo feature 名中不应该含有无意义的占位词</a></li>
<li><a href="safe-guides/code_style/./naming/G.NAM.01.html">G.NAM.01 标识符命名应该符合阅读习惯</a></li>
<li><a href="safe-guides/code_style/./naming/G.NAM.02.html">G.NAM.02 使用统一的命名风格</a></li>
<li><a href="safe-guides/code_style/./naming/G.NAM.03.html">G.NAM.03 作用域越大，命名越精确；反之应简短</a></li>
<li><a href="safe-guides/code_style/./naming/G.NAM.04.html">G.NAM.04 类型转换函数命名需要遵循所有权语义</a></li>
<li><a href="safe-guides/code_style/./naming/G.NAM.05.html">G.NAM.05 用于访问或获取数据的 <code>getter</code> 类方法通常不要使用 <code>get_</code> 等前缀</a></li>
<li><a href="safe-guides/code_style/./naming/G.NAM.06.html">G.NAM.06 遵循 <code>iter/ iter_mut/ into_iter</code> 规范来生成迭代器</a></li>
<li><a href="safe-guides/code_style/./naming/G.NAM.07.html">G.NAM.07 避免使用语言内置保留字、关键字、内置类型和trait等特殊名称</a></li>
<li><a href="safe-guides/code_style/./naming/G.NAM.08.html">G.NAM.08 避免在变量的命名中添加类型标识</a></li>
<li><a href="safe-guides/code_style/./naming/G.NAM.09.html">G.NAM.09 定义全局静态变量时需加前缀<code>G_</code>和常量有所区分</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pnam01--同一个crate中标识符的命名规则应该使用统一的词序"><a class="header" href="#pnam01--同一个crate中标识符的命名规则应该使用统一的词序">P.NAM.01  同一个crate中标识符的命名规则应该使用统一的词序</a></h2>
<p><strong>【描述】</strong></p>
<p>具体选择什么样的词序并不重要，但务必要保证同一个 crate 内词序的一致性。
若提供与标准库中相似功能的东西时，也要与标准库名称的词性顺序一致.</p>
<blockquote>
<p>拿错误类型来举个例子：</p>
<p>当crate中类型名称都按照 <strong>动词-宾语-error</strong> 这样的顺序来命名错误类型时，如果要增加新的错误类型，则也需要按同样的词序来增加。</p>
</blockquote>
<p><strong>【正例】</strong></p>
<p>以下是来自标准库的处理错误的一些类型：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/env/struct.JoinPathsError.html"><code>JoinPathsError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/str/struct.ParseBoolError.html"><code>ParseBoolError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/char/struct.ParseCharError.html"><code>ParseCharError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/num/struct.ParseFloatError.html"><code>ParseFloatError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/mpsc/enum.RecvTimeoutError.html"><code>RecvTimeoutError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/path/struct.StripPrefixError.html"><code>StripPrefixError</code></a></li>
</ul>
<p>如果你想新增和标准库相似的错误类型，比如“解析地址错误”类型，为了保持词性一致，应该使用<code>ParseAddrError</code> 名称，而不是<code>AddrParseError</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ParseAddrError{}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 与标准库错误类型次序不一致，应该为 ParseAddrError
struct AddrParseError {}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pnam02--cargo-feature-名中不应该含有无意义的占位词"><a class="header" href="#pnam02--cargo-feature-名中不应该含有无意义的占位词">P.NAM.02  cargo feature 名中不应该含有无意义的占位词</a></h2>
<p><strong>【描述】</strong></p>
<p>给 <a href="http://doc.crates.io/manifest.html#the-features-section">Cargo feature</a> 命名时，不要带有无实际含义的的词语，比如无需 <code>use-abc</code> 或 <code>with-abc</code> ，而是直接以 <code>abc</code> 命名。</p>
<p>这条原则经常出现在对 Rust 标准库进行 <a href="https://doc.rust-lang.org/cargo/reference/features.html#optional-dependencies">可选依赖(optional-dependency)</a> 配置的 crate 上。</p>
<p><strong>【反例】</strong></p>
<pre><code class="language-toml"># In Cargo.toml

// 不要给 feature 取 `use-std` 或者 `with-std` 或者除 `std` 之外另取名字。
[features]
default = [&quot;use-std&quot;]
std = []
</code></pre>
<pre><code class="language-rust ignored">// In lib.rs

#![cfg_attr(not(feature = &quot;use-std&quot;), no_std)]
</code></pre>
<p>feature 应与 Cargo 在推断可选依赖时隐含的 features 具有一致的名字。</p>
<p>假如<code>x</code> crate 对 Serde 和 标准库 具有可选依赖关系</p>
<pre><code class="language-toml">[package]
name = &quot;x&quot;
version = &quot;0.1.0&quot;

[features]
std = [&quot;serde/std&quot;]
// Cargo 要求 features 应该是叠加的，所以像 `no-abc` 这种负向的 feature 命名实际上并不正确。
no-abc=[]

[dependencies]
serde = { version = &quot;1.0&quot;, optional = true }
</code></pre>
<p><strong>【正例】</strong></p>
<p>最简洁且正确的做法是：</p>
<pre><code class="language-toml"># In Cargo.toml

[features]
default = [&quot;std&quot;]
std = []
</code></pre>
<pre><code class="language-rust ignored">// In lib.rs

#![cfg_attr(not(feature = &quot;std&quot;), no_std)]
</code></pre>
<p>假如 <code>x</code> crate 对 Serde 和 标准库具有可选依赖关系：</p>
<pre><code class="language-toml">[package]
name = &quot;x&quot;
version = &quot;0.1.0&quot;

[features]
std = [&quot;serde/std&quot;]

[dependencies]
serde = { version = &quot;1.0&quot;, optional = true }
</code></pre>
<p>当我们使用 <code>x</code> crate 时，可以使用 <code>features = [&quot;serde&quot;]</code> 开启 Serde 依赖。类似地，也可以使用 <code>features = [&quot;std&quot;]</code> 开启标准库依赖。
Cargo 推断的隐含的 features 应该叫做 <code>serde</code> ，而不是 <code>use-serde</code> 或者 <code>with-serde</code> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gnam01-标识符命名应该符合阅读习惯"><a class="header" href="#gnam01-标识符命名应该符合阅读习惯">G.NAM.01 标识符命名应该符合阅读习惯</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>标识符的命名要清晰、明了，有明确含义，容易理解。符合英文阅读习惯的命名将明显提高代码可读性。</p>
<p>一些好的实践包括但不限于：</p>
<ul>
<li>使用正确的英文单词并符合英文语法，不要使用拼音</li>
<li>仅使用常见或领域内通用的单词缩写</li>
<li>布尔型变量或函数避免使用否定形式，双重否定不利于理解</li>
<li>不要使用 Unicode 标识符。</li>
</ul>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ming: &amp;str = &quot;John&quot;;
let xing: &amp;str = &quot;Smith&quot;;
const ERROR_NO_1: u32 = 336;
const ERROR_NO_2: u32 = 594;

fn not_number(s:&amp;str) -&gt; bool {/* ... */}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let first_name: &amp;str = &quot;John&quot;;
let last_name: &amp;str = &quot;Smith&quot;;
const ERROR_DIRECTORY_NOT_SUPPORTED: u32 = 336;
const ERROR_DRIVER_CANCEL_TIMEOUT: u32 = 594;

fn is_number(s:&amp;str) -&gt; bool {/* ... */} //用来判断是否为整数
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>检测错误的英文拼写，检测出后提示；检测拼音，检测出来提示。拼写错误可参考 <a href="https://github.com/client9/misspell">client9/misspell</a> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gnam02-使用统一的命名风格"><a class="header" href="#gnam02-使用统一的命名风格">G.NAM.02 使用统一的命名风格</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>Rust 倾向于在“类型级别”的结构中使用 <code>UpperCamelCase</code> 命名风格，在 “值（实例）级别”的结构中使用 <code>snake_case</code>命名风格。</p>
<p>下面是具体汇总。</p>
<table><thead><tr><th>Item</th><th>规范</th></tr></thead><tbody>
<tr><td>包（Crates）</td><td><a href="https://github.com/rust-lang/api-guidelines/issues/29">通常使用 snake_case</a> <sup class="footnote-reference"><a href="#crate-name">1</a></sup></td></tr>
<tr><td>模块（Modules）</td><td><code>snake_case</code></td></tr>
<tr><td>类型（Types）</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>特质（Traits）</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>枚举体（Enum variants）</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>函数（Functions）</td><td><code>snake_case</code></td></tr>
<tr><td>方法（Methods）</td><td><code>snake_case</code></td></tr>
<tr><td>通用构造函数（General constructors）</td><td><code>new</code> 或者 <code>with_more_details</code></td></tr>
<tr><td>转换构造函数（Conversion constructors）</td><td><code>from_some_other_type</code></td></tr>
<tr><td>宏（Macros）</td><td><code>snake_case!</code></td></tr>
<tr><td>本地变量（Local variables）</td><td><code>snake_case</code></td></tr>
<tr><td>静态变量（Statics）</td><td><code>SCREAMING_SNAKE_CASE</code></td></tr>
<tr><td>常量（Constants）</td><td><code>SCREAMING_SNAKE_CASE</code></td></tr>
<tr><td>类型参数（Type parameters）</td><td>简明的 <code>UpperCamelCase</code> ，通常使用单个大写字母： <code>T</code></td></tr>
<tr><td>生存期（Lifetimes）</td><td>简短的 <code>lowercase</code>，通常使用单个小写字母 <code>'a</code>, <code>'de</code>, <code>'src</code>，尽量保持语义</td></tr>
<tr><td>特性（Features）</td><td><code>snake_case</code></td></tr>
</tbody></table>
<p>说明 :</p>
<ol>
<li>在 <code>UpperCamelCase</code>情况下，由首字母缩写组成的缩略语和 复合词的缩写，算作一个词。比如，应该使用 <code>Uuid</code> 而非 <code>UUID</code>，使用 <code>Usize</code> 而不是 <code>USize</code>，或者是 <code>Stdin</code> 而不是 <code>StdIn</code>。</li>
<li>在<code>snake_case</code>中，首字母缩写和缩略词是小写的：is_xid_start。</li>
<li>在 <code>snake_case</code> 或者 <code>SCREAMING_SNAKE_CASE</code> 情况下，每个词不应该由单个字母组成——除非这个字母是最后一个词。比如，使用 <code>btree_map</code> 而不使用 <code>b_tree_map</code>，使用 <code>PI_2</code> 而不使用 <code>PI2</code> 。</li>
</ol>
<p>关于包命名：</p>
<ul>
<li>由于历史问题，包名有两种形式 <code>snake_case</code> 或 <code>kebab-case</code> ，但实际在代码中需要引入包名的时候，Rust 只能识别 <code>snake_case</code>，也会自动将 <code>kebab-case</code> 识别为  <code>kebab_case</code>。所以建议使用<code>snake_case</code>。</li>
<li>Crate 的名称通常不应该使用 <code>-rs</code> 或者 <code>-rust</code> 作为后缀或者前缀。 因为每个 crate 都是 Rust 编写的！ 没必要一直提醒使用者这一点。但是有些情况下，比如是其他语言移植的同名 Rust 实现，则可以使用 <code>-rs</code> 后缀来表明这是 Rust 实现的版本。</li>
</ul>
<p><strong>【参考】</strong></p>
<p>Rust 命名规范在 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md">RFC 0430</a> 中有也描述。</p>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#non-camel-case-types"><code>Rustc: non_camel_case_types</code></a></td><td>no</td><td>yes</td><td>Style</td></tr>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#non-snake-case"><code>Rustc: non_snake_case</code></a></td><td>no</td><td>yes</td><td>Style</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gnam03-作用域越大命名越精确反之应简短"><a class="header" href="#gnam03-作用域越大命名越精确反之应简短">G.NAM.03 作用域越大，命名越精确；反之应简短</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<ol>
<li>对于全局函数、全局变量、宏、类型名、枚举命名，应当精确描述并全局唯一。</li>
<li>对于函数局部变量，或者结构体、枚举中的成员变量，在其命名能够准确表达含义的前提下，应该尽量简短，避免冗余信息重复描述。</li>
</ol>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 全局静态变量
static GET_COUNT: i32 = 42;  // 不符合：描述不精确

// 枚举类型
enum WebEvent {
    // An `enum` may either be `unit-like`,
    PageLoadEvent,
    PageUnloadEvent,
    // like tuple structs,
    KeyPressEvent(char),
    PasteEvent(String),
    // or c-like structures.
    ClickEvent { x: i64, y: i64 },
}

// 类型别名
type MaskSize = u16; 

pub struct HeaderMap {
    // 这样使用就显得有些冗余
    mask: MaskSize,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 全局静态变量
static MAX_THREAD_COUNT: i32 = 42;  // 符合

// 枚举类型
// 符合： 上下文信息已经知道它是 Event
enum WebEvent {
    // An `enum` may either be `unit-like`,
    PageLoad,
    PageUnload,
    // like tuple structs,
    KeyPress(char),
    Paste(String),
    // or c-like structures.
    Click { x: i64, y: i64 },
}

// 类型别名
type Size = u16; 

pub struct HeaderMap {
    // 在使用它的地方自然就知道是描述谁的大小
    mask: Size,
}

<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#module_name_repetitions">module_name_repetitions</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gnam04-类型转换函数命名需要遵循所有权语义"><a class="header" href="#gnam04-类型转换函数命名需要遵循所有权语义">G.NAM.04 类型转换函数命名需要遵循所有权语义</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>应该使用带有以下前缀名称方法来进行特定类型转换：</p>
<table><thead><tr><th>名称前缀</th><th>内存代价</th><th>所有权</th></tr></thead><tbody>
<tr><td><code>as_</code></td><td>无代价</td><td>borrowed -&gt; borrowed</td></tr>
<tr><td><code>to_</code></td><td>代价昂贵</td><td>borrowed -&gt; borrowed<br>borrowed -&gt; owned (非 Copy 类型)<br>owned -&gt; owned (Copy 类型)</td></tr>
<tr><td><code>into_</code></td><td>看情况</td><td>owned -&gt; owned (非 Copy 类型)</td></tr>
</tbody></table>
<p>以 <code>as_</code> 和 <code>into_</code> 作为前缀的类型转换通常是 <em>降低抽象层次</em> ，要么是查看背后的数据 ( <code>as</code> ) ，要么是分解 (deconstructe) 背后的数据 ( <code>into</code> ) 。
相对来说，以 <code>to_</code> 作为前缀的类型转换处于同一个抽象层次，但是做了更多的工作。</p>
<p>当一个类型用更高级别的语义 (higher-level semantics) 封装 (wraps) 一个与之有关的值时，应该使用 <code>into_inner()</code> 方法名来取出被封装的值。</p>
<p>这适用于以下封装器：</p>
<p>读取缓存 (<a href="https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner"><code>BufReader</code></a>) 、编码或解码 (<a href="https://docs.rs/flate2/1.0.22/flate2/read/struct.GzDecoder.html#method.into_inner"><code>GzDecoder</code></a>) 、取出原子 (<a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.into_inner"><code>AtomicBool</code></a> 、
或者任何相似的语义 (<a href="https://doc.rust-lang.org/stable/std/io/struct.BufWriter.html#method.into_inner"><code>BufWriter</code></a>)。</p>
<p><strong>【正例】</strong></p>
<p>标准库 API 命名有如下示例：</p>
<ul>
<li><code>as_</code>
<ul>
<li><a href="https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes"><code>str::as_bytes()</code></a> 
用于查看 UTF-8 字节的 <code>str</code> 切片，
这是无内存代价的（不会产生内存分配）。
传入值是 <code>&amp;str</code> 类型，输出值是 <code>&amp;[u8]</code> 类型。</li>
</ul>
</li>
<li><code>to_</code>
<ul>
<li>[<code>Path::to_str</code>] (https://doc.rust-lang.org/stable/std/path/struct.Path.html#method.to_str)
对操作系统路径进行 UTF-8 字节检查，开销昂贵。
虽然输入和输出都是借用，但是这个方法对运行时产生不容忽视的代价，
所以不应使用 <code>as_str</code> 名称。</li>
<li>[<code>str::to_lowercase()</code>] (https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase)
生成正确的 Unicode 小写字符，
涉及遍历字符串的字符，可能需要分配内存。
输入值是 <code>&amp;str</code> 类型，输出值是 <code>String</code> 类型。</li>
<li>[<code>f64::to_radians()</code>] (https://doc.rust-lang.org/std/primitive.f64.html#method.to_radians)
把浮点数的角度制转换成弧度制。
输入和输出都是 <code>f64</code> 。没必要传入 <code>&amp;f64</code> ，因为复制 <code>f64</code> 花销很小。
但是使用 <code>into_radians</code> 名称就会具有误导性，因为输入数据没有被消耗。</li>
</ul>
</li>
<li><code>into_</code>
<ul>
<li><a href="https://doc.rust-lang.org/std/string/struct.String.html#method.into_bytes"><code>String::into_bytes()</code></a>
从 <code>String</code> 提取出背后的 <code>Vec&lt;u8&gt;</code> 数据，这是无代价的。
它转移了 <code>String</code> 的所有权，然后返回具有所有权的 <code>Vec&lt;u8&gt;</code> 。</li>
<li>[<code>BufReader::into_inner()</code>] (https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner)
转移了 buffered reader 的所有权，取出其背后的 reader ，这是无代价的。
存于缓冲区的数据被丢弃了。</li>
<li>[<code>BufWriter::into_inner()</code>] (https://doc.rust-lang.org/std/io/struct.BufWriter.html#method.into_inner)
转移了 buffered writer 的所有权，取出其背后的 writer ，这可能以很大的代价刷新所有缓存数据。</li>
</ul>
</li>
</ul>
<p>如果类型转换方法返回的类型具有 <code>mut</code> 标识符，那么这个方法的名称应如同返回类型组成部分的顺序那样，带有 <code>mut</code> 名。
比如 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.as_mut_slice"><code>Vec::as_mut_slice</code></a> 返回 <code>mut slice</code> 类型，这个方法的功能正如其名称所述，所以这个名称优于 <code>as_slice_mut</code> 。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Return type is a mut slice.
fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T];
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.as_ref"><code>Result::as_ref</code></a></li>
<li><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.as_ptr"><code>RefCell::as_ptr</code></a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.to_vec"><code>slice::to_vec</code></a></li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.into_iter"><code>Option::into_iter</code></a></li>
</ul>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>Lint Level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#wrong_self_convention">wrong_self_convention</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gnam05-用于访问或获取数据的-getter-类方法通常不要使用-get_-前缀"><a class="header" href="#gnam05-用于访问或获取数据的-getter-类方法通常不要使用-get_-前缀">G.NAM.05 用于访问或获取数据的 <code>getter</code> 类方法通常不要使用 <code>get_</code> 前缀</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>因为 Rust 所有权语义的存在，此例子中两个方法的参数分别是共享引用 <code>&amp;self</code> 和 独占引用 <code>&amp;mut self</code>，分别代表了 getter 的语义。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct First;
pub struct Second;

pub struct S {
    first: First,
    second: Second,
}

impl S {
    // 不符合：访问成员函数名字不用get_前缀。
    pub fn get_first(&amp;self) -&gt; &amp;First {
        &amp;self.first
    }

    // 不符合：
    // 同样不建议 `get_mut_first`, or `mut_first`.
    pub fn get_first_mut(&amp;mut self) -&gt; &amp;mut First {
        &amp;mut self.first
    }

    // set_前缀是可以的
    pub fn set_first(&amp;mut self, f: First) -&gt; &amp;mut First {
        self.first = f;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct First;
pub struct Second;

pub struct S {
    first: First,
    second: Second,
}

impl S {
    // 不建议 `get_first`。
    pub fn first(&amp;self) -&gt; &amp;First {
        &amp;self.first
    }

    // 不建议 `get_first_mut`, `get_mut_first`, or `mut_first`.
    pub fn first_mut(&amp;mut self) -&gt; &amp;mut First {
        &amp;mut self.first
    }

    // set_前缀是可以的
    pub fn set_first(&amp;mut self, f: First) -&gt; &amp;mut First {
        self.first = f;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>但也存在例外情况：只有当有一个明显的东西可以通过<code>getter</code>得到时，才会使用<code>get</code>命名。例如，<code>Cell::get</code>可以访问一个<code>Cell</code>的内容。</p>
<p>对于进行运行时验证的getter，例如边界检查，可以考虑添加一个 Unsafe 的<code>_unchecked</code> 配套方法。一般来说，会有以下签名。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 进行一些运行时验证，例如边界检查
fn get(&amp;self, index: K) -&gt; Option&lt;&amp;V&gt;;
fn get_mut(&amp;mut self, index: K) -&gt; Option&lt;&amp;mut V&gt;;
// 没有运行时验证，用于在某些情况下提升性能。比如，在当前运行环境中不可能发生越界的情况。
unsafe fn get_unchecked(&amp;self, index: K) -&gt; &amp;V;
unsafe fn get_unchecked_mut(&amp;mut self, index: K) -&gt; &amp;mut V;
<span class="boring">}
</span></code></pre></pre>
<p>getter 和类型转换 (<a href="safe-guides/code_style/naming/./G.NAM.02.html">G.NAM.02</a>) 之间的区别很小，大部分时候不那么清晰可辨。比如 <a href="https://docs.rs/tempdir/0.3.7/tempdir/struct.TempDir.html#method.path"><code>TempDir::path</code></a> 可以被理解为临时目录的文件系统路径的 getter ，而 <a href="https://docs.rs/tempdir/0.3.7/tempdir/struct.TempDir.html#method.into_path"><code>TempDir::into_path</code></a> 负责把删除临时目录时转换的数据传给调用者。</p>
<p>因为 <code>path</code> 方法是一个 getter ，如果用 <code>get_path</code> 或者 <code>as_path</code> 就不对了。</p>
<p>来自标准库的例子：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/io/struct.Cursor.html#method.get_mut"><code>std::io::Cursor::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ptr/struct.Unique.html#method.get_mut"><code>std::ptr::Unique::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html#method.get_mut"><code>std::sync::PoisonError::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.get_mut"><code>std::sync::atomic::AtomicBool::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/hash_map/struct.OccupiedEntry.html#method.get_mut"><code>std::collections::hash_map::OccupiedEntry::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked"><code>&lt;[T]&gt;::get_unchecked</code></a></li>
</ul>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>检测 Struct 实现的方法名是否包含 <code>get_/set_</code> 前缀，如果包含，则给予警告。 </p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gnam06-遵循-iter-iter_mut-into_iter-规范来生成迭代器"><a class="header" href="#gnam06-遵循-iter-iter_mut-into_iter-规范来生成迭代器">G.NAM.06 遵循 <code>iter/ iter_mut/ into_iter</code> 规范来生成迭代器</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>此规则包含两条基本子规则：</p>
<ol>
<li>对于容纳 <code>U</code> 类型的容器 (container) ，其迭代器方法应该遵循<code>iter/ iter_mut/ into_iter</code> 这三种命名方式。</li>
<li>并且返回的迭代器类型名称也应该和其方法名保持一致，如一个叫做<code>into_iter()</code>的方法应该返回一个叫做<code>IntoIter</code>的类型。</li>
</ol>
<p>说明：</p>
<ul>
<li>规则一适用于在概念上属于同质集合的数据结构的方法，而非函数。例如，第三方库 <code>url</code>  中的 <a href="https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html">percent_encode</a> 返回一个 URL 编码的字符串片段的迭代器。使用<code>iter/iter_mut/into_iter</code>约定的话，函数名就不会有任何明确的语义了。</li>
<li>规则二同样主要适用于方法，但通常对函数也有意义。例如，第三方库 <code>url</code>  中的 <a href="https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html">percent_encode</a> 返回一个<code>PercentEncode</code> 类型的迭代器。</li>
</ul>
<p><strong>【反例】</strong></p>
<p>标准库中存在一个反例： <code>str</code> 类型是有效 UTF-8 字节的切片（slice），概念上与同质集合略有差别，所以 <code>str</code> 没有提供 <code>iter</code>/<code>iter_mut</code>/<code>into_iter</code> 命名的迭代器方法，而是提供 <a href="https://doc.rust-lang.org/stable/std/primitive.str.html#method.bytes"><code>str::bytes</code></a> 方法来输出字节迭代器、 <a href="https://doc.rust-lang.org/stable/std/primitive.str.html#method.chars"><code>str::chars</code></a> 方法来输出字符迭代器。</p>
<p><strong>【正例】</strong></p>
<pre><code class="language-rust ignored">fn iter(&amp;self) -&gt; Iter             // Iter 实现 Iterator&lt;Item = &amp;U&gt;
fn iter_mut(&amp;mut self) -&gt; IterMut  // IterMut 实现 Iterator&lt;Item = &amp;mut U&gt;
fn into_iter(self) -&gt; IntoIter     // IntoIter 实现 Iterator&lt;Item = U&gt;
</code></pre>
<p>另外还有来自标准库的例子：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter"><code>Vec::iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut"><code>Vec::iter_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter"><code>Vec::into_iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter"><code>BTreeMap::iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter_mut"><code>BTreeMap::iter_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.keys"><code>BTreeMap::keys</code></a>  返回 [<code>Keys</code>]<a href="https://doc.rust-lang.org/std/collections/btree_map/struct.Keys.html">btree_map::Keys</a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.values"><code>BTreeMap::values</code></a> 返回 [<code>Values</code>]<a href="https://doc.rust-lang.org/std/collections/btree_map/struct.Values.html">btree_map::Values</a></li>
</ul>
<p><strong>【参考】</strong></p>
<p>参考 [RFC 199]: https://github.com/rust-lang/rfcs/blob/master/text/0199-ownership-variants.md</p>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>检测 <code>iter/iter_mut/into_iter</code> 方法的返回类型是否对应 <code>Iter/IterMut/IntoIter</code> ，且，其返回类型是否与方法名相匹配，如果不是，则给予警告。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gnam07--避免使用语言内置保留字关键字内置类型和trait等特殊名称"><a class="header" href="#gnam07--避免使用语言内置保留字关键字内置类型和trait等特殊名称">G.NAM.07  避免使用语言内置保留字、关键字、内置类型和<code>trait</code>等特殊名称</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>命名必须要避免使用语言内置的保留字、关键字、内置类型和<code>trait</code>等特殊名称。 具体可以参考<a href="https://doc.rust-lang.org/stable/reference/keywords.html">The Rust Reference-Keywords</a></p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// Sized ： Rust 内置了同名 trait 
type Sized = u16; 

fn main() {
    // try 为保留关键字，使用`r#`前缀可以使用它，但要尽力避免
    let r#try = 1;
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>可以检测 标识符 是否通过<code>r#</code>使用了 语言内置的保留字、关键字、内置类型和<code>trait</code>等特殊名称，如果使用，则给予警告。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gnam08--避免在变量的命名中添加类型标识"><a class="header" href="#gnam08--避免在变量的命名中添加类型标识">G.NAM.08  避免在变量的命名中添加类型标识</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>因为 Rust 语言类型系统崇尚显式的哲学，所以不需要在变量命名中也添加关于类型的标识。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let account_bytes: Vec&lt;u8&gt; = read_some_input();   // account 的类型很清楚，没必要在命名中加 `_bytes`
let account_str = String::from_utf8(account_bytes)?; // account 的类型很清楚，没必要在命名中加 `_str`
let account: Account = account_str.parse()?;   // account 的类型很清楚，没必要在命名中加 `_str`
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let account: Vec&lt;u8&gt; = read_some_input();   // account 的类型很清楚
let account = String::from_utf8(account)?;  // account 的类型很清楚
let account: Account = account.parse()?;   // account 的类型很清楚
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】
这条规则如果需要定制Lint，则可以获取变量命名的结尾部分和变量类型，进行匹配，判断是否重复。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gnam09-定义全局静态变量时需加前缀g_和常量有所区分"><a class="header" href="#gnam09-定义全局静态变量时需加前缀g_和常量有所区分">G.NAM.09 定义全局静态变量时需加前缀<code>G_</code>和常量有所区分</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>为了提升代码可读性和可维护性，有必要将常量的命名和全局静态变量有所区分。所以在定义全局静态变量时，需要以前缀<code>G_</code>命名。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static EVENT: [i32;5]=[1,2,3,4,5];
const MAGIC_NUM: i32 = 65 ;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static G_EVENT: [i32;5]=[1,2,3,4,5];
const MAGIC_NUM: i32 = 65 ;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】
检测<code>static</code> 全局静态变量的命名是否包含<code>G_</code>前缀。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="22-格式"><a class="header" href="#22-格式">2.2 格式</a></h1>
<p>Rust 有自动化格式化工具 rustfmt ，可以帮助开发者摆脱手工调整代码格式的工作，提升生产力。但是，rustfmt 遵循什么样的风格规范，作为开发者应该需要了解，在编写代码的时候可以主动按这样的风格编写。</p>
<p>说明：以下 <code>rustfmt</code> 配置中对应配置项如果 <code>Stable</code>为<code>No</code>，则表示该配置项不能用于 Stable Rust 下在 <code>rustfmt.toml</code> 中自定义，但其默认值会在<code>cargo fmt</code>时生效。在 Nightly Rust 下则都可以自定义。</p>
<p>在 Stable Rust 下使用未稳定配置项的方法、了解配置示例及其他全局配置项说明请参阅：<a href="safe-guides/code_style/./../Appendix/tools/rustfmt.html">Rustfmt 配置相关说明</a> 。</p>
<p>注意： 以下规则 针对 rustfmt  version 1.4.36 版本。</p>
<h2 id="列表-1"><a class="header" href="#列表-1">列表</a></h2>
<ul>
<li><a href="safe-guides/code_style/./fmt/P.FMT.01.html">P.FMT.01 代码格式以保证可读性为前提</a></li>
<li><a href="safe-guides/code_style/./fmt/G.FMT.01.html">G.FMT.01 始终使用 rustfmt 进行自动格式化代码</a></li>
<li><a href="safe-guides/code_style/./fmt/G.FMT.02.html">G.FMT.02 缩进始终使用空格（space）而非制表符（tab）</a></li>
<li><a href="safe-guides/code_style/./fmt/G.FMT.03.html">G.FMT.03 行间距最大宽度空一行</a></li>
<li><a href="safe-guides/code_style/./fmt/G.FMT.04.html">G.FMT.04 语言项（Item) 定义时花括号（brace）位置应该与语言项保持同一行</a></li>
<li><a href="safe-guides/code_style/./fmt/G.FMT.05.html">G.FMT.05 存在多个标识符时应该保持块状（Block）缩进</a></li>
<li><a href="safe-guides/code_style/./fmt/G.FMT.09.html">G.FMT.06 当有多行表达式操作时，操作符应该置于行首</a></li>
<li><a href="safe-guides/code_style/./fmt/G.FMT.10.html">G.FMT.07 枚举变体和结构体字段相互之间默认左对齐</a></li>
<li><a href="safe-guides/code_style/./fmt/G.FMT.11.html">G.FMT.08 多个函数参数和导入模块的布局</a></li>
<li><a href="safe-guides/code_style/./fmt/G.FMT.12.html">G.FMT.09 空格使用规则</a></li>
<li><a href="safe-guides/code_style/./fmt/G.FMT.14.html">G.FMT.10 match 分支格式</a></li>
<li><a href="safe-guides/code_style/./fmt/G.FMT.15.html">G.FMT.11 导入模块分组规则</a></li>
<li><a href="safe-guides/code_style/./fmt/G.FMT.16.html">G.FMT.12 声明宏分支格式</a></li>
<li><a href="safe-guides/code_style/./fmt/G.FMT.17.html">G.FMT.13 具名结构体字段初始化时字段名最好不要省略</a></li>
<li><a href="safe-guides/code_style/./fmt/G.FMT.18.html">G.FMT.14 extern 外部函数需要显式指定 ABI</a></li>
<li><a href="safe-guides/code_style/./fmt/G.FMT.19.html">G.FMT.15 解构元组的时候允许使用<code>..</code>来指代剩余元素</a></li>
<li><a href="safe-guides/code_style/./fmt/G.FMT.20.html">G.FMT.16 不要将多个不相关的派生(Derive)宏合并为同一行</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfmt01--代码格式以保证可读性为前提"><a class="header" href="#pfmt01--代码格式以保证可读性为前提">P.FMT.01  代码格式以保证可读性为前提</a></h2>
<p><strong>【描述】</strong></p>
<p>制定统一的编码风格，是为了提升代码的可读性，让日常代码维护和团队之间审查代码更加方便。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfmt01--始终使用-rustfmt-进行自动格式化代码"><a class="header" href="#gfmt01--始终使用-rustfmt-进行自动格式化代码">G.FMT.01  始终使用 rustfmt 进行自动格式化代码</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>应该总是在项目中添加 <code>rustfmt.toml</code> 或 <code>.rustfmt.toml</code>文件，即使它是空文件。这是向潜在的合作者表明你希望代码是自动格式化的。</p>
<p><strong>【例外】</strong></p>
<p>在特殊的情况下，可以通过条件编译属性 <code>#[cfg_attr(rustfmt, rustfmt_skip)]</code> 或 <code>#[rustfmt::skip]</code> 来关闭自动格式化。</p>
<p>比如下面示例：</p>
<p><code>vec!</code> 中的元素排布是固定格式，这样有助于开发的便利。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let got = vec![
            0x00, 0x05, 0x01, 0x00,
            0xff,
            0x00,
            0x00,
    
            0x01, 0x0c, 0x02, 0x00,
            0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
            b'd', b'e', b'a', b'd', b'b', b'e', b'e', b'f', 0x00,
            0x00,
    
            127, 0x06, 0x03, 0x00,
            0x01, 0x02,
            b'a', b'b', b'c', b'd', 0x00,
            b'1', b'2', b'3', b'4', 0x00,
            0x00,
    ];
}
</code></pre></pre>
<p>如果使用 自动格式化，会变成：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let got = vec![
        0x00, 0x05, 0x01, 0x00, 0xff, 0x00, 0x00, 0x01, 0x0c, 0x02, 0x00, 0xde, 0xad, 0xbe, 0xef,
        0xde, 0xad, 0xbe, 0xef, b'd', b'e', b'a', b'd', b'b', b'e', b'e', b'f', 0x00, 0x00, 127,
        0x06, 0x03, 0x00, 0x01, 0x02, b'a', b'b', b'c', b'd', 0x00, b'1', b'2', b'3', b'4', 0x00,
        0x00,
    ];
}
</code></pre></pre>
<p>但是加上 <code>#[rustfmt::skip]</code> 就不会被自动格式化影响：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    #[rustfmt::skip] 
    let got = vec![
            0x00, 0x05, 0x01, 0x00,
            0xff,
            0x00,
            0x00,
    
            0x01, 0x0c, 0x02, 0x00,
            0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
            b'd', b'e', b'a', b'd', b'b', b'e', b'e', b'f', 0x00,
            0x00,
    
            127, 0x06, 0x03, 0x00,
            0x01, 0x02,
            b'a', b'b', b'c', b'd', 0x00,
            b'1', b'2', b'3', b'4', 0x00,
            0x00,
    ];
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化建议】</p>
<p>通过检测 项目 根目录下是否存在 <code>rustfmt.toml</code> 或 <code>.rustfmt.toml</code> ，如果没有该文件，则发出警告，让开发者使用 rustfmt 来格式化代码。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfmt02--缩进始终使用空格space而非制表符tab"><a class="header" href="#gfmt02--缩进始终使用空格space而非制表符tab">G.FMT.02  缩进始终使用空格（space）而非制表符（tab）</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<ol>
<li>缩进要使用 四个 空格，不要使用制表符（<code>\t</code>）代替。</li>
<li>通过 IDE/Editor 为缩进默认好设置值。</li>
</ol>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/#tab_spaces"><code>tab_spaces</code></a></td><td>4</td><td>yes（默认）</td><td>缩进空格数｜</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/#hard_tabs"><code>hard_tabs</code></a></td><td>false</td><td>yes（默认）</td><td>禁止使用tab缩进｜</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfmt03--行间距最大宽度空一行"><a class="header" href="#gfmt03--行间距最大宽度空一行">G.FMT.03  行间距最大宽度空一行</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>代码行之间，最小间隔 <code>0</code> 行，最大间隔<code>1</code>行。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    println!(&quot;a&quot;);
}
// 1
// 2
fn bar() {
    println!(&quot;b&quot;);
// 1
// 2
    println!(&quot;c&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    println!(&quot;a&quot;);
}
// 1
fn bar() {
    println!(&quot;b&quot;);
    println!(&quot;c&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>或者</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    println!(&quot;a&quot;);
}
fn bar() {
    println!(&quot;b&quot;);
	// 1
    println!(&quot;c&quot;);
}

<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#blank_lines_lower_bound"><code>blank_lines_lower_bound</code></a></td><td>0（默认）</td><td>No</td><td>不空行</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#blank_lines_upper_bound"><code>blank_lines_upper_bound</code></a></td><td>1（默认）</td><td>No</td><td>最大空一行</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfmt04--语言项item-定义时花括号brace位置应该与语言项保持同一行"><a class="header" href="#gfmt04--语言项item-定义时花括号brace位置应该与语言项保持同一行">G.FMT.04  语言项（Item) 定义时花括号（brace）位置应该与语言项保持同一行</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>花括号的位置风格默认使用 <code>SameLineWhere</code>，但是也根据不同的语言项略有区别。</p>
<p><strong>【反例】</strong></p>
<p>如果设置 <code>brace_style = &quot;AlwaysNextLine&quot;</code>，则：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem()
{
    // body
}

fn lorem(ipsum: usize)
{
    // body
}

fn lorem&lt;T&gt;(ipsum: T)
where
    T: Add + Sub + Mul + Div,
{
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>如果设置 <code>brace_style = &quot;PreferSameLine&quot;</code>，则：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem() {
    // body
}

fn lorem(ipsum: usize) {
    // body
}

fn lorem&lt;T&gt;(ipsum: T)
where
    T: Add + Sub + Mul + Div, { // 注意这里和 `SameLineWhere`的区别
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>结构体与枚举：</p>
<p>如果设置 <code>brace_style = &quot;AlwaysNextLine&quot;</code>，则：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Lorem
{
    ipsum: bool,
}

struct Dolor&lt;T&gt;
where
    T: Eq,
{
    sit: T,
}
<span class="boring">}
</span></code></pre></pre>
<p>如果设置 <code>brace_style = &quot;PreferSameLine&quot;</code>，则：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Lorem {
    ipsum: bool,
}

struct Dolor&lt;T&gt;
where
    T: Eq, {
    sit: T,
}
<span class="boring">}
</span></code></pre></pre>
<p>流程控制倾向于默认使用 <code>AlwaysSameLine</code>，即，总在同一行。因为流程控制没有<code>where</code>子句。</p>
<p>如果设置 <code>brace_style = &quot;AlwaysNextLine&quot;</code>，则：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    if lorem
    {
        println!(&quot;ipsum!&quot;);
    }
    else
    {
        println!(&quot;dolor!&quot;);
    }
}
</code></pre></pre>
<p>如果设置 <code>brace_style = &quot;ClosingNextLine&quot;</code>，则：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    if lorem {
        println!(&quot;ipsum!&quot;);
    } // 注意这里 if 分支结尾处，else 换行
    else { 
        println!(&quot;dolor!&quot;);
    }
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<p>函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem() { // 花括号和fn定义在同一行
    // body
}

fn lorem(ipsum: usize) { // 花括号和fn定义在同一行
    // body
}

// 当有 `where` 子句的时候，花括号换行
// 并且，`where` 子句和 `where` 关键字不在同一行
fn lorem&lt;T&gt;(ipsum: T)
where
    T: Add + Sub + Mul + Div,
{
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>通过配置 <code>where_single_line</code> 为 true，方可设置 <code>where</code>子句在同一行，如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 当有 `where` 子句的时候，花括号换行
// 设置了 `where_single_line=true` ，则`where` 子句和 `where` 关键字在同一行
fn lorem&lt;T&gt;(ipsum: T)
where T: Add + Sub + Mul + Div,
{
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>结构体与枚举</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Lorem {
    ipsum: bool,
}

struct Dolor&lt;T&gt;
where
    T: Eq,
{
    sit: T,
}
<span class="boring">}
</span></code></pre></pre>
<p>流程控制倾向于默认使用 <code>AlwaysSameLine</code>，即，总在同一行。因为流程控制没有<code>where</code>子句。</p>
<pre><pre class="playground"><code class="language-rust">// &quot;AlwaysSameLine&quot; (default)
fn main() {
    if lorem {
        println!(&quot;ipsum!&quot;);
    } else {
        println!(&quot;dolor!&quot;);
    }
}
</code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#brace_style"><code>brace_style</code></a></td><td>SameLineWhere （默认）</td><td>No</td><td>应该与语言项保持同一行，但是 where 语句例外</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#brace_style"><code>brace_style</code></a></td><td>AlwaysNextLine</td><td>No</td><td>应该在语言项的下一行</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#brace_style"><code>brace_style</code></a></td><td>PreferSameLine</td><td>No</td><td>总是优先与语言项保持同一行，where 语句也不例外</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#where_single_line"><code>where_single_line</code></a></td><td>false（默认）</td><td>No</td><td>强制将 <code>where</code> 子句放在同一行上</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#AlwaysSameLine"><code>brace_style</code> in control-flow</a></td><td>AlwaysSameLine （默认）</td><td>No</td><td>总在同一行上，用于控制流程中默认值</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#ClosingNextLine"><code>brace_style</code> in control-flow</a></td><td>ClosingNextLine</td><td>No</td><td>用于控制流程中 else 分支在 if 分支结尾处换行</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfmt05--存在多个标识符时应该保持块状block缩进"><a class="header" href="#gfmt05--存在多个标识符时应该保持块状block缩进">G.FMT.05  存在多个标识符时应该保持块状（Block）缩进</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>当在表达式或语言项定义中出现多个标识符，则应该让其保持块状风格缩进。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lorem = vec![&quot;ipsum&quot;,
                     &quot;dolor&quot;,
                     &quot;sit&quot;,
                     &quot;amet&quot;,
                     &quot;consectetur&quot;,
                     &quot;adipiscing&quot;,
                     &quot;elit&quot;];
}
</code></pre></pre>
<p>流程控制</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    if lorem_ipsum
       &amp;&amp; dolor_sit // 注意：这里缩进只是三个空格，仅仅是和前一行 `lorem_ipsum`对齐
       &amp;&amp; amet_consectetur
       &amp;&amp; lorem_sit
       &amp;&amp; dolor_consectetur
       &amp;&amp; amet_ipsum
       &amp;&amp; lorem_consectetur
    {
        // ...
    }
}
</code></pre></pre>
<p>函数参数</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem() {}

fn lorem(ipsum: usize) {}

fn lorem(ipsum: usize,
         dolor: usize,
         sit: usize,
         amet: usize,
         consectetur: usize,
         adipiscing: usize,
         elit: usize) {
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>函数调用</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    lorem(&quot;lorem&quot;,
          &quot;ipsum&quot;,
          &quot;dolor&quot;,
          &quot;sit&quot;,
          &quot;amet&quot;,
          &quot;consectetur&quot;,
          &quot;adipiscing&quot;,
          &quot;elit&quot;);
}
</code></pre></pre>
<p>泛型</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem&lt;Ipsum: Eq = usize,
         Dolor: Eq = usize,
         Sit: Eq = usize,
         Amet: Eq = usize,
         Adipiscing: Eq = usize,
         Consectetur: Eq = usize,
         Elit: Eq = usize&gt;(
    ipsum: Ipsum,
    dolor: Dolor,
    sit: Sit,
    amet: Amet,
    adipiscing: Adipiscing,
    consectetur: Consectetur,
    elit: Elit)
    -&gt; T {
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>结构体</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lorem = Lorem { ipsum: dolor,
                        sit: amet };
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<p>数组：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lorem = vec![
        &quot;ipsum&quot;,
        &quot;dolor&quot;,
        &quot;sit&quot;,
        &quot;amet&quot;,
        &quot;consectetur&quot;,
        &quot;adipiscing&quot;,
        &quot;elit&quot;,
    ];
}
</code></pre></pre>
<p>流程控制</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    if lorem_ipsum
        &amp;&amp; dolor_sit
        &amp;&amp; amet_consectetur
        &amp;&amp; lorem_sit
        &amp;&amp; dolor_consectetur
        &amp;&amp; amet_ipsum
        &amp;&amp; lorem_consectetur
    {
        // ...
    }
}
</code></pre></pre>
<p>函数参数</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem() {}

fn lorem(ipsum: usize) {}

fn lorem(
    ipsum: usize,
    dolor: usize,
    sit: usize,
    amet: usize,
    consectetur: usize,
    adipiscing: usize,
    elit: usize,
) {
    // body
}

<span class="boring">}
</span></code></pre></pre>
<p>函数调用</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    lorem(
        &quot;lorem&quot;,
        &quot;ipsum&quot;,
        &quot;dolor&quot;,
        &quot;sit&quot;,
        &quot;amet&quot;,
        &quot;consectetur&quot;,
        &quot;adipiscing&quot;,
        &quot;elit&quot;,
    );
}
</code></pre></pre>
<p>泛型</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem&lt;
    Ipsum: Eq = usize,
    Dolor: Eq = usize,
    Sit: Eq = usize,
    Amet: Eq = usize,
    Adipiscing: Eq = usize,
    Consectetur: Eq = usize,
    Elit: Eq = usize,
&gt;(
    ipsum: Ipsum,
    dolor: Dolor,
    sit: Sit,
    amet: Amet,
    adipiscing: Adipiscing,
    consectetur: Consectetur,
    elit: Elit,
) -&gt; T {
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>结构体</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lorem = Lorem {
        ipsum: dolor,
        sit: amet,
    };
}
</code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#indent_style"><code>indent_style</code></a></td><td>Block（默认）</td><td>No</td><td>多个标识符定义保持块状风格，但看上去可能不太工整</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#indent_style"><code>indent_style</code></a></td><td>Visual</td><td>No</td><td>多个标识符定义保持对齐风格，为了看上去工整</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfmt06--当有多行表达式操作时操作符应该置于行首"><a class="header" href="#gfmt06--当有多行表达式操作时操作符应该置于行首">G.FMT.06  当有多行表达式操作时，操作符应该置于行首</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>当有多行表达式操作时，操作符应该置于行首。</p>
<p><strong>【反例】</strong></p>
<p>操作符置于行尾</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let or = foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo ||
        barbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar;

    let sum = 123456789012345678901234567890 +
        123456789012345678901234567890 +
        123456789012345678901234567890;

    let range = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..
        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<p>操作符置于行首</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let or = foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo
        || barbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar;

    let sum = 123456789012345678901234567890
        + 123456789012345678901234567890
        + 123456789012345678901234567890;

    let range = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
        ..bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;
}
</code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#binop_separator"><code>binop_separator</code></a></td><td>Front（默认）</td><td>No</td><td>换行后，操作符置于行首</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfmt07-枚举变体和结构体字段相互之间默认左对齐"><a class="header" href="#gfmt07-枚举变体和结构体字段相互之间默认左对齐">G.FMT.07 枚举变体和结构体字段相互之间默认左对齐</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>对于自定义了判别式的枚举体，和有字段的结构体而言，默认只需要左对齐就可以。这个宽度可以设置为任意值，但默认是0。此宽度并不是指插入多少空格，而是指需要对齐的字符长度。</p>
<p><strong>【反例】</strong></p>
<p>当 <code>enum_discrim_align_threshold = 20</code> 时。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Foo {
    A   = 0,
    Bb  = 1,
    RandomLongVariantGoesHere = 10, // 注意，该变体长度已经超过了20，所以它不会被对齐
    Ccc = 2,
}

enum Bar {
    VeryLongVariantNameHereA = 0, // 注意，该变体长度已经超过了20，所以它不会被对齐
    VeryLongVariantNameHereBb = 1, // 注意，该变体长度已经超过了20，所以它不会被对齐
    VeryLongVariantNameHereCcc = 2,// 注意，该变体长度已经超过了20，所以它不会被对齐
}
<span class="boring">}
</span></code></pre></pre>
<p>当 <code>enum_discrim_align_threshold = 50</code> 时。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>enum Foo {
    A                         = 0,
    Bb                        = 1,
    RandomLongVariantGoesHere = 10, // 注意，该变体长度未超过50，所以它会被对齐
    Ccc                       = 2,
}

enum Bar {
    VeryLongVariantNameHereA   = 0, // 注意，该变体长度未超过50，所以它会被对齐
    VeryLongVariantNameHereBb  = 1, // 注意，该变体长度未超过50，所以它会被对齐
    VeryLongVariantNameHereCcc = 2, // 注意，该变体长度未超过50，所以它会被对齐
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>enum Bar {
    A = 0,
    Bb = 1,
    RandomLongVariantGoesHere = 10,
    Ccc = 71,
}

enum Bar {
    VeryLongVariantNameHereA = 0,
    VeryLongVariantNameHereBb = 1,
    VeryLongVariantNameHereCcc = 2,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#enum_discrim_align_threshold"><code>enum_discrim_align_threshold</code></a></td><td>0（默认）</td><td>No</td><td>具有判别式的枚举变体与其他变体进行垂直对齐的最大长度。没有判别符的变体在对齐时将被忽略。</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#struct_field_align_threshold"><code>struct_field_align_threshold</code></a></td><td>0（默认）</td><td>No</td><td>结构体字段垂直对齐的最大长度</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfmt08--多个函数参数和导入模块的布局"><a class="header" href="#gfmt08--多个函数参数和导入模块的布局">G.FMT.08  多个函数参数和导入模块的布局</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<ol>
<li>五个以内函数参数可以置于一行，超过五个则使用「块」状缩进。</li>
<li>导入模块每行超过四个，则换行。</li>
</ol>
<p><strong>【反例】</strong></p>
<p>当 <code>fn_args_layout</code> 和 <code>imports_layout</code> 被设置为其他值时：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Lorem {
    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet);

    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet) {
        // body
    }

    fn lorem(
        ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet, consectetur: Consectetur,
        adipiscing: Adipiscing, elit: Elit,
    );

    fn lorem(
        ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet, consectetur: Consectetur,
        adipiscing: Adipiscing, elit: Elit,
    ) {
        // body
    }
}

use foo::{xxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyy, zzzzzzzzzzzzzzzzzz};

use foo::{
    aaaaaaaaaaaaaaaaaa,
    bbbbbbbbbbbbbbbbbb,
    cccccccccccccccccc,
    dddddddddddddddddd,
    eeeeeeeeeeeeeeeeee,
    ffffffffffffffffff,
};

<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>trait Lorem {
    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet, consectetur: Consectetur);

    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet) {
        // body
    }

    fn lorem(
        ipsum: Ipsum,
        dolor: Dolor,
        sit: Sit,
        amet: Amet,
        consectetur: Consectetur,
        adipiscing: Adipiscing,
        elit: Elit,
    );

    fn lorem(
        ipsum: Ipsum,
        dolor: Dolor,
        sit: Sit,
        amet: Amet,
        consectetur: Consectetur,
        adipiscing: Adipiscing,
        elit: Elit,
    ) {
        // body
    }
}

use foo::{xxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyy, zzzzzzzzzzzzzzzzzz};

use foo::{
    aaaaaaaaaaaaaaaaaa, bbbbbbbbbbbbbbbbbb, cccccccccccccccccc, dddddddddddddddddd,
    eeeeeeeeeeeeeeeeee,
};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#fn_args_layout"><code>fn_args_layout</code></a></td><td>Tall（默认）</td><td>Yes</td><td>函数参数五个或以内可以一行，超过五个则使用块状缩进</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#imports_layout"><code>imports_layout</code></a></td><td>Mixed（默认）</td><td>No</td><td>导入模块每行超过四个则换行</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfmt09--空格使用规则"><a class="header" href="#gfmt09--空格使用规则">G.FMT.09  空格使用规则</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>总结：</p>
<ol>
<li>在冒号之后添加空格，在冒号之前不要加空格。</li>
<li>在范围（range）操作符（<code>..</code>和<code>..=</code>）前后不要使用空格。</li>
<li>在<code>+</code>或<code>=</code>操作符前后要加空格。</li>
</ol>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 当 `space_after_colon=false`
fn lorem&lt;T:Eq&gt;(t:T) {
    let lorem:Dolor = Lorem {
        ipsum:dolor,
        sit:amet,
    };
}

// 当 `space_before_colon=true`
fn lorem&lt;T : Eq&gt;(t : T) {
    let lorem : Dolor = Lorem {
        ipsum : dolor,
        sit : amet,
    };
}

// 当 `spaces_around_ranges=true`
let lorem = 0 .. 10;
let ipsum = 0 ..= 10;

// 当 `type_punctuation_density=&quot;Compressed&quot;`
fn lorem&lt;Ipsum: Dolor+Sit=Amet&gt;() {
    // body
    let answer = 1 + 2;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 当 `space_after_colon=true`
fn lorem&lt;T: Eq&gt;(t: T) {
    let lorem: Dolor = Lorem {
        ipsum: dolor,
        sit: amet,
    };
}

// 当 `space_before_colon=false`
fn lorem&lt;T: Eq&gt;(t: T) {
    let lorem: Dolor = Lorem {
        ipsum: dolor,
        sit: amet,
    };
}

// 当 `spaces_around_ranges=false`
let lorem = 0..10;
let ipsum = 0..=10;

// 当 `type_punctuation_density=&quot;Wide&quot;`
fn lorem&lt;Ipsum: Dolor + Sit = Amet&gt;() {
    // body
    let answer = 1 + 2;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#space_after_colon"><code>space_after_colon</code></a></td><td>true（默认）</td><td>No</td><td>在冒号后面要加空格</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#space_before_colon"><code>space_before_colon</code></a></td><td>false（默认）</td><td>No</td><td>在冒号前面不要加空格</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#spaces_around_ranges"><code>spaces_around_ranges</code></a></td><td>false（默认）</td><td>No</td><td>在<code>..</code>和<code>..=</code>范围操作符前后不要加空格</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#type_punctuation_density"><code>type_punctuation_density</code></a></td><td>&quot;Wide&quot;（默认）</td><td>No</td><td>在 <code>+</code>或<code>=</code>操作符前后要加空格（此处特指类型签名）</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfmt10--match-分支格式"><a class="header" href="#gfmt10--match-分支格式">G.FMT.10  <code>match</code> 分支格式</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<ol>
<li>当match分支右侧代码体太长无法和<code>=&gt;</code>置于同一行需要使用块(block)来包裹。</li>
<li>在match分支左侧匹配表达式前不要增加管道符(<code>|</code>)</li>
</ol>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 当 `match_arm_blocks=false`
fn main() {
    match lorem {
        ipsum =&gt; 
            foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo(x),
        dolor =&gt; println!(&quot;{}&quot;, sit),
        sit =&gt; foo(
            &quot;foooooooooooooooooooooooo&quot;,
            &quot;baaaaaaaaaaaaaaaaaaaaaaaarr&quot;,
            &quot;baaaaaaaaaaaaaaaaaaaazzzzzzzzzzzzz&quot;,
            &quot;qqqqqqqqquuuuuuuuuuuuuuuuuuuuuuuuuuxxx&quot;,
        ),
    }
}

// 当 `match_arm_leading_pipes=&quot;Alaways&quot;`
fn foo() {
    match foo {
        | &quot;foo&quot; | &quot;bar&quot; =&gt; {}
        | &quot;baz&quot;
        | &quot;something relatively long&quot;
        | &quot;something really really really realllllllllllllly long&quot; =&gt; println!(&quot;x&quot;),
        | &quot;qux&quot; =&gt; println!(&quot;y&quot;),
        | _ =&gt; {}
    }
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 当 `match_arm_blocks=true`
fn main() {
    match lorem {
        ipsum =&gt; { 
            foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo(x)
        }
        dolor =&gt; println!(&quot;{}&quot;, sit),
        sit =&gt; foo(
            &quot;foooooooooooooooooooooooo&quot;,
            &quot;baaaaaaaaaaaaaaaaaaaaaaaarr&quot;,
            &quot;baaaaaaaaaaaaaaaaaaaazzzzzzzzzzzzz&quot;,
            &quot;qqqqqqqqquuuuuuuuuuuuuuuuuuuuuuuuuuxxx&quot;,
        ),
    }
}

// 当 `match_arm_leading_pipes=&quot;Never&quot;`
fn foo() {
    match foo {
        &quot;foo&quot; | &quot;bar&quot; =&gt; {}
        &quot;baz&quot;
        | &quot;something relatively long&quot;
        | &quot;something really really really realllllllllllllly long&quot; =&gt; println!(&quot;x&quot;),
        &quot;qux&quot; =&gt; println!(&quot;y&quot;),
        _ =&gt; {}
    }
}
</code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#match_arm_blocks"><code>match_arm_blocks</code></a></td><td>true（默认）</td><td>No</td><td>当match分支右侧代码体太长无法和<code>=&gt;</code>置于同一行需要使用块(block)来包裹</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#match_arm_leading_pipes"><code>match_arm_leading_pipes</code></a></td><td>Never（默认）</td><td>No</td><td>在match分支左侧匹配表达式前不要增加管道符(`</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfmt11--导入模块分组规则"><a class="header" href="#gfmt11--导入模块分组规则">G.FMT.11  导入模块分组规则</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<ol>
<li>导入同一模块的类型，应该置于同一个块内（<code>imports_granularity=&quot;Crate&quot;</code>）。</li>
<li>模块导入应该按以下规则进行分组（<code>group_imports=&quot;StdExternalCrate&quot;</code>）：
<ul>
<li>导入来自 <code>std</code>、<code>core</code> 和 <code>alloc</code>的模块需要置于前面一组。</li>
<li>导入来自 第三方库的模块 应该置于中间一组。</li>
<li>导入来自本地 <code>self</code>、<code>super</code>和<code>crate</code>前缀的模块，置于后面一组。</li>
</ul>
</li>
<li>分组内使用字典序进行排序（<code>reorder_imports=true</code>）。</li>
</ol>
<p>说明： 默认 rustfmt 不会对导入的模块自动分组，而是保留开发者的导入顺序。所以，这里需要修改rustfmt 默认配置，但因为这几个配置项暂时未稳定，所以需要在 Nightly 下使用。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// 当 `imports_granularity=&quot;Preserve&quot;`
use foo::b;
use foo::b::{f, g};
use foo::{a, c, d::e};
use qux::{h, i};


// 当按默认值设置时，模块导入比较乱，影响可读性
use super::update::convert_publish_payload;
use chrono::Utc;

use alloc::alloc::Layout;
use juniper::{FieldError, FieldResult};
use uuid::Uuid;

use std::sync::Arc;

use broker::database::PooledConnection;

use super::schema::{Context, Payload};
use crate::models::Event;
use core::f32;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 当 `imports_granularity=&quot;Crate&quot;`
use foo::{
    a, b,
    b::{f, g},
    c,
    d::e,
};
use qux::{h, i};


// 当 `group_imports=&quot;StdExternalCrate` 且 `reorder_imports=true`
use alloc::alloc::Layout;
use core::f32;
use std::sync::Arc;

use broker::database::PooledConnection;
use chrono::Utc;
use juniper::{FieldError, FieldResult};
use uuid::Uuid;

use super::schema::{Context, Payload};
use super::update::convert_publish_payload;
use crate::models::Event;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#imports_granularity"><code>imports_granularity</code></a></td><td>（Preserve（默认），Crate(推荐)）</td><td>No</td><td>默认保留开发者的模块导入顺序</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#reorder_imports"><code>reorder_imports</code></a></td><td>true（默认）</td><td>No</td><td>模块分组内根据模块首字母按字典序进行排序</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#group_imports"><code>group_imports</code></a></td><td>（Preserve（默认）， StdExternalCrate（建议））</td><td>No</td><td>默认保留开发者的模块导入分组</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfmt12--声明宏分支格式"><a class="header" href="#gfmt12--声明宏分支格式">G.FMT.12  声明宏分支格式</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<ol>
<li>在声明宏中，模式匹配分支（<code>=&gt;</code> 左侧）应该使用紧凑格式（<code>format_macro_matchers=true</code>）。</li>
<li>而分支代码体（<code>=&gt;</code> 右侧） 使用宽松格式。详细请看示例。</li>
</ol>
<p>一切都是为了提升可读性。</p>
<p>说明：因为这里需要修改<code>format_macro_matchers</code>的默认值，且该配置项并未 Stable ，所以需要 Nightly 下格式化。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 当 `format_macro_matchers=false`且 `format_macro_bodies=true`
macro_rules! foo {
    ($a: ident : $b: ty) =&gt; {
        $a(42): $b;
    };
    ($a: ident $b: ident $c: ident) =&gt; {
        $a = $b + $c;
    };
}

// 当 `format_macro_matchers=false`且 `format_macro_bodies=false`
macro_rules! foo {
    ($a: ident : $b: ty) =&gt; {
        $a(42):$b;
    };
    ($a: ident $b: ident $c: ident) =&gt; {
        $a=$b+$c;
    };
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 当 `format_macro_matchers=true` 且 `format_macro_bodies=true`
macro_rules! foo {
    // 匹配分支紧凑格式， `$a:ident` 和 `$b:ty` 各自配对
    ($a:ident : $b:ty) =&gt; {
        $a(42): $b; // 在代码体内，则宽松一点
    };
    ($a:ident $b:ident $c:ident) =&gt; {
        $a = $b + $c;
    };
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#format_macro_matchers"><code>format_macro_matchers</code></a></td><td>（false（默认），true(建议)）</td><td>No</td><td>声明宏 模式匹配分支（<code>=&gt;</code> 左侧）中要使用紧凑格式</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#format_macro_bodies"><code>format_macro_bodies</code></a></td><td>true（默认）</td><td>No</td><td>声明宏分支代码体（<code>=&gt;</code> 右侧） 使用宽松格式</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfmt13--具名结构体字段初始化时字段名最好不要省略"><a class="header" href="#gfmt13--具名结构体字段初始化时字段名最好不要省略">G.FMT.13  具名结构体字段初始化时字段名最好不要省略</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>因为本规则严重依赖于rustfmt，而rustfmt会根据相应配置项对代码进行自动更改，为了确保不会因为rustfmt配置项的更改而导致代码错误，请在遵循rustfmt使用注意事项的基础上，遵循本规则：</p>
<ol>
<li>省略字段名的时候需要注意变量名和字段名保持一致。</li>
<li>变量名和字段名不一致的情况下，最好不要省略字段名。</li>
</ol>
<p>以此规则标题主要目的是来规范rustfmt的默认配置不会被人设置为<code>true</code>，而把代码修改错误。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    a: u32, // 注意这里是 a
    y: u32,
    z: u32,
}

fn main() {
    let x = 1;
    let y = 2;
    let z = 3;
    // 这里省略了字段名，用了变量x
    // rustfmt 无法检查这个错误，但是编译时能检查出来，所以要遵循rustfmt使用注意事项就不会出问题
    let a = Foo { x, y, z };
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
struct Foo {
    a: u32,
    y: u32,
    z: u32,
}

fn main() {
    let x = 1;
    let y = 2;
    let z = 3;
    let a = Foo { a: x, y: y, z: z };
}
</code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#use_field_init_shorthand"><code>use_field_init_shorthand</code></a></td><td>false（默认）</td><td>Yes</td><td>具名结构体字段初始化不能省略字段名</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfmt14--extern-外部函数需要显式指定-abi"><a class="header" href="#gfmt14--extern-外部函数需要显式指定-abi">G.FMT.14  extern 外部函数需要显式指定 ABI</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>当使用 <code>extern</code> 指定外部函数时，建议显式指定 <code>C-ABI</code>。<code>extern</code> 不指定的话默认就是 <code>C-ABI</code>，但是 Rust 语言显式指定是一种约定俗成。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 省略 ABI 指定，则默认是 C-ABI
extern {
    pub static lorem: c_int;
}

// 非 C-ABI 是无法省略的
extern &quot;Rust&quot; {
    type MyType;
    fn f(&amp;self) -&gt; usize;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 默认就是 `C-ABI`
extern &quot;C&quot; {
    pub static lorem: c_int;
}

extern &quot;Rust&quot; {
    type MyType;
    fn f(&amp;self) -&gt; usize;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#force_explicit_abi"><code>force_explicit_abi</code></a></td><td>true（默认）</td><td>Yes</td><td>extern 外部函数总是要指定 ABI</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfmt15--解构元组的时候允许使用来指代剩余元素"><a class="header" href="#gfmt15--解构元组的时候允许使用来指代剩余元素">G.FMT.15  解构元组的时候允许使用<code>..</code>来指代剩余元素</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>默认选项是 false，表示不允许 解构元组的时候使用<code>..</code>来指代剩余元素</p>
<p><strong>【反例】</strong></p>
<p>这种情况下，rustfmt不会自动更改代码，会保留原来的写法。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let (lorem, ipsum, _, _) = (1, 2, 3, 4);
    let (lorem, ipsum, ..) = (1, 2, 3, 4);
    let (lorem, _,ipsum, _, _) = (1, 2, 3, 4, 5);
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<p>设置 <code>condense_wildcard_suffixes = true</code> 时，会强行更改代码为下面形式。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let (lorem, ipsum, ..) = (1, 2, 3, 4);
    let (lorem, _,ipsum, ..) = (1, 2, 3, 4, 5);
}
</code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#condense_wildcard_suffixes"><code>condense_wildcard_suffixes</code></a></td><td>false（默认） true （推荐）</td><td>No</td><td>解构元组的时候是否允许使用<code>..</code>来指代剩余元素</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfmt16--不要将多个不相关的-派生derive-宏合并为同一行"><a class="header" href="#gfmt16--不要将多个不相关的-派生derive-宏合并为同一行">G.FMT.16  不要将多个不相关的 派生(Derive) 宏合并为同一行</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>不要将多个不相关的 Derive 宏合并为同一行，可以增加代码可读性，明确语义。
rustfmt 不会识别Derive 宏是否相关，这是开发者自己编写的。</p>
<p><strong>【反例】</strong></p>
<p>用默认设置  <code>merge_derives = true</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Eq, PartialEq, Debug, Copy, Clone)]
pub enum Foo {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>修改默认设置 <code>merge_derives = false</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Eq, PartialEq)]
#[derive(Debug)]
#[derive(Copy, Clone)]
pub enum Foo {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#merge_derives"><code>merge_derives</code></a></td><td>true（默认） false（推荐）</td><td>Yes</td><td>是否将多个 Derive 宏合并为同一行</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="23-注释与文档"><a class="header" href="#23-注释与文档">2.3 注释与文档</a></h1>
<p>在 Rust 中，注释分为两类：普通注释和文档注释。普通注释使用 <code>//</code> 或 <code>/* ... */</code>，文档注释使用 <code>///</code>、<code>//!</code> 或 <code>/** ... **/</code>。</p>
<p>在原则和规则中提到「注释」时，包括普通注释和文档注释。当提到「文档」时，特指文档注释。</p>
<h2 id="列表-2"><a class="header" href="#列表-2">列表</a></h2>
<ul>
<li><a href="safe-guides/code_style/./comments/P.CMT.01.html">P.CMT.01 代码能做到自注释，文档要干练简洁</a></li>
<li><a href="safe-guides/code_style/./comments/G.CMT.01.html">G.CMT.01 注释应该有一定宽度限制</a></li>
<li><a href="safe-guides/code_style/./comments/G.CMT.02.html">G.CMT.02 使用行注释而避免使用块注释</a></li>
<li><a href="safe-guides/code_style/./comments/G.CMT.03.html">G.CMT.03 在每一个文件开头加入版权公告、创建和修改年份和功能描述</a></li>
<li><a href="safe-guides/code_style/./comments/G.CMT.04.html">G.CMT.04 在注释中使用 FIXME 和 TODO 来帮助任务协作</a></li>
<li><a href="safe-guides/code_style/./comments/G.CMT.05.html">G.CMT.05 在公开的返回Result类型返回的函数文档中增加 Error 注释</a></li>
<li><a href="safe-guides/code_style/./comments/G.CMT.06.html">G.CMT.06 如果公开的API在某些情况下会发生Panic，则相应文档中需增加 Panic 注释</a></li>
<li><a href="safe-guides/code_style/./comments/G.CMT.07.html">G.CMT.07 在文档注释中要使用空格代替 tab</a></li>
</ul>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ol>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC 505: API 注释约定</a></li>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/1574-more-api-documentation-conventions.md">RFC 1574: API 文档约定</a></li>
<li><a href="https://www.tangramvision.com/blog/making-great-docs-with-rustdoc">Making Great Docs with Rustdoc</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">Rust Doc book</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pcmt01-代码能做到自注释文档要干练简洁"><a class="header" href="#pcmt01-代码能做到自注释文档要干练简洁">P.CMT.01 代码能做到自注释，文档要干练简洁</a></h2>
<p><strong>【描述】</strong></p>
<p>一、代码能够做到自注释，避免冗余的普通代码注释。</p>
<p>注释固然很重要, 但最好的代码应当本身就是文档。有意义的类型名、函数名和变量名, 要远胜过要用注释解释的含糊不清的名字。当有意义的类型名、函数名和变量名还不能表达完整的语义时，再使用注释。</p>
<p>不要描述显而易见的现象, 永远不要用自然语言翻译代码作为注释。</p>
<p>二、文档注释要干练简洁：</p>
<ol>
<li>文档注释中内容用语应该尽量简短精干，不宜篇幅过长。请确保你的代码注释良好并且易于他人理解，好的注释能够传达上下文关系和代码目的。</li>
<li>注释内容始终围绕两个关键点来构建：
<ul>
<li>What : 用于阐述代码为了什么而实现。</li>
<li>how : 用于阐述代码如何去使用。</li>
</ul>
</li>
<li>注释和文档注释使用的自然语言要保持一致。</li>
<li>Rust 项目文档应该始终基于 <code>rustdoc</code> 工具来构建，<code>rustdoc</code> 支持 Markdown 格式，为了使得文档更加美观易读，文档注释应该使用 Markdown 格式。</li>
</ol>
<p><strong>【正例】</strong> </p>
<p>模块级文档，来自于 Rust 标准库<code>std::vec</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! # The Rust core allocation and collections library
//!
//! This library provides smart pointers and collections for managing
//! heap-allocated values.
//!
//! This library, like libcore, normally doesn’t need to be used directly
//! since its contents are re-exported in the [`std` crate](../std/index.html).
//! Crates that use the `#![no_std]` attribute however will typically
//! not depend on `std`, so they’d use this crate instead.
//!
//! ## Boxed values
//!
//! The [`Box`] type is a smart pointer type. There can only be one owner of a
//! [`Box`], and the owner can decide to mutate the contents, which live on the
//! heap.
<span class="boring">}
</span></code></pre></pre>
<p>普通文档注释示例，来自标准库<code>Vec::new</code>方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Constructs a new, empty `Vec&lt;T&gt;`.
    ///
    /// The vector will not allocate until elements are pushed onto it.
    ///
    /// # Examples
    ///
    /// ```
    /// # #![allow(unused_mut)]
    /// let mut vec: Vec&lt;i32&gt; = Vec::new();
    /// ```
    #[inline]
    #[rustc_const_stable(feature = &quot;const_vec_new&quot;, since = &quot;1.39.0&quot;)]
    #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
    pub const fn new() -&gt; Self {
        Vec { buf: RawVec::NEW, len: 0 }
    }
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcmt01--注释应该有一定宽度限制"><a class="header" href="#gcmt01--注释应该有一定宽度限制">G.CMT.01  注释应该有一定宽度限制</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>每行注释的宽度不能过长，需要设置一定的宽度，有助于提升可读性。<code>comment_width</code>可配合 <code>wrap_comments</code> 将超过宽度限制的注释自动分割为多行。</p>
<p>注意：<code>use_small_heuristics</code>配置项并不包括<code>comment_width</code>。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>当 <code>comment_width=80</code> 且 <code>wrap_comments=true</code>时。</p>
<p>注意：这里 <code>wrap_comments</code>并未使用默认值，需要配置为 true。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Lorem ipsum dolor sit amet, consectetur adipiscing elit,
// sed do eiusmod tempor incididunt ut labore et dolore
// magna aliqua. Ut enim ad minim veniam, quis nostrud
// exercitation ullamco laboris nisi ut aliquip ex ea
// commodo consequat.
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#comment_width"><code>comment_width</code></a></td><td>80（默认）</td><td>No</td><td>指定一行注释允许的最大宽度</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#wrap_comments"><code>wrap_comments</code></a></td><td>false（默认），true（建议）</td><td>No</td><td>运行多行注释按最大宽度自动换成多行注释</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcmt02--使用行注释而避免使用块注释"><a class="header" href="#gcmt02--使用行注释而避免使用块注释">G.CMT.02  使用行注释而避免使用块注释</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>尽量使用行注释（<code>//</code> 或 <code>///</code>），而非块注释。这是Rust社区的约定俗成。</p>
<p>对于文档注释，仅在编写模块级文档时使用 <code>//!</code>，在其他情况使用 <code>///</code>更好。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/*
 * Wait for the main task to return, and set the process error code
 * appropriately.
 */

mod tests {
    //! This module contains tests

    // ...
}

#![doc = &quot;Example documentation&quot;]

#[doc = &quot;Example item documentation&quot;]
pub enum Foo {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>当 <code>normalize_comments = true</code>  时：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Wait for the main task to return, and set the process error code
// appropriately.

// 在使用 `mod` 关键字定义模块时，在 `mod`之上使用 `///` 更好。
/// This module contains tests
mod tests {
    // ...
}

//! Example documentation

/// Example item documentation
pub enum Foo {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#normalize_comments"><code>normalize_comments</code></a></td><td>false（默认） true（推荐）</td><td>No</td><td>将 <code>/**/</code> 注释转为 <code>//</code></td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#normalize_doc_attributes"><code>normalize_doc_attributes</code></a></td><td>false（默认）</td><td>No</td><td>将 <code>#![doc]</code> 和 <code>#[doc]</code> 注释转为 <code>//!</code> 和 <code>///</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcmt03--在每一个文件开头加入版权公告创建和修改年份和功能描述"><a class="header" href="#gcmt03--在每一个文件开头加入版权公告创建和修改年份和功能描述">G.CMT.03  在每一个文件开头加入版权公告、创建和修改年份和功能描述</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>每个文件都应该包含许可证引用。为项目选择合适的许可证版本.(比如, Apache 2.0, BSD, LGPL, GPL)。</p>
<p>可以通过 <code>rustfmt</code> 的 <code>license_template_path</code> 配置项 和 <code>license.template</code>来自动化此操作。
另外还需要增加该文件的首次创建年份、最后修改年份，以及功能描述。不过这两项就无法通过rustfmt自动插入
对于文件修改时间，其实VSCode的一些插件也可以帮忙做到。</p>
<p><strong>【正例】</strong></p>
<p>可以命名为<code>.rustfmt.license-template</code>许可证模版。 比如</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright {\d+} YOURCOMPANY Project Authors. Licensed under Apache-2.0.
<span class="boring">}
</span></code></pre></pre>
<p>在 <code>rustfmt.toml</code> 中配置：</p>
<pre><code class="language-toml">license_template_path = &quot;.rustfmt.license-template&quot;
</code></pre>
<p>在代码文件中手工添加对应的注释 （自动插入功能还未支持）：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Copyright 2021 YOURCOMPANY Project Authors. Licensed under Apache-2.0.
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#license_template_path"><code>license_template_path</code></a></td><td>格式化每一个Rust文件（默认）</td><td>No</td><td>指定许可证模版路径</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcmt04--在注释中使用-fixme-和-todo-来帮助任务协作"><a class="header" href="#gcmt04--在注释中使用-fixme-和-todo-来帮助任务协作">G.CMT.04  在注释中使用 <code>FIXME</code> 和 <code>TODO</code> 来帮助任务协作</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>通过在注释中开启 <code>FIXME</code> 和 <code>TODO</code> 可以方便协作。rustfmt 默认不开启该项，所以需要配置。</p>
<p>但是配置为 <code>Always</code> 没必要，只需要配置为 <code>Unnumbered</code> 针对编号的 <code>FXIME</code> 和 <code>TODO</code> 报告即可。</p>
<p>这两个配置目前有 Bug ，无法正确识别报告，但不影响这个规则的应用。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// TODO(calebcartwright): consider enabling box_patterns feature gate
fn annotation_type_for_level(level: Level) -&gt; AnnotationType {
    match level {
        Level::Bug | Level::Fatal | Level::Error =&gt; AnnotationType::Error,
        Level::Warning =&gt; AnnotationType::Warning,
        Level::Note =&gt; AnnotationType::Note,
        Level::Help =&gt; AnnotationType::Help,
        // FIXME(#59346): Not sure how to map these two levels
        Level::Cancelled | Level::FailureNote =&gt; AnnotationType::Error,
        Level::Allow =&gt; panic!(&quot;Should not call with Allow&quot;),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#report_fixme"><code>report_fixme</code></a></td><td>Never（默认），Unnumbered（推荐）</td><td>No</td><td>是否报告 FIXME 注释</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#report_todo"><code>report_todo</code></a></td><td>Never（默认），Unnumbered（推荐）</td><td>No</td><td>是否报告 FIXME 注释</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcmt05--在-公开的返回result类型返回的函数文档中增加-error-注释"><a class="header" href="#gcmt05--在-公开的返回result类型返回的函数文档中增加-error-注释">G.CMT.05  在 公开的返回<code>Result</code>类型返回的函数文档中增加 Error 注释</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在公开（pub）的返回<code>Result</code>类型函数文档中，建议增加 <code># Error</code> 注释来解释什么场景下该函数会返回什么样的错误类型，方便用户处理错误。</p>
<p>说明： 该规则通过 cargo clippy 来检测。默认不会警告。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io;
</span>pub fn read(filename: String) -&gt; io::Result&lt;String&gt; {
    unimplemented!();
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io;
</span>/// # Errors
///
/// Will return `Err` if `filename` does not exist or the user does not have
/// permission to read it.
pub fn read(filename: String) -&gt; io::Result&lt;String&gt; {
    unimplemented!();
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>默认 level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_errors_doc">missing_errors_doc </a></td><td>yes</td><td>no</td><td>Style</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcmt06--如果公开的api在某些情况下会发生panic则相应文档中需增加-panic-注释"><a class="header" href="#gcmt06--如果公开的api在某些情况下会发生panic则相应文档中需增加-panic-注释">G.CMT.06  如果公开的API在某些情况下会发生Panic，则相应文档中需增加 Panic 注释</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>在公开（pub）函数文档中，建议增加 <code># Panic</code> 注释来解释该函数在什么条件下会 Panic，便于使用者进行预处理。</p>
<p>说明： 该规则通过 cargo clippy 来检测。默认不会警告。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn divide_by(x: i32, y: i32) -&gt; i32 {
    if y == 0 {
        panic!(&quot;Cannot divide by 0&quot;)
    } else {
        x / y
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// # Panics
///
/// Will panic if y is 0
pub fn divide_by(x: i32, y: i32) -&gt; i32 {
    if y == 0 {
        panic!(&quot;Cannot divide by 0&quot;)
    } else {
        x / y
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>默认 level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_panics_doc">missing_panics_doc </a></td><td>yes</td><td>no</td><td>Style</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcmt07--在文档注释中要使用空格代替-tab"><a class="header" href="#gcmt07--在文档注释中要使用空格代替-tab">G.CMT.07  在文档注释中要使用空格代替 tab</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Rust 代码风格中提倡使用<strong>四个空格</strong>代替tab，在文档注释中也应该统一使用<strong>四个空格</strong>。</p>
<p><strong>【反例】</strong></p>
<p>下面文档注释中使用了 tab。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>///
/// Struct to hold two strings:
/// 	- first		one
/// 	- second	one
pub struct DoubleString {
   ///
   /// 	- First String:
   /// 		- needs to be inside here
   first_string: String,
   ///
   /// 	- Second String:
   /// 		- needs to be inside here
   second_string: String,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>///
/// Struct to hold two strings:
///     - first        one
///     - second    one
pub struct DoubleString {
   ///
   ///     - First String:
   ///         - needs to be inside here
   first_string: String,
   ///
   ///     - Second String:
   ///         - needs to be inside here
   second_string: String,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>默认 level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#tabs_in_doc_comments">tabs_in_doc_comments </a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-编程实践"><a class="header" href="#3-编程实践">3. 编程实践</a></h1>
<p>编码实践相关原则和规则，有助于编写更地道更安全的 Rust 代码。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="31-常量"><a class="header" href="#31-常量">3.1 常量</a></h1>
<p>在 Rust 中，常量有两种用途：</p>
<ul>
<li>编译时常量（Compile-time constants）</li>
<li>编译时求值 （CTEF, compile-time evaluable functions）</li>
</ul>
<p>常量命名风格指南请看 <a href="safe-guides/coding_practice/../code_style/naming.html">编码风格-命名</a></p>
<h2 id="列表-3"><a class="header" href="#列表-3">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./consts/G.CNS.01.html">G.CNS.01 对于科学计算中涉及浮点数近似值的常量宜使用预定义常量</a></li>
<li><a href="safe-guides/coding_practice/./consts/G.CNS.02.html">G.CNS.02 不应断言常量布尔类型</a></li>
<li><a href="safe-guides/coding_practice/./consts/G.CNS.03.html">G.CNS.03 不应将内部可变性容器声明为常量</a></li>
<li><a href="safe-guides/coding_practice/./consts/G.CNS.04.html">G.CNS.04 不应在常量定义中增加显式的 <code>'static</code> 生命周期</a></li>
<li><a href="safe-guides/coding_practice/./consts/G.CNS.05.html">G.CNS.05 对于适用 <code>const fn</code> 的函数或方法宜尽可能地使用 <code>const fn</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcns01-对于科学计算中涉及浮点数近似值的常量宜使用预定义常量"><a class="header" href="#gcns01-对于科学计算中涉及浮点数近似值的常量宜使用预定义常量">G.CNS.01 对于科学计算中涉及浮点数近似值的常量宜使用预定义常量</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Rust标准库中已经提供了一些特殊常量的定义，其精确度通常会比开发者自行定义的高，所以若考虑数值精确度时则宜使用标准库已定义的特殊常量。</p>
<p>这些特殊常量都可以在标准库中找到，例如<a href="https://doc.rust-lang.org/std/f32/consts/index.html">std::f32::consts</a></p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 3.14;
let y = 1_f64 / x;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = std::f32::consts::PI;
let y = std::f64::consts::FRAC_1_PI;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#approx_constant">approx_constant</a></td><td>yes</td><td>no</td><td>Correctness</td><td>deny</td></tr>
</tbody></table>
<p>该 Lint 默认为 <code>deny</code>，但在某些场景下，可以设置为<code>allow</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcns02-不应断言常量布尔类型"><a class="header" href="#gcns02-不应断言常量布尔类型">G.CNS.02 不应断言常量布尔类型</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>此类语句会被编译器优化掉。最好直接使用 <code>panic!</code> 或 <code>unreachable!</code>代替。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const B: bool = false;
assert!(B);
assert!(true);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>panic!（&quot;something&quot;）;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>该示例需要维护一个常量的不变性，确保它在未来修改时不会被无意中破坏。类似于 <a href="https://docs.rs/static_assertions/1.1.0/static_assertions/">static_assertions</a> 的作用。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![allow(clippy::assertions_on_constants)]
<span class="boring">fn main() {
</span>const MIN_OVERFLOW: usize = 8192;
const MAX_START: usize = 2048;
const MAX_END: usize = 2048;
const MAX_PRINTED: usize = MAX_START + MAX_END;
assert!(MAX_PRINTED &lt; MIN_OVERFLOW);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#assertions_on_constants">assertions_on_constants</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcns03-不应将内部可变性容器声明为常量"><a class="header" href="#gcns03-不应将内部可变性容器声明为常量">G.CNS.03 不应将内部可变性容器声明为常量</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>由于常量会到处内联的特性。
若将一个内容可变容器声明为常量，那么在引用它的时候同样会新建一个实例，这样会破坏内容可变容器的使用目的，
所以需要将它的值存储为静态（static）或者直接将其定义为静态。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};
const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);

// Bad.
CONST_ATOM.store(6, SeqCst); // 此处相当于新建了一个atomic实例，所以原容器内容并未改变
assert_eq!(CONST_ATOM.load(SeqCst), 12); // 仍为12，因为这两行的CONST_ATOM为不同实例

<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};
const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);

// Good.
static STATIC_ATOM: AtomicUsize = CONST_ATOM;
STATIC_ATOM.store(9, SeqCst);
assert_eq!(STATIC_ATOM.load(SeqCst), 9); // 使用`static`, 故上下文的STATIC_ATOM皆指向同一个实例

// 或直接声明为static
static ANOTHER_STATIC_ATOM: AtomicUsize = AtomicUsize::new(15);
ANOTHER_STATIC_ATOM.store(9, SeqCst);
assert_eq!(ANOTHER_STATIC_ATOM.load(SeqCst), 9);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#borrow_interior_mutable_const">borrow_interior_mutable_const</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#declare_interior_mutable_const">declare_interior_mutable_const</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcns04-不应在常量定义中增加显式的-static-生命周期"><a class="header" href="#gcns04-不应在常量定义中增加显式的-static-生命周期">G.CNS.04 不应在常量定义中增加显式的 <code>'static</code> 生命周期</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>在常量和静态变量声明时已经默认含有隐式的<code>'static</code>生命周期，所以不需要额外增加显式<code>'static</code>声明周期。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOO: &amp;'static [(&amp;'static str, &amp;'static str, fn(&amp;Bar) -&gt; bool)] =
&amp;[...]
static FOO: &amp;'static [(&amp;'static str, &amp;'static str, fn(&amp;Bar) -&gt; bool)] =
&amp;[...]
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FOO: &amp;[(&amp;str, &amp;str, fn(&amp;Bar) -&gt; bool)] = &amp;[...]
 static FOO: &amp;[(&amp;str, &amp;str, fn(&amp;Bar) -&gt; bool)] = &amp;[...]
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#redundant_static_lifetimes">redundant_static_lifetimes</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcns05--对于适用-const-fn-的函数或方法宜尽可能地使用-const-fn"><a class="header" href="#gcns05--对于适用-const-fn-的函数或方法宜尽可能地使用-const-fn">G.CNS.05  对于适用 <code>const fn</code> 的函数或方法宜尽可能地使用 <code>const fn</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>函数或方法缺失<code>const</code>关键词时无法被指派给常量。
但是要注意不是所有函数都能使用<code>const fn</code>，因为相比一般函数或方法，<code>const fn</code>在使用时会有限制，一些功能将无法在<code>const fn</code>内使用，例如迭代器。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; usize {
    10
}

let bar: usize = foo();   // OK
const BAZ: usize = foo(); // ERROR
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo() -&gt; usize {
    10
} 

let bar: usize = foo():   // OK
const BAZ: usize = foo(); // OK
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo() -&gt; bool {
    for _i in 0..5 {}      // ERROR, 因为for loop默认不能用在const fn内（需要注明#![feature(const_for)]）
    false
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#missing_const_for_fn">missing_const_for_fn</a></td><td>yes</td><td>no</td><td>Perf</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="32-静态变量"><a class="header" href="#32-静态变量">3.2 静态变量</a></h1>
<p>静态变量是用 <code>static</code> 关键字定义的全局静态变量。</p>
<h2 id="列表-4"><a class="header" href="#列表-4">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./statics/G.STV.01.html">G.STV.01 不宜直接使用可变静态变量作为全局变量</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gstv01--不宜直接使用可变静态变量作为全局变量"><a class="header" href="#gstv01--不宜直接使用可变静态变量作为全局变量">G.STV.01  不宜直接使用可变静态变量作为全局变量</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>对可变静态变量直接进行全局修改是 Unsafe 的。在多线程应用中，修改静态变量会导致数据争用（data race），此未定义行为目前并不会被 Clippy 或 Rustc 检测出。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut NUM_OF_APPLES: usize = 0;

unsafe fn buy_apples(count: usize) {
    NUM_OF_APPLES += count;
}

unsafe fn eat_apple() {
    NUM_OF_APPLES -= 1;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>若需要变更的值的类型为整数或布尔时，可直接使用 atomic。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};

static NUM_OF_APPLES: AtomicUsize = AtomicUsize::new(0);

fn buy_apple(count: usize) {
    NUM_OF_APPLES.fetch_add(count, SeqCst);
}

fn eat_apple() {
    NUM_OF_APPLES.fetch_sub(1, SeqCst);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>若需修改整数或布尔之外的数据类型时，可考虑使用 Mutex 或 Rwlock 配合 once_cell 对全局变量进行变更。</p>
<p>（注: once_cell 目前已经被引入到 Nightly 版本的标准库中但还不稳定, 可参考 <a href="https://doc.rust-lang.org/std/lazy/index.html">std::lazy</a>。若要在 Stable 版本下使用，则需要引入第三方库 <a href="https://docs.rs/once_cell/latest/once_cell/">once_cell</a>。）</p>
<pre><pre class="playground"><code class="language-rust">#![feature(once_cell)]          // 需要nightly compiler

use std::sync::Mutex;
use std::lazy::SyncLazy;        // 若使用stable版本则需要将之替换为once_cell::sync::Lazy

static GLOBAL_MESSAGE: SyncLazy&lt;Mutex&lt;String&gt;&gt; = SyncLazy::new(|| {
    Mutex::new(String::from(&quot;I'm hungry&quot;))
});

fn update_msg(msg: &amp;str) {
    let mut old_msg = GLOBAL_MESSAGE.lock().unwrap();
    *old_msg = msg.to_string();
}

fn main() {
    println!(&quot;{}&quot;, GLOBAL_MESSAGE.lock().unwrap()); // I'm hungry
    update_msg(&quot;I'm not hungry anymore!&quot;);
    println!(&quot;{}&quot;, GLOBAL_MESSAGE.lock().unwrap()); // I'm not hungry anymore!
}
</code></pre></pre>
<p>上述示例亦可通过使用第三方库 <a href="https://docs.rs/lazy_static/latest/lazy_static/">lazy_static</a> 的方式实现。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Mutex;
use lazy_static::lazy_static;

lazy_static! {
    static ref GLOBAL_MESSAGE: Mutex&lt;String&gt; = Mutex::new(String::from(&quot;I'm hungry&quot;));
}

fn update_msg(msg: &amp;str) {
    ...
}
...
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>在使用FFI引用外部，例如C的函数时，其本身有可能会返回全局变量。当 rust 接入这些函数时需要指定输入的变量类型为静态（static），而若要改变它们的值的时候就需要将其定义为可变静态变量（static mut）。</p>
<pre><pre class="playground"><code class="language-rust">use std::ffi::CString;
use std::ptr;

#[link(name = &quot;readline&quot;)]
extern {
    static mut rl_prompt: *const libc::c_char;
}

fn main() {
    let prompt = CString::new(&quot;[my-awesome-shell] $&quot;).unwrap();
    unsafe {
        rl_prompt = prompt.as_ptr();
        println!(&quot;{:?}&quot;, rl_prompt);
        rl_prompt = ptr::null();
    }
}
</code></pre></pre>
<p><strong>【例外】</strong></p>
<p>通常情况下直接修改 static mut 会有线程安全风险，但若配合使用 <a href="https://doc.rust-lang.org/std/sync/struct.Once.html#">std::sync::Once</a> 则可保证该变量只初始化一次，不会产生线程安全风险。</p>
<p>（注：此用法在功能上等同于 <a href="https://docs.rs/once_cell/latest/once_cell/sync/struct.OnceCell.html">once_cell::sync::OnceCell</a> 或 Nightly 版本中的 <a href="https://doc.rust-lang.org/std/lazy/struct.SyncOnceCell.html">std::lazy::SyncOnceCell</a>。但在使用 Stable 版本编译器并且不使用第三方库的条件下此写法完全合规，故算作例外情况。）</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Mutex, Once};

static mut SOUND: Option&lt;Mutex&lt;String&gt;&gt; = None;
static SOUND_ONCE: Once = Once::new();

fn make_sound() -&gt; &amp;'static Mutex&lt;String&gt; {
    unsafe {
        SOUND_ONCE.call_once(|| {
            SOUND = Some(Mutex::new(&quot;Oh! Apple! nom nom nom...&quot;.to_string()));
        });
        SOUND.as_ref().unwrap()
    }
}

fn main() {
    println!(&quot;{}&quot;, *make_sound().lock().unwrap()); // Oh! Apple! nom nom nom...
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p><strong>【定制化参考】</strong></p>
<p>这条规则如果需要定制 Lint，则应考虑两种情况:</p>
<ol>
<li>代码中定义为 static mut 的变量是否仅被用于 FFI</li>
<li>代码中定义为 static mut 的变量是否经过 call_once 初始化</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="33-变量"><a class="header" href="#33-变量">3.3 变量</a></h1>
<p>这里所说的变量单指局部变量而不包括全局变量。 默认情况下，Rust 会强制初始化所有变量的值，以防止使用未初始化的内存。</p>
<p>变量命名风格指南请看 <a href="safe-guides/coding_practice/../code_style/naming.html">编码风格-命名</a></p>
<h2 id="列表-5"><a class="header" href="#列表-5">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./variables/P.VAR.01.html">P.VAR.01 非必要请避免像 C 语言那样先声明可变变量再赋值</a></li>
<li><a href="safe-guides/coding_practice/./variables/P.VAR.02.html">P.VAR.02 利用变量遮蔽功能保证变量安全使用</a></li>
<li><a href="safe-guides/coding_practice/./variables/G.VAR.01.html">G.VAR.01 使用解构元组方式定义多个变量时不应使用太多单个字符来命名变量</a></li>
<li><a href="safe-guides/coding_practice/./variables/G.VAR.02.html">G.VAR.02 通常不应使用非 ASCII 字符作为标识符</a></li>
<li><a href="safe-guides/coding_practice/./variables/G.VAR.03.html">G.VAR.03 在某些场合下不宜使用变量遮蔽功能</a></li>
<li><a href="safe-guides/coding_practice/./variables/G.VAR.04.html">G.VAR.04 避免局部变量导致的大量栈分配</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pvar01--一般情况下避免先声明可变变量再赋值"><a class="header" href="#pvar01--一般情况下避免先声明可变变量再赋值">P.VAR.01  一般情况下避免先声明可变变量再赋值</a></h2>
<p><strong>【描述】</strong></p>
<p>一般情况下，不要先声明一个可变的变量，然后在后续过程中再去改变它的值，这可能来自于 C 语言的习惯，但 Rust 中不推荐这样使用。</p>
<p>一般情况下，声明一个变量的时候，要对其进行初始化。如果后续可能会改变其值，要考虑优先使用变量遮蔽（继承式可变）功能。如果需要在一个子作用域内改变其值，再使用可变绑定或可变引用。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let base : u8;
if cfg!(not(USB_PROTOCOL_NEW_ARCH)) {
    base = other_instance.base;
} else {
    base = 42u8;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let base : u8 = if cfg!(not(USB_PROTOCOL_NEW_ARCH)) {
    base = other_instance.base;
} else {
    base = 42u8;
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pvar02-利用变量遮蔽功能保证变量安全使用"><a class="header" href="#pvar02-利用变量遮蔽功能保证变量安全使用">P.VAR.02 利用变量遮蔽功能保证变量安全使用</a></h2>
<p><strong>【描述】</strong></p>
<p>在某些场景，可能会临时准备或处理一些数值，但在此之后，数据只用于检查而非修改。</p>
<p>那么可以将其通过变量遮蔽功能，重写绑定为不可变变量，来表明这种临时可变，但后面不变的意图。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut data = get_vec();
data_sort(); //临时需要排序
let data = data; // 后面就不需要改动了，由编译器可以确保

// Here `data` is immutable
<span class="boring">}
</span></code></pre></pre>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = {
    let mut data = get_vec();
    data.sort();
    data // 虽然后面不再改动，但代码语义上没有表现出来先改变，后不变那种顺序语义
}

// Here `data` is immutable
<span class="boring">}
</span></code></pre></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="gvar01--以解构元组方式定义多个变量时不应使用太多无意义变量名"><a class="header" href="#gvar01--以解构元组方式定义多个变量时不应使用太多无意义变量名">G.VAR.01  以解构元组方式定义多个变量时不应使用太多无意义变量名</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在以解构元组的方式定义多个变量时，变量命可能是无特别语义的，如用单个字符表示的临时变量。但是不宜使用过多无意义变量名。</p>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 修改可以绑定的单个字符变量名最大数量。默认为 4
single-char-binding-names-threshold=4
</code></pre>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (a, b, c, d, e, f, g) = (...);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>元组元素超过三个的，建议使用包含语义的变量命。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (width, high, len, shape, color, status) = (...);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#many_single_char_names">many_single_char_names</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gvar02--不应使用非-ascii-字符作为标识符"><a class="header" href="#gvar02--不应使用非-ascii-字符作为标识符">G.VAR.02  不应使用非 ASCII 字符作为标识符</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>Rust 语言默认支持 Non ASCII 字符作为合法标识符。但是，为了统一团队代码风格，建议使用最常用的 ASCII 字符作为合法标识符。</p>
<p>此外，通常<strong>命名相关</strong>的 Lint 检查只支持英文命名。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct 人 {
    /// 普通话
    名字: String,
    /// 廣東話
    屋企: String,
}

fn main () {
    let 我的名字 = &quot;मनीष&quot;.to_string();
    let 我嘅屋企 = &quot;Berkeley&quot;.to_string();
    
    // मराठी
    let मनीष = 人 {
        名字: 我的名字,
        屋企: 我嘅屋企,
    };
    
    // हिंदी
    let उसका_नाम = &quot;مصطفى&quot;.to_string();
    let 他的家 = &quot;Oakland&quot;.to_string();
   
    // اردو 
    let مصطفى = 人 {
        名字: उसका_नाम,
        屋企: 他的家,
    }; 
    
    println!(&quot;मी: {:?}&quot;, मनीष);
    println!(&quot;माझा मित्र: {:?}&quot;, مصطفى);
}

// 输出：
// मी: 人 { 名字: &quot;मनीष&quot;, 屋企: &quot;Berkeley&quot; }
// माझा मित्र: 人 { 名字: &quot;مصطفى&quot;, 屋企: &quot;Oakland&quot; }
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct People {
    name: String,
    addr: String,
}

fn main () {
    let name = &quot;मनीष&quot;.to_string();
    let addr = &quot;Berkeley&quot;.to_string();
    
    // मराठी
    let me = People {
        name: name,
        addr: addr,
    };
    
    // हिंदी
    let name = &quot;مصطفى&quot;.to_string();
    let addr = &quot;Oakland&quot;.to_string();
   
    // اردو     
    let he = People {
        name: name,
        addr: addr,
    }; 
    
    println!(&quot;my name: {:?}&quot;, me);
    println!(&quot;his name: {:?}&quot;, he);
}

// 输出
// my name: People { name: &quot;मनीष&quot;, addr: &quot;Berkeley&quot; }
// his name: People { name: &quot;مصطفى&quot;, addr: &quot;Oakland&quot; }
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#non-ascii-idents">rustc-lint: non-ascii-idents</a></td><td>no</td><td>yes</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gvar03--变量遮蔽功能应当合理使用"><a class="header" href="#gvar03--变量遮蔽功能应当合理使用">G.VAR.03  变量遮蔽功能应当合理使用</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>变量遮蔽功能在功能上属于一种继承式可变。他会覆盖之前的变量绑定，而创建一个新的同名的变量绑定。</p>
<ol>
<li>在同一个作用域中，非必要时不宜通过新变量声明遮蔽旧变量声明的方式来修改变量。</li>
<li>在子作用域内修改“哨兵变量”时，应该避免使用变量遮蔽功能，防止引起逻辑bug。</li>
<li>如果使用变量遮蔽，禁止用不同类型的变量遮蔽前一个变量，如果实现同一个 <code>trait</code> 的可以例外。</li>
</ol>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">let x = 2;
let x = x + 1; // 将会改变x的值

let x = &amp;x; // 只是改变引用级别

let x = y; // 更早的绑定
let x = z; // 遮蔽了更早的绑定

// or

fn main() {
    let mut a = 0;
    {
        // 这里使用变量遮蔽逻辑已经被改变
        let a = 42;
    }
    
    a; // use a again
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">let x = 2;
let y = x + 1; // 不改变x的值，声明新的变量y

let y = &amp;x; // 不改变x的绑定，声明新的变量

let w = z; // 使用不同的名字

// or

fn main() {
    let mut a = 0;
    {
        // do something
        a = 42;
    }
    a;// use a again
}
</code></pre></pre>
<p><strong>【例外】</strong></p>
<p>在某些场景，可能会临时准备或处理一些数据，但在此之后，数据只用于检查而非修改。</p>
<p>那么可以将其通过变量遮蔽功能，重写绑定为不可变变量，来表明这种 临时可变，但后面不变的意图。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不建议用法
let data = { 
    let mut data = get_vec();
    data.sort();
    data // 虽然后面不再改动，但代码语义上没有表现出来先改变，后不变那种顺序语义
};

// Here `data` is immutable.
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 建议用法
let mut data = get_vec();
data.sort(); // 临时需要排序
let data = data; //  由编译器确保后面不再改动

// Here `data` is immutable.
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#shadow_reuse">shadow_reuse</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#shadow_same">shadow_same</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#shadow_unrelated">shadow_unrelated</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gvar05--避免因局部变量导致的大量栈分配"><a class="header" href="#gvar05--避免因局部变量导致的大量栈分配">G.VAR.05  避免因局部变量导致的大量栈分配</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Rust 局部变量默认分配在栈上。当局部变量占用栈空间过大时，会栈溢出，可以采用<code>Box&lt;T&gt;</code>使变量在堆上分配。</p>
<p>Rust 默认栈分配空间为：</p>
<ol>
<li>主线程默认 <code>8MiB</code> 。</li>
<li>运行中代码创建的子线程默认是 <code>2MiB</code> 。</li>
</ol>
<p>也可以自行配置栈分配内存大小。</p>
<p>所以，局部变量占用多少空间才算过大，这个需要开发者根据具体的场景根据栈大小配置情况做出合适的预判，一般以 512 KiB为宜。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _: [i32; 8000] = [1; 8000];
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _: Box&lt;[i32; 8000]&gt; = Box::new([1; 8000]);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p><strong>【定制化参考】</strong></p>
<p>这条规则如果需要定制Lint，则可以分别检测每个局部变量占用的栈空间，并统计总体占用情况，进行告警。
局部变量占用栈空间的告警阈值默认是 2MB，但是用户可以按需配置该值。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="34-数据类型"><a class="header" href="#34-数据类型">3.4 数据类型</a></h1>
<p>数据类型记录 Rust 标准库提供的 原生类型，以及结构体和枚举体等编码实践。</p>
<h2 id="列表-6"><a class="header" href="#列表-6">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./data-type/P.TYP.01.html">P.TYP.01 必要时，应该使得类型可以表达更明确的语义，而不是只是直接使用原生类型</a></li>
<li><a href="safe-guides/coding_practice/./data-type/G.TYP.01.html">G.TYP.01 类型转换尽可能使用安全的转换函数代替 <code>as</code></a></li>
<li><a href="safe-guides/coding_practice/./data-type/G.TYP.02.html">G.TYP.02 数字字面量在使用的时候应该明确标注好类型</a></li>
<li><a href="safe-guides/coding_practice/./data-type/G.TYP.03.html">G.TYP.03 不要用数字类型边界值去判断能否安全转换，而应该使用 try_from 相关方法</a></li>
<li><a href="safe-guides/coding_practice/./safe-guides/coding_practice/data-type/bool.html">布尔</a>
<ul>
<li><a href="safe-guides/coding_practice/./data-type/bool/G.TYP.BOL.01.html">G.TYP.BOL.01 返回为布尔值的表达式或函数值不应和布尔字面量进行比较</a></li>
<li><a href="safe-guides/coding_practice/./data-type/bool/G.TYP.BOL.02.html">G.TYP.BOL.02 如果 match 匹配表达式为布尔类型，应使用 if 表达式来代替</a></li>
<li><a href="safe-guides/coding_practice/./data-type/bool/G.TYP.BOL.03.html">G.TYP.BOL.03 不应将数字类型转换为布尔值</a></li>
<li><a href="safe-guides/coding_practice/./data-type/bool/G.TYP.BOL.04.html">G.TYP.BOL.04 禁止在<code>if</code>表达式条件中使用块（block）结构</a></li>
<li><a href="safe-guides/coding_practice/./data-type/bool/G.TYP.BOL.05.html">G.TYP.BOL.05 非必要时，布尔运算应使用逻辑运算符(<code>&amp;&amp;/||</code>)而非位运算符(<code>&amp;/|</code>)</a></li>
<li><a href="safe-guides/coding_practice/./data-type/bool/G.TYP.BOL.06.html">G.TYP.BOL.06 不应使用数字来代替布尔值</a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./data-type/char.html">字符</a>
<ul>
<li><a href="safe-guides/coding_practice/./data-type/char/G.TYP.CHR.01.html">G.TYP.CHR.01 不宜将字符字面量强制转换为 <code>u8</code></a></li>
<li><a href="safe-guides/coding_practice/./data-type/char/G.TYP.CHR.02.html">G.TYP.CHR.02 字符串方法中如果需要单个字符的值作为参数，宜使用字符而非字符串</a></li>
<li><a href="safe-guides/coding_practice/./data-type/char/G.TYP.CHR.03.html">G.TYP.CHR.03 当需要将整数转换为字符时，应使用安全转换函数，而非 transmute</a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./data-type/int.html">整数</a>
<ul>
<li><a href="safe-guides/coding_practice/./data-type/int/G.TYP.INT.01.html">G.TYP.INT.01 在用整数计算的时候需要考虑整数溢出、回绕和截断的风险</a></li>
<li><a href="safe-guides/coding_practice/./data-type/int/G.TYP.INT.02.html">G.TYP.INT.02 避免有符号整数和无符号整数之间的强制转换</a></li>
<li><a href="safe-guides/coding_practice/./data-type/int/G.TYP.INT.03.html">G.TYP.INT.03 对负数取模计算的时候不应使用<code>%</code></a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./data-type/float.html">浮点数</a>
<ul>
<li><a href="safe-guides/coding_practice/./data-type/float/G.TYP.FLT.01.html">G.TYP.FLT.01 使用<code>f32</code>字面量时，避免被Rust编译器截断</a></li>
<li><a href="safe-guides/coding_practice/./data-type/float/G.TYP.FLT.02.html">G.TYP.FLT.02 从任何数字类型转换为<code>f64</code>类型时注意避免损失精度</a></li>
<li><a href="safe-guides/coding_practice/./data-type/float/G.TYP.FLT.03.html">G.TYP.FLT.03 对精度高要求的场景下，不应直接使用浮点数进行运算和比较</a></li>
<li><a href="safe-guides/coding_practice/./data-type/float/G.TYP.FLT.04.html">G.TYP.FLT.04 宜使用Rust内置方法处理浮点数计算</a></li>
<li><a href="safe-guides/coding_practice/./data-type/float/G.TYP.FLT.05.html">G.TYP.FLT.05 使用字面量定义浮点数时，尽量使用<code>f64</code>类型而非<code>f32</code>类型</a></li>
<li><a href="safe-guides/coding_practice/./data-type/float/G.TYP.FLT.06.html">G.TYP.FLT.06 禁止在浮点数和整数相互转换时使用 transmute</a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./data-type/slice.html">切片</a>
<ul>
<li><a href="safe-guides/coding_practice/./data-type/slice/P.TYP.SLC.01.html">P.TYP.SLC.01 宜使用切片迭代器来代替手工索引</a></li>
<li><a href="safe-guides/coding_practice/./data-type/slice/P.TYP.SLC.02.html">P.TYP.SLC.02 宜使用切片模式来提升代码的可读性</a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./data-type/tuple.html">元组</a>
<ul>
<li><a href="safe-guides/coding_practice/./data-type/tuple/G.TYP.TUP.01.html">G.TYP.TUP.01 使用元组时，其元素最多不宜超过3个</a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./data-type/array.html">固定长度数组</a>
<ul>
<li><a href="safe-guides/coding_practice/./data-type/array/G.TYP.ARR.01.html">G.TYP.ARR.01 创建大全局数组时宜使用静态变量而非常量</a></li>
<li><a href="safe-guides/coding_practice/./data-type/array/G.TYP.ARR.02.html">G.TYP.ARR.02 使用数组索引时禁止越界访问</a></li>
<li><a href="safe-guides/coding_practice/./data-type/array/G.TYP.ARR.03.html">G.TYP.ARR.03 当数组元素为原生数据类型（Primitive），排序时宜使用非稳定排序</a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./data-type/vec.html">动态数组</a>
<ul>
<li><a href="safe-guides/coding_practice/./data-type/vec/P.TYP.VEC.01.html">P.TYP.VEC.01 非必要时不宜使用动态数组</a></li>
<li><a href="safe-guides/coding_practice/./data-type/vec/P.TYP.VEC.02.html">P.TYP.VEC.02 创建动态数组时，宜预先分配足够容量，避免后续操作中产生多次分配</a></li>
<li><a href="safe-guides/coding_practice/./data-type/vec/G.TYP.VEC.01.html">G.TYP.VEC.01 禁止访问未初始化的数组</a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./data-type/struct.html">结构体</a>
<ul>
<li><a href="safe-guides/coding_practice/./data-type/struct/P.TYP.SCT.01.html">P.TYP.SCT.01 为结构体实现构造性方法时，避免构造后再初始化的情况</a></li>
<li><a href="safe-guides/coding_practice/./data-type/struct/P.TYP.SCT.02.html">P.TYP.SCT.02 结构体实例需要默认实现时，宜使用Default特质</a></li>
<li><a href="safe-guides/coding_practice/./data-type/struct/G.TYP.SCT.01.html">G.TYP.SCT.01 对外导出的公开的 Struct，宜添加<code>#[non_exhaustive]</code>属性</a></li>
<li><a href="safe-guides/coding_practice/./data-type/struct/G.TYP.SCT.02.html">G.TYP.SCT.02 当结构体中有超过三个布尔类型的字段，宜将其独立为一个枚举</a></li>
<li><a href="safe-guides/coding_practice/./data-type/struct/G.TYP.SCT.03.html">G.TYP.SCT.03 宜使用结构体功能更新语法来提升代码可读性</a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./data-type/enum.html">枚举体</a>
<ul>
<li><a href="safe-guides/coding_practice/./data-type/enum/G.TYP.ENM.01.html">G.TYP.ENM.01 合理选择<code>map</code>和<code>and_then</code></a></li>
<li><a href="safe-guides/coding_practice/./data-type/enum/G.TYP.ENM.02.html">G.TYP.ENM.02 非必要时不应自行创建空枚举</a></li>
<li><a href="safe-guides/coding_practice/./data-type/enum/G.TYP.ENM.03.html">G.TYP.ENM.03 在使用类似 C 语言的枚举写法且使用<code>repr(isize/usize)</code> 布局时注意 32位架构上截断的问题</a></li>
<li><a href="safe-guides/coding_practice/./data-type/enum/G.TYP.ENM.04.html">G.TYP.ENM.04 不宜在<code>use</code>语句中引入Enum的全部变体（variants）</a></li>
<li><a href="safe-guides/coding_practice/./data-type/enum/G.TYP.ENM.05.html">G.TYP.ENM.05 对外导出的公开Enum，宜添加<code>#[non_exhaustive]</code>属性</a></li>
<li><a href="safe-guides/coding_practice/./data-type/enum/G.TYP.ENM.06.html">G.TYP.ENM.06 Enum内变体的大小差异不宜过大</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptyp01---必要时应使类型可以表达更明确的语义而不是只是直接使用原生类型"><a class="header" href="#ptyp01---必要时应使类型可以表达更明确的语义而不是只是直接使用原生类型">P.TYP.01   必要时，应使类型可以表达更明确的语义，而不是只是直接使用原生类型</a></h2>
<p><strong>【描述】</strong></p>
<p>在类型中表达语义，可以增加代码的可读性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let years = 1942;
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">struct Years(i64);

fn main() {
    let years = Years(1942);
    let years_as_primitive_1: i64 = years.0; // Tuple
    let Years(years_as_primitive_2) = years; // Destructuring
}
</code></pre></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtyp01-类型转换尽可能使用安全的转换函数代替-as"><a class="header" href="#gtyp01-类型转换尽可能使用安全的转换函数代替-as">G.TYP.01 类型转换尽可能使用安全的转换函数代替 <code>as</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Rust 的 <code>as</code> 转换包含了「静默的有损转换(lossy conversion)」。诸如 <code>i32::from</code> 之类的转换函数只会执行无损转换(lossless conversion)。 如果输入表达式的类型发生变化，使用转换函数可以防止转换变成无声的有损转换，并使阅读代码的人更容易知道转换是无损的。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn as_u64(x: u8) -&gt; u64 {
    x as u64
}
// or
let a: u32;
f(a as u16);
// or
let ptr: *const u32 = &amp;42_u32;
let mut_ptr: *mut u32 = &amp;mut 42_u32;
let _ = ptr as *const i32;
let _ = mut_ptr as *mut i32;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn as_u64(x: u8) -&gt; u64 {
    u64::from(x)
}
// or
f(a.try_into()?);
// or
f(a.try_into().expect(&quot;Unexpected u16 overflow in f&quot;));
// or
let ptr: *const u32 = &amp;42_u32;
let mut_ptr: *mut u32 = &amp;mut 42_u32;
let _ = ptr.cast::&lt;i32&gt;();
let _ = mut_ptr.cast::&lt;i32&gt;();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#as_conversions">as_conversions</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_lossless">cast_lossless</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_possible_truncation">cast_possible_truncation</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_possible_wrap">cast_possible_wrap</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_precision_loss">cast_precision_loss</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_sign_loss">cast_sign_loss</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#fn_to_numeric_cast">fn_to_numeric_cast</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#fn_to_numeric_cast_with_truncation">fn_to_numeric_cast_with_truncation</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#char_lit_as_u8">char_lit_as_u8</a></td><td>yes</td><td>no</td><td>Complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_ref_to_mut">cast_ref_to_mut</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#ptr_as_ptr">ptr_as_ptr</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtyp02--数字字面量在使用的时候应该明确标注类型"><a class="header" href="#gtyp02--数字字面量在使用的时候应该明确标注类型">G.TYP.02  数字字面量在使用的时候应该明确标注类型</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>如果数字字面量没有被指定具体类型，那么单靠类型推导，整数类型会被默认绑定为 <code>i32</code> 类型，而浮点数则默认绑定为 <code>f64</code>类型。这可能导致某些运行时的意外。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let i = 10; // i32
let f = 1.23; // f64
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let i = 10u32;
let f = 1.23f32;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#default_numeric_fallback">default_numeric_fallback</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtyp03---不应用数字类型边界值判断能否安全转换而应使用-try_from-方法"><a class="header" href="#gtyp03---不应用数字类型边界值判断能否安全转换而应使用-try_from-方法">G.TYP.03   不应用数字类型边界值判断能否安全转换，而应使用 <code>try_from</code> 方法</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在 Rust 中 <code>From</code> 代表不能失败的转换，而 <code>TryFrom</code> 则允许返回错误。</p>
<p>一般在数字类型转换的时候，不需要防御式地去判断数字大小边界，那样可读性比较差，应该使用 <code>try_from</code> 方法，在无法转换的时候处理错误即可。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo: u32 = 5;
let _ = foo &lt;= i16::MAX as u32; // 等价于 let _ = foo &lt;= (i32::MAX as u32);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo: u32 = 5; 
let f = i16::try_from(foo).is_ok(); // 返回 false
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#checked_conversions">checked_conversions</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="布尔"><a class="header" href="#布尔">布尔</a></h1>
<p>Rust 中的布尔类型有 <code>true</code>和<code>false</code>两种值。</p>
<h2 id="列表-7"><a class="header" href="#列表-7">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/data-type/./bool/G.TYP.BOL.01.html">G.TYP.BOL.01 返回为布尔值的表达式或函数值不应和布尔字面量进行比较</a></li>
<li><a href="safe-guides/coding_practice/data-type/./bool/G.TYP.BOL.02.html">G.TYP.BOL.02 如果 match 匹配表达式为布尔类型，应使用 if 表达式来代替</a></li>
<li><a href="safe-guides/coding_practice/data-type/./bool/G.TYP.BOL.03.html">G.TYP.BOL.03 不应将数字类型转换为布尔值</a></li>
<li><a href="safe-guides/coding_practice/data-type/./bool/G.TYP.BOL.04.html">G.TYP.BOL.04 禁止在<code>if</code>表达式条件中使用块（block）结构</a></li>
<li><a href="safe-guides/coding_practice/data-type/./bool/G.TYP.BOL.05.html">G.TYP.BOL.05 非必要时，布尔运算应使用逻辑运算符(<code>&amp;&amp;/||</code>)而非位运算符(<code>&amp;/|</code>)</a></li>
<li><a href="safe-guides/coding_practice/data-type/./bool/G.TYP.BOL.06.html">G.TYP.BOL.06 不应使用数字来代替布尔值</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypbol01-不应将布尔值和布尔字面量进行比较"><a class="header" href="#gtypbol01-不应将布尔值和布尔字面量进行比较">G.TYP.BOL.01 不应将布尔值和布尔字面量进行比较</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>在 Rust 中，返回为布尔值的表达式或函数值可以直接当作布尔值使用。</p>
<p>总之，使用布尔表达式的时候，要尽可能地简洁明了。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if x == true {}
if y == false {}

assert_eq!(&quot;a&quot;.is_empty(), false);
assert_ne!(&quot;a&quot;.is_empty(), true);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if x {}
if !y {}

assert!(!&quot;a&quot;.is_empty());
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#bool_comparison">bool_comparison </a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#bool_assert_comparison">bool_assert_comparison </a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#needless_bool">needless_bool </a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#nonminimal_bool">nonminimal_bool  </a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#needless_bitwise_bool">needless_bitwise_bool  </a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#needless_bitwise_bool">assertions_on_constants  </a></td><td>yes</td><td>no</td><td>pedantic</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypbol02-如果-match-匹配表达式为布尔类型宜使用-if-表达式来代替"><a class="header" href="#gtypbol02-如果-match-匹配表达式为布尔类型宜使用-if-表达式来代替">G.TYP.BOL.02 如果 match 匹配表达式为布尔类型，宜使用 <code>if</code> 表达式来代替</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>对于布尔表达式更倾向于使用 <code>if ... else ...</code>，相比较 <code>match</code> 模式匹配更有利于代码可读性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn foo() {}
</span><span class="boring">fn bar() {}
</span>let condition: bool = true;
match condition {
    true =&gt; foo(),
    false =&gt; bar(),
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn foo() {}
</span><span class="boring">fn bar() {}
</span>let condition: bool = true;
if condition {
    foo();
} else {
    bar();
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#logic_bug">logic_bug </a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#match_bool">match_bool</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypbol03-不应将数字类型转换为布尔值"><a class="header" href="#gtypbol03-不应将数字类型转换为布尔值">G.TYP.BOL.03 不应将数字类型转换为布尔值</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>这可能会让布尔值在内存中的表示无效。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1_u8;
unsafe {
    let _: bool = std::mem::transmute(x); // where x: u8
}

<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#transmute_int_to_bool">transmute_int_to_bool </a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypbol04-禁止在if表达式条件中使用块block结构"><a class="header" href="#gtypbol04-禁止在if表达式条件中使用块block结构">G.TYP.BOL.04 禁止在if表达式条件中使用块（block）结构</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>为了增加可读性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if { true } { /* ... */ }

<span class="boring">fn somefunc() -&gt; bool { true };
</span>if { let x = somefunc(); x } { /* ... */ }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if true { /* ... */ }

<span class="boring">fn somefunc() -&gt; bool { true };
</span>let res = { let x = somefunc(); x };
if res { /* ... */ }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#blocks_in_if_conditions">blocks_in_if_conditions  </a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypbol05-非必要时布尔运算应使用逻辑运算符-而非位运算符-"><a class="header" href="#gtypbol05-非必要时布尔运算应使用逻辑运算符-而非位运算符-">G.TYP.BOL.05 非必要时，布尔运算应使用逻辑运算符( <code>&amp;&amp;/||</code>)而非位运算符 (<code>&amp;/|</code>)</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>位运算不支持短路（short-circuiting），所以会影响性能。逻辑运算符则支持短路。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x,y) = (true, false);
if x &amp; !y {} //  位运算符，不支持短路
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x,y) = (true, false);
if x &amp;&amp; !y {} //  逻辑运算符，支持短路
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#needless_bitwise_bool">needless_bitwise_bool</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypbol06--不应使用数字代替布尔值"><a class="header" href="#gtypbol06--不应使用数字代替布尔值">G.TYP.BOL.06  不应使用数字代替布尔值</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>Rust 中布尔值就是 <code>true</code>  和 <code>false</code>。 不要试图使用数字 <code>1</code> 和 <code>0</code> 来代替布尔值。</p>
<p>虽然 布尔值 可以强转为 对应的数字，但是反之则不行。</p>
<p>不要通过判断数字来代替 布尔值，除非是 FFi 场景通过 C-ABI 和其他语言打交道。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 1;
let b = 0;
assert_eq!(true, a == 1);  
assert_eq!(false, b == 0);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = true;
let b = false;
assert_eq!(1, a as u32);
assert_eq!(0, b as u32);
<span class="boring">}
</span></code></pre></pre>
<p>【例外】</p>
<p>FFi 时从外部传入数字</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符"><a class="header" href="#字符">字符</a></h1>
<p>在 Rust 中，字符是一个合法的 Unicode 标量值（Unicode scalar value），一个字符大小为 4 字节，对应一个 Unicode 码位（CodePoint）。</p>
<h2 id="列表-8"><a class="header" href="#列表-8">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/data-type/./char/G.TYP.CHR.01.html">G.TYP.CHR.01 不宜将字符字面量强制转换为 <code>u8</code></a></li>
<li><a href="safe-guides/coding_practice/data-type/./char/G.TYP.CHR.02.html">G.TYP.CHR.02 字符串方法中如果需要单个字符的值作为参数，宜使用字符而非字符串</a></li>
<li><a href="safe-guides/coding_practice/data-type/./char/G.TYP.CHR.03.html">G.TYP.CHR.03 当需要将整数转换为字符时，应使用安全转换函数，而非 transmute</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypchr01--不应将字符字面量强制转换为-u8"><a class="header" href="#gtypchr01--不应将字符字面量强制转换为-u8">G.TYP.CHR.01  不应将字符字面量强制转换为 <code>u8</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>应该使用字节字面量去代替将字符字面量强转为 <code>u8</code>。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'x' as u8
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>b'x'
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#char_lit_as_u8">char_lit_as_u8</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypchr02-字符串方法中如果需要单个字符的值作为参数宜使用字符而非字符串"><a class="header" href="#gtypchr02-字符串方法中如果需要单个字符的值作为参数宜使用字符而非字符串">G.TYP.CHR.02 字符串方法中如果需要单个字符的值作为参数，宜使用字符而非字符串</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>大部分情况下，使用字符比用字符串性能更好。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;yxz&quot;;
s.split(&quot;x&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;yxz&quot;;
s.split('x');
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#single_char_pattern">single_char_pattern</a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypchr03-需要将整数转换为字符时应使用安全转换函数而非-transmute"><a class="header" href="#gtypchr03-需要将整数转换为字符时应使用安全转换函数而非-transmute">G.TYP.CHR.03 需要将整数转换为字符时，应使用安全转换函数，而非 <code>transmute</code></a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>并非每个整数都对应一个合法的 Unicode 标量值，使用 <code>transmute</code> 转换会有未定义行为。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 37_u32;
unsafe {
    let x: char = std::mem::transmute(x); // where x: u32
    assert_eq!('%', x);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 37_u32;
unsafe {
    let x = std::char::from_u32(x).unwrap(); // 请按情况处理 None
    // let x = std::char::from_u32_unchecked(x);  // 如果确定该整数对应合法的unicode，可以使用 uncheck 方法加速
    assert_eq!('%', x);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#transmute_int_to_char">transmute_int_to_char</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整数"><a class="header" href="#整数">整数</a></h1>
<p>Rust 中有目前有十二种整数类型：<code>i8/u8</code>, <code>i16/u16</code>, <code>i32/u32</code>, <code>i64/u64</code>, <code>i128/u128</code>, <code>isize/usize</code> 。</p>
<h2 id="列表-9"><a class="header" href="#列表-9">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/data-type/./int/G.TYP.INT.01.html">G.TYP.INT.01 在用整数计算的时候需要考虑整数溢出、回绕和截断的风险</a></li>
<li><a href="safe-guides/coding_practice/data-type/./int/G.TYP.INT.02.html">G.TYP.INT.02 避免有符号整数和无符号整数之间的强制转换</a></li>
<li><a href="safe-guides/coding_practice/data-type/./int/G.TYP.INT.03.html">G.TYP.INT.03 对负数取模计算的时候不应使用<code>%</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypint01--在用整数计算的时候需要考虑整数溢出回绕和截断的风险"><a class="header" href="#gtypint01--在用整数计算的时候需要考虑整数溢出回绕和截断的风险">G.TYP.INT.01  在用整数计算的时候需要考虑整数溢出、回绕和截断的风险</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>使用整数计算时需要结合场景和业务来考虑如果发生溢出、回绕或截断的时候，是否会引起严重的问题。</p>
<p>比如，对于时间要求精准的系统，如果在计算时间发生整数溢出，或者去计算某个数组的索引等，那可能会发生严重问题。但如果你只是一个简单的计算器，不会被用到具体的业务场合，那溢出也没有关系，因为你只需要在合理的数字范围内计算性能最好。</p>
<p>在 Rust 标准库中，提供 <code>add</code>/ <code>checked_add</code> / <code> saturating_add</code>/<code>overflowing_add</code> / <code>wrapping_add</code> 不同系列方法，返回值不同，根据不同的场合选择适合的方法。</p>
<ol>
<li><code>check_*</code>函数返回<code>Option</code>，一旦发生溢出则返回None。</li>
<li><code>saturating_*</code>系列函数返回类型是整数，如果溢出，则给出该类型可表示范围的“最大/最小”值。</li>
<li><code>wrapping_*</code>系列函数则是直接抛弃已经溢出的最高位，将剩下的部分返回。</li>
</ol>
<p>Rust 编译器在编译时默认没有溢出检查（可通过编译参数来引入），但在运行时会有 Rust 内置 lint (<code>#[deny(arithmetic_overflow)]</code>)来检查，如果有溢出会 Panic。</p>
<p>无符号整数使用时要注意回绕(wrap around)，不同整数类型转换时需注意截断。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!((-5i32).abs(), 5);
assert_eq!(100i32+1, 101);

fn test_integer_overflow() {
    // debug 与 release 编译都会有溢出检查
    let mut a: u8 = 255 + 1;
    
    // debug模式，运行panic；release模式，x = 0
    let mut x: u8 = 255;
    x += 1;
    println!(&quot;x={}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!((-5i32).checked_abs(), Some(5));
assert_eq!(100i32.saturating_add(1), 101);

fn add_num(a: u8) -&gt; u8 { a.wrapping_add(255) }

fn test_integer_overflow() {
    // 对于字面量或常量表达式，debug 与 release 编译模式都会有溢出检查
    let mut a: u8 = 255 + 1;

    // debug模式，运行会Panic
    // release模式，x 会等于 0
    let mut x: u8 = 255;
    x = add_num(x);
    println!(&quot;x={}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#integer_arithmetic">integer_arithmetic</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#manual_saturating_arithmetic">manual_saturating_arithmetic</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypint02--避免在有符号整数和无符号整数之间进行强制转换"><a class="header" href="#gtypint02--避免在有符号整数和无符号整数之间进行强制转换">G.TYP.INT.02  避免在有符号整数和无符号整数之间进行强制转换</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>当有符号整数被强制转换为无符号整数时，负值会发生回绕，变成更大的正值，这在实际应用时有可能助长缓冲区溢出风险。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let y: i8 = -1;
y as u128; // will return 18446744073709551615
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let y : i8 = -1;
// Error: 
// the trait `From&lt;i8&gt;` is not implemented for `u128`
// the trait bound `u128: From&lt;i8&gt;` is not satisfied
let z = u128::from(y);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_sign_loss">cast_sign_loss</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>注意：默认情况下该 lint 是<code> allow</code>，如果需要检查这种转换，则需要设置为 <code>warn</code>或 <code>deny</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypint03--对负数取模计算的时候不应使用"><a class="header" href="#gtypint03--对负数取模计算的时候不应使用">G.TYP.INT.03  对负数取模计算的时候不应使用<code>%</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Rust 中的 <code>%</code> 符号为余数运算符，它的行为与<code>C</code>或<code>Java</code>等语言中相同符号的运算符相同。它也类似于<code>Python</code>或<code>Haskell</code>等语言中的模（modulo）运算符，只是它对负数的行为不同：余数是基于截断除法，而模运算是基于向下取整（floor）除法。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a: i32 = -1;
    let b: i32 = 6;
    // 余数运算符只是返回第一个操作数除以第二个操作数的余数。所以 -1/6 给出 0，余数为 -1
    assert_eq!(a % b, -1);
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a: i32 = -1;
    let b: i32 = 6;
	//  取模是严格低于第二个操作数的自然数（所以是非负数），与第二个操作数的最大倍数相加，也低于或等于第一个操作数，则为第一个操作数。
    //  6的最大倍数低于或等于-1 是 -6（6*-1），模数是5，因为-6+5=-1。
    assert_eq!(a.rem_euclid(b), 5);
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#modulo_arithmetic">modulo_arithmetic</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="浮点数"><a class="header" href="#浮点数">浮点数</a></h1>
<p>Rust 的浮点数包括 <code>f32</code> 和 <code>f64</code> 两种类型。Rust 编译器默认推断的 Float 类型是 <code>f64</code>。</p>
<h2 id="列表-10"><a class="header" href="#列表-10">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/data-type/./float/G.TYP.FLT.01.html">G.TYP.FLT.01 使用<code>f32</code>字面量时，避免被Rust编译器截断</a></li>
<li><a href="safe-guides/coding_practice/data-type/./float/G.TYP.FLT.02.html">G.TYP.FLT.02 从任何数字类型转换为<code>f64</code>类型时注意避免损失精度</a></li>
<li><a href="safe-guides/coding_practice/data-type/./float/G.TYP.FLT.03.html">G.TYP.FLT.03 对精度高要求的场景下，不应直接使用浮点数进行运算和比较</a></li>
<li><a href="safe-guides/coding_practice/data-type/./float/G.TYP.FLT.04.html">G.TYP.FLT.04 宜使用Rust内置方法处理浮点数计算</a></li>
<li><a href="safe-guides/coding_practice/data-type/./float/G.TYP.FLT.05.html">G.TYP.FLT.05 使用字面量定义浮点数时，尽量使用<code>f64</code>类型而非<code>f32</code>类型</a></li>
<li><a href="safe-guides/coding_practice/data-type/./float/G.TYP.FLT.06.html">G.TYP.FLT.06 禁止在浮点数和整数相互转换时使用 transmute</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypflt01-使用浮点数字面量时避免被rust编译器截断"><a class="header" href="#gtypflt01-使用浮点数字面量时避免被rust编译器截断">G.TYP.FLT.01 使用浮点数字面量时，避免被Rust编译器截断</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>当指定超过 <code>f32</code> 精度的字面量值时，Rust 会默认截断该值。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: f32 = 0.123_456_789_9;
println!(&quot;{}&quot;, v); //  0.123_456_789
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: f64 = 0.123_456_789_9;
println!(&quot;{}&quot;, v); //  0.123_456_789_9
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#excessive_precision">excessive_precision</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypflt02--从任何数字类型转换为浮点类型时注意避免损失精度"><a class="header" href="#gtypflt02--从任何数字类型转换为浮点类型时注意避免损失精度">G.TYP.FLT.02  从任何数字类型转换为浮点类型时注意避免损失精度</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>这种转换可能会有值的舍入错误发生。在某些对于精度要求比较高的场景需要注意。</p>
<p>开发者需要了解可能发生精度损失的位置，对于精度要求精确的地方更加有好处。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// f32 示例
let _: f32 = 16_777_219.0 ; // 该数字转换为 f32 后会表示为 16_777_220.0
let _: f32 = - 16_777_219.0 ; // 该数字转换为 f32 后会表示为 -16_777_220.0

// f64 示例
let _: f64 = 9_007_199_254_740_993.0 ; // 该数字转换为 f32 后会表示为 9_007_199_254_740_992.0
let _: f64 = - 9_007_199_254_740_993.0 ; // 该数字转换为 f32 后会表示为 -9_007_199_254_740_992.0
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_precision_loss">cast_precision_loss</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypflt03--对精度高要求的场景下不应直接使用浮点数进行运算和比较"><a class="header" href="#gtypflt03--对精度高要求的场景下不应直接使用浮点数进行运算和比较">G.TYP.FLT.03  对精度高要求的场景下，不应直接使用浮点数进行运算和比较</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>浮点数计算通常都是不精确的，直接对浮点数进行运算和比较可能造成数据错误。 如何更好地处理浮点数，可以参阅 <a href="https://floating-point-gui.de/">浮点数指南</a> 。</p>
<p>但是对精度要求不高的场合，比如机器学习中某些场景，对此不做要求。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1.2331f64;
let y = 1.2332f64;

if y == 1.23f64 { }
if y != x {} // where both are floats

// or
pub fn is_roughly_equal(a: f32, b: f32) -&gt; bool {
    (a - b) &lt; f32::EPSILON
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1.2331f64;
let y = 1.2332f64;

let error_margin = f64::EPSILON; // Use an epsilon for comparison
// Or, if Rust &lt;= 1.42, use `std::f64::EPSILON` constant instead.
// let error_margin = std::f64::EPSILON;
if (y - 1.23f64).abs() &lt; error_margin { }
if (y - x).abs() &gt; error_margin { }

// or
pub fn is_roughly_equal(a: f32, b: f32) -&gt; bool {
    (a - b).abs() &lt; f32::EPSILON
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#float_arithmetic">float_arithmetic</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#float_cmp">float_cmp</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#float_cmp_const">float_cmp_const</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#float_equality_without_abs">float_equality_without_abs</a></td><td>yes</td><td>no</td><td>suspicious</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypflt04--宜使用rust内置方法处理浮点数计算"><a class="header" href="#gtypflt04--宜使用rust内置方法处理浮点数计算">G.TYP.FLT.04  宜使用Rust内置方法处理浮点数计算</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>内置方法会牺牲一定性能，但可以提升准确性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 3f32;
let _ = a.powf(1.0 / 3.0);
let _ = (1.0 + a).ln();
let _ = a.exp() - 1.0;

use std::f32::consts::E;

let a = 3f32;
let _ = (2f32).powf(a);
let _ = E.powf(a);
let _ = a.powf(1.0 / 2.0);
let _ = a.log(2.0);
let _ = a.log(10.0);
let _ = a.log(E);
let _ = a.powf(2.0);
let _ = a * 2.0 + 4.0;
let _ = if a &lt; 0.0 {
    -a
} else {
    a
};
let _ = if a &lt; 0.0 {
    a
} else {
    -a
};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 3f32;
let _ = a.cbrt();
let _ = a.ln_1p();
let _ = a.exp_m1();

use std::f32::consts::E;

let a = 3f32;
let _ = a.exp2();
let _ = a.exp();
let _ = a.sqrt();
let _ = a.log2();
let _ = a.log10();
let _ = a.ln();
let _ = a.powi(2);
let _ = a.mul_add(2.0, 4.0);
let _ = a.abs();
let _ = -a.abs();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#imprecise_flops">imprecise_flops</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#suboptimal_flops">suboptimal_flops</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypflt05--使用字面量定义浮点数时尽量使用-f64-类型而非f32类型"><a class="header" href="#gtypflt05--使用字面量定义浮点数时尽量使用-f64-类型而非f32类型">G.TYP.FLT.05  使用字面量定义浮点数时，尽量使用 <code>f64</code> 类型而非<code>f32</code>类型</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在 <code>f32</code> 浮点数字面量在定义时，将会损失精度，应该尽量使用 <code>f64</code> 类型。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x : f32 = 16_777_217.0;
assert_eq!(16777216.0, x);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x : f64 = 16_777_217.0;
assert_eq!(16777217.0, x);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#imprecise_flops">imprecise_flops</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypflt06-禁止在浮点数和整数相互转换时使用-transmute"><a class="header" href="#gtypflt06-禁止在浮点数和整数相互转换时使用-transmute">G.TYP.FLT.06 禁止在浮点数和整数相互转换时使用 <code>transmute</code></a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>使用 <code>transmute</code> 转换是非常容易出错的，建议使用 <code>to_bites</code> 这样转换更加安全。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
    let _: u32 = std::mem::transmute(1f32);
    let _: f32 = std::mem::transmute(1_u32); // where x: u32
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _: f32 = f32::from_bits(1_u32);
let _: u32 = 1f32.to_bits();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#transmute_float_to_int">transmute_float_to_int</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#transmute_int_to_float">transmute_int_to_float</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="切片"><a class="header" href="#切片">切片</a></h1>
<p>切片（slice）允许开发者引用集合中连续的元素序列，类型签名用 <code>[T]</code>表示，但因为它是动态大小类型（DST），所以一般用 <code>&amp;[T]</code> 表示切片。</p>
<p><code>&amp;str</code> 就是一种字符串切片。</p>
<h2 id="列表-11"><a class="header" href="#列表-11">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/data-type/./slice/P.TYP.SLC.01.html">P.TYP.SLC.01 宜使用切片迭代器来代替手工索引</a></li>
<li><a href="safe-guides/coding_practice/data-type/./slice/P.TYP.SLC.02.html">P.TYP.SLC.02 宜使用切片模式来提升代码的可读性</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptypslc01--宜使用切片迭代器来代替手工索引"><a class="header" href="#ptypslc01--宜使用切片迭代器来代替手工索引">P.TYP.SLC.01  宜使用切片迭代器来代替手工索引</a></h2>
<p><strong>【描述】</strong></p>
<p>在 for 循环中使用索引是比较常见的编程习惯，但是这种方式是最有可能导致边界错误的。</p>
<p>利用 切片自带的方法，并利用迭代器，可以避免这种错误。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let points: Vec&lt;Coordinate&gt; = ...;
let mut differences = Vec::new();

// 切片提供 windows 或 array_windows 方法返回迭代器
for [previous, current] in points.array_windows().copied() {
    differences.push(current - previous);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let points: Vec&lt;Coordinate&gt; = ...;
let differences = Vec::new();

// 人工计算长度选择范围很可能会出错
for i in 1..points.len() [
  let current = points[i];
  let previous = points[i-1];
  differences.push(current - previous);
]
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptypslc02-宜使用切片模式来提升代码的可读性"><a class="header" href="#ptypslc02-宜使用切片模式来提升代码的可读性">P.TYP.SLC.02 宜使用切片模式来提升代码的可读性</a></h2>
<p><strong>【描述】</strong></p>
<p>切片也支持模式匹配，适当应用切片模式，可以有效提升代码可读性。</p>
<p><strong>【正例】</strong></p>
<p>利用切片模式编写判断回文字符串的函数。代码来自于：<a href="https://adventures.michaelfbryan.com/posts/daily/slice-patterns/#matching-the-start-of-a-slice">Daily Rust: Slice Patterns</a>  ，还有更多用例。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn word_is_palindrome(word: &amp;str) -&gt; bool {
    let letters: Vec&lt;_&gt; = word.chars().collect();

    is_palindrome(&amp;letters)
}
// 利用切片模式匹配来判断是否回文字符串
fn is_palindrome(items: &amp;[char]) -&gt; bool {
    match items {
        [first, middle @ .., last] =&gt; first == last &amp;&amp; is_palindrome(middle),
        [] | [_] =&gt; true,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn known_palindromes() {
        assert!(word_is_palindrome(&quot;&quot;));
        assert!(word_is_palindrome(&quot;a&quot;));
        assert!(word_is_palindrome(&quot;aba&quot;));
        assert!(word_is_palindrome(&quot;abba&quot;));
    }

    #[test]
    fn not_palindromes() {
        assert!(!word_is_palindrome(&quot;abc&quot;));
        assert!(!word_is_palindrome(&quot;abab&quot;));
    }
}

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元组"><a class="header" href="#元组">元组</a></h1>
<p>元组是异构复合类型，可以存储多个不同类型的元素。</p>
<h2 id="列表-12"><a class="header" href="#列表-12">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/data-type/./tuple/G.TYP.TUP.01.html">G.TYP.TUP.01 使用元组时，其元素最多不宜超过3个</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtyptup01--使用元组时其元素不宜超过3个"><a class="header" href="#gtyptup01--使用元组时其元素不宜超过3个">G.TYP.TUP.01  使用元组时，其元素不宜超过3个</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>元组是异构复合类型，元素过多，其表达力会下降，影响代码可读性和可维护性。</p>
<p>尤其是利用元组作为函数返回值时，不宜过多。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn convert(x: i8) -&gt; (i8, i16, i32, i64, f32, f64) {
    (x as i8, x as i16, x as i32, 
     x as i64, x as f32, x as f64)
}

fn main(){
    let _ = convert(3);
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>可以检测元组中元素个数，如果超过 3 个，发出警告或建议。并且可以支持配置允许个数。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数组"><a class="header" href="#数组">数组</a></h1>
<p>这里指固定长度数组。注意，不同长度的数组，被视为不同的类型。比如 <code>[T;1]</code>和 <code>[T;3]</code> 是两种不同的类型。</p>
<p>从 Rust 1.51 版本开始，稳定了常量泛型（const generics）功能，形如 <code>[T;1]</code>和 <code>[T;3]</code> 这种不同的类型可以统一为 <code>[T; N]</code>。</p>
<h2 id="列表-13"><a class="header" href="#列表-13">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/data-type/./array/G.TYP.ARR.01.html">G.TYP.ARR.01 创建大全局数组时宜使用静态变量而非常量</a></li>
<li><a href="safe-guides/coding_practice/data-type/./array/G.TYP.ARR.02.html">G.TYP.ARR.02 使用数组索引时禁止越界访问</a></li>
<li><a href="safe-guides/coding_practice/data-type/./array/G.TYP.ARR.03.html">G.TYP.ARR.03 当数组元素为原生数据类型（Primitive），排序时宜使用非稳定排序</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtyparr01-创建大全局数组时宜使用静态变量而非常量"><a class="header" href="#gtyparr01-创建大全局数组时宜使用静态变量而非常量">G.TYP.ARR.01 创建大全局数组时宜使用静态变量而非常量</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>因为常量会内联，对于大的数组，通常情况下，会使用其引用，使用静态变量定义更好。</p>
<p>栈上的数组大小以不超过 512KiB 为宜。</p>
<blockquote>
<p>虽然常量本质上是会内联，但 Rust 支持复制消除（Copy Elision）优化（非强制），而且在不断改进完善中，对于这种大的数据应该会有相关优化。</p>
</blockquote>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const A: [u32;1_000_000] = [0u32; 1_000_000];
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub static A: [u32;1_000_000] = [0u32; 1_000_000];
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#large_const_arrays">large_const_arrays</a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#large_stack_arrays">large_stack_arrays</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>注意： <code>large_stack_arrays</code> 会检查在栈上分配的大数组，但clippy默认是 allow，根据实际使用场景决定是否针对这种情况发出警告。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtyparr02--使用数组索引时禁止越界访问"><a class="header" href="#gtyparr02--使用数组索引时禁止越界访问">G.TYP.ARR.02  使用数组索引时禁止越界访问</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>越界访问在运行时会 Panic！</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = [1, 2, 3, 4];
x[9];
&amp;x[2..9];
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = [1, 2, 3, 4];
x[0];
x[3];
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#out_of_bounds_indexing">out_of_bounds_indexing</a></td><td>yes</td><td>no</td><td><strong>correctness</strong></td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtyparr03--当数组元素为原生数据类型primitive排序时优先选用非稳定排序"><a class="header" href="#gtyparr03--当数组元素为原生数据类型primitive排序时优先选用非稳定排序">G.TYP.ARR.03  当数组元素为原生数据类型（Primitive），排序时优先选用非稳定排序</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>稳定排序会消耗更多的内存和 CPU 周期，相对而言，非稳定排序性能更佳。</p>
<p>当然，在必须要稳定排序的场合，不应该使用非稳定排序。</p>
<p>注： <code>Vec&lt;T&gt;</code> 动态数组也适用此规则</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vec = vec![2, 1, 3];
vec.sort();  // stable sort
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vec = vec![2, 1, 3];
vec.sort_unstable(); // unstable sort
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// https://docs.rs/crate/solana-runtime/1.7.11/source/src/accounts_db.rs#:~:text=clippy%3a%3astable_sort_primitive
 pub fn generate_index(&amp;self, limit_load_slot_count_from_snapshot: Option&lt;usize&gt;) {
        let mut slots = self.storage.all_slots();
        #[allow(clippy::stable_sort_primitive)]
        slots.sort(); // The business requirement here is to use stable sort 
        // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#stable_sort_primitive">stable_sort_primitive</a></td><td>yes</td><td>no</td><td><strong>perf</strong></td><td>warn</td></tr>
</tbody></table>
<p>当确实需要稳定排序时，需要修改该 lint 的设置为 <code>allow</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="动态数组"><a class="header" href="#动态数组">动态数组</a></h1>
<p>这里指可以动态增长的数组<code>Vec&lt;T&gt;</code>。</p>
<p>在数组一节中有<a href="safe-guides/coding_practice/data-type/./array.html">部分原则和规则</a>也适用于这里。</p>
<h2 id="列表-14"><a class="header" href="#列表-14">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/data-type/./vec/P.TYP.VEC.01.html">P.TYP.VEC.01 非必要时不宜使用动态数组</a></li>
<li><a href="safe-guides/coding_practice/data-type/./vec/P.TYP.VEC.02.html">P.TYP.VEC.02 创建动态数组时，宜预先分配足够容量，避免后续操作中产生多次分配</a></li>
<li><a href="safe-guides/coding_practice/data-type/./vec/G.TYP.VEC.01.html">G.TYP.VEC.01 禁止访问未初始化的数组</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ptypvec01"><a class="header" href="#ptypvec01">P.TYP.VEC.01</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ptypvec02"><a class="header" href="#ptypvec02">P.TYP.VEC.02</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypvec01"><a class="header" href="#gtypvec01">G.TYP.VEC.01</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体"><a class="header" href="#结构体">结构体</a></h1>
<p>Rust 包含了三种结构体： 命名结构体、元组结构体、单元结构体。</p>
<h2 id="列表-15"><a class="header" href="#列表-15">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/data-type/./struct/P.TYP.SCT.01.html">P.TYP.SCT.01 为结构体实现构造性方法时，避免构造后再初始化的情况</a></li>
<li><a href="safe-guides/coding_practice/data-type/./struct/P.TYP.SCT.02.html">P.TYP.SCT.02 结构体实例需要默认实现时，宜使用Default特质</a></li>
<li><a href="safe-guides/coding_practice/data-type/./struct/G.TYP.SCT.01.html">G.TYP.SCT.01 对外导出的公开的 Struct，宜添加<code>#[non_exhaustive]</code>属性</a></li>
<li><a href="safe-guides/coding_practice/data-type/./struct/G.TYP.SCT.02.html">G.TYP.SCT.02 当结构体中有超过三个布尔类型的字段，宜将其独立为一个枚举</a></li>
<li><a href="safe-guides/coding_practice/data-type/./struct/G.TYP.SCT.03.html">G.TYP.SCT.03 宜使用结构体功能更新语法来提升代码可读性</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptypsct01-为结构体实现构造性方法时避免构造后再初始化的情况"><a class="header" href="#ptypsct01-为结构体实现构造性方法时避免构造后再初始化的情况">P.TYP.SCT.01 为结构体实现构造性方法时，避免构造后再初始化的情况</a></h2>
<p><strong>【描述】</strong></p>
<p>跟其他OOP 或 FP 语言不一样， Rust 的惯用方式是构建即初始化。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 先构建
let mut dict = Dictionary::new();
// 后初始化
dict.load_from_file(&quot;./words.txt&quot;)?;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 构建即初始化
let dict = Dictionary::from_file(&quot;./words.txt&quot;)?;

impl Dictionary {
  fn from_file(filename: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Self, Error&gt; {
    let text = std::fs::read_to_string(filename)?;
    // 不会去存储空状态
    let mut words = Vec::new();
    for line in text.lines() {
      words.push(line);
    }
    Ok(Dictionary { words })
  }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptypsct02--结构体实例需要默认实现时宜使用default特质"><a class="header" href="#ptypsct02--结构体实例需要默认实现时宜使用default特质">P.TYP.SCT.02  结构体实例需要默认实现时，宜使用<code>Default</code>特质</a></h2>
<p><strong>【描述】</strong></p>
<p>为结构体实现 <code>Default</code> 对于简化代码提高可读性很有帮助。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::{path::PathBuf, time::Duration};

// note that we can simply auto-derive Default here.
#[derive(Default, Debug, PartialEq)]
struct MyConfiguration {
    // Option defaults to None
    output: Option&lt;PathBuf&gt;,
    // Vecs default to empty vector
    search_path: Vec&lt;PathBuf&gt;,
    // Duration defaults to zero time
    timeout: Duration,
    // bool defaults to false
    check: bool,
}

impl MyConfiguration {
    // add setters here
}

fn main() {
    // construct a new instance with default values
    let mut conf = MyConfiguration::default();
    // do something with conf here
    conf.check = true;
    println!(&quot;conf = {:#?}&quot;, conf);
        
    // partial initialization with default values, creates the same instance
    let conf1 = MyConfiguration {
        check: true,
        ..Default::default()
    };
    assert_eq!(conf, conf1);
}
</code></pre></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypsct01-对外导出的公开的-struct宜添加non_exhaustive属性"><a class="header" href="#gtypsct01-对外导出的公开的-struct宜添加non_exhaustive属性">G.TYP.SCT.01 对外导出的公开的 Struct，宜添加<code>#[non_exhaustive]</code>属性</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>作为对外公开的 结构体，为了保持稳定性，应该使用 <code>#[non_exhaustive]</code>属性，避免因为将来结构体字段发生变化而影响到下游的使用。主要涉及命名结构体和元组结构体。</p>
<p><strong>【反例】</strong></p>
<p>在 <code>#[non_exhaustive]</code> 属性稳定之前，社区内还有一种约定俗成的写法来达到防止下游自定义枚举方法。通过 <code>manual_non_exhaustive</code> 可以监控这类写法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S {
    pub a: i32,
    pub b: i32,
    _priv: (),  // 这里用 下划线作为前缀定义的字段，作为私有字段，不对外公开
}

// 用户无法自定义实现该结构体的方法。
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
struct Foo {
    bar: u8,
    baz: String,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>也有例外情况！</p>
<p>从语义角度看，<code>#[non_exhaustive]</code> 只是代表未穷尽的字段或枚举变体，是为了表达“未来可能有变化”这种语义。</p>
<p>但是当要表达 “这个结构体不允许对方实例化” 的语义时，通过自定义的 <code>_priv</code>字段就可以更好地表达这个语义。</p>
<p>而使用 <code>#[non_exhaustive]</code> 虽然也能达到 “不允许对方实例化的目的”，但是在代码可读性层面，却无法表达出这个语义。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://github.com/tokio-rs/tokio/blob/master/tokio-util/src/codec/framed.rs

#[allow(clippy::manual_non_exhaustive)]
pub struct FramedParts&lt;T, U&gt; {
    pub io: T,
    pub codec: U,
    pub read_buf: BytesMut,
    pub write_buf: BytesMut,
    
    /// This private field allows us to add additional fields in the future in a
    /// backwards compatible way.
    _priv: (),
}

impl&lt;T, U&gt; FramedParts&lt;T, U&gt; {
    /// Create a new, default, `FramedParts`
    pub fn new&lt;I&gt;(io: T, codec: U) -&gt; FramedParts&lt;T, U&gt;
    where
        U: Encoder&lt;I&gt;,
    {
        FramedParts {
            io,
            codec,
            read_buf: BytesMut::new(),
            write_buf: BytesMut::new(),
            _priv: (),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#exhaustive_structs">exhaustive_structs</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#manual_non_exhaustive">manual_non_exhaustive</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypsct02--当结构体中有超过三个布尔类型的字段宜将其独立为新的枚举类"><a class="header" href="#gtypsct02--当结构体中有超过三个布尔类型的字段宜将其独立为新的枚举类">G.TYP.SCT.02  当结构体中有超过三个布尔类型的字段，宜将其独立为新的枚举类</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>这样有助于提升 代码可读性和 API 。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S {
    is_pending: bool,
    is_processing: bool,
    is_finished: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum S {
    Pending,
    Processing,
    Finished,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#struct_excessive_bools">struct_excessive_bools</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 用于配置函数可以拥有的 bool 类型参数最大数量，默认为 3。
max-struct-bools=3 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypsct03-宜使用结构体功能更新语法来提升代码可读性"><a class="header" href="#gtypsct03-宜使用结构体功能更新语法来提升代码可读性">G.TYP.SCT.03 宜使用结构体功能更新语法来提升代码可读性</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>更改结构体最好提供结构体方法进行更改，而不是直接构建结构体内容。</p>
<p>但是需要多次修改结构体内容的时候，宜使用结构体更新语法来提升代码可读性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a: A = Default::default();
a.i = 42;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = A {
    i: 42,
    .. Default::default()
};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#field_reassign_with_default">field_reassign_with_default</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举体"><a class="header" href="#枚举体">枚举体</a></h1>
<p>Rust 的枚举是一种带 Tag 的联合体。 一般分为三类：空枚举、无字段（fieldless）枚举和数据承载（data carrying）枚举。</p>
<h2 id="列表-16"><a class="header" href="#列表-16">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/data-type/./enum/G.TYP.ENM.01.html">G.TYP.ENM.01 合理选择<code>map</code>和<code>and_then</code></a></li>
<li><a href="safe-guides/coding_practice/data-type/./enum/G.TYP.ENM.02.html">G.TYP.ENM.02 非必要时不应自行创建空枚举</a></li>
<li><a href="safe-guides/coding_practice/data-type/./enum/G.TYP.ENM.03.html">G.TYP.ENM.03 在使用类似 C 语言的枚举写法且使用<code>repr(isize/usize)</code> 布局时注意 32位架构上截断的问题</a></li>
<li><a href="safe-guides/coding_practice/data-type/./enum/G.TYP.ENM.04.html">G.TYP.ENM.04 不宜在<code>use</code>语句中引入Enum的全部变体（variants）</a></li>
<li><a href="safe-guides/coding_practice/data-type/./enum/G.TYP.ENM.05.html">G.TYP.ENM.05 对外导出的公开Enum，宜添加<code>#[non_exhaustive]</code>属性</a></li>
<li><a href="safe-guides/coding_practice/data-type/./enum/G.TYP.ENM.06.html">G.TYP.ENM.06 Enum内变体的大小差异不宜过大</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypenm01-合理使用map和and_then方法"><a class="header" href="#gtypenm01-合理使用map和and_then方法">G.TYP.ENM.01 合理使用<code>map</code>和<code>and_then</code>方法</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在标准库中内置的一些 Enum 类型中提供了一些方便的组合算子，比如 <code>map</code> 和 <code>and_then</code>。</p>
<ul>
<li><code>map</code> ，函数签名是 <code>fn map&lt;U, F&gt;(self, f: F) -&gt; Option&lt;U&gt; where F: FnOnce(T) -&gt; U</code> 。</li>
<li><code>and_then</code> ，函数签名是 <code>fn and_then&lt;U, F&gt;(self, f: F) -&gt; Option&lt;U&gt; where F: FnOnce(T) -&gt; U</code> 。</li>
</ul>
<p><code>Result</code> 中实现的 <code>map/and_then</code> 函数签名也和 <code>Option</code> 一致。这两个方法之间的区别在于传入的闭包参数的返回值类型不同。</p>
<p>这意味着：</p>
<ul>
<li>当你通过 <code>F</code> 对 <code>U</code> 进行 <code>map</code> 转换的时候，意味着这个转换是一定会成功的。</li>
<li>当你通过 <code>F</code> 对 <code>U</code> 进行 <code>map</code> 转换的时候，意味着这个转换是不一定会成功的，需要在 <code>F</code> 调用之后对其结果 <code>Option&lt;U&gt;/Result&lt;U&gt;</code> 进行处理。</li>
</ul>
<p>在合适的场景中选择合适的组合算子，可以让代码更加简洁，提升可读性和可维护性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn opt() -&gt; Option&lt;&amp;'static str&gt; { Some(&quot;42&quot;) }
</span><span class="boring">fn res() -&gt; Result&lt;&amp;'static str, &amp;'static str&gt; { Ok(&quot;42&quot;) }
</span>let _ = opt().and_then(|s| Some(s.len()));
let _ = res().and_then(|s| if s.len() == 42 { Ok(10) } else { Ok(20) });
let _ = res().or_else(|s| if s.len() == 42 { Err(10) } else { Err(20) });

<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>像这种简单的一定会成功的情况，应该使用 <code>map</code>，否则使用<code>and_then</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn opt() -&gt; Option&lt;&amp;'static str&gt; { Some(&quot;42&quot;) }
</span><span class="boring">fn res() -&gt; Result&lt;&amp;'static str, &amp;'static str&gt; { Ok(&quot;42&quot;) }
</span>let _ = opt().map(|s| s.len());
let _ = res().map(|s| if s.len() == 42 { 10 } else { 20 });
let _ = res().map_err(|s| if s.len() == 42 { 10 } else { 20 });
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#bind_instead_of_map">bind_instead_of_map </a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypenm02-不应自行创建空枚举"><a class="header" href="#gtypenm02-不应自行创建空枚举">G.TYP.ENM.02 不应自行创建空枚举</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在 Rust 中 只有 <code>never</code> 类型（<code>!</code>）才是唯一合法表达 无法被实例化类型 的类型。但目前 <code>never</code> 类型还未稳定，只能在 Nightly 下使用。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Test {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>所以，如果想在稳定版 Rust 中使用，建议使用<a href="https://doc.rust-lang.org/std/convert/enum.Infallible.html#"><code>std::convert::Infallible</code></a> 。 <code>Infallible</code> 枚举是一个合法的空枚举，常用于错误处理中，表示永远不可能出现的错误。但是目前也可以用于在稳定版中替代  <code>never</code>   类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 未来 never 类型稳定的话，将会把 Infallible 设置为 never 类型的别名
pub type Infallible = !;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>因为 <a href="https://doc.rust-lang.org/std/convert/enum.Infallible.html#"><code>std::convert::Infallible</code></a> 默认实现了很多 trait，如果不想依赖其他 trait ，那么可以用 空枚举。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum NoUserError {}

impl Display for NoUserError {
    fn fmt(&amp;self, _formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {}
    }
}

<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#empty_enum">empty_enum</a></td><td>yes</td><td>no</td><td><strong>pedantic</strong></td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypenm03--在使用类似-c-语言的枚举写法且使用reprisizeusize-布局时注意-32位架构上截断的问题"><a class="header" href="#gtypenm03--在使用类似-c-语言的枚举写法且使用reprisizeusize-布局时注意-32位架构上截断的问题">G.TYP.ENM.03  在使用类似 C 语言的枚举写法且使用<code>repr(isize/usize)</code> 布局时注意 32位架构上截断的问题</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在使用类似 C 语言的枚举写法且使用<code>repr(isize/usize)</code> 布局时，在32位架构上会截断变体值，但在64位上工作正常。</p>
<p>但是没有这种风险的时候，可以正常使用。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_pointer_width = &quot;64&quot;)]
#[repr(usize)]
enum NonPortable {
    X = 0x1_0000_0000,
    Y = 0,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>因为当前 lint 默认是<code> deny</code>，所以需要将其配置为 <code>allow</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![allow(clippy::enum_clike_unportable_variant)]

<span class="boring">fn main() {
</span>#[repr(isize)]
pub enum ZBarColor {
    ZBarSpace = 0,
    ZBarBar   = 1,
}

// 或者，没有指定 repr(isize/usize)

#[allow(clippy::enum_clike_unportable_variant)]
pub(crate) enum PropertyType {
    ActionItemSchemaVersion = 0x0C003473,
    ActionItemStatus = 0x10003470,
    ActionItemType = 0x10003463,
    Author = 0x1C001D75,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#enum_clike_unportable_variant">enum_clike_unportable_variant</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypenm04-不宜在use语句中引入enum的全部变体variants"><a class="header" href="#gtypenm04-不宜在use语句中引入enum的全部变体variants">G.TYP.ENM.04 不宜在<code>use</code>语句中引入Enum的全部变体（variants）</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>使用 Enum 的类型前缀可以使代码更加可读。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering::*; // 这里导入了全部变体
foo(Less);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;
foo(Ordering::Less)
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>当枚举体非常多的时候，比如 <a href="https://docs.rs/glutin/0.27.0/glutin/event/enum.VirtualKeyCode.html"> glutin::event::VirtualKeyCode</a> 这类对应键盘按键的枚举，并且上下文比较明确，都是在处理和 Key 相关的内容时，可以直接全部导入。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From:  https://github.com/alacritty/alacritty/blob/master/alacritty/src/config/bindings.rs#L368
#![allow(clippy::enum_glob_use)]

pub fn default_key_bindings() -&gt; Vec&lt;KeyBinding&gt; {
    let mut bindings = bindings!(
        KeyBinding;
        Copy;  Action::Copy;
        Copy,  +BindingMode::VI; Action::ClearSelection;
        Paste, ~BindingMode::VI; Action::Paste;
        L, ModifiersState::CTRL; Action::ClearLogNotice;
        L,    ModifiersState::CTRL,  ~BindingMode::VI, ~BindingMode::SEARCH;
            Action::Esc(&quot;\x0c&quot;.into());
        Tab,  ModifiersState::SHIFT, ~BindingMode::VI, ~BindingMode::SEARCH;
            Action::Esc(&quot;\x1b[Z&quot;.into());
        // ...
    }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#enum_glob_use">enum_glob_use</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypenm05-对外导出的公开enum宜添加non_exhaustive属性"><a class="header" href="#gtypenm05-对外导出的公开enum宜添加non_exhaustive属性">G.TYP.ENM.05 对外导出的公开Enum，宜添加<code>#[non_exhaustive]</code>属性</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>作为对外公开的 Enum，为了保持稳定性，应该使用 <code>#[non_exhaustive]</code>属性，避免因为将来Enum 枚举变体的变化而影响到下游的使用。</p>
<p><strong>【反例】</strong></p>
<p>在 <code>#[non_exhaustive]</code> 属性稳定之前，社区内还有一种约定俗成的写法来达到防止下游自定义枚举方法。通过 <code>manual_non_exhaustive</code> 可以监控这类写法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum E {
    A,
    B,
    #[doc(hidden)]
    _C, // 这里用 下划线作为前缀定义的变体，作为隐藏的变体，不对外展示
}
// 用户无法自定义实现该 枚举的方法，达到一种稳定公开枚举的目的。
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
enum E {
    A,
    B,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#exhaustive_enums">exhaustive_enums</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#manual_non_exhaustive">manual_non_exhaustive</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypenm06--enum内变体的大小差异不宜过大"><a class="header" href="#gtypenm06--enum内变体的大小差异不宜过大">G.TYP.ENM.06  Enum内变体的大小差异不宜过大</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>要注意 Enum 内变体的大小差异不要过大，因为 Enum 内存布局是以最大的变体进行对齐。根据场景，如果该Enum 实例中小尺寸变体的实例使用很多的话，内存就会有所浪费。如果小尺寸变体的实例使用很少，则影响不大。</p>
<p>解决办法之一为把大尺寸变体包含到 <code>Box&lt;T&gt;</code>中。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Test {
    A(i32),
    B([i32; 1000]),
    C([i32; 8000]),
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Test {
    A(i32),
    B(Box&lt;[i32; 1000]&gt;),
    C(Box&lt;[i32; 8000]&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#large_enum_variant">large_enum_variant</a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
</tbody></table>
<p>该 lint 可以通过 clippy 配置项 <code>enum-variant-size-threshold = 200</code> 来配置，默认是 <code>200</code> 字节。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="35-表达式"><a class="header" href="#35-表达式">3.5 表达式</a></h1>
<p>Rust 中几乎一切皆表达式。</p>
<h2 id="列表-17"><a class="header" href="#列表-17">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./expr/G.EXP.01.html">G.EXP.01 当需要对表达式求值之后重新赋值时，宜使用复合赋值模式</a></li>
<li><a href="safe-guides/coding_practice/./expr/G.EXP.02.html">G.EXP.02 不宜在比较中使用不兼容的位掩码</a></li>
<li><a href="safe-guides/coding_practice/./expr/G.EXP.03.html">G.EXP.03 不要利用数组表达式的边界检查来 Panic，而应该用断言</a></li>
<li><a href="safe-guides/coding_practice/./expr/G.EXP.04.html">G.EXP.04 自增/自减运算使用 <code>+=/-=</code></a></li>
<li><a href="safe-guides/coding_practice/./expr/G.EXP.05.html">G.EXP.05 表达式操作最好使用括号来表达清楚优先级顺序</a></li>
<li><a href="safe-guides/coding_practice/./expr/G.EXP.06.html">G.EXP.06 避免在比较中添加无用的掩码操作</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gexp01-当需要对表达式求值后重新赋值时宜使用复合赋值模式"><a class="header" href="#gexp01-当需要对表达式求值后重新赋值时宜使用复合赋值模式">G.EXP.01 当需要对表达式求值后重新赋值时，宜使用复合赋值模式</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>略</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 5;
let b = 0;
a = a + b;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 5;
let b = 0;
a += b;
<span class="boring">}
</span></code></pre></pre>
<p>【Lint 检测】</p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#assign_op_pattern">assign_op_pattern</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gexp02--不宜在比较中使用不兼容的位掩码"><a class="header" href="#gexp02--不宜在比较中使用不兼容的位掩码">G.EXP.02  不宜在比较中使用不兼容的位掩码</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>可以对照下面表格进行检查。</p>
<table><thead><tr><th>Comparison</th><th>Bit Op</th><th>Example</th><th>is always</th><th>Formula</th></tr></thead><tbody>
<tr><td>== or !=</td><td>&amp;</td><td>x &amp; 2 == 3</td><td>false</td><td>c &amp; m != c</td></tr>
<tr><td>&lt; or &gt;=</td><td>&amp;</td><td>x &amp; 2 &lt; 3</td><td>true</td><td>m &lt; c</td></tr>
<tr><td>&gt; or &lt;=</td><td>&amp;</td><td>x &amp; 1 &gt; 1</td><td>false</td><td>m &lt;= c</td></tr>
<tr><td>== or !=</td><td>|</td><td>x | 1 == 0</td><td>false</td><td>c | m != c</td></tr>
<tr><td>&lt; or &gt;=</td><td>|</td><td>x | 1 &lt; 1</td><td>false</td><td>m &gt;= c</td></tr>
<tr><td>&lt;= or &gt;</td><td>|</td><td>x | 1 &gt; 0</td><td>true</td><td>m &gt; c</td></tr>
</tbody></table>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if (x &amp; 1 == 2) { }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#bad_bit_mask">bad_bit_mask</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gexp03-不应利用数组表达式的边界检查来-panic而应使用断言"><a class="header" href="#gexp03-不应利用数组表达式的边界检查来-panic而应使用断言">G.EXP.03 不应利用数组表达式的边界检查来 Panic，而应使用断言</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>这样会影响代码可读性。使用断言可以更好的描述代码的意图。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main(){
    [42, 55][get_usize()];
    compute_array()[0];
}

fn get_usize() -&gt; usize {
   6
}


fn compute_array() -&gt; [i32; 3] {
   [1,2,3]
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main(){
    assert!([42, 55].len() &gt; get_usize());
    assert!(compute_array().len() &gt; 0);
}

fn get_usize() -&gt; usize {
   6
}

fn compute_array() -&gt; [i32; 3] {
   [1,2,3]
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#unnecessary_operation">unnecessary_operation</a></td><td>yes</td><td>no</td><td><strong>complexity</strong></td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gexp04-自增自减运算使用--"><a class="header" href="#gexp04-自增自减运算使用--">G.EXP.04 自增/自减运算使用 <code>+=</code>/<code>-=</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>C/Cpp 等编程语言常用的自增自减操作，如 <code>++i</code> 、<code>i++</code> 、<code>i--</code> 等不是合法的 Rust 表达式， <code>--i</code> 虽然是合法的 Rust 表达式，但是表达对i取反两次，而不是自减语义。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 3;
--x; // x == 3
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 3;
x -= 1; // x == 2
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#double_neg">double_neg</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gexp05-使用括号来清楚表示表达式的计算顺序"><a class="header" href="#gexp05-使用括号来清楚表示表达式的计算顺序">G.EXP.05 使用括号来清楚表示表达式的计算顺序</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>并不是每个人都能记得住优先级，所以最好使用括号把优先级顺序区分出来，增加可读性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>1 &lt;&lt; 2 + 3
-1i32.abs()
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(1 &lt;&lt; 2) + 3
(-1i32).abs()
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#precedence">precedence</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gexp06-避免在比较中添加无用的掩码操作"><a class="header" href="#gexp06-避免在比较中添加无用的掩码操作">G.EXP.06 避免在比较中添加无用的掩码操作</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>检查比较中的无用位掩码操作，可以在不改变结果的情况下删除该位掩码操作。</p>
<p>请对照下面表格进行检查。</p>
<table><thead><tr><th>Comparison</th><th>Bit Op</th><th>Example</th><th>equals</th></tr></thead><tbody>
<tr><td>&gt; / &lt;=</td><td>| / ^</td><td>x | 2 &gt; 3</td><td>x &gt; 3</td></tr>
<tr><td>&lt; / &gt;=</td><td>| / ^</td><td>x ^ 1 &lt; 4</td><td>x &lt; 4</td></tr>
</tbody></table>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if (x | 1 &gt; 3) {  }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if (x &gt; 3) {  }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#ineffective_bit_mask">ineffective_bit_mask</a></td><td>yes</td><td>no</td><td>correctness</td><td><strong>deny</strong></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="36-控制流程"><a class="header" href="#36-控制流程">3.6 控制流程</a></h1>
<p>Rust中流程控制也是属于表达式，但在本规范中将其独立出来。</p>
<h2 id="列表-18"><a class="header" href="#列表-18">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./control-flow/P.CTF.01.html">P.CTF.01 不要过度使用迭代器</a></li>
<li><a href="safe-guides/coding_practice/./control-flow/P.CTF.02.html">P.CTF.02 优先使用模式匹配而不是判断后再取值</a></li>
<li><a href="safe-guides/coding_practice/./control-flow/G.CTF.01.html">G.CTF.01 当需要通过多个if判断来比较大小来区分不同情况时，优先使用match和cmp来代替if表达式</a></li>
<li><a href="safe-guides/coding_practice/./control-flow/G.CTF.02.html">G.CTF.02 if条件表达式分支中如果包含了else if分支也应该包含else分支</a></li>
<li><a href="safe-guides/coding_practice/./control-flow/G.CTF.03.html">G.CTF.03 如果要通过 if 条件表达式来判断是否panic，请优先使用断言</a></li>
<li><a href="safe-guides/coding_practice/./control-flow/G.CTF.04.html">G.CTF.04 在Match分支的Guard语句中不要使用带有副作用的条件表达式</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pctf01-避免滥用迭代器"><a class="header" href="#pctf01-避免滥用迭代器">P.CTF.01 避免滥用迭代器</a></h2>
<p><strong>【描述】</strong></p>
<p>迭代器虽然是 Rust 中比较推崇的方式，但也没必要过度使用它。总之，如果使用迭代器让代码太复杂，就考虑换个非迭代器的方式实现吧。</p>
<p><strong>【反例】</strong></p>
<p>创建一个 Matrix变换的函数，但是这种迭代器的方式，代码可读性相比于命令式更困难。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From : https://adventures.michaelfbryan.com/posts/rust-best-practices/bad-habits/#overusing-iterators
pub fn functional_blur(input: &amp;Matrix) -&gt; Matrix {
    assert!(input.width &gt;= 3);
    assert!(input.height &gt;= 3);

    // Stash away the top and bottom rows so they can be
    // directly copied across later
    let mut rows = input.rows();
    let first_row = rows.next().unwrap();
    let last_row = rows.next_back().unwrap();

    let top_row = input.rows();
    let middle_row = input.rows().skip(1);
    let bottom_row = input.rows().skip(2);

    let blurred_elements = top_row
        .zip(middle_row)
        .zip(bottom_row)
        .flat_map(|((top, middle), bottom)| blur_rows(top, middle, bottom));

    let elements: Vec&lt;f32&gt; = first_row
        .iter()
        .copied()
        .chain(blurred_elements)
        .chain(last_row.iter().copied())
        .collect();

    Matrix::new_row_major(elements, input.width, input.height)
}

fn blur_rows&lt;'a&gt;(
    top_row: &amp;'a [f32],
    middle_row: &amp;'a [f32],
    bottom_row: &amp;'a [f32],
) -&gt; impl Iterator&lt;Item = f32&gt; + 'a {
    // stash away the left-most and right-most elements so they can be copied across directly.
    let &amp;first = middle_row.first().unwrap();
    let &amp;last = middle_row.last().unwrap();

    // Get the top, middle, and bottom row of our 3x3 sub-matrix so they can be
    // averaged.
    let top_window = top_row.windows(3);
    let middle_window = middle_row.windows(3);
    let bottom_window = bottom_row.windows(3);

    // slide the 3x3 window across our middle row so we can get the average
    // of everything except the left-most and right-most elements.
    let averages = top_window
        .zip(middle_window)
        .zip(bottom_window)
        .map(|((top, middle), bottom)| top.iter().chain(middle).chain(bottom).sum::&lt;f32&gt;() / 9.0);

    std::iter::once(first)
        .chain(averages)
        .chain(std::iter::once(last))
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>创建一个 Matrix变换的函数，使用命令式风格，代码功能比较明确，更加直观。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://adventures.michaelfbryan.com/posts/rust-best-practices/bad-habits/#overusing-iterators
pub fn imperative_blur(input: &amp;Matrix) -&gt; Matrix {
    assert!(input.width &gt;= 3);
    assert!(input.height &gt;= 3);

    // allocate our output matrix, copying from the input so
    // we don't need to worry about the edge cases.
    let mut output = input.clone();

    for y in 1..(input.height - 1) {
        for x in 1..(input.width - 1) {
            let mut pixel_value = 0.0;

            pixel_value += input[[x - 1, y - 1]];
            pixel_value += input[[x, y - 1]];
            pixel_value += input[[x + 1, y - 1]];

            pixel_value += input[[x - 1, y]];
            pixel_value += input[[x, y]];
            pixel_value += input[[x + 1, y]];

            pixel_value += input[[x - 1, y + 1]];
            pixel_value += input[[x, y + 1]];
            pixel_value += input[[x + 1, y + 1]];

            output[[x, y]] = pixel_value / 9.0;
        }
    }

    output
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pctf02-优先使用模式匹配而非判断后再取值"><a class="header" href="#pctf02-优先使用模式匹配而非判断后再取值">P.CTF.02 优先使用模式匹配而非判断后再取值</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 中 模式匹配 是惯用法，而不是通过 <code>if</code> 判断值是否相等。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let opt: Option&lt;_&gt; = ...;

if opt.is_some() {
  let value = opt.unwrap();
  ...
}

// or
let list: &amp;[f32] = ...;

if !list.is_empty() {
  let first = list[0];
  ...
}

<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(value) = opt {
  ...
}
// or
if let [first, ..] = list {
  ...
}
<span class="boring">}
</span></code></pre></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="gctf01-当需要通过多个if判断来比较大小来区分不同情况时优先使用match和cmp来代替if表达式"><a class="header" href="#gctf01-当需要通过多个if判断来比较大小来区分不同情况时优先使用match和cmp来代替if表达式">G.CTF.01 当需要通过多个<code>if</code>判断来比较大小来区分不同情况时，优先使用<code>match</code>和<code>cmp</code>来代替<code>if</code>表达式</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在使用多个<code>if-else</code>来对不同情况进行区分时，使用 <code>match</code> 和 <code>cmp</code> 代替 <code>if</code> 的好处是语义更加明确，而且也能帮助开发者穷尽所有可能性。
但是这里需要注意这里使用 <code>match</code> 和 <code>cmp</code> 的性能要低于 <code>if</code>表达式，因为 一般的 <code>&gt;</code> 或 <code>&lt;</code> 等比较操作是内联的，而 <code>cmp</code>方法没有内联。</p>
<p>根据实际情况来选择是否设置 <code>comparison_chain</code> 为 <code>allow</code>。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn a() {}
</span><span class="boring">fn b() {}
</span><span class="boring">fn c() {}
</span>fn f(x: u8, y: u8) {
    if x &gt; y {
        a()
    } else if x &lt; y {
        b()
    } else {
        c()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;
<span class="boring">fn a() {}
</span><span class="boring">fn b() {}
</span><span class="boring">fn c() {}
</span>fn f(x: u8, y: u8) {
     match x.cmp(&amp;y) {
         Ordering::Greater =&gt; a(),
         Ordering::Less =&gt; b(),
         Ordering::Equal =&gt; c()
     }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#comparison_chain">comparison_chain</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gctf02-if条件表达式分支中如果包含了else-if分支也应该包含else分支"><a class="header" href="#gctf02-if条件表达式分支中如果包含了else-if分支也应该包含else分支">G.CTF.02 <code>if</code>条件表达式分支中如果包含了<code>else if</code>分支也应该包含<code>else</code>分支</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>略</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn a() {}
</span><span class="boring">fn b() {}
</span><span class="boring">let x: i32 = 1;
</span>if x.is_positive() {
    a();
} else if x.is_negative() {
    b();
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn a() {}
</span><span class="boring">fn b() {}
</span><span class="boring">let x: i32 = 1;
</span>if x.is_positive() {
    a();
} else if x.is_negative() {
    b();
} else {
    // We don't care about zero.
}
<span class="boring">}
</span></code></pre></pre>
<p>【Lint 检测】**</p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#else_if_without_else">else_if_without_else</a></td><td>yes</td><td>no</td><td><strong>restriction</strong></td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gctf03-如果要通过-if-条件表达式来判断是否panic请优先使用断言"><a class="header" href="#gctf03-如果要通过-if-条件表达式来判断是否panic请优先使用断言">G.CTF.03 如果要通过 <code>if</code> 条件表达式来判断是否panic，请优先使用断言</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>略</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sad_people: Vec&lt;&amp;str&gt; = vec![];
if !sad_people.is_empty() {
    panic!(&quot;there are sad people: {:?}&quot;, sad_people);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sad_people: Vec&lt;&amp;str&gt; = vec![];
assert!(sad_people.is_empty(), &quot;there are sad people: {:?}&quot;, sad_people);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#if_then_panic">if_then_panic</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gctf04-在match分支的guard语句中不要使用带有副作用的条件表达式"><a class="header" href="#gctf04-在match分支的guard语句中不要使用带有副作用的条件表达式">G.CTF.04 在Match分支的Guard语句中不要使用带有副作用的条件表达式</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>因为在 mactch 分支中， 匹配几次就会执行 Guard 几次。如果携带副作用，会产生意料之外的情况。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 下面代码会输出两次 &quot;ha&quot;
fn main() {
    use std::cell::Cell;
    let i: Cell&lt;i32&gt; = Cell::new(0);
    match 1 {
        1 | _  // 这里匹配两次
            if { // 这个 Guard 条件表达式带有副作用：打印，因为匹配两次，所以会执行两次
                println!(&quot;ha&quot;);
                i.set(i.get() + 1);
                false
            } =&gt; {}
        _ =&gt; {}
    }
    assert_eq!(i.get(), 2);
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p><strong>【定制化参考】</strong></p>
<p>可以检测 match分支中 Guard 的 if 表达式是否使用 <code>{}</code> ，如果是的话，发出警告，不要带有副作用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="37-字符串"><a class="header" href="#37-字符串">3.7 字符串</a></h1>
<p>Rust 中字符串是有效的 UTF-8 编码的字节数组。</p>
<p>Rust 字符串类型众多，但本节内容主要围绕 ：<code>String</code> / <code>&amp;str</code></p>
<h2 id="列表-19"><a class="header" href="#列表-19">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./strings/P.STR.01.html">P.STR.01 处理字符串非必要不要按字符来处理，应该按字节处理</a></li>
<li><a href="safe-guides/coding_practice/./strings/P.STR.02.html">P.STR.02 创建字符串时，可以预先分配大约足够的容量来避免后续操作中产生多次分配</a></li>
<li><a href="safe-guides/coding_practice/./strings/P.STR.03.html">P.STR.03 在使用内建字符串处理函数或方法的时候，应该注意避免隐藏的嵌套迭代或多次迭代</a></li>
<li><a href="safe-guides/coding_practice/./strings/P.STR.04.html">P.STR.04 只有在合适的场景下，才使用第三方库正则表达式regex</a></li>
<li><a href="safe-guides/coding_practice/./strings/P.STR.05.html">P.STR.05 在拼接字符串时，建议使用format!</a></li>
<li><a href="safe-guides/coding_practice/./strings/G.STR.01.html">G.STR.01 在实现Display特质时不要调用to_string()方法</a></li>
<li><a href="safe-guides/coding_practice/./strings/G.STR.02.html">G.STR.02 在追加字符串时使用push_str方法可读性更强</a></li>
<li><a href="safe-guides/coding_practice/./strings/G.STR.03.html">G.STR.03 将只包含 ASCII字符的字符串字面量转为字节序列可以直接使用b&quot;str&quot; 语法代替调用as_bytes方法</a></li>
<li><a href="safe-guides/coding_practice/./strings/G.STR.04.html">G.STR.04 需要判断字符串以哪个字符开头或结尾时，不要按字符迭代比较</a></li>
<li><a href="safe-guides/coding_practice/./strings/G.STR.05.html">G.STR.05 对字符串按指定位置进行切片的时候需要小心破坏其 UTF-8 编码</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pstr01---处理字符串元素时优先按字节处理而非字符"><a class="header" href="#pstr01---处理字符串元素时优先按字节处理而非字符">P.STR.01   处理字符串元素时优先按字节处理而非字符</a></h2>
<p><strong>【描述】</strong></p>
<p>处理字符串有两种方式，一种是按字符处理，即把字符串转为字符数组<code>[char]</code>，另一种是直接按字节处理<code>[u8]</code>。</p>
<p>两者之间的一些区别：</p>
<ul>
<li><code>[char]</code>  保证是有效的 Unicode，但不一定是有效的 UTF-8，一般将其看作是 UTF-32 。将字符数组转换为字符串需要注意。</li>
<li><code>[u8]</code> 不一定是有效的字符串，它比 <code>[char]</code> 节省内存。将其转换为字符串需要检查 <code>UTF-8</code>编码。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pstr02---创建字符串时宜预先分配大约足够的容量来避免后续操作中产生多次分配"><a class="header" href="#pstr02---创建字符串时宜预先分配大约足够的容量来避免后续操作中产生多次分配">P.STR.02   创建字符串时，宜预先分配大约足够的容量来避免后续操作中产生多次分配</a></h2>
<p><strong>【描述】</strong></p>
<p>预分配足够的容量，避免后续内存分配，可以提升代码性能。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut output = String::new();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut output = String::with_capacity(input.len());
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pstr03-在使用内建字符串处理函数或方法的时候应注意避免隐藏的嵌套迭代或多次迭代"><a class="header" href="#pstr03-在使用内建字符串处理函数或方法的时候应注意避免隐藏的嵌套迭代或多次迭代">P.STR.03 在使用内建字符串处理函数或方法的时候，应注意避免隐藏的嵌套迭代或多次迭代</a></h2>
<p><strong>【描述】</strong></p>
<p>比如 <code>contains</code> 函数的实现就是按字符遍历字符串，但是如果你将它用于一个字符串的迭代处理中，就会产生嵌套迭代，时间复杂度从你以为的 <code>O(n)</code> 变成了 <code>O(n^2)</code>。没有将其用于迭代中，也有可能产生多次迭代，<code>O(n)</code> 变为 <code>O(n+m)</code> 。 为了避免这个问题，我们可以用 <code>find</code>  来代替 <code>contains</code>。</p>
<p>所以，在使用内建函数的时候要注意它的实现，选择合适的函数或方法，来避免这类问题。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 对输入的字符串进行转义
pub fn find&lt;'a, S: Into&lt;Cow&lt;'a, str&gt;&gt;&gt;(input: S) -&gt; Cow&lt;'a, str&gt; {
    let input = input.into();
    fn is_trouble(c: char) -&gt; bool {
        c == '&lt;' || c == '&gt;' || c == '&amp;'
    }
    
    // 使用 find 而非 contains
    // find 使用模式查找，可以返回匹配字符的位置信息
    let first = input.find(is_trouble);
    
    // 利用 find 的位置信息，避免第二次遍历
    if let Some(first) = first {
        let mut output = String::from(&amp;input[0..first]);
        output.reserve(input.len() - first);
        let rest = input[first..].chars();
        for c in rest {
            match c {
                '&lt;' =&gt; output.push_str(&quot;&amp;lt;&quot;),
                '&gt;' =&gt; output.push_str(&quot;&amp;gt;&quot;),
                '&amp;' =&gt; output.push_str(&quot;&amp;amp;&quot;),
                _ =&gt; output.push(c),
            }
        }

        Cow::Owned(output)
    } else {
        input.into()
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pstr04-只在合适的场景下使用正则表达式第三方库regex"><a class="header" href="#pstr04-只在合适的场景下使用正则表达式第三方库regex">P.STR.04 只在合适的场景下，使用正则表达式第三方库<code>regex</code></a></h2>
<p><strong>【描述】</strong></p>
<p>合适的场景包括：</p>
<ol>
<li>不在乎编译文件大小。<code>regex</code> 正则引擎是第三方库，引入它的时候意味着还会引入其他依赖，对编译文件大小有要求可以考虑，是否使用 <code>Cow</code> 和 内建函数方法来替代。</li>
<li>对字符串查找性能有极致需求。<code>regex</code> 的  <code>find</code> 实现性能很好，但是 <code>replace</code> 替换就不一定了。对于替换需求，在适合 <code>Cow&lt;str&gt;</code> 的场景下，使用 <code>Cow</code> 和 内建函数方法来替代 regex 可能更好。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pstr05---在拼接字符串时优先使用format"><a class="header" href="#pstr05---在拼接字符串时优先使用format">P.STR.05   在拼接字符串时，优先使用<code>format!</code></a></h2>
<p><strong>【描述】</strong></p>
<p>在Rust中有很多方法可以连接字符串，不同的连接方法适用于不同的场景，性能也会有所差别。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust"> // 组合字符串是最简单和直观的方法，尤其是在字符串和非字符串混合的情况下。
 fn main() {
	let name = &quot;world!&quot;;
	let hw = format!(&quot;Hello {}!&quot;, name);
	println!(&quot;{:#?}&quot;, hw);
 }
 
 // 在追加字符串的时候，可以使用`push_str`方法,`push_str`性能比`format!`更好
 fn main() {
    let mut hw = String::new();
    hw.push_str(&quot;hello&quot;);
    hw.push_str(&quot; world!&quot;);
    println!(&quot;{:#?}&quot;, hw);
}

 // 通过`concat()`方法将字符串数组拼接成一个字符串
 fn main() {
    let hw = [&quot;hello&quot;, &quot; &quot;, &quot;world!&quot;].concat();
    println!(&quot;{:#?}&quot;, hw);
 }
 
 // 通过`join()`方法将字符串数组拼接成一个字符串
 fn main() {
    let hw_1 = [&quot;hello&quot;, &quot;world!&quot;].join(&quot;&quot;);
    println!(&quot;{:#?}&quot;, hw_1);
	// 输出：
	// helloworld!
	
    // 使用`join()`方法在拼接字符串时添加或指定字符
    let hw_2 = [&quot;hello&quot;, &quot;world!&quot;].join(&quot;+&quot;);
    println!(&quot;{:#?}&quot;, hw_2);
	// 输出：
	// hello+world!
 }
 
 // 使用`collect()`方式对数组中的字符串进行拼接
 fn main() {
    let hw = [&quot;hello&quot;, &quot; &quot;, &quot;world!&quot;];
    let res: String = hw.iter().map(|x| *x).collect();
    println!(&quot;{:#?}&quot;, res);
 }
 
 // 使用符号`+`进行字符串拼接
 fn main() {
    let hw_1 = &amp;(String::from(&quot;hello&quot;) + &amp;String::from(&quot; &quot;) + &amp;String::from(&quot;world!&quot;));
    println!(&quot;{:#?}&quot;, hw_1);
    
    let hw_2 = &amp;(String::from(&quot;hello&quot;) + &quot; &quot; + &quot;world!&quot;);
    println!(&quot;{:#?}&quot;, hw_2);
    
    let hw_3 = &amp;(&quot;hello&quot;.to_owned() + &quot; &quot; + &quot;world!&quot;);
    println!(&quot;{:#?}&quot;, hw_3);

    let hw_4 = &amp;(&quot;hello&quot;.to_string() + &quot; &quot; + &quot;world!&quot;);
    println!(&quot;{:#?}&quot;, hw_4);
 }
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gstr01---在实现display特征时不应调用to_string方法"><a class="header" href="#gstr01---在实现display特征时不应调用to_string方法">G.STR.01   在实现<code>Display</code>特征时不应调用<code>to_string()</code>方法</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>因为 <code>to_string</code> 是间接通过 <code>Display</code> 来实现的，如果实现 <code>Display</code> 的时候再使用 <code>to_tring</code> 的话，将会无限递归。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

struct Structure(i32);
impl fmt::Display for Structure {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, self.to_string())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

struct Structure(i32);
impl fmt::Display for Structure {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, self.0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#to_string_in_display">to_string_in_display</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gstr02---在追加字符串时使用push_str方法"><a class="header" href="#gstr02---在追加字符串时使用push_str方法">G.STR.02   在追加字符串时使用<code>push_str</code>方法</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>增强代码的可读性</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = &quot;Hello&quot;.to_owned();
x = x + &quot;, World&quot;;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = &quot;Hello&quot;.to_owned();

// More readable
x += &quot;, World&quot;;
x.push_str(&quot;, World&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#string_add_assign">string_add_assign</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#string_add">string_add</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gstr03---将只包含-ascii字符的字符串字面量转为字节序列可以直接使用bstr-语法代替调用as_bytes方法"><a class="header" href="#gstr03---将只包含-ascii字符的字符串字面量转为字节序列可以直接使用bstr-语法代替调用as_bytes方法">G.STR.03   将只包含 <code>ASCII</code>字符的字符串字面量转为字节序列可以直接使用<code>b&quot;str&quot;</code> 语法代替调用<code>as_bytes</code>方法</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>这是为了增强可读性，让代码更简洁。</p>
<p>注意，<code>&quot;str&quot;.as_bytes()</code> 并不等价于  <code>b&quot;str&quot;</code>，而是等价于 <code>&amp;b&quot;str&quot;[..]</code>  。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bs = &quot;a byte string&quot;.as_bytes();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bs = b&quot;a byte string&quot;;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#string_lit_as_bytes">string_lit_as_bytes</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gstr04---需要辨别字符串的字符开头或结尾字符时不应按字符迭代比较"><a class="header" href="#gstr04---需要辨别字符串的字符开头或结尾字符时不应按字符迭代比较">G.STR.04   需要辨别字符串的字符开头或结尾字符时，不应按字符迭代比较</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Rust 语言核心库和标准库都对字符串内置了一些方便的方法来处理这类需求。</p>
<p>迭代字符的性能虽然也很快（对500多个字符迭代转义处理大概需要4.5微秒左右），但这种场景用迭代的话，代码可读性更差一些。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = &quot;_&quot;;
name.chars().last() == Some('_') || name.chars().next_back() == Some('-');

let name = &quot;foo&quot;;
if name.chars().next() == Some('_') {};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = &quot;_&quot;;
name.ends_with('_') || name.ends_with('-');

let name = &quot;foo&quot;;
if name.starts_with('_') {};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#chars_last_cmp">chars_last_cmp</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#chars_next_cmp">chars_next_cmp</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gstr05---对字符串按指定位置进行切片的时候需要小心破坏其-utf-8-编码"><a class="header" href="#gstr05---对字符串按指定位置进行切片的时候需要小心破坏其-utf-8-编码">G.STR.05   对字符串按指定位置进行切片的时候需要小心破坏其 UTF-8 编码</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>字符串默认是合法的 <code>UTF-8</code>字节序列，如果通过指定索引位置来对字符串进行切片，有可能破坏其合法 <code>UTF-8</code> 编码，除非这个位置是确定的，比如按 <code>char_indices</code> 方法来定位是合法的。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Ölkanne&quot;;
// thread 'main' panicked at 'byte index 1 is not a char boundary; 
// it is inside 'Ö' (bytes 0..2) of `Ölkanne`'
let sub_s = &amp;s[1..];
// println!(&quot;{:?}&quot;, sub_s);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Ölkanne&quot;;
let mut char_indices = s.char_indices();
assert_eq!(Some((0, 'Ö')), char_indices.next());
// assert_eq!(Some((2, 'l')), char_indices.next()); 
let pos = if let Some((pos, _)) = char_indices.next(){ pos } else {0};
let sub_s = &amp;s[pos..];
assert_eq!(&quot;lkanne&quot;, sub_s);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#string_slice">string_slice</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="38-集合类型"><a class="header" href="#38-集合类型">3.8 集合类型</a></h1>
<p>Rust 中的集合类型包括四大类：</p>
<ul>
<li>线性序列： <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>Vec</code></a>, <a href="https://doc.rust-lang.org/stable/std/collections/struct.VecDeque.html"><code>VecDeque</code></a>, <a href="https://doc.rust-lang.org/stable/std/collections/struct.LinkedList.html"><code>LinkedList</code></a></li>
<li>映射集：<a href="https://doc.rust-lang.org/stable/std/collections/hash_map/struct.HashMap.html"><code>HashMap</code></a>, <a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html"><code>BTreeMap</code></a></li>
<li>集合： <a href="https://doc.rust-lang.org/stable/std/collections/hash_set/struct.HashSet.html"><code>HashSet</code></a>, <a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html"><code>BTreeSet</code></a></li>
<li>其他： <a href="https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html"><code>BinaryHeap</code></a></li>
</ul>
<h2 id="列表-20"><a class="header" href="#列表-20">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./collections/P.CLT.01.html">P.CLT.01 创建HashMap、VecDeque时，可以预先分配大约足够的容量来避免后续操作中产生多次分配</a></li>
<li><a href="safe-guides/coding_practice/./collections/G.CLT.01.html">G.CLT.01 非必要情况下，不要使用LinkedList，而用Vec或VecDeque代替</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pclt01-创建hashmapvecdeque时可以预先分配大约足够的容量来避免后续操作中产生多次分配"><a class="header" href="#pclt01-创建hashmapvecdeque时可以预先分配大约足够的容量来避免后续操作中产生多次分配">P.CLT.01 创建HashMap、VecDeque时，可以预先分配大约足够的容量来避免后续操作中产生多次分配</a></h2>
<p><strong>【描述】</strong></p>
<p>预分配足够的容量，避免后续内存分配，可以提升代码性能。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use std::collections::VecDeque;

fn main() {

    // HashMap
    let mut map = HashMap::new();
    map.insert(&quot;a&quot;, 1);
    map.insert(&quot;b&quot;, 2);
    map.insert(&quot;c&quot;, 3);
    println!(&quot;{:#?}&quot;, map);
    
    // VecDeque
    let mut deque = VecDeque::new();
    deque.push_back(1);
    deque.push_back(2);
    deque.push_back(3);
    println!(&quot;{:#?}&quot;, deque);
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use std::collections::VecDeque;

fn main() {

    // HashMap
    let mut map = HashMap::with_capacity(3);
    map.insert(&quot;a&quot;, 1);
    map.insert(&quot;b&quot;, 2);
    map.insert(&quot;c&quot;, 3);
    println!(&quot;{:#?}&quot;, map);
    
    // VecDeque
    let mut deque = VecDeque::with_capacity(3);
    deque.push_back(1);
    deque.push_back(2);
    deque.push_back(3);
    println!(&quot;{:#?}&quot;, deque);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gclt01-非必要情况下不要使用linkedlist而用vec或vecdeque代替"><a class="header" href="#gclt01-非必要情况下不要使用linkedlist而用vec或vecdeque代替">G.CLT.01 非必要情况下，不要使用<code>LinkedList</code>，而用<code>Vec</code>或<code>VecDeque</code>代替</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>一般情况下，有 <code>Vec</code>和<code>VecDeque</code> 性能更好。<code>LinkedList</code> 存在内存浪费，缓存局部性（Cache Locality）比较差，无法更好地利用CPU 缓存机制，性能很差。</p>
<p>只有在有大量的 列表 拆分 和 合并 操作时，才真正需要链表，因为链表允许你只需操作指针而非复制数据来完成这些操作。 </p>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#linkedlist">linkedlist</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 如果函数是被导出的 API，则该 lint 不会被触发，是防止 lint 建议对 API 有破坏性的改变。默认为 true
avoid-breaking-exported-api=true 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="39-函数设计"><a class="header" href="#39-函数设计">3.9 函数设计</a></h1>
<p>创建函数或使用闭包时需要注意的地方。</p>
<h2 id="列表-21"><a class="header" href="#列表-21">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./fn-design/P.FUD.01.html">P.FUD.01 传递到闭包的变量建议单独重新绑定</a></li>
<li><a href="safe-guides/coding_practice/./fn-design/P.FUD.02.html">P.FUD.02 函数返回值不要使用 return</a></li>
<li><a href="safe-guides/coding_practice/./fn-design/G.FUD.01.html">G.FUD.01 函数参数最长不要超过五个</a></li>
<li><a href="safe-guides/coding_practice/./fn-design/G.FUD.02.html">G.FUD.02 当函数参数实现了 Copy，并且是按值传入，如果值可能会太大，则宜考虑按引用传递</a></li>
<li><a href="safe-guides/coding_practice/./fn-design/G.FUD.03.html">G.FUD.03 当函数参数出现太多 bool 类型的参数时，应该考虑将其封装为自定义的结构体或枚举</a></li>
<li><a href="safe-guides/coding_practice/./fn-design/G.FUD.04.html">G.FUD.04 当Copy 类型的足够小的值作为函数参数时，应该按值（by-value）传入，而不是引用(by-ref)</a></li>
<li><a href="safe-guides/coding_practice/./fn-design/G.FUD.05.html">G.FUD.05 不要为函数指定 inline(always)</a></li>
<li><a href="safe-guides/coding_practice/./fn-design/G.FUD.06.html">G.FUD.06 函数参数建议使用借用类型</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfud01---传递到闭包的变量建议单独重新绑定"><a class="header" href="#pfud01---传递到闭包的变量建议单独重新绑定">P.FUD.01   传递到闭包的变量建议单独重新绑定</a></h2>
<p><strong>【描述】</strong></p>
<p>默认情况下，闭包通过借用来捕获环境变量。或者，可以使用 <code>move</code> 关键字来移动环境变量到闭包中。</p>
<p>将这些要在闭包内用的变量，重新进行分组绑定，可读性更好。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let num1 = Rc::new(1);
let num2 = Rc::new(2);
let num3 = Rc::new(3);
let closure = {
    // `num1` is moved
    let num2 = num2.clone();  // `num2` is cloned
    let num3 = num3.as_ref();  // `num3` is borrowed
    move || {
        *num1 + *num2 + *num3;
    }
};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let num1 = Rc::new(1);
let num2 = Rc::new(2);
let num3 = Rc::new(3);
// 单独对要传递到闭包的变量重新绑定
let num2_cloned = num2.clone();
let num3_borrowed = num3.as_ref();
let closure = move || {
    *num1 + *num2_cloned + *num3_borrowed;
};
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfud02---函数返回值不要使用-return"><a class="header" href="#pfud02---函数返回值不要使用-return">P.FUD.02   函数返回值不要使用 <code>return</code></a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 中函数块会自动返回最后一个表达式的值，不需要显式地指定 Return。</p>
<p>只有在函数过程中需要提前返回的时候再加 Return。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: usize) -&gt; usize {
    if x &lt; 42{
        return x;
    }
    return x + 1;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: usize) -&gt; usize {
    if x &lt; 42{
        return x;
    }
    x + 1
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfud01--函数参数最长不要超过五个"><a class="header" href="#gfud01--函数参数最长不要超过五个">G.FUD.01  函数参数最长不要超过五个</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>为了提升代码可读性，函数的参数最长不宜超过五个。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color;
fn foo(x: f32, y: f32, name: &amp;str, c: Color, w: u32, h: u32, a: u32, b: u32) {
    // ..
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>想办法把过长的参数缩短。</p>
<pre><pre class="playground"><code class="language-rust">struct Color;
// 此处使用 常量泛型（const generic） 来接收后面多个 u32 类型的参数
// 使用元组 缩短 2~3 个参数为一个参数
fn foo&lt;T, const N: usize&gt;(x: (f32, f32), name: &amp;str, c: Color, last: [T; N]) {
    ;
}

fn main(){
    let arr = [1u32, 2u32];
    foo((1.0f32, 2.0f32), &quot;hello&quot;, Color, arr);
    let arr = [1.0f32, 2.0f32, 3.0f32];
    foo((1.0f32, 2.0f32), &quot;hello&quot;, Color, arr);
}
</code></pre></pre>
<h3 id="lint-检测"><a class="header" href="#lint-检测">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#too_many_arguments">too_many_arguments</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 函数参数最长不要超过5个
too-many-arguments-threshold=5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfud02---当函数参数实现了-copy并且是按值传入如果值可能会太大则宜考虑按引用传递"><a class="header" href="#gfud02---当函数参数实现了-copy并且是按值传入如果值可能会太大则宜考虑按引用传递">G.FUD.02   当函数参数实现了 Copy，并且是按值传入，如果值可能会太大，则宜考虑按引用传递</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>通过值传递的参数可能会导致不必要的 <code>memcpy</code> 拷贝，这可能会造成性能损失。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy)]
struct TooLarge([u8; 2048]);

// Bad
fn foo(v: TooLarge) {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy)]
struct TooLarge([u8; 2048]);

// Good
fn foo(v: &amp;TooLarge) {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#large_types_passed_by_value">large_types_passed_by_value</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 如果函数是被导出的 API，则该 lint 不会被触发，是防止 lint 建议对 API 有破坏性的改变。默认为 true
avoid-breaking-exported-api=true 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfud03---当函数参数出现太多-bool-类型的参数时应该考虑将其封装为自定义的结构体或枚举"><a class="header" href="#gfud03---当函数参数出现太多-bool-类型的参数时应该考虑将其封装为自定义的结构体或枚举">G.FUD.03   当函数参数出现太多 bool 类型的参数时，应该考虑将其封装为自定义的结构体或枚举</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong>
布尔类型的参数过多，很难让人记住，容易出错。将其封装为枚举或结构体，可以更好地利用类型系统的检查而避免出错。
其他类型参数过多时，也可以考虑是否可以用自定义结构体或枚举进行封装。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(is_round: bool, is_hot: bool) { ... }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Shape {
    Round,
    Spiky,
}

enum Temperature {
    Hot,
    IceCold,
}

fn f(shape: Shape, temperature: Temperature) { ... }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#fn_params_excessive_bools">fn_params_excessive_bools</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 用于配置函数可以拥有的 bool 类型参数最大数量，默认为 3。
max-fn-params-bools=3 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfud04---当copy-类型的足够小的值作为函数参数时应该按值by-value传入而不是引用by-ref"><a class="header" href="#gfud04---当copy-类型的足够小的值作为函数参数时应该按值by-value传入而不是引用by-ref">G.FUD.04   当Copy 类型的足够小的值作为函数参数时，应该按值（by-value）传入，而不是引用(by-ref)</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在函数参数为 Copy 类型 且 其值足够小的时候，一般情况下，会避免传引用。因为对于这种小的值，性能上和按引用传递是一样快的，并且在代码更容易编写和可读。包括一些小的 结构体，也推荐按值传递，但要注意【例外】示例所示的情况。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(v: &amp;u32) {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(v: u32) {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)]
struct RawPoint {
    pub x: u8,
}

#[derive(Clone, Copy)]
struct Point {
    pub raw: RawPoint,
}

impl Point {
    pub fn raw(&amp;self) -&gt; *const RawPoint {
        &amp;self.raw
    }
    // 如果听信 lint 的建议，将上面的 raw 函数参数 self 的引用去掉就是 raw_linted 函数
    pub fn raw_linted(self) -&gt; *const RawPoint {
        &amp;self.raw
    }
}

fn main() {
    let p = Point { raw: RawPoint { x: 10 } };

    // This passes
    assert_eq!(p.raw(), p.raw());
    // This fails 事实上，如果去掉那个 self 的引用，该函数的行为就变了
    // 因为 结构体 Point 是 Copy 的，每次调用 raw_linted 方法，结构体实例就会被复制一次，得到的结果就不一样了
    assert_eq!(p.raw_linted(), p.raw_linted());
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#trivially_copy_pass_by_ref">trivially_copy_pass_by_ref</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 如果函数是被导出的 API，则该 lint 不会被触发，是防止 lint 建议对 API 有破坏性的改变。默认为 true
avoid-breaking-exported-api=true
# 考虑Copy按值而不是按引用传递的类型的最大大小（以字节为单位）。默认是None
trivial-copy-size-limit=None
</code></pre>
<p><strong>注意</strong>，该 lint 没有考虑指针相关的情况，见例外示例。需要酌情考虑使用。例外示例来自  <a href="https://github.com/rust-lang/rust-clippy/issues/5953">rust-clippy/issues/5953</a> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfud05---不要为函数指定-inlinealways"><a class="header" href="#gfud05---不要为函数指定-inlinealways">G.FUD.05   不要为函数指定 <code>inline(always)</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p><code>inline</code> 虽然可以提升性能，但也会增加编译时间和编译大小。</p>
<p>Rust 中性能、编译时间和编译大小之间需要权衡。根据需要再 <code>inline</code> 即可。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline(always)]
fn not_quite_hot_code(..) { ... }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>根据需要再inline即可，比如明确知道某个函数被调用次数非常频繁，这个时候为了性能考虑要为其手工指定内联。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 实现内存回收功能，调用非常频繁。性能优先。
#[inline(always)]
pub fn buf_recycle(buf_id: usize) {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#inline_always">inline_always</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfud06--函数参数建议使用借用类型"><a class="header" href="#gfud06--函数参数建议使用借用类型">G.FUD.06  函数参数建议使用借用类型</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>这里是指 借用类型，而非 借用有所有权的类型。这样的好处是参数可以灵活兼容更多类型。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn three_vowels(word: &amp;String) -&gt; bool {
    let mut vowel_count = 0;
    for c in word.chars() {
        matchc {
            'a' | 'e' | 'i' | 'o' | 'u' =&gt; {
                vowel_count += 1;
                if vowel_count &gt;= 3 {
                    return true
                }
            }
            _ =&gt; volweld_count = 0
        }
    }
    false
}

fn main() {
    let sentence_string = &quot;Once upon a time, there was a friendly curious crab named Ferris&quot;.to_string();
    for word in sentence_string.split(' ') {
        if three_vowels(word.to_string()) {
            println!(&quot;{} has three consecutive vowels!&quot;, word);
        }
    }
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 这里的参数可以接受 &amp;String / &amp;'str/ &amp;'static str 三种类型参数
fn three_vowels(word: &amp;str) -&gt; bool {
    let mut vowel_count = 0;
    for c in word.chars() {
        match c {
            'a' | 'e' | 'i' | 'o' | 'u' =&gt; {
                vowel_count += 1;
                if vowel_count &gt;= 3 {
                    return true
                }
            }
            _ =&gt; vowel_count = 0
        }
    }
    false
}

fn main() {
    let sentence_string =
        &quot;Once upon a time, there was a friendly curious crab named Ferris&quot;.to_string();
    for word in sentence_string.split(' ') {
        if three_vowels(word) {
            println!(&quot;{} has three consecutive vowels!&quot;, word);
        }
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="310-泛型"><a class="header" href="#310-泛型">3.10 泛型</a></h1>
<p>Rust 中的泛型允许开发人员编写更加简洁、更少重复的代码。但泛型可能会引起编译文件大小膨胀，酌情使用。</p>
<h2 id="列表-22"><a class="header" href="#列表-22">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./generic/P.GEN.01.html">P.GEN.01 用泛型来抽象公共语义</a></li>
<li><a href="safe-guides/coding_practice/./generic/P.GEN.02.html">P.GEN.02 不要随便使用 impl Trait 语法替代泛型限定</a></li>
<li><a href="safe-guides/coding_practice/./generic/P.GEN.03.html">P.GEN.03 不要使用太多泛型参数和 trait 限定，否则会增长编译时间</a></li>
<li><a href="safe-guides/coding_practice/./generic/P.GEN.04.html">P.GEN.04 为泛型类型实现方法时，impl 中声明的泛型类型参数一定要被用到</a></li>
<li><a href="safe-guides/coding_practice/./generic/P.GEN.05.html">P.GEN.05 定义泛型函数时，如果该函数实现用到来自 trait 定义的相关行为，需要为泛型指定相关 trait 的限定</a></li>
<li><a href="safe-guides/coding_practice/./generic/G.GEN.01.html">G.GEN.01 不要在泛型位置上使用内建类型</a></li>
<li><a href="safe-guides/coding_practice/./generic/G.GEN.02.html">G.GEN.02 使用 Rust 标准库中某些方法，要注意避免使用其泛型默认实现，而应该使用具体类型的实现</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pgen01----用泛型来抽象公共语义"><a class="header" href="#pgen01----用泛型来抽象公共语义">P.GEN.01    用泛型来抽象公共语义</a></h2>
<p><strong>【描述】</strong></p>
<p>应该巧用泛型来抽象公共语义，消除重复代码。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, Clone, Copy)]
struct Meter {
    value: f64
}

impl Meter {
    fn new(value: f64) -&gt; Self {
        Self { value }
    }
}

impl Add for Meter {
    type Output = Meter;

    fn add(self, another: Meter) -&gt; Self::Output {
        let value = self.value + another.value;
        Meter { value }
    }
}

#[derive(Debug, Clone, Copy)]
struct Kilogram {
    value: f64
}

impl Kilogram {
    fn new(value: f64) -&gt; Self {
        Self { value }
    }
}

impl Add for Kilogram {
    type Output = Kilogram;

    fn add(self, another: Kilogram) -&gt; Self::Output {
        let value = self.value + another.value;
        Kilogram { value }
    }
}
fn main() {
    let one_meter = Meter::new(1.0);
    let two_kilograms = Kilogram::new(2.0);
    
    let two_meters = one_meter + one_meter;
}

</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;
use std::marker::PhantomData;

#[derive(Debug, Clone, Copy)]
struct Unit&lt;T&gt; {
    value: f64,
    unit_type: PhantomData&lt;T&gt;,
}

impl&lt;T&gt; Unit&lt;T&gt; {
    fn new(value: f64) -&gt; Self {
        Self {
            value,
            unit_type: PhantomData,
        }
    }
}

impl&lt;T&gt; Add for Unit&lt;T&gt; {
    type Output = Unit&lt;T&gt;;

    fn add(self, another: Unit&lt;T&gt;) -&gt; Self::Output {
        let new_value = self.value + another.value;
        Unit::new(new_value)
    }
}

#[derive(Debug, Clone, Copy)]
struct MeterType;

#[derive(Debug, Clone, Copy)]
struct KilogramType;

type Meter = Unit&lt;MeterType&gt;;
type Kilogram = Unit&lt;KilogramType&gt;;
fn main() {
    let one_meter = Meter::new(1.0);
    let two_kilograms = Kilogram::new(2.0);
    
    let two_meters = one_meter + one_meter;
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pgen02--不要随便使用-impl-trait-语法替代泛型限定"><a class="header" href="#pgen02--不要随便使用-impl-trait-语法替代泛型限定">P.GEN.02  不要随便使用 <code>impl Trait</code> 语法替代泛型限定</a></h2>
<p><strong>【描述】</strong></p>
<p><code>impl Trait</code> 语法 和 泛型限定，虽然都是静态分发，且效果类似，但是它们的语义是不同的。</p>
<p><strong>在类型系统层面上的语义：</strong></p>
<ol>
<li><code>impl Trait</code> 是 存在量化类型。意指，存在某一个被限定的类型。</li>
<li>泛型限定 是 通用量化类型。意指，所有被限定的类型。</li>
</ol>
<p>要根据它们的语义来选择不同的写法。</p>
<p>另外，<code>impl Trait</code> 可以用在函数参数位置和返回值位置，但是不同位置意义不同。</p>
<p><strong>函数参数位置</strong></p>
<p>等价于 泛型参数。</p>
<p>但要注意：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(b1: impl Bar, b2: impl Bar) -&gt; usize
<span class="boring">}
</span></code></pre></pre>
<p>等价于：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;B1: Bar, B2: Bar&gt;(b1: B1, b2: B2) -&gt; usize
<span class="boring">}
</span></code></pre></pre>
<p>而不是</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;B: Bar&gt;(b1: B, b2: B) -&gt; usize
<span class="boring">}
</span></code></pre></pre>
<p>证明示例：</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

// 函数参数可以传入 整数，但是函数返回值是 String
fn func(arg: impl Display) -&gt; impl Display {
    format!(&quot;Hay! I am not the same as \&quot;{}\&quot;&quot;, arg)
}

// 很明显不等价于下面这类
// fn somefunc2&lt;T: Display&gt;(arg: T) -&gt; T {
//     // 需要指定同一个类型 T 的行为
// }

fn main(){
    let a  = 42;
    let a = func(42);
}
</code></pre></pre>
<p><strong>函数返回值</strong></p>
<p>在返回值位置上，如果是泛型参数，则是由调用者来选择具体类型，比如 <code>parse::&lt;i32&gt;(&quot;32&quot;)</code> ； 如果是 <code>impl Trait</code>，则是由被调用者来决定具体类型，但只能有一种类型。</p>
<p>在返回值位置上的 <code>impl Trait</code> 会根据函数体的返回值自动推断实现了哪些  auto trait。这意味着你不必在 <code>impl Trait</code> 后面再 加 <code>Sync + Send </code> 这种auto trait。</p>
<p>注意下面代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Error： 这里只允许有同一种具体类型，Foo 和 Baz 都实现了 Bar 也是错的。
fn f(a: bool) -&gt; impl Bar {
    if a {
        Foo { ... }
    } else {
        Baz { ... }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pgen03---不要使用太多泛型参数和-trait-限定否则会增长编译时间"><a class="header" href="#pgen03---不要使用太多泛型参数和-trait-限定否则会增长编译时间">P.GEN.03   不要使用太多泛型参数和 trait 限定，否则会增长编译时间</a></h2>
<p><strong>【描述】</strong></p>
<p>为泛型函数添加详细的 trait 限定，可以在一定程度上增强用户使用体验，但使用过多的泛型参数和 trait 限定会显著地增长编译时间。</p>
<p><strong>【反例】</strong></p>
<p>此写法比正例的写法编译时间要多十倍。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // From: https://github.com/tokio-rs/axum/pull/198
    fn handle_error&lt;ReqBody, ResBody, F, Res, E&gt;(
        self,
        f: F,
    ) -&gt; HandleError&lt;Self, F, ReqBody, HandleErrorFromRouter&gt;
    where
        Self: Service&lt;Request&lt;ReqBody&gt;, Response = Response&lt;ResBody&gt;&gt;,
        F: FnOnce(Self::Error) -&gt; Result&lt;Res, E&gt;,
        Res: IntoResponse,
        ResBody: http_body::Body&lt;Data = Bytes&gt; + Send + Sync + 'static,
        ResBody::Error: Into&lt;BoxError&gt; + Send + Sync + 'static,
    {
        HandleError::new(self, f)
    }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>来自于 Web 框架 Axum 的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // From: https://github.com/tokio-rs/axum/pull/198
    fn handle_error&lt;ReqBody, F&gt;(
        self,
        f: F,
    ) -&gt; HandleError&lt;Self, F, ReqBody, HandleErrorFromRouter&gt; {
        HandleError::new(self, f)
    }   
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pgen04--为泛型类型实现方法时impl-中声明的泛型类型参数一定要被用到"><a class="header" href="#pgen04--为泛型类型实现方法时impl-中声明的泛型类型参数一定要被用到">P.GEN.04  为泛型类型实现方法时，<code>impl</code> 中声明的泛型类型参数一定要被用到</a></h2>
<p><strong>【描述】</strong></p>
<p>在 <code>impl</code> 中被声明的类型参数，至少要满足下面三种形式：</p>
<ol>
<li><code>impl&lt;T&gt; Foo&lt;T&gt;</code>，  <code>T</code>  出现在实现的<code>Self</code> 类型<code>Foo&lt;T&gt;</code> 中 。</li>
<li><code>impl&lt;T&gt; SomeTrait&lt;T&gt; for Foo</code> ， <code>T</code>出现在要实现的 trait 中 。</li>
<li><code>impl&lt;T, U&gt; SomeTrait for T where T: AnotherTrait&lt;AssocType=U&gt;</code> ， 出现在 <code>T</code> 的 trait 限定的关联类型中。</li>
</ol>
<p>除此之外，都不算 <code>T</code> 被用到（出现在 Self 类型中）。</p>
<p>有这种限制，主要有两个原因：</p>
<ol>
<li>方便 Rust 类型推断。有这些限制才能明确能推断这些泛型参数的行为，避免产生错误。参考 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md">RFC 0447 </a> 。</li>
<li>避免语义定义不明确的情况。如果 <code>impl</code> 上存在自由的 泛型参数，则无法保证这一点。</li>
</ol>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// case 1

struct Foo;

impl&lt;T: Default&gt; Foo {
    // error: the type parameter `T` is not constrained by the impl trait, self
    // type, or predicates [E0207]
    fn get(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}

// case 2
trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}
struct Foo&lt;T&gt; {
    foo: T
}
struct FooMaker;
impl&lt;T: Default&gt; Maker for FooMaker {
// error: the type parameter `T` is not constrained by the impl trait, self
// type, or predicates [E0207]
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo { foo: &lt;T as Default&gt;::default() }
    }
}

// error: the type parameter `A` is not constrained by the impl trait, self type, or predicates
trait Foo {}
impl&lt;F, A&gt; Foo for F where F: Fn(A) {} // error
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// case 1
struct Foo;

// Move the type parameter from the impl to the method
impl Foo {
    fn get&lt;T: Default&gt;(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}

// case 2
use std::marker::PhantomData;

trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

// Add a type parameter to `FooMaker`
struct FooMaker&lt;T&gt; {
    phantom: PhantomData&lt;T&gt;,
}

impl&lt;T: Default&gt; Maker for FooMaker&lt;T&gt; {
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo {
            foo: &lt;T as Default&gt;::default(),
        }
    }
}

// closue : 相关 issue:  https://github.com/rust-lang/rust/issues/25041 
trait Foo {}
impl&lt;F, A&gt; Foo for F where F: Fn() -&gt; A {} // 此处 A 是 闭包trait内的一个关联类型
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pgen05-定义泛型函数时如果该函数实现用到来自-trait-定义的相关行为需要为泛型指定相关-trait-的限定"><a class="header" href="#pgen05-定义泛型函数时如果该函数实现用到来自-trait-定义的相关行为需要为泛型指定相关-trait-的限定">P.GEN.05 定义泛型函数时，如果该函数实现用到来自 trait 定义的相关行为，需要为泛型指定相关 trait 的限定</a></h2>
<p><strong>【描述】</strong></p>
<p>泛型，在 Rust 类型系统中的语义是一种 通用量化l类型（Universally-quantified type），即，泛型类型<code> T</code> 的所有可能 的单态类型。</p>
<p>在泛型函数内部，如果使用了来自某个 trait 定义的行为，则需要为泛型指定相关的 trait 限定，来排除其他没有实现该trait 的类型。</p>
<p>注：Rust编译器可以检测这种情况，但是编译错误比较晦涩，本原则用来提示开发者注意这种情况。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

// println! 中 `{:?}` 为 Debug triat 定义行为
fn some_func&lt;T&gt;(foo: T) {
    println!(&quot;{:?}&quot;, foo); // error[E0277]: `T` doesn't implement `Debug`
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

// 为泛型类型 T 指派 Debug triat 限定
fn some_func&lt;T: fmt::Debug&gt;(foo: T) {
    println!(&quot;{:?}&quot;, foo); 
}

struct A;

fn main() {
   some_func(5i32);
   
   // A 没有实现 Debug trait，会被排除掉
   some_func(A); // error[E0277]: `A` doesn't implement `Debug`
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ggen01-不要在泛型位置上使用内建类型"><a class="header" href="#ggen01-不要在泛型位置上使用内建类型">G.GEN.01 不要在泛型位置上使用内建类型</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>这样做虽然会导致编译错误，但是这种错误会使开发者感到困惑，反而无法找到问题所在。</p>
<p><strong>【反例】</strong></p>
<p>这里 <code>u32</code> 会被认为是一个类型参数。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;u32&gt; Foo&lt;u32&gt; {
    fn impl_func(&amp;self) -&gt; u32 {
        42
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Foo&lt;T&gt; {
    fn impl_func(&amp;self) -&gt; T {
        42
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#builtin_type_shadow">builtin_type_shadow</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ggen02---使用-rust-标准库中某些方法要注意避免使用其泛型默认实现而应该使用具体类型的实现"><a class="header" href="#ggen02---使用-rust-标准库中某些方法要注意避免使用其泛型默认实现而应该使用具体类型的实现">G.GEN.02   使用 Rust 标准库中某些方法，要注意避免使用其泛型默认实现，而应该使用具体类型的实现</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#inefficient_to_string">inefficient_to_string</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p><strong>【描述】</strong></p>
<p>Rust 标准库内部某些类型使用了 泛型特化（未稳定特性），比如 <code>ToString</code> trait。</p>
<p>该 trait 有一个<a href="https://doc.rust-lang.org/stable/src/alloc/string.rs.html#2369">泛型默认实现</a>， 并且一些具体类型也实现了它，比如 <code>char</code>/ <code>str</code> /  <code>u8</code>/ <code>i8</code> 等。</p>
<p>在实际代码中，应该选择去调用具体类型实现的 <code>to_string()</code> 方法，而非调用泛型的默认实现。 </p>
<p><strong>这一规则要求开发者对 Rust 标准库的一些方法实现有一定了解。</strong> </p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 闭包参数中， s 为 `&amp;&amp;str` 类型
//  `&amp;&amp;str` 就会去调用泛型的默认实现
[&quot;foo&quot;, &quot;bar&quot;].iter().map(|&amp;s| s.to_string() );
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 闭包参数中， s 为 `&amp;&amp;str` 类型，使用 `|&amp;s|` 对参数模式匹配后，闭包体内 `s` 就变成了 `&amp;str` 类型
// 经过这样的转换，直接调用 `&amp;str`的 `to_string()` 方法，而如果是 `&amp;&amp;str` 就会去调用泛型的默认实现。 
[&quot;foo&quot;, &quot;bar&quot;].iter().map(|&amp;s| s.to_string() );
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="311-特质"><a class="header" href="#311-特质">3.11 特质</a></h1>
<p>特质就是指 trait。在 Rust 中， trait 不是具体类型，而是一种抽象接口。但是通过 <code>impl Trait</code> 和 <code>dyn Trait</code> 也可以将 trait 作为类型使用。</p>
<h2 id="列表-23"><a class="header" href="#列表-23">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./traits/P.TRA.01.html">P.TRA.01 使用 trait 时要注意 trait 一致性规则</a></li>
<li><a href="safe-guides/coding_practice/./traits/std-builtin.html">标准库内置 trait</a>
<ul>
<li><a href="safe-guides/coding_practice/./traits/std-builtin/P.TRA.BLN.01.html">P.TRA.BLN.01 在实现<code>Borrow</code>特质时，需要注意一致性</a></li>
<li><a href="safe-guides/coding_practice/./traits/std-builtin/G.TRA.BLN.01.html">G.TRA.BLN.01 应该具体类型的 <code>default()</code> 方法代替 <code>Default::default()</code> 调用</a></li>
<li><a href="safe-guides/coding_practice/./traits/std-builtin/G.TRA.BLN.02.html">G.TRA.BLN.02 不要为迭代器实现Copy特质</a></li>
<li><a href="safe-guides/coding_practice/./traits/std-builtin/G.TRA.BLN.03.html">G.TRA.BLN.03 能使用派生宏（Derive）自动实现Default特质就不要用手工实现</a></li>
<li><a href="safe-guides/coding_practice/./traits/std-builtin/G.TRA.BLN.04.html">G.TRA.BLN.04 在使用<code>#[derive(Hash)]</code>的时候，避免再手工实现<code>PartialEq</code></a></li>
<li><a href="safe-guides/coding_practice/./traits/std-builtin/G.TRA.BLN.05.html">G.TRA.BLN.05 在使用<code>#[derive(Ord)]</code> 的时候，避免再手工实现 <code>PartialOrd</code></a></li>
<li><a href="safe-guides/coding_practice/./traits/std-builtin/G.TRA.BLN.06.html">G.TRA.BLN.06 不要对实现 <code>Copy</code> 或引用类型调用 <code>std::mem::drop</code> 和 <code>std::mem::forgot</code></a></li>
<li><a href="safe-guides/coding_practice/./traits/std-builtin/G.TRA.BLN.07.html">G.TRA.BLN.07 对实现 <code>Copy</code> 的可迭代类型来说，要通过迭代器拷贝其所有元素时，应该使用 <code>copied</code>方法，而非<code>cloned</code></a></li>
<li><a href="safe-guides/coding_practice/./traits/std-builtin/G.TRA.BLN.08.html">G.TRA.BLN.08 实现 <code>From</code> 而不是 <code>Into</code></a></li>
<li><a href="safe-guides/coding_practice/./traits/std-builtin/G.TRA.BLN.09.html">G.TRA.BLN.09 一般情况下不要给 <code>Copy</code> 类型手工实现 <code>Clone</code></a></li>
<li><a href="safe-guides/coding_practice/./traits/std-builtin/G.TRA.BLN.10.html">G.TRA.BLN.10 不要随便使用Deref特质来模拟继承</a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./traits/trait-object.html">trait 对象</a>
<ul>
<li><a href="safe-guides/coding_practice/./traits/trait-object/P.TRA.OBJ.01.html">P.TRA.OBJ.01 根据场景合理选择使用trait对象或泛型静态分发</a></li>
<li><a href="safe-guides/coding_practice/./traits/trait-object/P.TRA.OBJ.02.html">P.TRA.OBJ.02 除非必要，避免自定义虚表</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptra01--使用-trait-时要注意-trait-一致性规则"><a class="header" href="#ptra01--使用-trait-时要注意-trait-一致性规则">P.TRA.01  使用 trait 时要注意 trait 一致性规则</a></h2>
<p><strong>【描述】</strong></p>
<p>使用 trait 的时候，必须要满足 trait 一致性规则，即，<strong>孤儿规则（orphans rule）</strong>：类型和trait，必须有一个是在本地crate内定义的。
当不满足古尔规则时，可以考虑使用<code>NewType</code>模式来解决问题。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// String 和 FromStr都在标准库中被定义
// 如果想给String实现FromStr，则编译器会报错，告诉你这违反孤儿规则
// （虽然标准库内已经为string实现了FromStr,这里只是示例）
// 但是通过使用NewType，我们可以间接的达成目标
// 使用这种单个元素的元组结构体包装一个类型就叫NewType模式。
pub struct PhoneNumber(String);

use std::str::FromStr;
impl FromStr for PhoneNumber {
    type Err = Box&lt;dyn std::error::Error&gt;;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        Ok(PhoneNumber(s.to_string()))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>-</td><td>no</td><td>yes</td><td>-</td><td>-</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内置-trait"><a class="header" href="#内置-trait">内置 trait</a></h1>
<p>Rust 标准库内置了很多 trait，在使用这些 trait 的时候也需要注意。</p>
<h2 id="列表-24"><a class="header" href="#列表-24">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/P.TRA.BLN.01.html">P.TRA.BLN.01 在实现<code>Borrow</code>特质时，需要注意一致性</a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.01.html">G.TRA.BLN.01 应该具体类型的 <code>default()</code> 方法代替 <code>Default::default()</code> 调用</a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.02.html">G.TRA.BLN.02 不要为迭代器实现Copy特质</a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.03.html">G.TRA.BLN.03 能使用派生宏（Derive）自动实现Default特质就不要用手工实现</a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.04.html">G.TRA.BLN.04 在使用<code>#[derive(Hash)]</code>的时候，避免再手工实现<code>PartialEq</code></a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.05.html">G.TRA.BLN.05 在使用<code>#[derive(Ord)]</code> 的时候，避免再手工实现 <code>PartialOrd</code></a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.06.html">G.TRA.BLN.06 不要对实现 <code>Copy</code> 或引用类型调用 <code>std::mem::drop</code> 和 <code>std::mem::forgot</code></a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.07.html">G.TRA.BLN.07 对实现 <code>Copy</code> 的可迭代类型来说，要通过迭代器拷贝其所有元素时，应该使用 <code>copied</code>方法，而非<code>cloned</code></a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.08.html">G.TRA.BLN.08 实现 <code>From</code> 而不是 <code>Into</code></a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.09.html">G.TRA.BLN.09 一般情况下不要给 <code>Copy</code> 类型手工实现 <code>Clone</code></a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.10.html">G.TRA.BLN.10 不要随便使用Deref特质来模拟继承</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptrabln01--在实现borrow特质时需要注意一致性"><a class="header" href="#ptrabln01--在实现borrow特质时需要注意一致性">P.TRA.BLN.01  在实现<code>Borrow</code>特质时，需要注意一致性</a></h2>
<p><strong>【描述】</strong></p>
<p>当你想把不同类型的借用进行统一抽象，或者当你要建立一个数据结构，以同等方式处理自拥有值（ownered）和借用值（borrowed）时，例如散列（hash）和比较（compare）时，选择<code> Borrow</code>。当把某个类型直接转换为引用，选择 <code>AsRef</code> 。</p>
<p>但是使用 <code>Borrow</code> 的时候，需要注意一致性问题。具体请看示例。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这个结构体能不能作为 HashMap 的 key？
pub struct CaseInsensitiveString(String);

// 它实现 Eq 没有问题
impl  PartialEq for CaseInsensitiveString {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
       // 但这里比较是要求忽略了 ascii 大小写
        self.0.eq_ignore_ascii_case(&amp;other.0)
    }
}

impl Eq for CaseInsensitiveString { }

// 实现 Hash 没有问题
// 但因为 eq 忽略大小写，那么 hash 计算也必须忽略大小写
impl Hash for CaseInsensitiveString {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        for c in self.0.as_bytes() {
            // 没有忽略大小写
            c.to_ascii_lowercase().hash(state)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这种情况下，就不能为 <code>CaseInsensitiveString</code> 实现 <code>Borrow</code>，并非编译不通过，而是在逻辑上不应该为其实现 <code>Borrow</code>，因为  <code>CaseInsensitiveString</code>  实现 <code>Eq</code> 和 <code>Hash</code> 的行为不一致，而 <code>HashMap</code> 则要求 <code>Key</code> 必须 <code>Hash</code> 和 <code>Eq</code> 的实现一致。这种不一致，编译器无法检查，所以在逻辑上，就不应该为其实现 <code>Borrow</code>。如果强行实现，那可能会出现逻辑 Bug。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtrabln01---应该具体类型的-default-方法代替--defaultdefault-调用"><a class="header" href="#gtrabln01---应该具体类型的-default-方法代替--defaultdefault-调用">G.TRA.BLN.01   应该具体类型的 <code>default()</code> 方法代替 <code> Default::default()</code> 调用</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>为了增强可读性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: String = Default::default();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::default();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#default_trait_access">default_trait_access</a></td><td>yes</td><td>no</td><td><strong>pedantic</strong></td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtrabln02---不要为迭代器实现copy-特质"><a class="header" href="#gtrabln02---不要为迭代器实现copy-特质">G.TRA.BLN.02   不要为迭代器实现<code>Copy</code> 特质</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>不要为迭代器实现 <code>Copy</code> 特质，因为一般会存在有改变状态的迭代器，如果实现 <code>Copy</code>，则可能会被意外隐式复制，违反 Rust 编译器可变借用独占原则，可能会导致一些意外行为。</p>
<p>所以，通常可以只为迭代器实现 <code>Clone</code>，需要复制的时候显式拷贝，如果出现问题也容易排查。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::marker::PhantomData;

#[derive(Debug)]
struct ABC {
    a: [i32; 3],
    b: [i32; 3],
    c: [i32; 3],
}

impl ABC {
    fn iter_mut(&amp;mut self) -&gt; ABCIterMut {
        ABCIterMut {
            abc: self,
            index: 0,
            _phantom: PhantomData::default(),
        }
    }

}

// 这里为迭代器 ABCIterMut&lt;'a&gt;  实现 Copy 
#[derive(Copy, Clone)]
struct ABCIterMut&lt;'a&gt; {
    abc: *mut ABC,
    index: u8,
    _phantom: PhantomData&lt;&amp;'a mut ABC&gt;,
}

impl&lt;'a&gt; Iterator for ABCIterMut&lt;'a&gt; {
    type Item = &amp;'a mut [i32; 3];
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {

        let value = unsafe {
            match self.index {
                0 =&gt; &amp;mut (*self.abc).a,
                1 =&gt; &amp;mut (*self.abc).b,
                2 =&gt; &amp;mut (*self.abc).c,
                _ =&gt; return None
            }
        };
        self.index += 1;
        Some(value)
    }
}

fn main(){
    let mut abc = ABC{a: [1; 3], b: [2;3], c: [3;3]};
    let mut abc_iter_mut = abc.iter_mut();


    // 因为实现 Copy，迭代器这里会隐式复制，返回结构体内部字段可变借用
    for i in abc_iter_mut {
        // Do Something
    }

    // 因为实现 Copy，迭代器这里会隐式复制，返回结构体内部字段可变借用
    // 存在意外风险而不容易被发现
    for i in abc_iter_mut {
        // Do Something
    }

}
</code></pre></pre>
<p>另外，对于标准库里的 <code>Range&lt;T&gt;</code> 就不能实现 Copy，因为它也是一个迭代器。</p>
<p>细节可以参考来自官方讨论： <a href="https://github.com/rust-lang/rust/pull/27186#issuecomment-123390413">https://github.com/rust-lang/rust/pull/27186#issuecomment-123390413</a></p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::marker::PhantomData;

#[derive(Debug)]
struct ABC {
    a: [i32; 3],
    b: [i32; 3],
    c: [i32; 3],
}

impl ABC {
    fn iter_mut(&amp;mut self) -&gt; ABCIterMut {
        ABCIterMut {
            abc: self,
            index: 0,
            _phantom: PhantomData::default(),
        }
    }

}

// 不实现 Copy
// 在需要的时候只实现 Clone
#[derive(Clone)]
struct ABCIterMut&lt;'a&gt; {
    abc: *mut ABC,
    index: u8,
    _phantom: PhantomData&lt;&amp;'a mut ABC&gt;,
}

impl&lt;'a&gt; Iterator for ABCIterMut&lt;'a&gt; {
    type Item = &amp;'a mut [i32; 3];
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {

        let value = unsafe {
            match self.index {
                0 =&gt; &amp;mut (*self.abc).a,
                1 =&gt; &amp;mut (*self.abc).b,
                2 =&gt; &amp;mut (*self.abc).c,
                _ =&gt; return None
            }
        };
        self.index += 1;
        Some(value)
    }
}

fn main(){
    let mut abc = ABC{a: [1; 3], b: [2;3], c: [3;3]};
    let mut abc_iter_mut = abc.iter_mut();

    // 因为只实现了 Clone
    // 需要用多次迭代器的时候，显式调用 clone() 方法，
    // 开发者可以明确地知道自己在做什么
    for i in abc_iter_mut.clone() {
        println!(&quot;{i:?}&quot;);
    }

    for i in abc_iter_mut {
        println!(&quot;{i:?}&quot;)
    }

}

</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#copy_iterator">copy_iterator</a></td><td>yes</td><td>no</td><td><strong>pedantic</strong></td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtrabln03---能使用派生宏derive自动实现default特质就不要用手工实现"><a class="header" href="#gtrabln03---能使用派生宏derive自动实现default特质就不要用手工实现">G.TRA.BLN.03   能使用派生宏（Derive）自动实现<code>Default</code>特质就不要用手工实现</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>手工实现 Default，代码不精炼。 </p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    bar: bool
}

impl std::default::Default for Foo {
    fn default() -&gt; Self {
        Self {
            bar: false
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct Foo {
    bar: bool
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#derivable_impls">derivable_impls</a></td><td>yes</td><td>no</td><td><strong>complexity</strong></td><td>warn</td></tr>
</tbody></table>
<p>该lint不能用于检测泛型参数类型的 Default 手工实现。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtrabln04---在使用derivehash-的时候避免再手工实现-partialeq"><a class="header" href="#gtrabln04---在使用derivehash-的时候避免再手工实现-partialeq">G.TRA.BLN.04   在使用<code>#[derive(Hash)]</code> 的时候，避免再手工实现 <code>PartialEq</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>实现 Hash 和 Eq 必须要满足下面一个等式：</p>
<pre><code class="language-text">k1 == k2  -&gt; hash(k1) == hash(k2)
</code></pre>
<p>即，当<code>k1</code> 和 <code>k2</code> 相等时，<code>hash(k1)</code>也应该和 <code>hash(k2)</code> 相等。  所以要求 <code>PartialEq</code> / <code>Eq</code> / <code>Hash</code>  的实现必须保持一致。 </p>
<p>如果用 <code>#[derive(Hash)]</code> 的时候，搭配了一个手工实现的 <code>PartialEq</code> 就很可能出现不一致的情况。</p>
<p>但也有例外。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Hash)]
struct Foo;

impl PartialEq for Foo {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Eq, Hash)]
struct Foo;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://docs.rs/crate/blsttc/3.3.0/source/src/lib.rs

// Clippy warns that it's dangerous to derive `PartialEq` and explicitly implement `Hash`, but the
// `pairing::bls12_381` types don't implement `Hash`, so we can't derive it.
#![allow(clippy::derive_hash_xor_eq)]
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#derive_hash_xor_eq">derive_hash_xor_eq</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtrabln05---在使用deriveord-的时候避免再手工实现-partialord"><a class="header" href="#gtrabln05---在使用deriveord-的时候避免再手工实现-partialord">G.TRA.BLN.05   在使用<code>#[derive(Ord)]</code> 的时候，避免再手工实现 <code>PartialOrd</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>跟实现 Hash 和 Eq 的要求类似，对于实现<code> Ord</code> 的类型来说，必须要满足下面一个等式：</p>
<pre><code class="language-text">k1.cmp(&amp;k2) == k1.partial_cmp(&amp;k2).unwrap()
</code></pre>
<p>所以要求与  <code>PartialOrd</code>   的实现必须保持一致，并确保<code>max</code>、<code>min</code>和<code>clamp</code>与<code>cmp</code>一致。</p>
<p>通过<code>#[derive(Ord)]</code> 并手动实现<code>PartialOrd</code>，很容易意外地使cmp和partial_cmp不一致。</p>
<p>但也有例外。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Ord, PartialEq, Eq)]
struct Foo;

impl PartialOrd for Foo {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Ord, PartialOrd, PartialEq, Eq)]
struct Foo;

// or

#[derive(PartialEq, Eq)]
struct Foo;

impl PartialOrd for Foo {
    fn partial_cmp(&amp;self, other: &amp;Foo) -&gt; Option&lt;Ordering&gt; {
       Some(self.cmp(other))
    }
}

impl Ord for Foo {
    ...
}

<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>使用 <code>#[derive(PartialOrd)]</code> 自动实现 <code>PartialOrd</code>，然后再手工实现 <code>Ord</code>的时候在内部调用自动实现的<code>partial_cmp</code> ，应该是满足 <code>k1.cmp(&amp;k2) == k1.partial_cmp(&amp;k2).unwrap()</code> 了。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://docs.rs/crate/adventjson/0.1.1/source/src/lib.rs
#[derive(Clone, Debug, PartialEq, PartialOrd)]
pub enum JsonObject
{
    /// An array of objects (e.g.: \[1,2,3\])
    Array(Vec&lt;Self&gt;),
    /// Key-value pairs (e.g.: {\&quot;first\&quot;: 10, \&quot;other\&quot;: 15})
    Obj(Vec&lt;(String, Self)&gt;),
    /// A number (e.g.: -0.08333)
    Number(f64),
    /// A string (e.g.: \&quot;Test: \\\&quot;\&quot;)
    JsonStr(String),
    /// A boolean (e.g. true)
    Bool(bool),
    /// The null-value
    Null,
}

/// Save because no not-number values are allowed in json
impl Eq for JsonObject {}

/// Save because no not-number values are allowed in json
#[allow(clippy::derive_ord_xor_partial_ord)]
impl Ord for JsonObject
{
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering
    {
        self.partial_cmp(other).unwrap()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#derive_ord_xor_partial_ord">derive_ord_xor_partial_ord</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtrabln06----不要对实现-copy--或引用类型调用--stdmemdrop-和-stdmemforgot"><a class="header" href="#gtrabln06----不要对实现-copy--或引用类型调用--stdmemdrop-和-stdmemforgot">G.TRA.BLN.06    不要对实现 <code>Copy</code>  或引用类型调用  <code>std::mem::drop</code> 和 <code>std::mem::forgot</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p><code>std::mem::drop</code> 函数只是利用 Rust 所有权的一个技巧，对于 实现了 Copy 的类型 或引用，是无效的。如果使用它，对导致代码可读方便产生误导作用。</p>
<p>另外<code>std::mem::drop</code> 也无法 Drop 掉 <code>ManuallyDrop</code> 类型。</p>
<p><code>std::mem::forgot</code>   同理。</p>
<p>但是也存在例外的情况。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32 = 42; // i32 implements Copy
std::mem::drop(x) // A copy of x is passed to the function, leaving the
                  // original unaffected
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>在某些情况下，虽然不会有实际效果，但是为了提升语义，也可以使用。</p>
<p>下面代码中，为了防止自引用的问题，使用 <code>drop(self)</code> ，提升了代码语义，但实际并不会 drop。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://docs.rs/crate/dhall/0.10.1/source/src/error/builder.rs

#[allow(clippy::drop_ref)]
pub fn format(&amp;mut self) -&gt; String {
    if self.consumed {
        panic!(&quot;tried to format the same ErrorBuilder twice&quot;)
    }
    let this = std::mem::take(self);
    self.consumed = true;
    drop(self); // Get rid of the self reference so we don't use it by mistake.
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#drop_copy">drop_copy</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#drop_ref">drop_ref</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#forget_copy">forget_copy</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#forget_ref">forget_ref</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#undropped_manually_drops">undropped_manually_drops</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtrabln07---对实现-copy-的可迭代类型来说要通过迭代器拷贝其所有元素时应该使用-copied方法而非cloned"><a class="header" href="#gtrabln07---对实现-copy-的可迭代类型来说要通过迭代器拷贝其所有元素时应该使用-copied方法而非cloned">G.TRA.BLN.07   对实现 <code>Copy</code> 的可迭代类型来说，要通过迭代器拷贝其所有元素时，应该使用 <code>copied</code>方法，而非<code>cloned</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p><code>copied</code> 方法在语义层面，是针对实现 <code>Copy</code> 的类型，所以应该使用 <code>copied</code> 来增加代码可读性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3];

let v_copied: Vec&lt;_&gt; = a.iter().cloned().collect();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3];

let v_copied: Vec&lt;_&gt; = a.iter().copied().collect();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cloned_instead_of_copied">cloned_instead_of_copied</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtrabln08-实现-from-而不是-into"><a class="header" href="#gtrabln08-实现-from-而不是-into">G.TRA.BLN.08 实现 <code>From</code> 而不是 <code>Into</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>优先为类型实现 <code>From</code> 而非 <code>Into</code>。因为实现了 <code>From</code>，<code>Into</code> 也会被自动实现。并且在错误处理的时候，<code>?</code> 操作符会通过调用 <code>From</code> 实现自动进行错误类型转换。</p>
<p>但是在泛型限定上，优先 <code>Into</code> 。</p>
<p>当然，也存在例外。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StringWrapper(String);

impl Into&lt;StringWrapper&gt; for String {
    fn into(self) -&gt; StringWrapper {
        StringWrapper(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StringWrapper(String);

impl From&lt;String&gt; for StringWrapper {
    fn from(s: String) -&gt; StringWrapper {
        StringWrapper(s)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>有两类情况，可以直接实现 <code>Into</code>。</p>
<ol>
<li><code>Into</code> 不提供 <code>From</code> 实现。在一些场景中，<code>From</code>  自动实现的 <code>Into</code> 并不符合转换需求。</li>
<li>使用 <code>Into</code> 来跳过孤儿规则。</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 第一种情况。 
// From： https://github.com/apache/arrow-datafusion/blob/master/ballista/rust/core/src/serde/scheduler/from_proto.rs
#[allow(clippy::from_over_into)]
impl Into&lt;PartitionStats&gt; for protobuf::PartitionStats {
    fn into(self) -&gt; PartitionStats {
        PartitionStats::new(
            foo(self.num_rows),
            foo(self.num_batches),
            foo(self.num_bytes),
        )
    }
}

// From： https://github.com/apache/arrow-datafusion/blob/master/ballista/rust/core/src/serde/scheduler/to_proto.rs
#[allow(clippy::from_over_into)]
impl Into&lt;protobuf::PartitionStats&gt; for PartitionStats {
    fn into(self) -&gt; protobuf::PartitionStats {
        let none_value = -1_i64;
        protobuf::PartitionStats {
            num_rows: self.num_rows.map(|n| n as i64).unwrap_or(none_value),
            num_batches: self.num_batches.map(|n| n as i64).unwrap_or(none_value),
            num_bytes: self.num_bytes.map(|n| n as i64).unwrap_or(none_value),
            column_stats: vec![],
        }
    }
}

// 第二种情况
// 根据孤儿规则，trait 和 类型必须有一个在本地定义，所以不能为 Vec&lt;T&gt; 实现 From trait
struct Wrapper&lt;T&gt;(Vec&lt;T&gt;);
impl&lt;T&gt; From&lt;Wrapper&lt;T&gt;&gt; for Vec&lt;T&gt; {
    fn from(w: Wrapper&lt;T&gt;) -&gt; Vec&lt;T&gt; {
        w.0
    }
}
// 但是通过 Into&lt;Vec&lt;T&gt;&gt; ，就可以绕过这个规则
struct Wrapper&lt;T&gt;(Vec&lt;T&gt;);
impl&lt;T&gt; Into&lt;Vec&lt;T&gt;&gt; for Wrapper&lt;T&gt; {
    fn into(self) -&gt; Vec&lt;T&gt; {
        self.0
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#from_over_into">from_over_into</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtrabln09---一般情况下不要给-copy-类型手工实现-clone"><a class="header" href="#gtrabln09---一般情况下不要给-copy-类型手工实现-clone">G.TRA.BLN.09   一般情况下不要给 Copy 类型手工实现 Clone</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>手工为 Copy 类型实现 Clone ，并不能改变 Copy 类型的行为。除非你显式地去调用 <code>clone()</code>方法。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy)]
struct Foo;

impl Clone for Foo {
    // ..
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone)]
struct Foo;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>在有些情况下，需要手动实现 Copy 和 Clone 。 相关 issues : <a href="https://github.com/rust-lang/rust/issues/26925">https://github.com/rust-lang/rust/issues/26925</a> </p>
<pre><pre class="playground"><code class="language-rust">use std::marker::PhantomData;

struct Marker&lt;A&gt;(PhantomData&lt;A&gt;);

// 如果使用 Derive 自动实现的话，会要求 Marker&lt;A&gt; 里的 A 也必须实现 Clone
// 这里通过手工给 Marker&lt;A&gt; 实现 Copy 和 Clone 可以避免这种限制
impl&lt;A&gt; Copy for Marker&lt;A&gt; {}
impl&lt;A&gt; Clone for Marker&lt;A&gt; {
    fn clone(&amp;self) -&gt; Self {
        *self
    }
}

// 不需要给 NoClone 实现 Clone
struct NoClone;
fn main() {
    let m: Marker&lt;NoClone&gt; = Marker(PhantomData);
    let m2 = m.clone();
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#expl_impl_clone_on_copy">expl_impl_clone_on_copy</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptrabln01-不要随便使用deref特质来模拟继承"><a class="header" href="#ptrabln01-不要随便使用deref特质来模拟继承">P.TRA.BLN.01 不要随便使用<code>Deref</code>特质来模拟继承</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p><code>Deref</code> trait是专门用于实现自定义指针类型而存在的。虽然可以实现 <code>Deref</code> 来达到某种类似于继承的行为，但 Rust 中不推荐这样做。</p>
<p>这是因为 Rust 语言推崇显式的转换，而 <code>Deref</code> 则是 Rust 中为数不多的隐式行为。如果 <code>Deref</code> 被滥用，那么程序中隐式行为可能会增多，隐式的转换是 Bug 的温床。</p>
<p><strong>【反例】</strong>
不要像下面这样用<code>Deref</code>来模拟继承。</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

struct Foo {}

impl Foo {
    fn m(&amp;self) {
        // ...
    }
}

struct Bar {
    f: Foo
}

impl Deref for Bar {
    type Target = Foo;

    fn deref(&amp;self) -&gt; &amp;Foo {
        &amp;self.f
    }
}

fn main() {
    let bar = Bar { f: Foo {} };
    bar.m();
}

</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>-</td><td>no</td><td>no</td><td>-</td><td>yes</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-对象"><a class="header" href="#trait-对象">trait 对象</a></h1>
<p>trait 对象需要注意 动态安全 （dyn safe），也叫对象安全 （object safe），但官方现在倾向于 动态安全这个术语。</p>
<h2 id="列表-25"><a class="header" href="#列表-25">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/traits/./trait-object/P.TRA.OBJ.01.html">P.TRA.OBJ.01 根据场景合理选择使用trait对象或泛型静态分发</a></li>
<li><a href="safe-guides/coding_practice/traits/./trait-object/P.TRA.OBJ.02.html">P.TRA.OBJ.02 除非必要，避免自定义虚表</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptraobj01--根据场景合理选择使用trait对象或泛型静态分发"><a class="header" href="#ptraobj01--根据场景合理选择使用trait对象或泛型静态分发">P.TRA.OBJ.01  根据场景合理选择使用trait对象或泛型静态分发</a></h2>
<p><strong>【描述】</strong></p>
<p>trait对象存在一定运行时开销，除非必要，不要滥用，但triat对象也可以避免编译文件大小膨胀。</p>
<p>在性能有严格要求的情况下，可以考虑<code>Enum</code>或泛型静态分发代替。</p>
<p><strong>【正例】</strong></p>
<p>使用 Enum 代替 trait 对象。 示例来自于 <a href="https://docs.rs/enum_dispatch/0.3.7/enum_dispatch/">enum_dispatch</a></p>
<pre><pre class="playground"><code class="language-rust">trait KnobControl {
    fn set_position(&amp;mut self, value: f64);
    fn get_value(&amp;self) -&gt; f64;
}

struct LinearKnob {
    position: f64,
}

struct LogarithmicKnob {
    position: f64,
}

impl KnobControl for LinearKnob {
    fn set_position(&amp;mut self, value: f64) {
        self.position = value;
    }

    fn get_value(&amp;self) -&gt; f64 {
        self.position
    }
}

impl KnobControl for LogarithmicKnob {
    fn set_position(&amp;mut self, value: f64) {
        self.position = value;
    }

    fn get_value(&amp;self) -&gt; f64 {
        (self.position + 1.).log2()
    }
}

fn main() {
    // 这里使用 trait 对象
    let v: Vec&lt;Box&lt;dyn KnobControl&gt;&gt; = vec![
        //set the knobs
    ];

    //use the knobs
}
</code></pre></pre>
<p>用 Enum 代替：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Knob {
    Linear(LinearKnob),
    Logarithmic(LogarithmicKnob),
}

impl KnobControl for Knob {
    fn set_position(&amp;mut self, value: f64) {
        match self {
            Knob::Linear(inner_knob) =&gt; inner_knob.set_position(value),
            Knob::Logarithmic(inner_knob) =&gt; inner_knob.set_position(value),
        }
    }

    fn get_value(&amp;self) -&gt; f64 {
        match self {
            Knob::Linear(inner_knob) =&gt; inner_knob.get_value(),
            Knob::Logarithmic(inner_knob) =&gt; inner_knob.get_value(),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>性能有显著提高，但是牺牲了维护成本。可以借助于宏来自动生成相关代码，参见： <a href="https://docs.rs/enum_dispatch/0.3.7/enum_dispatch/">enum_dispatch</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptraobj02--除非必要避免自定义虚表"><a class="header" href="#ptraobj02--除非必要避免自定义虚表">P.TRA.OBJ.02  除非必要，避免自定义虚表</a></h2>
<p><strong>【描述】</strong></p>
<p>trait 对象 <code>dyn Trait</code> 隐藏了复杂而又为危险的虚表实现，为我们提供了简单而又安全的动态分发。手动实现虚表的代码中充斥着大量的 <code>unsafe</code>，稍有不慎，就会引入 bug 。如无必要，不要自定义虚表。</p>
<p>如果你的设计不能使用标准的 <code>dyn Trait</code> 结构来表达，那么你首先应该尝试重构你的程序，并参考以下理由来决定是否使用自定义的虚表。</p>
<ul>
<li>你想要为一类指针对象实现多态，并且无法忍受多级指针解引用造成的性能开销，参考 <a href="https://doc.rust-lang.org/std/task/struct.RawWaker.html">RawWaker</a> 与 <a href="https://docs.rs/bytes/1.1.0/bytes/struct.Bytes.html">Bytes</a>。</li>
<li>你想要自定义内存布局，比如像 C++ 中虚表一样紧凑的内存结构（虚表指针位于对象内），参考 <a href="https://github.com/tokio-rs/tokio/blob/master/tokio/src/runtime/task/raw.rs#L12">RawTask</a>。</li>
<li>你的 crate 需要在 <code>no_std</code> 环境中使用动态分发，参考 <a href="https://doc.rust-lang.org/std/task/struct.RawWaker.html">RawWaker</a>  。</li>
<li>或者，标准的 trait object 确实无法实现你的需求。</li>
</ul>
<p><strong>【正例】</strong></p>
<p>来自标准库中 <a href="https://doc.rust-lang.org/std/task/struct.RawWaker.html">RawWaker</a> 的定义。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub struct RawWaker {
    /// A data pointer, which can be used to store arbitrary data as required
    /// by the executor. This could be e.g. a type-erased pointer to an `Arc`
    /// that is associated with the task.
    /// The value of this field gets passed to all functions that are part of
    /// the vtable as the first parameter.
    data: *const (),
    /// Virtual function pointer table that customizes the behavior of this waker.
    vtable: &amp;'static RawWakerVTable,
}
#[derive(PartialEq, Copy, Clone, Debug)]
pub struct RawWakerVTable {
    /// This function will be called when the [`RawWaker`] gets cloned, e.g. when
    /// the [`Waker`] in which the [`RawWaker`] is stored gets cloned.
    ///
    /// The implementation of this function must retain all resources that are
    /// required for this additional instance of a [`RawWaker`] and associated
    /// task. Calling `wake` on the resulting [`RawWaker`] should result in a wakeup
    /// of the same task that would have been awoken by the original [`RawWaker`].
    clone: unsafe fn(*const ()) -&gt; RawWaker,

    /// This function will be called when `wake` is called on the [`Waker`].
    /// It must wake up the task associated with this [`RawWaker`].
    ///
    /// The implementation of this function must make sure to release any
    /// resources that are associated with this instance of a [`RawWaker`] and
    /// associated task.
    wake: unsafe fn(*const ()),

    /// This function will be called when `wake_by_ref` is called on the [`Waker`].
    /// It must wake up the task associated with this [`RawWaker`].
    ///
    /// This function is similar to `wake`, but must not consume the provided data
    /// pointer.
    wake_by_ref: unsafe fn(*const ()),

    /// This function gets called when a [`RawWaker`] gets dropped.
    ///
    /// The implementation of this function must make sure to release any
    /// resources that are associated with this instance of a [`RawWaker`] and
    /// associated task.
    drop: unsafe fn(*const ()),
}
<span class="boring">}
</span></code></pre></pre>
<p>来自 <a href="https://docs.rs/bytes/1.1.0/bytes/struct.Bytes.html">Bytes</a> 的示例。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Bytes {
    ptr: *const u8,
    len: usize,
    // inlined &quot;trait object&quot;
    data: AtomicPtr&lt;()&gt;,
    vtable: &amp;'static Vtable,
}

pub(crate) struct Vtable {
    /// fn(data, ptr, len)
    pub clone: unsafe fn(&amp;AtomicPtr&lt;()&gt;, *const u8, usize) -&gt; Bytes,
    /// fn(data, ptr, len)
    pub drop: unsafe fn(&amp;mut AtomicPtr&lt;()&gt;, *const u8, usize),
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="312-错误处理"><a class="header" href="#312-错误处理">3.12 错误处理</a></h1>
<p>Rust 为了保证系统健壮性，将系统中出现的非正常情况划分为三大类：</p>
<ol>
<li>失败</li>
<li>错误</li>
<li>异常</li>
</ol>
<p>Rust 语言针对这三类非正常情况分别提供了专门的处理方式，让开发者可以分情况去选择。</p>
<ul>
<li>对于失败的情况，可以使用断言工具。</li>
<li>对于错误，Rust 提供了基于返回值的分层错误处理方式，比如 Option 可以用来处理可能存在空值的情况，而 Result 就专门用来处理可以被合理解决并需要传播的错误。</li>
<li>对于异常，Rust 将其看作无法被合理解决的问题，提供了线程恐慌机制，在发生异常的时候，线程可以安全地退出。</li>
</ul>
<h2 id="列表-26"><a class="header" href="#列表-26">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./error-handle/P.ERR.01.html">P.ERR.01 当传入函数的参数值因为超出某种限制可能会导致函数调用失败，应该使用断言</a></li>
<li><a href="safe-guides/coding_practice/./error-handle/P.ERR.03.html">P.ERR.02 在确定 <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code>类型的值不可能是 <code>None</code> 或 <code>Err </code>时，请用 <code>expect</code> 代替 <code>unwrap()</code></a></li>
<li><a href="safe-guides/coding_practice/./error-handle/G.ERR.01.html">G.ERR.01 在处理 <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code> 类型时，不要随便使用 <code>unwrap</code></a></li>
<li><a href="safe-guides/coding_practice/./error-handle/G.ERR.02.html">G.ERR.02 不要滥用 <code>expect</code>，请考虑用 <code>unwrap_or_</code> 系列方法代替</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="perr01---当传入函数的参数值因为超出某种限制可能会导致函数调用失败应该使用断言"><a class="header" href="#perr01---当传入函数的参数值因为超出某种限制可能会导致函数调用失败应该使用断言">P.ERR.01   当传入函数的参数值因为超出某种限制可能会导致函数调用失败，应该使用断言</a></h2>
<p><strong>【描述】</strong></p>
<p>当传入函数的某个参数值可能因为超出某种限制，比如超出数组长度的索引、字符串是否包含某个字符、数组是否为空等，应该使用断言。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: std::vec::Vec::swap_remove
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
pub fn swap_remove(&amp;mut self, index: usize) -&gt; T {
    #[cold]
    #[inline(never)]
    fn assert_failed(index: usize, len: usize) -&gt; ! {
        panic!(&quot;swap_remove index (is {}) should be &lt; len (is {})&quot;, index, len);
    }

    let len = self.len();
   
    if index &gt;= len {
        // 此处使用断言方法，虽然不是标准库内置断言宏，但也是一种断言
        assert_failed(index, len);
    }
    unsafe {
        // We replace self[index] with the last element. Note that if the
        // bounds check above succeeds there must be a last element (which
        // can be self[index] itself).
        let last = ptr::read(self.as_ptr().add(len - 1));
        let hole = self.as_mut_ptr().add(index);
        self.set_len(len - 1);
        ptr::replace(hole, last)
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="perr05--在确定--optiont-和-resultt-e类型的值不可能是-none-或-err-时请用---expect-代替--unwrap"><a class="header" href="#perr05--在确定--optiont-和-resultt-e类型的值不可能是-none-或-err-时请用---expect-代替--unwrap">P.ERR.05  在确定  <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code>类型的值不可能是 <code>None</code> 或 <code>Err</code> 时，请用   <code>expect</code> 代替  <code>unwrap()</code></a></h2>
<p><strong>【描述】</strong></p>
<p>当需要处理的   <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code> 类型的值，永远都不可能是 <code>None</code> 或 <code>Err</code> 时，虽然直接 <code>unwrap()</code> 也是可以的，但使用 <code>expect</code> 会有更加明确的语义。</p>
<blockquote>
<p><code>expect</code> 的语义： </p>
<p>我不打算处理 <code>None</code> 或 <code>Err</code> 这种可能性，因为我知道这种可能性永远不会发生，或者，它不应该发生。但是 类型系统并不知道它永远不会发生。所以，我需要像类型系统保证，如果它确实发生了，它可以认为是一种错误，并且程序应该崩溃，并带着可以用于跟踪和修复该错误的栈跟踪信息。</p>
</blockquote>
<p>所以在指定 <code>expect</code> 输出消息的时候，请使用肯定的描述，而非否定，用于提升可读性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 这个配置文件默认会跟随源码出现，所以，必定可以读取到
// 这个配置文件不应该没有被提供，如果万一出现了没有提供的情况，需要 Panic ，但这里并没有提供错误信息，对于调试或使用都没有帮助
let config = Config::read(&quot;some_config.toml&quot;).unwrap();

// or
// expect 的输出描述使用否定式内容，可读性不好
let config = Config::read(&quot;some_config.toml&quot;).expect(&quot;No configuration file provided&quot;); 

// or

fn main() {
    use std::net::IpAddr;
    let _home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
}

// or
// expect 的输出描述使用否定式内容，可读性不好
fn main() {
    use std::net::IpAddr;
    let _home: IpAddr = &quot;127.0.0.1&quot;.parse().expect(&quot;IP addr parse failed!&quot;);
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 这个配置文件默认会跟随源码出现，所以，必定可以读取到
// 这个配置文件不应该没有被提供，如果万一出现了没有提供的情况，需要 Panic 并提供错误信息方便调试，或者让使用者知道原因
// expect 里输出的描述信息，使用肯定的内容，整体代码可读性更高，更能突出 expect 的语义
let config = Config::read(&quot;some_config.toml&quot;).expect(&quot;Provide the correct configuration file&quot;); 

// or

fn main() {
    use std::net::IpAddr;
    let _home: IpAddr = &quot;127.0.0.1&quot;.parse().expect(&quot;Provide the correct Ip addr&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gerr01--在处理-optiont-和-resultt-e-类型时不要随便使用-unwrap"><a class="header" href="#gerr01--在处理-optiont-和-resultt-e-类型时不要随便使用-unwrap">G.ERR.01  在处理 <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code> 类型时，不要随便使用 <code>unwrap</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>当 <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code>类型的值分别是 <code>None</code> 或 <code>Err</code> 时，直接对其 <code>unwrap()</code> 会导致程序恐慌！</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn select(opt: Option&lt;String&gt;) {
    opt.unwrap();  // 可以用 expect 方法来处理 None 的情况
}
// OR
fn select(opt: Result&lt;String, ()&gt;) {
    res.unwrap();  // 可以用 expect 方法来处理 Err 的情况
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn select(opt: Option&lt;String&gt;) {
    opt.expect(&quot;more helpful message&quot;);  // 可以用 expect 方法来处理 None 的情况
}
// OR
fn select(opt: Result&lt;String, ()&gt;) {
    res.expect(&quot;more helpful message&quot;);  // 可以用 expect 方法来处理 Err 的情况
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="lint-检测-1"><a class="header" href="#lint-检测-1">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#unwrap_used">unwrap_used</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gerr02----不要滥用-expect请考虑用-unwrap_or_-系列方法代替"><a class="header" href="#gerr02----不要滥用-expect请考虑用-unwrap_or_-系列方法代替">G.ERR.02    不要滥用 <code>expect</code>，请考虑用 <code>unwrap_or_</code> 系列方法代替</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>使用 <code>expect</code> 的时候请遵循 <code>expect</code> 的语义，不要滥用。参考 ： <strong>P.ERR.05</strong> 。</p>
<p>但是对于一些存在“副作用”的函数，在 遇到 <code>None</code> 或 <code>Err</code> 时，可能需要返回一些指定的值。这个时候用 <code>expect</code> 就不太符合语义。</p>
<p>如果你的用法完全符合 <code>expect</code> 语义，那么可以设置 <code>#![allow(clippy::expect_fun_call]</code></p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = Some(String::new());
let err_code = &quot;418&quot;;
let err_msg = &quot;I'm a teapot&quot;;
foo.expect(&amp;format!(&quot;Err {}: {}&quot;, err_code, err_msg)); 
// or
foo.expect(format!(&quot;Err {}: {}&quot;, err_code, err_msg).as_str());  
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = Some(String::new());
let err_code = &quot;418&quot;;
let err_msg = &quot;I'm a teapot&quot;;
foo.unwrap_or_else(|| panic!(&quot;Err {}: {}&quot;, err_code, err_msg));  // 你可以根据场景选择性使用 panic! 或者 不 panic!
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>完全符合 <code>expect</code> 语义的使用。</p>
<pre><pre class="playground"><code class="language-rust">#![allow(clippy::expect_fun_call]

// 这个配置文件默认会跟随源码出现，所以，必定可以读取到
// 这个配置文件不应该没有被提供，如果万一出现了没有提供的情况，需要 Panic 并提供错误信息方便调试，或者让使用者知道原因
let config = Config::read(&quot;some_config.toml&quot;).expect(&quot;Provide the correct configuration file&quot;); 

// or

fn main() {
    use std::net::IpAddr;
    let _home: IpAddr = &quot;127.0.0.1&quot;.parse().expect(&quot;Provide the correct Ip addr&quot;);
}
</code></pre></pre>
<h3 id="lint-检测-2"><a class="header" href="#lint-检测-2">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#expect_fun_call">expect_fun_call</a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#expect_used">expect_used</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="313-内存管理"><a class="header" href="#313-内存管理">3.13 内存管理</a></h1>
<h2 id="列表-27"><a class="header" href="#列表-27">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./memory/lifetime.html">生命周期</a>
<ul>
<li><a href="safe-guides/coding_practice/./memory/lifetime/P.MEM.LFT.01.html">P.MEM.LFT.01 生命周期参数命名尽量有意义且简洁</a></li>
<li><a href="safe-guides/coding_practice/./memory/lifetime/P.MEM.LFT.02.html">P.MEM.LFT.02 通常需要显式地标注生命周期，而非利用编译器推断</a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./memory/smart-ptr.html">智能指针</a>
<ul>
<li><a href="safe-guides/coding_practice/./memory/smart-ptr/P.MEM.SPT.01.html">P.MEM.SPT.01 使用 <code>RefCell&lt;T&gt;</code> 时宜使用 <code>try_borrow/try_borrow_mut</code> 方法</a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./memory/box.html">Box 类型</a>
<ul>
<li><a href="safe-guides/coding_practice/./memory/box/G.MEM.BOX.01.html">G.MEM.BOX.01 一般情况下，不应直接对 <code>Box&lt;T&gt;</code> 进行借用</a></li>
<li><a href="safe-guides/coding_practice/./memory/box/G.MEM.BOX.02.html">G.MEM.BOX.02 一般情况下，不应直接对已经在堆上分配内存的类型进行 Box 装箱</a></li>
<li><a href="safe-guides/coding_practice/./memory/box/G.MEM.BOX.03.html">G.MEM.BOX.03 一般情况下，不应直接对栈分配类型进行 Box 装箱</a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./memory/drop.html">Drop 析构</a>
<ul>
<li><a href="safe-guides/coding_practice/./memory/drop/G.MEM.DRP.01.html">G.MEM.DRP.01 要注意防范内存泄漏</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h1>
<p>生命周期（lifetime），也被叫做 生存期。可以理解为引用的有效范围。</p>
<h2 id="列表-28"><a class="header" href="#列表-28">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/memory/./lifetime/P.MEM.LFT.01.html">P.MEM.LFT.01 生命周期参数命名尽量有意义且简洁</a></li>
<li><a href="safe-guides/coding_practice/memory/./lifetime/P.MEM.LFT.02.html">P.MEM.LFT.02 通常需要显式地标注生命周期，而非利用编译器推断</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmemlft01-生命周期参数命名尽量有意义且简洁"><a class="header" href="#pmemlft01-生命周期参数命名尽量有意义且简洁">P.MEM.LFT.01 生命周期参数命名尽量有意义且简洁</a></h2>
<p><strong>【描述】</strong></p>
<p>生命周期参数的命名应该尽量简单，可以使用表达一定语义的缩写。</p>
<p>因为生命周期参数的目的是给编译器使用，用于防止函数中出现悬垂引用。</p>
<p>适当简单的携带语义的缩写，可以最小化对业务代码的干扰。并且在生命周期参数较多的情况下，清晰地表达具体哪个引用属于哪个生命周期。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ConstraintGeneration&lt;'a, 'b, 'c&gt; {
    infcx: &amp;'c InferCtxt&lt;'b, 'c&gt;,
    all_facts: &amp;'a mut Option&lt;AllFacts&gt;,
    location_table: &amp;'a LocationTable,
    liveness_constraints: &amp;'a mut LivenessValues&lt;RegionVid&gt;,
    borrow_set: &amp;'a BorrowSet&lt;'c&gt;,
    body: &amp;'c Body&lt;'c&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 'cg = the duration of the constraint generation process itself.
struct ConstraintGeneration&lt;'cg, 'cx, 'tcx&gt; {
    infcx: &amp;'cg InferCtxt&lt;'cx, 'tcx&gt;,
    all_facts: &amp;'cg mut Option&lt;AllFacts&gt;,
    location_table: &amp;'cg LocationTable,
    liveness_constraints: &amp;'cg mut LivenessValues&lt;RegionVid&gt;,
    borrow_set: &amp;'cg BorrowSet&lt;'tcx&gt;,
    body: &amp;'cg Body&lt;'tcx&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmemlifetime02-通常需要显式地标注生命周期而非利用编译器推断"><a class="header" href="#pmemlifetime02-通常需要显式地标注生命周期而非利用编译器推断">P.MEM.Lifetime.02 通常需要显式地标注生命周期，而非利用编译器推断</a></h2>
<p><strong>【描述】</strong></p>
<p>编译器对生命周期参数有两种单态化方式（生命周期参数也是一种泛型）：</p>
<ul>
<li>Early bound。一般情况下，<code>'a: 'b</code> 以及 <code>impl&lt;'a&gt;</code> 这种方式是 early bound，意味着这些生命周期参数会在当前作用域单态化生命周期实例。</li>
<li>Late bound。默认的 <code>'a</code> 或 <code>for&lt;'a&gt;</code> 是在实际调用它们的地方才单态化生命周期实例。</li>
</ul>
<p>在不同的场景下需要指定合适的单态化方式，才能让编译器明白开发者的意图。</p>
<p>在使用匿名生命周期 <code>'_</code> 的时候需要注意，如果有多个匿名生命周期，比如 <code>('_，'_)</code> ，每个匿名生命周期都会有自己的单独实例。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v = vec![1, 2, 3, 4, 5, 6];
    let mut buf = Buffer::new(&amp;v);
    // error[E0499]: cannot borrow `buf` as mutable more than once at a time
    let b1 = buf.read_bytes();
    let b2 = buf.read_bytes();
    println!(&quot;{:#?} {:#?}&quot;, b1, b2);
}

struct Buffer&lt;'a&gt; {
    buf: &amp;'a [u8],
    pos: usize,
}

impl&lt;'a&gt; Buffer&lt;'a&gt; {
    fn new(b: &amp;'_ [u8]) -&gt; Buffer {
        Buffer { buf: b, pos: 0 }
    }
    // 此处依赖编译器推断的生命周期将导致main函数中该方法调用编译错误
    fn read_bytes(&amp;'_ mut self) -&gt; &amp;'_ [u8] {
        self.pos += 3;
        &amp;self.buf[self.pos - 3..self.pos]
    }
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v = vec![1, 2, 3, 4, 5, 6];
    let mut buf = Buffer::new(&amp;v);
    let b1 = buf.read_bytes();
    let b2 = buf.read_bytes();
    println!(&quot;{:#?} {:#?}&quot;, b1, b2);
}

struct Buffer&lt;'a&gt; {
    buf: &amp;'a [u8],
    pos: usize,
}

// 明确标示清楚生命周期，向编译器传达开发者意图，则可正常编译
impl&lt;'b, 'a: 'b&gt; Buffer&lt;'a&gt; {
    fn new(b: &amp;'_ [u8]) -&gt; Buffer {
        Buffer { buf: b, pos: 0 }
    }
    // 明确标示清楚输入引用和输出引用的生命周期关系是 `'a: 'b`
    fn read_bytes(&amp;'b mut self) -&gt; &amp;'a [u8] {
        self.pos += 3;
        &amp;self.buf[self.pos - 3..self.pos]
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="智能指针"><a class="header" href="#智能指针">智能指针</a></h1>
<p>智能指针，在 Rust 中参与自动管理堆内容、引用计数、抽象指针语义等功能。一般实现了 <code>Deref</code> trait 或 <code>Drop</code> trait 的类型都可以看作是一种智能指针。</p>
<p><code>Box&lt;T&gt;</code> 就是一个典型的智能指针，但是因为其在 Rust 中有特殊地位，所以为其单独罗列规则。</p>
<p>Rust 中常见的智能指针包括：</p>
<ul>
<li>自动管理堆内存：<code>Box&lt;T&gt;</code></li>
<li>引用计数：<code>Rc&lt;T&gt; / Arc&lt;T&gt;</code></li>
<li>内部可变性容器：<code>Cell&lt;T&gt; / RefCell&lt;T&gt;</code></li>
</ul>
<h2 id="列表-29"><a class="header" href="#列表-29">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/memory/./smart-ptr/P.MEM.SPT.01.html">P.MEM.SPT.01 使用 <code>RefCell&lt;T&gt;</code> 时宜使用 <code>try_borrow/try_borrow_mut</code> 方法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmemspt01-使用-refcellt-时宜使用-try_borrowtry_borrow_mut-方法"><a class="header" href="#pmemspt01-使用-refcellt-时宜使用-try_borrowtry_borrow_mut-方法">P.MEM.SPT.01 使用 <code>RefCell&lt;T&gt;</code> 时宜使用 <code>try_borrow/try_borrow_mut</code> 方法</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 的 <code>RefCell&lt;T&gt;</code> 在运行时会对通过 <code>borrow/borrow_mut</code> 方法借用出去的不可变借用和可变借用进行检查。如果发现违反了借用规则的情况，则会 Panic。</p>
<p>所以在一些多线程场景下，开发者可能对细粒度的操作加了锁同步，但是没有对 <code>RefCell&lt;T&gt;</code> 进行加锁，此时宜用 <code>try_borrow/try_borrow_mut</code> 来代替
<code>borrow/borrow_mut</code>，以避免在运行时因为违反借用检查规则而出现 Panic。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 以下两个函数会让 C 函数在多线程下调用
// 运行过程中有一定几率会出现 Panic
pub extern &quot;C&quot; fn nic_udrv_suspend() {
    NIC_ENTITY.borrow_mut().suspend(); // suspend()需要可变引用
}

pub extern &quot;C&quot; fn nic_udrv_buf_recycle(buf_id: usize) {
    NIC_ENTITY.borrow().buf_recycle(buf_id); // buf_recycle()内有锁可以避免多线程竞争
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 以下两个函数会让 C 函数在多线程下调用
// 使用 try_borrow 或 try_borrow_mut 可以避免运行过程中出现 Panic
pub extern &quot;C&quot; fn nic_udrv_suspend() {
    if let Ok(entity) = NIC_ENTITY.try_borrow_mut() {
        entity.suspend(); // suspend()需要可变引用
    }
}

pub extern &quot;C&quot; fn nic_udrv_buf_recycle(buf_id: usize) {
    if let Ok(entity) = NIC_ENTITY.try_borrow() {
        entity.buf_recycle(buf_id); // buf_recycle()内有锁可以避免多线程竞争
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box-类型"><a class="header" href="#box-类型">Box 类型</a></h1>
<p>Rust 中分配堆内存必须要使用的类型，类型签名为 <code>Box&lt;T&gt;</code>。</p>
<h2 id="列表-30"><a class="header" href="#列表-30">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/memory/./box/G.MEM.BOX.01.html">G.MEM.BOX.01 一般情况下，不应直接对 <code>Box&lt;T&gt;</code> 进行借用</a></li>
<li><a href="safe-guides/coding_practice/memory/./box/G.MEM.BOX.02.html">G.MEM.BOX.02 一般情况下，不应直接对已经在堆上分配内存的类型进行 Box 装箱</a></li>
<li><a href="safe-guides/coding_practice/memory/./box/G.MEM.BOX.03.html">G.MEM.BOX.03 一般情况下，不应直接对栈分配类型进行 Box 装箱</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmembox01--一般情况下不应直接对-boxt-进行借用"><a class="header" href="#gmembox01--一般情况下不应直接对-boxt-进行借用">G.MEM.BOX.01  一般情况下，不应直接对 <code>Box&lt;T&gt;</code> 进行借用</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>借用 <code>Box&lt;T&gt;</code> 等同于直接借用 <code>T</code>，而 <code>&amp;T</code> 要比 <code>&amp;Box&lt;T&gt;</code> 更常用。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(bar: &amp;Box&lt;T&gt;) { ... }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(bar: &amp;T) { ... }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>用例来源：<a href="https://github.com/cschaible/actix-web-security/blob/6e3a7716a1391ea880da85dfa4631dce3aaafd18/src/authentication/scheme/authentication_provider.rs#L12">actix-web-security</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait AuthenticationProvider: AuthenticationProviderClone {
    #[allow(clippy::borrowed_box)]
    async fn authenticate(
        &amp;self,
        authentication: &amp;Box&lt;dyn Authentication&gt;,
    ) -&gt; Result&lt;Box&lt;dyn UserDetails&gt;, AuthenticationError&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#borrowed_box">borrowed_box</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmembox02--一般情况下不应直接对已经在堆上分配内存的类型进行-box-装箱"><a class="header" href="#gmembox02--一般情况下不应直接对已经在堆上分配内存的类型进行-box-装箱">G.MEM.BOX.02  一般情况下，不应直接对已经在堆上分配内存的类型进行 <code>Box</code> 装箱</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>像 <code>Vec&lt;T&gt; / String</code> 这样的类型（数据集）已经在堆上分配了内存，就没有必要再使用 <code>Box</code> 对其进行装箱操作。当然也存在例外情况。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct X {
    // Vec已在堆上分配了内存
    values: Box&lt;Vec&lt;Foo&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct X {
    values: Vec&lt;Foo&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>用例来源：<a href="https://github.com/rocurley/jex/blob/31e51ff77ea4f7f3c6eaa4aaca2e439985e1241d/src/jq/query.rs#L22">jex</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct JQ {
    ptr: *mut jq_state,
    // We want to make sure the vec pointer doesn't move, so we can keep pushing to it.
    // 这里不想把 Vec 的指针 Move 掉，所以用 Box 装箱可以达到这个效果
    // 注：clippy::box_vec 以更名为 clippy::box_collection
    #[allow(clippy::box_vec)]
    errors: Box&lt;Vec&lt;JVRaw&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>或以下情况。来源 <a href="https://github.com/mmtk/mmtk-core/blob/ad95d7797f020eaab1e608dc03b7db6a3d79839a/src/plan/mutator_context.rs#L19">mmtk-core</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct MutatorConfig&lt;VM: VMBinding&gt; {
    // ...

    /// Mapping between allocator selector and spaces. Each pair represents a mapping.
    /// Put this behind a box, so it is a pointer-sized field.
    // 这里是为了让字段拥有指针一样的大小，所以装箱了
    #[allow(clippy::box_collection)]
    pub space_mapping: Box&lt;SpaceMapping&lt;VM&gt;&gt;,
  
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#box_collection">box_collection</a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmembox03--一般情况下不应直接对栈分配类型进行-box-装箱"><a class="header" href="#gmembox03--一般情况下不应直接对栈分配类型进行-box-装箱">G.MEM.BOX.03  一般情况下，不应直接对栈分配类型进行 <code>Box</code> 装箱</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>此举会对性能造成不必要的影响。
只有当某个栈变量太大，需要使用堆分配的情况下，或是栈变量需要逃逸的时候，才需要考虑是否对其使用 <code>Box</code> 装箱。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(bar: usize) {}
let x = Box::new(1);
foo(*x);
println!(&quot;{}&quot;, *x);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(bar: usize) {}
let x = 1;
foo(x);
println!(&quot;{}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>用例来源：<a href="https://github.com/mjkillough/aitch/blob/69fbd677a72d0ed1851624d16a53c2a676d49bd5/src/servers/hyper.rs#L28">aitch</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ServeFunc {
    fn call_box(self: Box&lt;Self&gt;) -&gt; Result&lt;()&gt;;
}

impl&lt;F&gt; ServeFunc for F
where
    F: FnOnce() -&gt; Result&lt;()&gt;,
{
    #[cfg_attr(feature = &quot;cargo-clippy&quot;, allow(boxed_local))]
    fn call_box(self: Box&lt;Self&gt;) -&gt; Result&lt;()&gt; {
        (*self)()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#boxed_local">boxed_local </a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drop-析构"><a class="header" href="#drop-析构">Drop 析构</a></h1>
<p>在 Safe Rust 中，Drop 比较安全。在 Unsafe Rust 中则需要注意更多关于 Drop 的问题。 </p>
<h2 id="列表-31"><a class="header" href="#列表-31">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/memory/./drop/G.MEM.DRP.01.html">G.MEM.DRP.01 要注意防范内存泄漏</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmemdrp01-要注意防范内存泄漏"><a class="header" href="#pmemdrp01-要注意防范内存泄漏">P.MEM.DRP.01 要注意防范内存泄漏</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 语言并不保证避免内存泄漏，内存泄漏不属于 Rust 安全职责范围。使用 Rust 的时候需要注意下面情况可能会发生内存泄漏：</p>
<ol>
<li>循环引用</li>
<li>使用 <code>forget</code> / <code>leak</code> 等函数主动跳过析构</li>
<li>使用 <code>std::mem::ManuallyDrop</code> 构建数据结构而忘记析构</li>
<li>析构函数内部发生了 panic</li>
<li>程序中止（abort on panic）</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="314-模块"><a class="header" href="#314-模块">3.14 模块</a></h1>
<p>Rust 中一个文件 即一个模块，也可以通过  <code>mod</code> 来创建模块。多个文件放到同一个目录下，也可以成为一个模块。</p>
<p>模块相关有三个概念：</p>
<ol>
<li><code>mod</code>是 Rust 代码的“骨架”。</li>
<li><code>use</code> 则是用来决定使用或导出哪个模块中的具体的类型或方法。</li>
<li><code>Path</code>，则是一个命名系统，类似于命名空间。</li>
</ol>
<h2 id="列表-32"><a class="header" href="#列表-32">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./module/P.MOD.01.html">P.MOD.01 合理控制对外接口和模块之间的可见性</a></li>
<li><a href="safe-guides/coding_practice/./module/P.MOD.02.html">P.MOD.02 将模块的测试移动到单独的文件，有助于增加编译速度</a></li>
<li><a href="safe-guides/coding_practice/./module/G.MOD.01.html">G.MOD.01 使用导入模块中的类型或函数，在某些情况下需要带 模块名前缀</a></li>
<li><a href="safe-guides/coding_practice/./module/G.MOD.02.html">G.MOD.02 如果是作为库供别人使用，在 lib.rs中重新导出对外类型、函数和 trait 等</a></li>
<li><a href="safe-guides/coding_practice/./module/G.MOD.03.html">G.MOD.03 导入模块不要随便使用 通配符<code>*</code></a></li>
<li><a href="safe-guides/coding_practice/./module/G.MOD.04.html">G.MOD.04 一个项目中应该避免使用不同的模块布局风格</a></li>
<li><a href="safe-guides/coding_practice/./module/G.MOD.05.html">G.MOD.05 不要在私有模块中设置其内部类型或函数方法为<code>pub(crate)</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmod01----合理控制对外接口和模块之间的可见性"><a class="header" href="#pmod01----合理控制对外接口和模块之间的可见性">P.MOD.01    合理控制对外接口和模块之间的可见性</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust提供强大的模块（module）系统，并且可以管理这些模块之间的可见性（公有（public）或私有（private））。</p>
<p>1、对于提供给其他crate使用的对外函数、结构体、trait等类型需要严格控制对外pub的范围，避免将内部成员对外提供。</p>
<p>2、对于crate内部，mod之间可见的类型，需要添加上<code>pub(crate) </code>。</p>
<p>3、对于mod内部私有的类型，不要添加<code>pub(crate) </code>或者<code>pub</code>。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lib.rs
pub mod sha512;
pub use sha512::Sha512;

// sha512.rs
pub struct Sha512 {
    inner: Sha512Inner, // inner作为内部结构体，不添加pub描述
}

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmod02----将模块的测试移动到单独的文件有助于增加编译速度"><a class="header" href="#pmod02----将模块的测试移动到单独的文件有助于增加编译速度">P.MOD.02    将模块的测试移动到单独的文件，有助于增加编译速度</a></h2>
<p><strong>【描述】</strong></p>
<p>将模块的测试代码 移到一个单独的文件中，并且用 `#[cfg(test)] 来条件编译 tests 的mod，这样可以减少rebuild和编译时间，在大型项目中很重要。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>src/
|--codes.rs
|--codes/test.rs
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmod01---使用导入模块中的类型或函数在某些情况下需要带-模块名前缀"><a class="header" href="#gmod01---使用导入模块中的类型或函数在某些情况下需要带-模块名前缀">G.MOD.01   使用导入模块中的类型或函数，在某些情况下需要带 模块名前缀</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>对于标准库中，很多人都熟知的类型 ，比如 <code>Arc</code>/ <code>Rc</code>/ <code>Cell</code>/ <code>HashMap</code> 等 ， 可以导入它们直接使用。</p>
<p>但是对于可能引起困惑的函数，比如 <code>std::ptr::replace</code> 和 <code>std::mem::replace</code> ，在使用它们的时候，就必须得带上模块前缀。</p>
<p>使用一些第三方库中定义的类型或函数，也建议带上crate或模块前缀。如果太长的话，可以考虑使用 <code>as</code>  或  <code>type</code> 来定义别名。</p>
<p>以上考虑都是为了增强代码的可读性、可维护性。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
let foo = Arc::new(vec![1.0, 2.0, 3.0]); // 直接使用 Arc
let a = foo.clone();

// 需要带上 ptr 前缀
use std::ptr;
let mut rust = vec!['b', 'u', 's', 't'];
// `mem::replace` would have the same effect without requiring the unsafe
// block.
let b = unsafe {
    ptr::replace(&amp;mut rust[0], 'r')
};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>可以检测外部模块导入的自定义的类型是否带模块前缀，给予建议。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmod02---如果是作为库供别人使用在-librs中重新导出对外类型函数和-trait-等"><a class="header" href="#gmod02---如果是作为库供别人使用在-librs中重新导出对外类型函数和-trait-等">G.MOD.02   如果是作为库供别人使用，在 <code>lib.rs</code>中重新导出对外类型、函数和 trait 等</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>这样使用方在使用的时候，就不需要<code>use crate::mod::mod::struct</code>，可以直接使用<code>use crate::struct</code>，好处是使用方<code>use</code>的时候会比较方便和直观。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From syn crate
pub use crate::data::{
    Field, Fields, FieldsNamed, FieldsUnnamed, Variant, VisCrate, VisPublic, VisRestricted,
    Visibility,
};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmod03---导入模块不要随便使用-通配符"><a class="header" href="#gmod03---导入模块不要随便使用-通配符">G.MOD.03   导入模块不要随便使用 通配符<code>*</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>使用通配符导入会污染命名空间，比如导入相同命名的函数或类型。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>use crate2::*; // Has a function named foo
foo(); // Calls crate1::foo
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate1::foo; // Imports a function named foo
foo(); // Calls crate1::foo
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prelude::*;

#[test]
use super::*
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#wildcard_imports">wildcard_imports</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>该 lint 可以通过 clippy 配置项 <code>warn-on-all-wildcard-imports = false</code> 来配置，用于是否禁用 <code>prelude</code>/ <code>super</code> (测试模块中) 使用通配符导入， 默认是 <code>false</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmod04----一个项目中应该避免使用不同的模块布局风格"><a class="header" href="#gmod04----一个项目中应该避免使用不同的模块布局风格">G.MOD.04    一个项目中应该避免使用不同的模块布局风格</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Rust 支持两种 模块布局，文件夹内使用 <code>mod.rs</code> 或者是使用跟文件夹同名的文件名，来组织模块。</p>
<p>但是项目里如果混合这两种模块布局，是比较让人困惑的，最好统一为同一种风格。</p>
<p>上面两种  lint ，选择其中一种用于检查是否存在不同的模块布局。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 使用 `self_named_module_files`，不允许下面模块布局
src/
  stuff/
    stuff_files.rs
  stuff.rs
  lib.rs

// 使用 `mod_module_files`，不允许下面模块布局

src/
  stuff/
    stuff_files.rs
    mod.rs
  lib.rs
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 使用 `self_named_module_files`，允许下面模块布局
src/
  stuff/
    stuff_files.rs
    mod.rs
  lib.rs

// 使用 `mod_module_files`，允许下面模块布局
src/
  stuff/
    stuff_files.rs
  stuff.rs
  lib.rs
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#self_named_module_files">self_named_module_files</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#mod_module_files">mod_module_files</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmod05-不要在私有模块中设置其内部类型或函数方法为-pubcrate"><a class="header" href="#gmod05-不要在私有模块中设置其内部类型或函数方法为-pubcrate">G.MOD.05 不要在私有模块中设置其内部类型或函数方法为 <code>pub(crate)</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>如果在私有模块中设置  <code>pub(crate)</code> 可能会让使用者产生误解。建议用 <code>pub</code> 代替。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod internal {
    pub(crate) fn internal_fn() { }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod internal {
    pub fn internal_fn() { }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#redundant_pub_crate">redundant_pub_crate</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
</tbody></table>
<p>注意：此 lint 为 nursery，意味着有 Bug。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="315-包管理"><a class="header" href="#315-包管理">3.15 包管理</a></h1>
<p>Cargo 不仅仅是包管理，它还是一个 Workflow 工具。这一节包含 Cargo 和 Crate 相关内容。</p>
<h2 id="列表-33"><a class="header" href="#列表-33">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./cargo/P.CAR.01.html">P.CAR.01 应该尽量把项目划分为合理的 crate 组合</a></li>
<li><a href="safe-guides/coding_practice/./cargo/P.CAR.02.html">P.CAR.02 不要滥用 Features</a></li>
<li><a href="safe-guides/coding_practice/./cargo/P.CAR.03.html">P.CAR.03 使用 <code>cargo features</code> 来代替 <code>--cfg</code> 条件编译参数</a></li>
<li><a href="safe-guides/coding_practice/./cargo/P.CAR.04.html">P.CAR.04 如果可能的话，使用 <code>cfg!</code> 来代替 <code>#[cfg]</code></a></li>
<li><a href="safe-guides/coding_practice/./cargo/G.CAR.01.html">G.CAR.01 当项目是可执行程序而非库时，建议使用 <code>src/main.rs</code> 和 <code>src/lib.rs</code> 模式</a></li>
<li><a href="safe-guides/coding_practice/./cargo/G.CAR.02.html">G.CAR.02 Crate 的 <code>Cargo.toml</code> 中应该包含必要的元信息</a></li>
<li><a href="safe-guides/coding_practice/./cargo/G.CAR.03.html">G.CAR.03 Feature 命名应该避免否定式或多余的前后缀</a></li>
<li><a href="safe-guides/coding_practice/./cargo/G.CAR.04.html">G.CAR.04 <code>Cargo.toml</code> 中依赖包版本不应使用通配符</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pcar01-应该尽量把项目划分为合理的-crate-组合"><a class="header" href="#pcar01-应该尽量把项目划分为合理的-crate-组合">P.CAR.01 应该尽量把项目划分为合理的 crate 组合</a></h2>
<p><strong>【描述】</strong></p>
<p>将整个项目按一定逻辑划分为合理的 crate，在工程方面有利于组件化。并且 crate 是 Rust 的编译单元，也有助于提升编译速度。</p>
<p>但需要注意，crate 之间的依赖关系应该是单向的，避免相互依赖的情况。</p>
<p>但 Rust 中编译时间、性能、编译大小之间，在考虑优化的时候也是需要权衡的。 </p>
<p>内联是优化的关键，当编译单元越大，内联优化效果就越好。所以需要权衡 crate 划分的粒度。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pcar02-不要滥用-features"><a class="header" href="#pcar02-不要滥用-features">P.CAR.02 不要滥用 Features</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 的 features 提供了方便的条件编译功能。从软件工程来说，features 应该是为了避免让用户依赖没必要依赖的功能而使用的。</p>
<p>在使用 features 的时候，应该考虑到底是不是真的需要 features。</p>
<p>滥用 features 会带来额外的测试和静态检查的难度，需要保证不同 features 下的测试覆盖和静态检查情况。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pcar03-使用-cargo-features-来代替---cfg-条件编译参数"><a class="header" href="#pcar03-使用-cargo-features-来代替---cfg-条件编译参数">P.CAR.03 使用 <code>cargo features</code> 来代替 <code>--cfg</code> 条件编译参数</a></h2>
<p><strong>【描述】</strong></p>
<p><code>cargo features</code> 为 Rust 原生的条件编译，可用于代替 <code>--cfg</code> 参数且兼容性更好。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pcar04-如果可能的话使用-cfg-来代替-cfg"><a class="header" href="#pcar04-如果可能的话使用-cfg-来代替-cfg">P.CAR.04 如果可能的话，使用 <code>cfg!</code> 来代替 <code>#[cfg]</code></a></h2>
<p><strong>【描述】</strong></p>
<p><code>cfg!</code> 就像正常代码一样，会检查全部函数逻辑，而 <code>#[cfg]</code> 是条件编译，会跳过一些 Dead Code。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcar01-当项目是可执行程序而非库时建议使用-srcmainrs-和-srclibrs-模式"><a class="header" href="#gcar01-当项目是可执行程序而非库时建议使用-srcmainrs-和-srclibrs-模式">G.CAR.01 当项目是可执行程序而非库时，建议使用 <code>src/main.rs</code> 和 <code>src/lib.rs</code> 模式</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p><code>crate</code> 结构类似于：</p>
<pre><code class="language-text">src/
  -- lib.rs
  -- main.rs
</code></pre>
<p>或</p>
<pre><code class="language-text">src/
  -- lib.rs
bin/
  -- main.rs
</code></pre>
<p>这样的好处有：</p>
<ol>
<li>便于单元测试。</li>
<li>有利于面向接口思考，让代码架构和逻辑更加清晰。</li>
</ol>
<p>若编写的可执行程序比较复杂，在 <code>main.rs</code> 里需要依赖太多东西时，那就需要创建 Workspace 把 <code>main.rs</code> 独立为一个 crate，而在这个 crate 内也没有必要再拆分为 <code>main</code> 和 <code>lib</code> 了。</p>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcar02-crate-的-cargotoml-中应该包含必要的元信息"><a class="header" href="#gcar02-crate-的-cargotoml-中应该包含必要的元信息">G.CAR.02 Crate 的 Cargo.toml 中应该包含必要的元信息</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在 Cargo.toml 中应该包含必要的元信息，以便使用者知道它的作用。
此外，若要将 <code>crate</code> 发布到 crates.io 上的话，这些信息也是必须的。可参考 The Cargo Book 中的<a href="https://doc.rust-lang.org/cargo/reference/manifest.html">相关介绍</a>。</p>
<p><strong>【反例】</strong></p>
<pre><code class="language-toml"># 此 `Cargo.toml` 缺失介绍(description)项。无法发布到 crates.io。
[package]
name = &quot;clippy&quot;
version = &quot;0.0.212&quot;
repository = &quot;https://github.com/rust-lang/rust-clippy&quot;
readme = &quot;README.md&quot;
license = &quot;MIT OR Apache-2.0&quot;
keywords = [&quot;clippy&quot;, &quot;lint&quot;, &quot;plugin&quot;]
categories = [&quot;development-tools&quot;, &quot;development-tools::cargo-plugins&quot;]
</code></pre>
<p><strong>【正例】</strong></p>
<pre><code class="language-toml"># 此 `Cargo.toml` 包含必要元信息。
[package]
name = &quot;clippy&quot;
version = &quot;0.0.212&quot;
description = &quot;A bunch of helpful lints to avoid common pitfalls in Rust&quot;
repository = &quot;https://github.com/rust-lang/rust-clippy&quot;
readme = &quot;README.md&quot;
license = &quot;MIT OR Apache-2.0&quot;
keywords = [&quot;clippy&quot;, &quot;lint&quot;, &quot;plugin&quot;]
categories = [&quot;development-tools&quot;, &quot;development-tools::cargo-plugins&quot;]
</code></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cargo_common_metadata">cargo_common_metadata</a></td><td>yes</td><td>no</td><td>cargo</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcar03-feature-命名应该避免否定式或多余的前后缀"><a class="header" href="#gcar03-feature-命名应该避免否定式或多余的前后缀">G.CAR.03 Feature 命名应该避免否定式或多余的前后缀</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Feature 命名应该避免出现 <code>no-</code> 或 <code>not-</code> 之类的否定前缀，或诸如 <code>use-</code>，<code>with-</code> 前缀或 <code>-support</code>后缀。Feature 的目的是正向的，可选的特性，使用否定式命名和它的目的背道而驰。</p>
<p><strong>【反例】</strong></p>
<pre><code class="language-toml">[features]
default = [&quot;no-abc&quot;, &quot;with-def&quot;, &quot;ghi-support&quot;]
no-abc = []         # 命名否定式
with-def = []       # 多余前缀
ghi-support = []    # 多余后缀
</code></pre>
<p><strong>【正例】</strong></p>
<pre><code class="language-toml">[features]
default = [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]
abc = []
def = []
ghi = []
</code></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#negative_feature_names">negative_feature_names</a></td><td>yes</td><td>no</td><td>cargo</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#redundant_feature_names">redundant_feature_names</a></td><td>yes</td><td>no</td><td>cargo</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcar04-cargotoml-中依赖包版本不应使用通配符"><a class="header" href="#gcar04-cargotoml-中依赖包版本不应使用通配符">G.CAR.04 Cargo.toml 中依赖包版本不应使用通配符</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>依赖的包必须指定具体的语义版本。关于语义版本说明参见：<a href="https://doc.rust-lang.org/cargo/reference/semver.html">The Cargo Book: SemVer Compatibility</a>。</p>
<p><strong>【反例】</strong></p>
<pre><code class="language-toml">[dependencies]
regex = &quot;*&quot;
</code></pre>
<p><strong>【正例】</strong></p>
<pre><code class="language-toml">[dependencies]
regex = &quot;1.5&quot;
</code></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#wildcard_dependencies">wildcard_dependencies</a></td><td>yes</td><td>no</td><td>cargo</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="316-宏"><a class="header" href="#316-宏">3.16 宏</a></h1>
<p>Rust 通过宏来支持元编程。其中宏有很多种，按实现方式可以分为两大类：声明宏（Declarative）和 过程宏（Procedural）。</p>
<p>按功能效果，过程宏又可以分为三类：</p>
<ol>
<li>Function-like 宏。类似于声明宏那样，像函数调用一样去使用的宏。</li>
<li>Derive 宏。用于为数据类型自动生成一些 语法项（item），比如 trait 、结构体、方法等。</li>
<li>Attribute 宏。用于更加通用的代码生成功能。</li>
</ol>
<p>Rust 语言核心库和标准库都内置了一些声明宏和过程宏，以方便开发者使用。</p>
<p>内置的属性宏按功能大体又可以分为四类：</p>
<blockquote>
<p>注：属性宏固定语法为 <code>#[attr]</code> 或 <code>#![attr]</code>，以下使用用例均已简化为 <code>attr</code> 的形式。即 <code>test</code>, <code>allow(c)</code> 代表其在 Rust 内的实现可分别表现为 <code>#[test]</code> 及 <code>#[allow(c)]</code>。</p>
</blockquote>
<ol>
<li>测试属性。<code>test</code> 属性宏用于将某个函数标记为单元测试函数。</li>
<li>诊断（<a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#diagnostic-attributes">Diagnostic</a>）属性。用于在编译过程中控制和生成诊断信息。包括：
<ol>
<li><code>allow(c)</code> / <code>warn(c)</code> / <code>deny(c)</code> / <code>forbid(c)</code>  等。</li>
<li><code>must_use</code> 。</li>
</ol>
</li>
<li><a href="https://doc.rust-lang.org/reference/attributes/codegen.html">代码生成属性</a>。包括：<code>inline</code> / <code>cold</code> / <code>target_feature</code> 等。</li>
<li><a href="https://doc.rust-lang.org/reference/attributes/limits.html">编译时限制属性</a>。包括：<code>recursion_limit </code> / <code>type_length_limit</code> 。</li>
<li><a href="https://doc.rust-lang.org/reference/attributes/type_system.html">类型系统属性</a>。包括：<code>non_exhaustive</code> 。</li>
</ol>
<p><strong>宏编程规范：</strong></p>
<p>使用宏时，需要从 <code>声明宏</code> 和 <code>过程宏</code> 各自的特性为出发点，来安全使用它。</p>
<ul>
<li><a href="safe-guides/coding_practice/./macros/decl.html">声明宏规范</a></li>
<li><a href="safe-guides/coding_practice/./macros/proc.html">过程宏规范</a></li>
</ul>
<p><strong>宏展开命令：</strong></p>
<pre><code class="language-text"># 对单个 rs 文件
rustc -Z unstable-options --pretty expanded hello.rs
# 对项目里的二进制 rs 文件
cargo rustc --bin hello -- -Z unstable-options --pretty=expanded
</code></pre>
<h2 id="列表-34"><a class="header" href="#列表-34">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./macros/P.MAC.01.html">P.MAC.01 不要轻易使用宏</a></li>
<li><a href="safe-guides/coding_practice/./macros/P.MAC.02.html">P.MAC.02 实现宏语法的时候，应该尽量贴近 Rust 语法</a></li>
<li><a href="safe-guides/coding_practice/./macros/G.MAC.01.html">G.MAC.01 dbg!() 宏只应该在 Debug 模式下使用</a></li>
<li><a href="safe-guides/coding_practice/./macros/G.MAC.02.html">G.MAC.02 使用宏时应该考虑宏展开会让编译文件膨胀的影响</a></li>
<li><a href="safe-guides/coding_practice/./macros/decl.html">声明宏</a>
<ul>
<li><a href="safe-guides/coding_practice/./macros/decl/P.MAC.DCL.01.html">P.MAC.DCL.01 不要将声明宏内的变量作为外部变量使用</a></li>
<li><a href="safe-guides/coding_practice/./macros/decl/P.MAC.DCL.02.html">P.MAC.DCL.02 在编写多个宏规则时，应该先从匹配粒度最小的开始写</a></li>
<li><a href="safe-guides/coding_practice/./macros/decl/P.MAC.DCL.03.html">P.MAC.DCL.03 不要在片段分类符跟随它不匹配的符号</a></li>
<li><a href="safe-guides/coding_practice/./macros/decl/P.MAC.DCL.04.html">P.MAC.DCL.04 匹配规则要精准，不要模糊不清</a></li>
<li><a href="safe-guides/coding_practice/./macros/decl/P.MAC.DCL.05.html">P.MAC.DCL.05 使用宏替换（substitution）元变量的时候要注意选择合适的片段分类符</a></li>
<li><a href="safe-guides/coding_practice/./macros/decl/P.MAC.DCL.06.html">P.MAC.DCL.06 当宏需要接收 self 时需要注意</a></li>
<li><a href="safe-guides/coding_practice/./macros/decl/P.MAC.DCL.07.html">P.MAC.DCL.07 确保在宏定义之后再去调用宏</a></li>
<li><a href="safe-guides/coding_practice/./macros/decl/P.MAC.DCL.08.html">P.MAC.DCL.08 同一个 crate 内定义的宏相互调用时，需要注意卫生性</a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./macros/proc.html">过程宏</a>
<ul>
<li><a href="safe-guides/coding_practice/./macros/proc/P.MAC.PRO.01.html">P.MAC.PRO.01 不要使用过程宏来规避静态分析检查</a></li>
<li><a href="safe-guides/coding_practice/./macros/proc/P.MAC.PRO.02.html">P.MAC.PRO.02 实现过程宏时要对关键特性增加测试</a></li>
<li><a href="safe-guides/coding_practice/./macros/proc/P.MAC.PRO.03.html">P.MAC.PRO.03 保证过程宏的卫生性</a></li>
<li><a href="safe-guides/coding_practice/./macros/proc/P.MAC.PRO.04.html">P.MAC.PRO.04 给出正确的错误位置</a></li>
<li><a href="safe-guides/coding_practice/./macros/proc/P.MAC.PRO.05.html">P.MAC.PRO.05 代码生成要按情况选择使用过程宏还是 build.rs</a></li>
<li><a href="safe-guides/coding_practice/./macros/proc/P.MAC.PRO.06.html">P.MAC.PRO.06 build.rs 生成的代码要保证没有任何警告</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmac01--不要轻易使用宏"><a class="header" href="#pmac01--不要轻易使用宏">P.MAC.01  不要轻易使用宏</a></h2>
<p><strong>【描述】</strong></p>
<p>当一个开发者想要能写出强大且用户友好的宏API时，不仅需要掌握如何用宏去实现，更需要掌握宏之外关于 Rust 的一切。</p>
<p>宏设计的重点在于宏生成什么样的代码，而不是宏如何生成代码。</p>
<p>宏只是将 Rust 语言特性以一种有趣的方式组合在一起能自动生成代码的创造力。</p>
<p>尤其是过程宏，它有一定复杂性，且很难调试，不卫生，也容易出错，不适用于新手。</p>
<blockquote>
<p>&quot;卫生&quot; 这个词表示，宏展开后，不会污染原来的词法作用域。</p>
</blockquote>
<p><strong>【参考】</strong></p>
<p><a href="https://github.com/dtolnay/case-studies">Rust 社区顶级专家 David Tolnay 写的宏学习案例</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmac02-实现宏语法的时候应该尽量贴近-rust-语法"><a class="header" href="#pmac02-实现宏语法的时候应该尽量贴近-rust-语法">P.MAC.02 实现宏语法的时候，应该尽量贴近 Rust 语法</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 宏可以让开发者定义自己的 DSL，但是在使用宏的时候，要尽可能贴近 Rust 的语法。这样可以增强可读性，让其他开发者在使用宏的时候，可以猜测出它生成的代码。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 无关键词
bitflags! {
    S: u32 { /* ... */ }
}

// 或使用一些自定义的特定用途关键词
bitflags! {
    flags S: u32 { /* ... */ }
}

// 或
bitflags! {
    struct S: u32 {
        const E = 0b010000, // 结尾应该是分号更符合 Rust 语法
        const F = 0b100000,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>bitflags! {
    struct S: u32 { /* ... */ }
}

// 也要注意结尾是正确的分号或逗号
bitflags! {
    struct S: u32 {
        const C = 0b000100;
        const D = 0b001000;
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmac01-dbg-宏只应该在-debug-模式下使用"><a class="header" href="#gmac01-dbg-宏只应该在-debug-模式下使用">G.MAC.01 <code>dbg!()</code> 宏只应该在 Debug 模式下使用</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p><code>dbg!()</code> 宏是 Rust 内置的宏，其目的是用于调试代码。 </p>
<p>注意：不管在 Debug 模式还是 Release 模式下，调试信息都会被打印出来。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Release 模式编译
let foo = false;
dbg!(foo); 
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Debug 模式编译
let foo = false;
dbg!(foo); 

// Release 模式编译
let foo = false;
// dbg!(foo); 
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#dbg_macro">dbg_macro</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmac02-使用宏时应该考虑宏展开会让编译文件膨胀的影响"><a class="header" href="#gmac02-使用宏时应该考虑宏展开会让编译文件膨胀的影响">G.MAC.02 使用宏时应该考虑宏展开会让编译文件膨胀的影响</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在多个地方使用 <code>println!</code> 或 <code>panic!</code> 之类的内置宏时，可以将其包装到函数内，使用 <code>#[cold]</code> 和 <code>#[inline(never)]</code> 属性避免其内联，从而避免编译文件膨胀。</p>
<p>因为像 <code>println!</code> 或 <code>panic!</code> 之类的宏，如果到处使用，就会到处展开代码，会导致编译文件大小膨胀。尤其在嵌入式领域需要注意。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn expect(self, msg: &amp;str) -&gt; T {
    match self {
        Ok(t) =&gt; t,
        Err(e) =&gt; panic!(&quot;{}: {:?}&quot;, msg, &amp;e),
    }
}

pub fn unwrap_err(self) -&gt; E {
    match self {
        Ok(t) =&gt; panic!(&quot;{}: {:?}&quot;, &quot;called `Result::unwrap_err()` on an `Ok` value&quot;, &amp;t),
        Err(e) =&gt; e,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline(never)]
#[cold]
#[track_caller] // 为了定位 panic 发生时的调用者的位置
fn unwrap_failed(msg: &amp;str, error: &amp;dyn fmt::Debug) -&gt; ! {
    panic!(&quot;{}: {:?}&quot;, msg, error)
}

pub fn expect(self, msg: &amp;str) -&gt; T {
    match self {
        Ok(t) =&gt; t,
        Err(e) =&gt; unwrap_failed(msg, &amp;e),
    }
}

pub fn unwrap_err(self) -&gt; E {
    match self {
        Ok(t) =&gt; unwrap_failed(&quot;called `Result::unwrap_err()` on an `Ok` value&quot;, &amp;t),
        Err(e) =&gt; e,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="声明宏"><a class="header" href="#声明宏">声明宏</a></h1>
<p><a href="https://doc.rust-lang.org/reference/macros-by-example.html">声明宏</a> 也被叫做 示例宏（macros by example），或者简单地叫做 宏。目前声明宏使用 <code>macro_rules!</code>来定义。</p>
<p>声明宏的特点是：它只用作代码替换，而无法进行计算。</p>
<h2 id="列表-35"><a class="header" href="#列表-35">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/macros/./decl/P.MAC.DCL.01.html">P.MAC.DCL声明宏内的变量作为外部变量使用</a></li>
<li><a href="safe-guides/coding_practice/macros/./decl/P.MAC.DCL.02.html">P.MAC.DCL.02 在编写多个宏规则时，应该先从匹配粒度最小的开始写</a></li>
<li><a href="safe-guides/coding_practice/macros/./decl/P.MAC.DCL.03.html">P.MAC.DCL.03 不要在片段分类符跟随它不匹配的符号</a></li>
<li><a href="safe-guides/coding_practice/macros/./decl/P.MAC.DCL.04.html">P.MAC.DCL.04 匹配规则要精准，不要模糊不清</a></li>
<li><a href="safe-guides/coding_practice/macros/./decl/P.MAC.DCL.05.html">P.MAC.DCL.05 使用宏替换（substitution）元变量的时候要注意选择合适的片段分类符</a></li>
<li><a href="safe-guides/coding_practice/macros/./decl/P.MAC.DCL.06.html">P.MAC.DCL.06 当宏需要接收 self 时需要注意</a></li>
<li><a href="safe-guides/coding_practice/macros/./decl/P.MAC.DCL.07.html">P.MAC.DCL.07 确保在宏定义之后再去调用宏</a></li>
<li><a href="safe-guides/coding_practice/macros/./decl/P.MAC.DCL.08.html">P.MAC.DCL.08 同一个 crate 内定义的宏相互调用时，需要注意卫生性</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacdcl01-不要将声明宏内的变量作为外部变量使用"><a class="header" href="#pmacdcl01-不要将声明宏内的变量作为外部变量使用">P.MAC.DCL.01 不要将声明宏内的变量作为外部变量使用</a></h2>
<p><strong>【描述】</strong></p>
<p>声明宏是半卫生（semi-hygienic）宏，其内部元变量（metavariables）不可作为外部变量去使用。</p>
<p>但是对于泛型参数（包括生命周期参数）是不卫生的，所以要小心使用。</p>
<p><strong>【反例】</strong></p>
<p>下面为卫生场景示例：</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! using_a {
    ($e:expr) =&gt; {
        {
            let a = 42;
            $e
        }
    }
}

fn main() {
    let four = using_a!(a / 10); // build error:  cannot find value `a` in this scope
}
</code></pre></pre>
<p>下面为不卫生场景示例：</p>
<pre><pre class="playground"><code class="language-rust">trait FooTrait {
    fn get(&amp;self) -&gt; i32;
}

// 使用宏为带生命周期的类型实现 FooTrait
macro_rules! impl_FooTrait {
    ($name:ty) =&gt; {
        // 这里使用的 'a 是宏内部定义
        impl&lt;'a&gt; $crate::FooTrait for $name { 
            fn get(&amp;self) -&gt; i32 {
                *self.0
            }    
        }
    };
}

struct Baz&lt;'a&gt;(&amp;'a i32);

impl_FooTrait!(Baz&lt;'a&gt;); // 这里的 'a 是宏外部


// 整个程序正常编译运行，说明宏内外的 'a 被共用，不卫生
fn main() {
    let val = 20;
    let baz = Baz(&amp;val);
    method(&amp;baz);
}

// 测试实现 FooTrait 的方法
fn method(foo: &amp;dyn FooTrait) {
    println!(&quot;{:?}&quot;, foo.get());
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<p>下面为卫生场景示例：</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! using_a {
    ($a:ident, $e:expr) =&gt; {{
        let $a = 42;
        $e
    }};
}

fn main() {
    let four = using_a!(a, a / 10);
}
</code></pre></pre>
<p>下面为不卫生场景示例：</p>
<pre><pre class="playground"><code class="language-rust">trait FooTrait {
    fn get(&amp;self) -&gt; i32;
}

// 使用宏为带生命周期的类型实现 FooTrait
macro_rules! impl_FooTrait {
    // 这里不直接使用宏内部定义的 'a ，而从外面通过 $lifetime 传入
    // 是为了避免不卫生可能引发的问题
    ($name:ty, $lifetime:tt) =&gt; {
        impl&lt;$lifetime&gt; $crate::FooTrait for $name { 
            fn get(&amp;self) -&gt; i32 {
                *self.0
            }    
        }
    };
}

struct Baz&lt;'a&gt;(&amp;'a i32);

impl_FooTrait!(Baz&lt;'a&gt;, 'a); // 这里的 'a 是从宏外部传入到宏内


// 整个程序正常编译运行
fn main() {
    let val = 20;
    let baz = Baz(&amp;val);
    method(&amp;baz);
}

// 测试实现 FooTrait 的方法
fn method(foo: &amp;dyn FooTrait) {
    println!(&quot;{:?}&quot;, foo.get());
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacdcl02-在编写多个宏规则时应该先从匹配粒度最小的开始写"><a class="header" href="#pmacdcl02-在编写多个宏规则时应该先从匹配粒度最小的开始写">P.MAC.DCL.02 在编写多个宏规则时，应该先从匹配粒度最小的开始写</a></h2>
<p><strong>【描述】</strong></p>
<p>因为 声明宏 中，是按规则的编写顺序来匹配的。当第一个规则被匹配到，后面的规则将永远不会匹配到。所以，编写声明宏规则时，需要先写匹配粒度最小的，最具体的规则，然后逐步编写匹配范围更广泛的规则。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! foo {
    (@as_expr $e:expr) =&gt; {$e}; // expr 比 tt 匹配更加具体

    ($($tts:tt)*) =&gt; {
        foo!(@as_expr $($tts)*)
    };
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacdcl03-不要在片段分类符跟随它不匹配的符号"><a class="header" href="#pmacdcl03-不要在片段分类符跟随它不匹配的符号">P.MAC.DCL.03 不要在片段分类符跟随它不匹配的符号</a></h2>
<p><strong>【描述】</strong></p>
<p><code>macro_rules!</code> 定义声明宏时，非终止的元变量匹配必须紧随一个已被决定能在这种匹配之后安全使用的标记。</p>
<p>具体的规则参见：<a href="https://doc.rust-lang.org/reference/macros-by-example.html#follow-set-ambiguity-restrictions">Follow-set Ambiguity Restrictions</a></p>
<p>片段分类符（<a href="https://doc.rust-lang.org/nightly/reference/macros-by-example.html#metavariables">fragment-specifier</a>）的说明参见<a href="safe-guides/coding_practice/macros/decl/./../../../Appendix/terms.html">附录B：术语解释</a></p>
<p><strong>【反例】</strong></p>
<p>对于 <code>[,]</code> 这样的分隔标记就是非法的。这是为了防止未来 Rust 语法变动导致宏定义失效。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! foo {
    ($e1:expr [,] $e2:expr) =&gt; {$e1; $e2}; 
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>该示例中，元变量 <code>$e1</code> 的 片段分类符 <code>expr</code> 是非终止的，所以后面需要跟随一个用于分隔的标记。</p>
<p>Rust 规定在 <code>expr</code> 片段分类符 后面可以合法地跟随 <code>=&gt;</code> / <code>,</code> / <code>;</code> 。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! foo {
    ( $e1:expr, $e2:expr) =&gt; {$e1; $e2}; 
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacdcl04-匹配规则要精准不要模糊不清"><a class="header" href="#pmacdcl04-匹配规则要精准不要模糊不清">P.MAC.DCL.04 匹配规则要精准，不要模糊不清</a></h2>
<p><strong>【描述】</strong></p>
<p>匹配规则必须精准，因为宏解析器并不会去执行代码，它无法匹配模糊不清的规则。</p>
<p><strong>【反例】</strong></p>
<p>宏解析器无法确定第一次匹配的应该是多少个 ident。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! ambiguity {
    ($($i:ident)* $i2:ident) =&gt; { };
}

// error:
//    local ambiguity: multiple parsing options: built-in NTs ident ('i') or ident ('i2').
fn main() { ambiguity!(an_identifier); }
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">macro_rules! ambiguity {
    ($i2:ident $($i:ident)* ) =&gt; { };
}

// ok
fn main() { ambiguity!(an_identifier  an_identifier2); }
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacdcl05-使用宏替换substitution元变量的时候要注意选择合适的片段分类符"><a class="header" href="#pmacdcl05-使用宏替换substitution元变量的时候要注意选择合适的片段分类符">P.MAC.DCL.05 使用宏替换（substitution）元变量的时候要注意选择合适的片段分类符</a></h2>
<p><strong>【描述】</strong></p>
<p>使用宏替换（substitution）元变量，就是指把已经进行过宏解析的 token 再次传给宏，需要注意此时传入的 token 已经被看作是宏解析器解析后的 AST 节点了。</p>
<p>片段分类符介绍（<a href="https://doc.rust-lang.org/nightly/reference/macros-by-example.html#metavariables">fragment-specifier</a>）</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">macro_rules! capture_then_what_is {
    (#[$m:meta]) =&gt; {what_is!(#[$m])};   // 这里片段分类符用的是 meta
}

macro_rules! what_is {
    (#[no_mangle]) =&gt; {&quot;no_mangle attribute&quot;};
    (#[inline]) =&gt; {&quot;inline attribute&quot;};
    ($($tts:tt)*) =&gt; {concat!(&quot;something else (&quot;, stringify!($($tts)*), &quot;)&quot;)};
}

fn main() {
    println!(
        &quot;{}\n{}\n{}\n{}&quot;,
        what_is!(#[no_mangle]),
        what_is!(#[inline]),
        capture_then_what_is!(#[no_mangle]), // 被 capture_then_what_is 宏 解析过的token，不会再二次被 what_is 宏解析，所以按 tt 规则处理
        capture_then_what_is!(#[inline]), // 被 capture_then_what_is 宏 解析过的token，不会再二次被 what_is 宏解析，所以按 tt 规则处理
    );
}
// 输出：
// no_mangle attribute
// inline attribute
// something else (#[no_mangle])
// something else (#[inline])
</code></pre></pre>
<p><strong>【正例】</strong></p>
<p>满足示例这类正常匹配情况的目前只有 <code>tt</code>、<code>ident</code> 或者 <code>lifetime</code> 分类符。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! capture_then_what_is {
    (#[$m:tt]) =&gt; {what_is!(#[$m])}; // 这里片段分类符用的是 tt
}

macro_rules! what_is {
    (#[no_mangle]) =&gt; {&quot;no_mangle attribute&quot;};
    (#[inline]) =&gt; {&quot;inline attribute&quot;};
    ($($tts:tt)*) =&gt; {concat!(&quot;something else (&quot;, stringify!($($tts)*), &quot;)&quot;)};
}

fn main() {
    println!(
        &quot;{}\n{}\n{}\n{}&quot;,
        what_is!(#[no_mangle]),
        what_is!(#[inline]),
        capture_then_what_is!(#[no_mangle]), // 被 capture_then_what_is 宏 解析过的token，还会被 what_is 二次处理
        capture_then_what_is!(#[inline]), // 被 capture_then_what_is 宏 解析过的token，还会被 what_is 二次处理
    );
}
// 输出：
// no_mangle attribute
// inline attribute
// no_mangle attribute
// inline attribute
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacdcl06-当宏需要接收-self-时需要注意"><a class="header" href="#pmacdcl06-当宏需要接收-self-时需要注意">P.MAC.DCL.06 当宏需要接收 <code>self</code> 时需要注意</a></h2>
<p><strong>【描述】</strong></p>
<p><code>self</code> 在 Rust 中属于关键字，它会在代码运行时被替换为具体类型的实例。当它传递给 宏 时会被看做为一个变量，而宏对于变量而言是具备卫生性的。而且，声明宏的作用只是替换而非计算，它并不能计算出 self 的具体类型。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">macro_rules! make_mutable {
    ($i:ident) =&gt; {let mut $i = $i;};
}

struct Dummy(i32);

impl Dummy {
    fn double(self) -&gt; Dummy {
        make_mutable!(self);  // 这里传入的 self 和宏内部 let 定义的 self 不同
        self.0 *= 2;
        self
    }
}

fn main() {
    println!(&quot;{:?}&quot;, Dummy(4).double().0);
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">macro_rules! double_method {
    ($self_:ident, $body:expr) =&gt; {
        fn double(mut $self_) -&gt; Dummy {
            $body
        }
    };
}

struct Dummy(i32);

impl Dummy {
    double_method! {self, {
        self.0 *= 2;
        self
    }}
}

fn main() {
    println!(&quot;{:?}&quot;, Dummy(4).double().0);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacdcl07-确保在宏定义之后再去调用宏"><a class="header" href="#pmacdcl07-确保在宏定义之后再去调用宏">P.MAC.DCL.07 确保在宏定义之后再去调用宏</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 中类型或函数在定义前后都可以调用，但是宏不一样。Rust 查找宏定义是按词法依赖顺序的，必须注意定义和调用的先后顺序。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">mod a {
    // X!(); // undefined
}

mod b {
    // X!(); // undefined
    macro_rules! X { () =&gt; {}; }
    X!(); // defined
}

mod c {
    // X!(); // undefined
}

fn main() {}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">macro_rules! X { () =&gt; {}; }

mod a {
    X!(); // defined
}

mod b {
    X!(); // defined
}

mod c {
    X!(); // defined
}

fn main() {}
</code></pre></pre>
<p><strong>【例外】</strong></p>
<p>宏与宏之间相互调用，不受词法顺序的限制。</p>
<pre><pre class="playground"><code class="language-rust">mod a {
    // X!(); // undefined
}

macro_rules! X { () =&gt; { Y!(); }; } // 注意：这里的 Y! 宏是在定义前被调用的，代码正常执行

mod b {
    // X!(); // defined, but Y! is undefined 
}

macro_rules! Y { () =&gt; {}; } // Y! 宏被定义在 X! 宏后面

mod c {
    X!(); // defined, and so is Y!
}
fn main() {}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacdcl08-同一个-crate-内定义的宏相互调用时需要注意卫生性"><a class="header" href="#pmacdcl08-同一个-crate-内定义的宏相互调用时需要注意卫生性">P.MAC.DCL.08 同一个 crate 内定义的宏相互调用时，需要注意卫生性</a></h2>
<p><strong>【描述】</strong></p>
<p>当同一个 crate 内定义的宏相互调用时候，应该使用 <code>$crate</code> 元变量来指代当前被调用宏的路径。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! helped {
    () =&gt; { helper!() } // This might lead to an error due to 'helper' not being in scope.
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}

//// 在另外的 crate 中使用这两个宏
// 注意：`helper_macro::helper` 并没有导入进来
use helper_macro::helped;

fn unit() {
   // Error! 这个宏会出现问题，因为其内部调用的 helper 宏的路径会被编译器认为是当前调用crate 的路径
   helped!();
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! helped {
    () =&gt; { $crate::helper!() }
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}

//// 在另外的 crate 中使用这两个宏
// 注意：`helper_macro::helper` 并没有导入进来
use helper_macro::helped;

fn unit() {
   // OK! 这个宏能运行通过，因为 `$crate` 正确地展开成 `helper_macro` crate 的路径（而不是使用者的路径）
   helped!();
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="过程宏"><a class="header" href="#过程宏">过程宏</a></h1>
<p><a href="https://doc.rust-lang.org/reference/procedural-macros.html">过程宏（<em>Procedural macros</em>）</a> 允许开发者来创建语法扩展。你可以通过过程宏创建类似函数的宏、派生宏以及属性宏。</p>
<p>广义上的&quot;过程宏&quot;指的是通过 syn/quote(毕竟几乎全部过程宏库都用 syn) 及 syn 生态(例如 darling) 进行代码生成等元编程操作。</p>
<p>syn/quote 不仅能用于过程宏，还广泛用于代码生成(<em>codegen</em>)、静态分析等用途，例如 tonic-build/prost 源码中也用到了 syn/quote 。</p>
<p>因此本过程宏规范不仅适用于过程宏，部分规范(例如 <a href="safe-guides/coding_practice/macros/./proc/P.MAC.PRO.06.html">P.MAC.PRO.06</a>) 还适用于 prost 这种代码生成库</p>
<p>过程宏必须被单独定义在一个类型为<code>proc-macro</code> 的 crate 中。</p>
<p>过程宏有两类报告错误的方式：<code>panic</code> 或 通过 <code>compile_error</code>  宏调用发出错误。</p>
<p>过程宏不具有卫生性（hygiene），这意味着它会受到外部语法项（item）的影响，也会影响到外部导入。</p>
<p>过程宏可以在编译期执行任意代码。</p>
<h2 id="列表-36"><a class="header" href="#列表-36">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/macros/./proc/P.MAC.PRO.01.html">P.MAC.PRO.01 不要使用过程宏来规避静态分析检查</a></li>
<li><a href="safe-guides/coding_practice/macros/./proc/P.MAC.PRO.02.html">P.MAC.PRO.02 实现过程宏时要对关键特性增加测试</a></li>
<li><a href="safe-guides/coding_practice/macros/./proc/P.MAC.PRO.03.html">P.MAC.PRO.03 保证过程宏的卫生性</a></li>
<li><a href="safe-guides/coding_practice/macros/./proc/P.MAC.PRO.04.html">P.MAC.PRO.04 给出正确的错误位置</a></li>
<li><a href="safe-guides/coding_practice/macros/./proc/P.MAC.PRO.05.html">P.MAC.PRO.05 代码生成要按情况选择使用过程宏还是 build.rs</a></li>
<li><a href="safe-guides/coding_practice/macros/./proc/P.MAC.PRO.06.html">P.MAC.PRO.06 build.rs 生成的代码要保证没有任何警告</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacpro01-不要使用过程宏来规避静态分析检查"><a class="header" href="#pmacpro01-不要使用过程宏来规避静态分析检查">P.MAC.PRO.01 不要使用过程宏来规避静态分析检查</a></h2>
<p><strong>【描述】</strong></p>
<p>不要利用过程宏来定义能规避 Rust 静态分析检查的宏。</p>
<p><strong>【反例】</strong></p>
<p>在 Rust 生态中有一个库 <a href="https://github.com/mxxo/plutonium"><code>plutonium</code></a>，该库利用了过程宏来消除代码中直接的 <code>unsafe</code> 块的使用，从而规避了编译器对 <code>unsafe</code> 关键字的静态检查。</p>
<p>该库会通过<code>#[safe]</code> 过程宏在自动生成代码的时候为函数体添加 <code>unsafe</code> 块，但这会影响到 <code>unsafe</code> 调用链依赖静态检查传播，从而进一步打断 unsafe 调用链路，影响后续通过 <code>unsafe</code> 关键字来定位问题。</p>
<pre><pre class="playground"><code class="language-rust">use plutonium::safe;

#[safe]
fn super_safe(x: f32) -&gt; i32 {
    std::mem::transmute::&lt;f32, i32&gt;(x)
}

#[safe]
unsafe fn deref_null() {
    *std::ptr::null::&lt;u8&gt;();
}

fn main(){
    println!(&quot;{:?}&quot;, super_safe(1.0));
    deref_null();
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<p>对于不安全的函数，应该显式地使用 <code>unsafe</code> 。这样做的好处是利用 Rust 编译器静态检查传播 unsafe 调用链条，以达到可以全局查找 unsafe 使用来消除一些代码隐患，方便定位问题。</p>
<pre><pre class="playground"><code class="language-rust">unsafe fn super_safe(x: f32) -&gt; i32 {
    unsafe { std::mem::transmute::&lt;f32, i32&gt;(x) }
}

unsafe fn deref_null() {
    unsafe { *std::ptr::null::&lt;u8&gt;(); }
}

fn main(){
    println!(&quot;{:?}&quot;, unsafe{super_safe(1.0f32)}); // 1065353216
    // error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
    // deref_null();  // 如果调用 unsafe 函数不加 unsafe 块，编译器就会报错。
    unsafe{ deref_null(); }
}
</code></pre></pre>
<p><strong>【相关讨论】</strong></p>
<ul>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0011.html">RUSTSEC-2020-0011</a></li>
<li><a href="https://github.com/RustSec/advisory-db/issues/275">https://github.com/RustSec/advisory-db/issues/275</a></li>
<li><a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/278">https://github.com/rust-lang/unsafe-code-guidelines/issues/278</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacpro02-实现过程宏时要对关键特性增加测试"><a class="header" href="#pmacpro02-实现过程宏时要对关键特性增加测试">P.MAC.PRO.02 实现过程宏时要对关键特性增加测试</a></h2>
<p><strong>【描述】</strong></p>
<p>实现过程宏的时候，要对关键特性增加测试，这是为了避免出现关键特性遗漏的情况。 </p>
<p><strong>【反例】</strong></p>
<p>在第三方库 <a href="https://github.com/iqlusioninc/crates/tree/main/zeroize">zeroize</a> 中，曾经因为过程宏中对枚举类型没有实现 Drop 而引起问题。参见：<a href="https://rustsec.org/advisories/RUSTSEC-2021-0115.html">RUSTSEC-2021-0115</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Zeroize)]
#[zeroize(drop)]
pub enum Fails {
    Variant(Vec&lt;u8&gt;),
}

// This does compile with zeroize_derive version 1.1, meaning `#[zeroize(drop)]` didn't implement `Drop`.
impl Drop for Fails {
    fn drop(&amp;mut self) {
        todo!()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>在第三方库 <a href="https://github.com/iqlusioninc/crates/tree/main/zeroize">zeroize</a> 中，曾经因为过程宏中对枚举类型没有实现 Drop 而引起问题。增加关键性测试可以避免这类问题。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn zeroize_on_struct() {
    parse_zeroize_test(stringify!(
        #[zeroize(drop)]
        struct Z {
            a: String,
            b: Vec&lt;u8&gt;,
            c: [u8; 3],
        }
    ));
}

#[test]
fn zeroize_on_enum() {
    parse_zeroize_test(stringify!(
        #[zeroize(drop)]
        enum Z {
            Variant1 { a: String, b: Vec&lt;u8&gt;, c: [u8; 3] },
        }
    ));
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacpro03-保证过程宏的卫生性"><a class="header" href="#pmacpro03-保证过程宏的卫生性">P.MAC.PRO.03 保证过程宏的卫生性</a></h2>
<p><strong>【描述】</strong></p>
<p>过程宏生成的代码尽量使用完全限定名，防止命名冲突产生意想不到的后果。</p>
<p>可以使用 <code>#![no_implicit_prelude]</code> 属性来验证过程宏的卫生性。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![no_implicit_prelude]

<span class="boring">fn main() {
</span>#[derive(MyMacro)]
struct A;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>quote!(a.to_string())
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>quote!(std::string::ToString::to_string(a))
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>quote! {{
    use std::string::ToString;
    a.to_string()
}}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacpro04-给出正确的错误位置"><a class="header" href="#pmacpro04-给出正确的错误位置">P.MAC.PRO.04 给出正确的错误位置</a></h2>
<p><strong>【描述】</strong></p>
<p>过程宏发生错误时，返回的错误应该有正确的位置信息。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 直接用Span::call_site()
Error::new(Span::call_site(), &quot;requires unit variant&quot;)
    .to_compile_error()
    .into()
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro_derive(MyMacro)]
pub fn derive_my_macro(input: TokenStream) -&gt; TokenStream {
    let derive_input: DeriveInput = syn::parse_macro_input!(input as DeriveInput);

    if let Data::Enum(e) = &amp;derive_input.data {
        for variant in &amp;e.variants {
            if !variant.fields.is_empty() {
                // 使用variant的span
                return syn::Error::new_spanned(&amp;variant, &quot;must be a unit variable.&quot;)
                    .to_compile_error()
                    .into();
            }
        }
    }

    todo!()
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacpro05-代码生成要按情况选择使用过程宏还是-buildrs"><a class="header" href="#pmacpro05-代码生成要按情况选择使用过程宏还是-buildrs">P.MAC.PRO.05 代码生成要按情况选择使用过程宏还是 <code>build.rs</code></a></h2>
<p><strong>【描述】</strong></p>
<p>用过程宏生进行代码生成，比如生成新类型或函数，有一个缺点就是：IDE 无法识别它们，影响开发体验。</p>
<p>但是使用 <code>build.rs</code> 生成的代码，对 IDE 更友好。</p>
<p>不过随着 IDE 的增强，过程宏以后应该也能变得更加 IDE 友好。</p>
<p>建议按应用场景选择：</p>
<ul>
<li><code>build.rs</code> 一般用于根据外部文件生成代码的场景。比如根据 <code>C</code> 头文件生成 Rust 绑定，或者根据 <code>proto</code> 文件生成相应的 Rust 类型等，供开发者直接使用。</li>
<li>过程宏一般用于消除样例式代码，提升库使用者的开发体验。</li>
</ul>
<p><strong>【正例】</strong></p>
<p><code>build.rs</code> 把 <code>tonic</code> 生成的代码直接放在 <code>src</code> 目录 (生成的代码文件应该在 .gitignore 中忽略版本管理)，这样 IDE 能够识别它们使自动完成能够工作，提高开发效率。</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    tonic_build::configure()
        .out_dir(&quot;src&quot;)
        .compile(
            &amp;[&quot;proto/helloworld/helloworld.proto&quot;],
            &amp;[&quot;proto/helloworld&quot;],
        )?;
    println!(&quot;cargo:rerun-if-changed=proto&quot;);
}
</code></pre></pre>
<p><code>tarpc</code>的<code>service</code>宏会生成一个新的<code>WorldClient</code>类型，IDE完全无法识别。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tarpc::service]
trait World {
    async fn hello(name: String) -&gt; String;
}

let (client_transport, server_transport) = tarpc::transport::channel::unbounded();
let mut client = WorldClient::new(client::Config::default(), client_transport).spawn();
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacpro06-buildrs-生成的代码要保证没有任何警告"><a class="header" href="#pmacpro06-buildrs-生成的代码要保证没有任何警告">P.MAC.PRO.06 <code>build.rs</code> 生成的代码要保证没有任何警告</a></h2>
<p><strong>【描述】</strong></p>
<p><code>build.rs</code> 生成的代码(codegen)，要通过或忽略 clippy 检查，不要让库的使用者或应用用户自行忽略</p>
<p>codegen 库要保证生成的代码应该非常干净没有任何警告，不应该让库的使用者去处理生成代码中的警告。</p>
<p><strong>【反例】</strong></p>
<p>lalrpop v0.19.6 生成的代码有几百个 clippy 警告，&quot;淹没&quot;了用户自己代码的 clippy 警告</p>
<pre><code>warning: using `clone` on type `usize` which implements the `Copy` trait
      --&gt; /home/w/temp/my_parser/target/debug/build/my_parser-dd96f436ee76c58d/out/my_parser.rs:182148:21
       |
182148 |         let __end = __start.clone();
       |                     ^^^^^^^^^^^^^^^ help: try removing the `clone` call: `__start`
</code></pre>
<p>使得 lalrpop 库的使用者必须手动给生成的模块代码加上 allow clippy，给使用者带来不便</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lalrpop_mod!(
    #[allow(clippy::all)]
    my_parser
);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>tonic-build 生成的 rs 会通过 allow 忽略掉 clippy 警告</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod peer_communication_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="317-多线程"><a class="header" href="#317-多线程">3.17 多线程</a></h1>
<p>Rust 天生可以有效消除数据竞争。</p>
<h2 id="列表-37"><a class="header" href="#列表-37">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./threads/lock.html">锁同步</a>
<ul>
<li><a href="safe-guides/coding_practice/./threads/lock/P.MTH.LOK.01.html">P.MTH.LOK.01 多线程下要注意识别锁争用的情况，避免死锁</a></li>
<li><a href="safe-guides/coding_practice/./threads/lock/G.MTH.LOK.01.html">G.MTH.LOK.01 对布尔或引用并发访问应该使用原子类型而非互斥锁</a></li>
<li><a href="safe-guides/coding_practice/./threads/lock/G.MTH.LOK.02.html">G.MTH.LOK.02 建议使用 <code>Arc&lt;str&gt; / Arc&lt;[T]&gt;</code> 来代替 <code>Arc&lt;String&gt; / Arc&lt;Vec&lt;T&gt;&gt;</code></a></li>
<li><a href="safe-guides/coding_practice/./threads/lock/G.MTH.LOK.03.html">G.MTH.LOK.03 尽量避免直接使用标准库 <code>std::sync</code> 模块中的同步原语，替换为 <code>parking_lot</code></a></li>
<li><a href="safe-guides/coding_practice/./threads/lock/G.MTH.LOK.04.html">G.MTH.LOK.04 尽量避免直接使用标准库 <code>std::sync::mpsc</code> 模块中的 <code>channel</code>，替换为 <code>crossbeam</code></a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./threads/lock-free.html">无锁</a>
<ul>
<li><a href="safe-guides/coding_practice/./threads/lock-free/P.MTH.LKF.01.html">P.MTH.LKF.01 除非必要，否则建议使用同步锁</a></li>
<li><a href="safe-guides/coding_practice/./threads/lock-free/P.MTH.LKF.02.html">P.MTH.LKF.02 使用无锁编程时，需要合理选择内存顺序</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="锁同步"><a class="header" href="#锁同步">锁同步</a></h1>
<p>Rust 中多线程并发使用锁来进行线程同步。</p>
<h2 id="列表-38"><a class="header" href="#列表-38">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/threads/./lock/P.MTH.LCK.02.html">P.MTH.LCK.01 多线程下要注意识别锁争用的情况，避免死锁</a></li>
<li><a href="safe-guides/coding_practice/threads/./lock/G.MTH.LCK.01.html">G.MTH.LCK.01 对布尔或引用并发访问应该使用原子类型而非互斥锁</a></li>
<li><a href="safe-guides/coding_practice/threads/./lock/G.MTH.LCK.02.html">G.MTH.LCK.02 建议使用 <code>Arc&lt;str&gt; / Arc&lt;[T]&gt;</code> 来代替 <code>Arc&lt;String&gt; / Arc&lt;Vec&lt;T&gt;&gt;</code></a></li>
<li><a href="safe-guides/coding_practice/threads/./lock/G.MTH.LCK.03.html">G.MTH.LCK.03 尽量避免直接使用标准库 <code>std::sync</code> 模块中的同步原语，替换为 <code>parking_lot</code></a></li>
<li><a href="safe-guides/coding_practice/threads/./lock/G.MTH.LCK.04.html">G.MTH.LCK.04 尽量避免直接使用标准库 <code>std::sync::mpsc</code> 模块中的 <code>channel</code>，替换为 <code>crossbeam</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmthlck01-多线程下要注意识别锁争用的情况避免死锁"><a class="header" href="#pmthlck01-多线程下要注意识别锁争用的情况避免死锁">P.MTH.LCK.01 多线程下要注意识别锁争用的情况，避免死锁</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 并不能保证没有死锁，要注意 <code>LockResult&lt;MutexGuard&lt;'_, T&gt;&gt;</code> 的生命周期，以防止出现死锁的情况。</p>
<p><strong>【反例】</strong></p>
<p>下面代码有一定的几率会触发死锁。</p>
<pre><pre class="playground"><code class="language-rust">// 触发死锁时，只会输出：
// Thread 1 holds a lock and starts waiting b lock
// Thread 2 hodls a lock and starts waiting a lock

use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let a = Arc::new(Mutex::new(0));
    let b = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    {
        let a = Arc::clone(&amp;a);
        let b = Arc::clone(&amp;b);
        let handle = thread::spawn(move || {
            let mut a_num = a.lock().unwrap();
            *a_num += 1;
            println!(&quot;Thread 1 holds a lock and starts waiting b lock&quot;);
            let mut b_num = b.lock().unwrap();
            *b_num += 1;
        });
        handles.push(handle);
    }
    {
        let a = Arc::clone(&amp;a);
        let b = Arc::clone(&amp;b);
        let handle = thread::spawn(move || {
            let mut b_num = b.lock().unwrap();
            *b_num += 1;
            println!(&quot;Thread 2 holds b lock and starts waiting a lock&quot;);
            let mut a_num = a.lock().unwrap();
            *a_num += 1;
            println!(&quot;Thread 2&quot;);
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Done {}&quot;, *a.lock().unwrap()); // never reach here
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 无死锁发生，正常输出
// Thread 1 holds a lock and starts waiting b lock
// Thread 2 hodls a lock and starts waiting a lock
// Thread 2
// Done 2

use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let a = Arc::new(Mutex::new(0));
    let b = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    {
        let a = Arc::clone(&amp;a);
        let b = Arc::clone(&amp;b);
        let handle = thread::spawn(move || {
            {   // &lt;- 这里增加显示作用域，确保 lock 之后可以自动解锁
                // 即 LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; 在作用域之外会自动释放
                let mut a_num = a.lock().unwrap();
                *a_num += 1;
                println!(&quot;Thread 1 holds a lock and starts waiting b lock&quot;);
            }
            {   // &lt;- 这里增加显示作用域，确保 lock 之后可以自动解锁
                // 即 LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; 在作用域之外会自动释放
                let mut b_num = b.lock().unwrap();
                *b_num += 1;
            }
        });
        handles.push(handle);
    }
    {
        let a = Arc::clone(&amp;a);
        let b = Arc::clone(&amp;b);
        let handle = thread::spawn(move || {
            {   // &lt;- 这里增加显示作用域，确保 lock 之后可以自动解锁
                // 即 LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; 在作用域之外会自动释放
                let mut b_num = b.lock().unwrap();
                *b_num += 1;
                println!(&quot;Thread 2 holds b lock and starts waiting a lock&quot;);
            }
            {   // &lt;- 这里增加显示作用域，确保 lock 之后可以自动解锁
                // 即 LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; 在作用域之外会自动释放
                let mut a_num = a.lock().unwrap();
                *a_num += 1;
            }
            println!(&quot;Thread 2&quot;);
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Done {}&quot;, *a.lock().unwrap());
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmthlck01-对布尔或引用并发访问应该使用原子类型而非互斥锁"><a class="header" href="#gmthlck01-对布尔或引用并发访问应该使用原子类型而非互斥锁">G.MTH.LCK.01 对布尔或引用并发访问应该使用原子类型而非互斥锁</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>使用原子类型性能更好。但要注意指定合理的内存顺序。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = Mutex::new(&amp;y);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = AtomicBool::new(y);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#mutex_atomic">mutex_atomic</a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmthlck02-建议使用-arcstr--arct-来代替--arcstring--arcvect"><a class="header" href="#gmthlck02-建议使用-arcstr--arct-来代替--arcstring--arcvect">G.MTH.LCK.02 建议使用 <code>Arc&lt;str&gt; / Arc&lt;[T]&gt;</code> 来代替  <code>Arc&lt;String&gt; / Arc&lt;Vec&lt;T&gt;&gt;</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p><code>Arc&lt;str&gt; / Arc&lt;[T]&gt;</code> 的性能比  <code>Arc&lt;String&gt; / Arc&lt;Vec&lt;T&gt;&gt;</code> 更好。</p>
<p>因为 ：</p>
<ul>
<li><code>Arc&lt;String&gt; / Arc&lt;Vec&lt;T&gt;&gt;</code> 有一层中间层： <code>arc -&gt; String len/Vec&lt;T&gt; len -&gt; text/data</code>，它是一个薄指针（thin pointer）。</li>
<li><code>Arc&lt;str&gt;/ Arc&lt;[T]&gt;</code> 则没有中间层： <code>arc &amp; string len / [T] len -&gt; text/data</code>，它是一个胖指针（fat pointer）。</li>
</ul>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;
use std::sync::Arc;

fn main() {
    let a = &quot;hello world&quot;.to_string();
    let b: Rc&lt;String&gt; = Rc::from(a);
    println!(&quot;{}&quot;, b);

    // or equivalently:
    let a = &quot;hello world&quot;.to_string();
    let b: Rc&lt;String&gt; = a.into();
    println!(&quot;{}&quot;, b);

    // we can also do this for Arc,
    let a = &quot;hello world&quot;.to_string();
    let b: Arc&lt;String&gt; = Arc::from(a);
    println!(&quot;{}&quot;, b);
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;
use std::sync::Arc;

fn main() {
    let a: &amp;str = &quot;hello world&quot;;
    let b: Rc&lt;str&gt; = Rc::from(a);
    println!(&quot;{}&quot;, b);

    // or equivalently:
    let b: Rc&lt;str&gt; = a.into();
    println!(&quot;{}&quot;, b);

    // we can also do this for Arc,
    let a: &amp;str = &quot;hello world&quot;;
    let b: Arc&lt;str&gt; = Arc::from(a);
    println!(&quot;{}&quot;, b);
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#rc_buffer">rc_buffer</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmthlck03-尽量避免直接使用标准库-stdsync-模块中的同步原语替换为-parking_lot"><a class="header" href="#gmthlck03-尽量避免直接使用标准库-stdsync-模块中的同步原语替换为-parking_lot">G.MTH.LCK.03 尽量避免直接使用标准库 <code>std::sync</code> 模块中的同步原语，替换为 <a href="https://crates.io/crates/parking_lot"><code>parking_lot</code></a></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>尽量避免对标准库 <code>std::sync</code> 模块中锁同步原语的使用，建议使用 <a href="https://crates.io/crates/parking_lot"><code>parking_lot</code></a> 的实现。</p>
<p><strong>【反例】</strong></p>
<p>来源于 <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html">std标准库文档</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::{Arc, Mutex};
use std::thread;
use std::sync::mpsc::channel;

const N: usize = 10;

let data = Arc::new(Mutex::new(0));

let (tx, rx) = channel();
for _ in 0..N {
    let (data, tx) = (Arc::clone(&amp;data), tx.clone());
    thread::spawn(move || {      
        let mut data = data.lock().unwrap();
        *data += 1;
        if *data == N {
            tx.send(()).unwrap();
        }
    });
}

rx.recv().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>例子来源于 <a href="https://docs.rs/parking_lot/0.11.2/parking_lot/type.Mutex.html">parking_lot 文档</a></p>
<p>相比<code>std::sync::Mutex</code>，使用 <code>parking_lot::Mutex</code> 能实现'无中毒'，锁在 panic 时正常释放，更少的空间占用等优势。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use parking_lot::Mutex;
use std::sync::{Arc, mpsc::channel};
use std::thread;

const N: usize = 10;

let data = Arc::new(Mutex::new(0));

let (tx, rx) = channel();
for _ in 0..10 {
    let (data, tx) = (Arc::clone(&amp;data), tx.clone());
    thread::spawn(move || {
        let mut data = data.lock();
        *data += 1;
        if *data == N {
            tx.send(()).unwrap();
        }
    });
}

rx.recv().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p><strong>【定制化参考】</strong>
这条规则如果需要定制 Lint，则可以扫描 <code>std::sync</code> 锁同步原语的使用，推荐优先选择 crate <code>parking_lot</code> 中对应的同步原语。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmthlck04-尽量避免直接使用标准库-stdsyncmpsc-模块中的-channel替换为-crossbeam"><a class="header" href="#gmthlck04-尽量避免直接使用标准库-stdsyncmpsc-模块中的-channel替换为-crossbeam">G.MTH.LCK.04 尽量避免直接使用标准库 <code>std::sync::mpsc</code> 模块中的 <code>channel</code>，替换为 <a href="https://github.com/crossbeam-rs/crossbeam"><code>crossbeam</code></a></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>尽量避免使用 <code>std::sync::mpsc::channel</code>，建议使用 <a href="https://github.com/crossbeam-rs/crossbeam"><code>crossbeam</code></a></p>
<p><strong>【反例】</strong></p>
<p>例子来源于 <a href="https://doc.rust-lang.org/std/sync/mpsc/"><code>std::sync::mpsc</code> 文档</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::sync::mpsc::channel;

let (tx, rx) = channel();

for i in 0..10 {
    let tx = tx.clone();
    thread::spawn(move|| {
        tx.send(i).unwrap();
    });
}

for _ in 0..10 {
    let j = rx.recv().unwrap();
    assert!(0 &lt;= j &amp;&amp; j &lt; 10);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crossbeam_channel::unbounded;

let (tx, rx) = unbounded();

for i in 0..10 {
    let tx = tx.clone();
    thread::spawn(move|| {
        tx.send(i).unwrap();
    });
}

for _ in 0..10 {
    let j = rx.recv().unwrap();
    assert!(0 &lt;= j &amp;&amp; j &lt; 10);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p><strong>【定制化参考】</strong>
这条规则如果需要定制 Lint，则可以扫描对 <code>std::sync::mpsc::channel</code> 的使用，推荐优先选择 crate <code>crossbeam</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="无锁并发"><a class="header" href="#无锁并发">无锁并发</a></h1>
<p>Rust 也支持原子类型，其内存顺序模型与 <code>C++20</code> 相同。</p>
<h2 id="列表-39"><a class="header" href="#列表-39">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/threads/./lock-free/P.MTH.LKF.01.html">P.MTH.LKF.01 除非必要，否则建议使用同步锁</a></li>
<li><a href="safe-guides/coding_practice/threads/./lock-free/P.MTH.LKF.02.html">P.MTH.LKF.02 使用无锁编程时，需要合理选择内存顺序</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmthlkf01-除非必要否则建议使用同步锁"><a class="header" href="#pmthlkf01-除非必要否则建议使用同步锁">P.MTH.LKF.01 除非必要，否则建议使用同步锁</a></h2>
<p><strong>【描述】</strong></p>
<p>无锁编程性能不一定比同步锁高。</p>
<p>使用无锁编程时需要注意的地方比使用同步锁多，比如指令重排、ABA 问题、内存顺序是否指定正确等。
正确实现无锁编程比使用同步锁要困难很多。所以，除非必要，否则直接使用同步锁就可以。</p>
<p>也有一些 <a href="https://github.com/magiclen/rust-performance-measurement/blob/master/benches/atomic_mutex.rs">性能测试</a> 作为参考，原子类型的性能比互斥锁的性能大概要好四倍左右。所以，当在同一个临界区内要有超过四次原子操作，也许使用互斥锁更加简单一些。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmthlkf02-使用无锁编程时需要合理选择内存顺序"><a class="header" href="#pmthlkf02-使用无锁编程时需要合理选择内存顺序">P.MTH.LKF.02 使用无锁编程时，需要合理选择内存顺序</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 原子类型使用 <a href="https://zh.cppreference.com/w/cpp/atomic/memory_order"><code>C++20</code> 的内存顺序模型</a> 来指定原子操作的内存同步方式，但也不是完全采用此模型。</p>
<p>目前 Rust 引入五种内存顺序：<code>Relaxed / Release / Acquire / AcqRel / SeqCst</code>。</p>
<p>在无锁编程中，指定正确的内存顺序是很重要很复杂的一件事，这里有一些建议：</p>
<ol>
<li>如果对程序中的原子类型同步方式的判断没有太多信息，建议使用 <code>SeqCst</code>，它表示顺序一致性，会强制所有线程都同意程序指令以单一全局线性的方式来执行。这样可以保证安全性，但性能有一定损失。</li>
<li>如果对无锁实现中线程间发生的数据竞争带来的后果不是特别关心，则可以放心使用 <code>Relaxed</code>，因为它性能最好。</li>
<li>当多个线程之间操作内存中同一个位置有因果关系时，适合使用 <code>Acquire / Release / AcqRel</code> 来配对。比如，线程 A 写 (<code>Release</code>) 内存中的一个位置，然后线程 B 随后读 (<code>Acquire</code>) 内存中一个相同的位置，就会产生一个因果关系，所以为了保证 A 的每次写入都能在 B 读取之前被观察到。如果 A 和 B 访问不同内存位置，则没有因果关系。</li>
</ol>
<p><strong>【正例】</strong></p>
<p>自旋锁中 <code>Acquire / Release</code> 搭配使用的简易示例：</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};
use std::thread;

fn main() {
    let lock = Arc::new(AtomicBool::new(false)); // 这个原子类型的值用来表示 &quot;是否获取到锁&quot;

    // ... distribute lock to threads somehow ...

    // 线程 A 尝试通过设置为 ture 来获取锁
    //
    // Acquire 内存顺序:
    // 当与 load 结合使用时，若 load 的值是由具有 Release (或更强) 排序的 store 操作写入的，则所有后续操作
    // 都将在该 store 之后进行排序。特别是，所有后续load都将看到在 store 之前写入的数据。
    while lock.compare_and_swap(false, true, Ordering::Acquire) { }
    // 在循环外，意味着已经拿到了锁！

    // ...访问/操作数据...

    // 线程A完成了数据操作，释放锁。
    // 此处用 Release 内存顺序可以确保线程B在获取锁时能看到线程A释放了锁（对内存写入 false）
    //
    // Release 内存顺序：
    // 当与 store 结合使用时，所有先前的操作都会在使用 Acquire（或更强）排序的任何 load 此值之前排序。
    // 特别是，所有先前的写入对执行 Acquire 此值（或更强）load 的线程都可见。
    lock.store(false, Ordering::Release);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="318-异步编程"><a class="header" href="#318-异步编程">3.18 异步编程</a></h1>
<p><code>async / await</code> 是 Rust 语言用于编写像同步代码一样的异步函数的内置工具。<code>async</code> 将一个代码块转化为一个实现了名为 <code>Future</code> 的特质 (trait)
的状态机。虽然在同步方法中调用阻塞函数会阻塞整个线程，但阻塞的 <code>Future</code> 将让出线程控制权，允许其他 <code>Future</code> 运行。</p>
<p>Rust 异步编程需要依赖于异步运行时，生产环境中比较推荐的开源异步运行时是 <a href="https://github.com/tokio-rs/tokio">Tokio</a>。</p>
<h2 id="列表-40"><a class="header" href="#列表-40">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./async-await/P.ASY.01.html">P.ASY.01 异步编程并不适合所有场景，计算密集型场景应该考虑同步编程</a></li>
<li><a href="safe-guides/coding_practice/./async-await/G.ASY.01.html">G.ASY.01 在 async 块/函数中调用 async 函数/闭包请不要忘记添加.await</a></li>
<li><a href="safe-guides/coding_practice/./async-await/G.ASY.02.html">G.ASY.02 在跨 await 调用中，需要对其持有的同步互斥锁进行处理</a></li>
<li><a href="safe-guides/coding_practice/./async-await/G.ASY.03.html">G.ASY.03 在跨 await 调用中，需要对其持有 RefCell 的引用进行处理</a></li>
<li><a href="safe-guides/coding_practice/./async-await/G.ASY.04.html">G.ASY.04 避免定义不必要的异步函数</a></li>
<li><a href="safe-guides/coding_practice/./async-await/G.ASY.05.html">G.ASY.05 避免在异步处理过程中包含阻塞操作</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pasy01-异步编程并不适合所有场景计算密集型场景应该考虑同步编程"><a class="header" href="#pasy01-异步编程并不适合所有场景计算密集型场景应该考虑同步编程">P.ASY.01 异步编程并不适合所有场景，计算密集型场景应该考虑同步编程</a></h2>
<p><strong>【描述】</strong></p>
<p>异步编程适合 I/O 密集型应用，如果是计算密集型场景应该考虑使用同步编程。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gasy01-在-async-块函数中调用-async-函数闭包请不要忘记添加await"><a class="header" href="#gasy01-在-async-块函数中调用-async-函数闭包请不要忘记添加await">G.ASY.01 在 <code>async</code> 块/函数中调用 <code>async</code> 函数/闭包请不要忘记添加<code>.await</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在此条件下 <code>.await</code> 语句通常为必须的。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo() {}

fn bar() {
  let x = async {
    foo()
  };
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo() {}

fn bar() {
  let x = async {
    foo().await
  };
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>用例来源：<a href="https://docs.rs/crate/fishrock_lambda_runtime/0.3.0-patched.1/source/src/lib.rs#:%7E:text=clippy%3a%3aasync_yields_async">fishrock_lambda_runtime</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[allow(clippy::async_yields_async)]
let task = tokio::spawn(async move { handler.call(body, ctx) });

let req = match task.await {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#async_yields_async">async_yields_async</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gasy02-在跨-await-调用中需要对其持有的同步互斥锁进行处理"><a class="header" href="#gasy02-在跨-await-调用中需要对其持有的同步互斥锁进行处理">G.ASY.02 在跨 <code>await</code> 调用中，需要对其持有的同步互斥锁进行处理</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>同步互斥锁本来就不是为异步上下文跨 <code>await</code> 调用而设计的，在这种场景中使用同步互斥锁容易造成死锁。当同步互斥锁被跨 <code>await</code> 时，有可能很长时间都不会返回这个调用点，在其他任务中再次用到这个互斥锁的时候，容易造成死锁。</p>
<p>这里有三种解决方案：</p>
<ol>
<li>使用异步互斥锁。但是异步互斥锁的开销要大于同步互斥锁。</li>
<li>确保同步互斥锁在调用 <code>await</code> 之前已经释放。</li>
</ol>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Mutex;

async fn foo(x: &amp;Mutex&lt;u32&gt;) {
  let guard = x.lock().unwrap();
  *guard += 1;
  bar.await;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;
// 使用同步互斥锁
async fn foo(x: &amp;Mutex&lt;u32&gt;) {
    {
        let guard = x.lock().unwrap();
        *guard += 1;
    }
    bar.await;
}

// 使用异步互斥锁
use tokio::sync::Mutex;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    // 使用 Arc 允许跨线程共享 Mutex
    let count = Arc::new(Mutex::new(0));

    for i in 0..5 {
        let my_count = Arc::clone(&amp;count);
        tokio::spawn(async move {
            for j in 0..10 {
                // 这里的 lock 在每次迭代后都会被释放
                let mut lock = my_count.lock().await;
                *lock += 1;
                println!(&quot;{} {} {}&quot;, i, j, lock);
            }
        });
    }

    loop {
        // 这里的 lock 在每次迭代后都会被释放
        if *count.lock().await &gt;= 50 {
            break;
        }
    }
    println!(&quot;Count hit 50.&quot;);
}
</code></pre></pre>
<p><strong>【例外】</strong></p>
<p>用例来源：<a href="https://github.com/khonsulabs/kludgine/blob/dafc1b5bab10702265cdd1d8ab210ce882d0f998/app/src/runtime/smol.rs#L31">kludgine</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Launch a thread pool
std::thread::spawn(|| {
    let (signal, shutdown) = flume::unbounded::&lt;()&gt;();

    easy_parallel::Parallel::new()
        // Run four executor threads.
        .each(0..4, |_| {
            #[allow(clippy::await_holding_lock)] // 这里是 读写锁，不是互斥锁
            futures::executor::block_on(async {
                let guard = GLOBAL_THREAD_POOL.read(); // 获取读写锁的读锁，不会出现锁争用情况，所以是线程安全的
                let executor = guard.as_ref().unwrap();
                executor.run(shutdown.recv_async()).await
            })
        })
        // Run the main future on the current thread.
        .finish(|| {});

    drop(signal);
});
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#await_holding_lock">await_holding_lock</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gasy03-在跨-await-调用中需要对其持有-refcell-的引用进行处理"><a class="header" href="#gasy03-在跨-await-调用中需要对其持有-refcell-的引用进行处理">G.ASY.03 在跨 <code>await</code> 调用中，需要对其持有 <code>RefCell</code> 的引用进行处理</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>与<a href="safe-guides/coding_practice/async-await/./G.ASY.02.html">上条规则</a>类似，使用 <code>RefCell</code> 的独占（可变）借用会导致 Panic。因为 <code>RefCell</code> 是运行时检查独占的可变访问，如果跨 <code>await</code> 持有一个可变引用则可能会因为共享的可变引用而引起 Panic。</p>
<p>这种共享可变在编译期是无法被检查出来的。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;

async fn foo(x: &amp;RefCell&lt;u32&gt;) {
  let mut y = x.borrow_mut();
  *y += 1;
  bar.await;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;

async fn foo(x: &amp;RefCell&lt;u32&gt;) {
  {
    let mut y = x.borrow_mut();
    *y += 1;
  }
  bar.await;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>跨 <code>await</code> 持有 <code>RefCell</code> 的可变借用，但是当前场景确信永远不会 Panic，则可以使用。</p>
<p>用例来源：<a href="https://github.com/MattiasBuelens/wasm-streams/blob/dff05d77513cc1d590c21cd251a63b43cf520fed/src/readable/into_underlying_byte_source.rs#L65">wasm-streams</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn pull(&amp;mut self, controller: sys::ReadableByteStreamController) -&gt; Promise {
  let inner = self.inner.clone();
  let fut = async move {
    // This mutable borrow can never panic, since the ReadableStream always queues
    // each operation on the underlying source.
    // 这个可变借用永远不会恐慌，因为 ReadableStream 对底层源的每个操作总是有序的。
    let mut inner = inner.try_borrow_mut().unwrap_throw();
    inner.pull(controller).await
  };
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#await_holding_refcell_ref">await_holding_refcell_ref</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gasy04-避免定义不必要的异步函数"><a class="header" href="#gasy04-避免定义不必要的异步函数">G.ASY.04 避免定义不必要的异步函数</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>如果一个异步函数内部没有任何异步代码，相比一个同步函数，它会产生额外的调用成本。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn add(value: i32) -&gt; i32 {
    value + 1
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(value: i32) -&gt; i32 {
    value + 1
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#unused_async">unused_async</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gasy05--避免在异步处理过程中包含阻塞操作"><a class="header" href="#gasy05--避免在异步处理过程中包含阻塞操作">G.ASY.05  避免在异步处理过程中包含阻塞操作</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>避免在异步编程中使用阻塞操作。</p>
<p><strong>【反例】</strong></p>
<p>不要在异步流程中使用阻塞操作函数</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error::Error;
use std::{fs, io};
    
async fn read_file() -&gt; Result&lt;String, std::io::Error&gt; {
    fs::read_to_string(&quot;test.txt&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>使用异步运行时，如tokio提供的非阻塞函数</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::fs;

async fn read_file() -&gt; std::io::Result&lt;()&gt; {
    let _ = fs::read_to_string(&quot;test.txt&quot;).await?;
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p><strong>【定制化参考】</strong>
这条规则如果需要定制Lint，则可以扫描异步过程，找到黑名单定义的阻塞操作调用，进行告警。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="319-unsafe-rust"><a class="header" href="#319-unsafe-rust">3.19 Unsafe Rust</a></h1>
<p>Unsafe Rust 是 Safe Rust 的超集，意味着在 Unsafe Rust 中也会有 Safe Rust的安全检查。但是 Unsafe Rust 中下面五件事是Safe Rust 的检查鞭长莫及的地方：</p>
<ol>
<li>解引用裸指针</li>
<li>调用 <code>unsafe</code>函数（C函数，编译器内部函数或原始分配器）</li>
<li>实现 <code>unsafe</code> trait</li>
<li>可变静态变量</li>
<li>访问  <code>union</code> 的字段</li>
</ol>
<p>使用 Unsafe Rust 的时候，需要遵守一定的规范，这样可以避免未定义行为的发生。</p>
<p>关于 Unsafe Rust 下的一些专用术语可以查看 <a href="safe-guides/coding_practice/./unsafe_rust/glossary.html">Unsafe 代码术语指南</a> 。</p>
<p><strong>Unsafe Rust 的语义：这是编译器无法保证安全的地方，需要程序员来保证安全。</strong> </p>
<h2 id="列表-41"><a class="header" href="#列表-41">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./unsafe_rust/P.UNS.01.html">P.UNS.01 不要为了逃避 编译器安全检查而滥用 Unsafe Rust</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/P.UNS.02.html">P.UNS.02 不要为了提升性能而盲目使用 Unsafe Rust</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/G.UNS.01.html">G.UNS.01 不要随便为 带有 unsafe命名的 类型或方法创建别名</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/safe_abstract.html">安全抽象</a>
<ul>
<li><a href="safe-guides/coding_practice/./unsafe_rust/safe_abstract/P.UNS.SAS.01.html">P.UNS.SAS.01 代码中要注意是否会因为 Panic 发生而导致内存安全问题</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/safe_abstract/P.UNS.SAS.02.html">P.UNS.SAS.02 Unsafe 代码编写者有义务检查代码是否满足安全不变式</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/safe_abstract/P.UNS.SAS.03.html">P.UNS.SAS.03 不要随便在公开的 API 中暴露未初始化内存</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/safe_abstract/P.UNS.SAS.04.html">P.UNS.SAS.04 要考虑 Panic Safety 的情况</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/safe_abstract/G.UNS.SAS.01.html">G.UNS.SAS.01 在公开的 unsafe 函数的文档中必须增加 Safety 注释</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/safe_abstract/G.UNS.SAS.02.html">G.UNS.SAS.02 在 Unafe 函数中应该使用 <code>assert!</code> 而非 <code>debug_assert!</code> 去校验边界条件</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/safe_abstract/G.UNS.SAS.03.html">G.UNS.SAS.03 Unsafe 代码中手动实现 <code>auto trait</code> 需要注意</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/safe_abstract/G.UNS.SAS.04.html">G.UNS.SAS.04 不要随便在公开的 API 中暴露裸指针</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/safe_abstract/G.UNS.SAS.05.html">G.UNS.SAS.05 在抽象安全方法的同时，也建议为性能考虑而增加相应的 Unsafe 方法</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/safe_abstract/G.UNS.SAS.06.html">G.UNS.SAS.06 函数参数是不可变借用的时候，返回值不应该是可变借用</a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/raw_ptr.html">裸指针操作</a>
<ul>
<li><a href="safe-guides/coding_practice/./unsafe_rust/raw_ptr/P.UNS.PTR.01.html">P.UNS.PTR.01 不要将裸指针在多线程间共享</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/raw_ptr/G.UNS.PTR.01.html">G.UNS.PTR.01 当指针类型被强转为和当前内存对齐不一致的指针类型时，禁止对其解引用</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/raw_ptr/G.UNS.PTR.02.html">G.UNS.PTR.02 禁止将不可变指针手工转换为可变指针</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/raw_ptr/G.UNS.PTR.03.html">G.UNS.PTR.03 尽量使用 pointer::cast 来代替 使用 as 强转指针</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/raw_ptr/G.UNS.PTR.04.html">G.UNS.PTR.04 建议使用 <code>NonNull&lt;T&gt;</code> 来替代 <code>*mut T</code></a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/raw_ptr/G.UNS.PTR.05.html">G.UNS.PTR.05 使用指针类型构造泛型结构体时，需要使用 PhantomData<T> 来指定 T上的协变和所有权</a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/union.html">联合体</a>
<ul>
<li><a href="safe-guides/coding_practice/./unsafe_rust/union/G.UNS.UNI.01.html">G.UNS.UNI.01 除了与 C 交互，尽量不要使用 Union</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/union/G.UNS.UNI.02.html">G.UNS.UNI.02 不要把联合体的不同变体用在不同生命周期内</a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/mem.html">内存</a>
<ul>
<li><a href="safe-guides/coding_practice/./unsafe_rust/mem/P.UNS.MEM.01.html">P.UNS.MEM.01 要注意选择合适的结构体、元组、枚举的数据布局</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/mem/P.UNS.MEM.02.html">P.UNS.MEM.02 不能修改其它进程/动态库的内存变量</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/mem/P.UNS.MEM.03.html">P.UNS.MEM.03 不能让 <code>String/Vec</code> 自动 <code>Drop</code> 其它进程/动态库的内存数据</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/mem/P.UNS.MEM.04.html">P.UNS.MEM.04 尽量用可重入(reentrant)版本的 C-API 或系统调用</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/mem/P.UNS.MEM.05.html">P.UNS.MEM.05 如果需要使用位域，推荐使用第三方库</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/mem/G.UNS.MEM.01.html">G.UNS.MEM.01 使用 <code>MaybeUninit&lt;T&gt;</code> 来处理未初始化的内存</a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/ffi.html">FFi</a>
<ul>
<li><a href="safe-guides/coding_practice/./unsafe_rust/ffi/P.UNS.FFI.01.html">P.UNS.FFI.01 避免从公开的 Rust API 直接传字符串到 C 中</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/ffi/P.UNS.FFI.02.html">P.UNS.FFI.02 在使用标准库 std::ffi 模块提供的类型时需要仔细查看其文档</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/ffi/P.UNS.FFI.03.html">P.UNS.FFI.03 当使用来自 C 的指针时，如果该指针需要管理内存，则需要为包装该指针的 Rust 类型实现 Drop 特质</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/ffi/P.UNS.FFI.04.html">P.UNS.FFI.04 如果一个函数正在跨越 FFi 边界，那么需要处理 Panic</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/ffi/P.UNS.FFI.05.html">P.UNS.FFI.05 建议使用诸如标准库或 <code>libc crate</code> 所提供的可移植类型别名，而不是特定平台的类型</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/ffi/P.UNS.FFI.06.html">P.UNS.FFI.06 Rust 和 C 之间传递字符或字符串时需要注意字符串要符合 C-ABI 以及 字符串的编码</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/ffi/P.UNS.FFI.07.html">P.UNS.FFI.07 不要为任何传入到外部的类型实现 Drop</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/ffi/P.UNS.FFI.08.html">P.UNS.FFI.08 FFi 中要进行合理的错误处理</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/ffi/P.UNS.FFI.09.html">P.UNS.FFI.09 当 Rust 调用外部 C 函数时，如果可以确认安全，可以通过引用来代替裸指针</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/ffi/P.UNS.FFI.10.html">P.UNS.FFI.10 当 Rust 函数导出外部函数时，必须从设计上保证被跨线程调用的安全性</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/ffi/P.UNS.FFI.11.html">P.UNS.FFI.11 如需引用指定为 <code>#[repr(packed)]</code> 内存布局的结构体成员字段要注意合理规避未定义行为</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/ffi/P.UNS.FFI.12.html">P.UNS.FFI.12 当依赖 C 端传入参数时，需要在文档注释中不变性声明，根据不同的调用场景选择合适的安全抽象方式</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/ffi/G.UNS.FFI.01.html">G.UNS.FFI.01 自定义数据类型要保证一致的数据布局</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/ffi/G.UNS.FFI.02.html">G.UNS.FFI.02 在 FFi 中使用的类型应该拥有稳定布局</a></li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/ffi/G.UNS.FFI.03.html">G.UNS.FFI.03 从外部传入的不健壮类型的外部值要进行检查</a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/io.html">I/O</a>
<ul>
<li><a href="safe-guides/coding_practice/./unsafe_rust/io/G.UNS.FIO.01.html">G.UNS.FIO.01 在使用原始句柄的时候，要注意 I/O 安全性</a></li>
</ul>
</li>
<li><a href="safe-guides/coding_practice/./unsafe_rust/glossary.html">Unsafe 代码术语指南</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="puns01--不要为了逃避-编译器安全检查而滥用-unsafe-rust"><a class="header" href="#puns01--不要为了逃避-编译器安全检查而滥用-unsafe-rust">P.UNS.01  不要为了逃避 编译器安全检查而滥用 Unsafe Rust</a></h2>
<p><strong>【描述】</strong></p>
<p>Unsafe Rust 有其应用范围和目标，不要为了逃避 编译器安全检查而随便滥用 Unsafe Rust，否则很可能引起未定义行为（UB）。</p>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">// 该函数为滥用 unsafe 来跳过 Rust 借用检查 
// 强行返回本地变量的引用，最终引起 UB 未定义行为
fn abuse_unsafe_return_local_ref&lt;'a&gt;() -&gt; &amp;'a String {
    let s = &quot;hello&quot;.to_string();
    let ptr_s_addr = &amp;s as *const String as usize;
    unsafe{ &amp;*(ptr_s_addr as *const String) }
}

fn main() {
    let s = abuse_unsafe_return_local_ref(); // error: Undefined Behavior: encountered a dangling reference (use-after-free)
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="puns02--不要为了提升性能而盲目使用-unsafe-rust"><a class="header" href="#puns02--不要为了提升性能而盲目使用-unsafe-rust">P.UNS.02  不要为了提升性能而盲目使用 Unsafe Rust</a></h2>
<p><strong>【描述】</strong></p>
<p>对比 Safe 代码的性能看是否够用，就可以减少不必要的 Unsafe。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="guns01--不宜为带有-unsafe-命名的类型或方法创建别名"><a class="header" href="#guns01--不宜为带有-unsafe-命名的类型或方法创建别名">G.UNS.01  不宜为带有 <code>unsafe</code> 命名的类型或方法创建别名</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Rust 里  <code>unsafe</code> 字样用于提醒开发者在编写代码的时候注意保证安全。如果修改别名，隐藏了这种提醒，不利于展示这种信息。</p>
<p>不利于开发者去保证安全。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::{UnsafeCell as TotallySafeCell};

extern crate crossbeam;
use crossbeam::{spawn_unsafe as spawn};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::{UnsafeCell};

extern crate crossbeam;
use crossbeam::{spawn_unsafe};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#unsafe_removed_from_name">unsafe_removed_from_name</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安全抽象规范"><a class="header" href="#安全抽象规范">安全抽象规范</a></h1>
<p>使用 Unsafe Rust 的一种方式是将 Unsafe 的方法或函数进行安全抽象，将其变成安全的方法或函数。</p>
<p>Unsafe Rust 中 API 的安全性设计通常有两种方式：</p>
<ol>
<li>将内部的 unsafe API 直接暴露给 API 的使用者，并且使用 <code>unsafe</code> 关键字来声明该 API 是非安全的，同时也需要对安全边界条件添加注释。</li>
<li>对 API 进行安全封装，即，安全抽象。在内部使用断言来保证当越过安全边界时可以 Panic，从而避免 UB 产生。</li>
</ol>
<p>第二种方式，对 Unsafe 代码进行安全抽象，是 Rust 生态的一种约定俗成。</p>
<h2 id="列表-42"><a class="header" href="#列表-42">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/unsafe_rust/./safe_abstract/P.UNS.SAS.01.html">P.UNS.SAS.01 代码中要注意是否会因为 Panic 发生而导致内存安全问题</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./safe_abstract/P.UNS.SAS.02.html">P.UNS.SAS.02 Unsafe 代码编写者有义务检查代码是否满足安全不变式</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./uafe_abstract/P.UNS.SAS.03.html">P.UNS.SAS.03 不要随便在公开的 API 中暴露未初始化内存</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./safe_abstract/P.UNS.SAS.04.html">P.UNS.SAS.04 要考虑 Panic Safety 的情况</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./safe_abstract/G.UNS.SAS.01.html">G.UNS.SAS.01 在公开的 unsafe 函数的文档中必须增加 Safety 注释</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./safe_abstract/G.UNS.SAS.02.html">G.UNS.SAS.02 在 Unafe 函数中应该使用 <code>assert!</code> 而非 <code>debug_assert!</code> 去校验边界条件</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./safe_abstract/G.UNS.SAS.03.html">G.UNS.SAS.03 Unsafe 代码中手动实现 <code>auto trait</code> 需要注意</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./safe_abstract/G.UNS.SAS.04.html">G.UNS.SAS.04 不要随便在公开的 API 中暴露裸指针</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./safe_abstract/G.UNS.SAS.05.html">G.UNS.SAS.05 在抽象安全方法的同时，也建议为性能考虑而增加相应的 Unsafe 方法</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./safe_abstract/G.UNS.SAS.06.html">G.UNS.SAS.06 函数参数是不可变借用的时候，返回值不应该是可变借用</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punssas01--代码中要注意是否会因为-panic-发生而导致内存安全问题"><a class="header" href="#punssas01--代码中要注意是否会因为-panic-发生而导致内存安全问题">P.UNS.SAS.01  代码中要注意是否会因为 Panic 发生而导致内存安全问题</a></h2>
<p><strong>【描述】</strong></p>
<p>Panic 一般在程序达到不可恢复的状态才用，当然在 Rust 中也可以对一些实现了<code>UnwindSafe</code> trait 的类型捕获Panic。</p>
<p>当 Panic 发生时，会引发栈回退（stack unwind），调用栈分配对象的析构函数，并将控制流转移给 Panic 处理程序中。所以，当 Panic 发生的时候，当前存活变量的析构函数将会被调用，从而导致一些内存安全问题，比如释放已经释放过的内存。</p>
<p>通常， 封装的 Unsafe 代码可能会暂时绕过所有权检查，而且，安全封装的 API 在内部 unsafe 代码的值返回之前，会根据安全边界条件确保它不会违反安全规则。但是，假如封装的 Unsafe 代码发生了Panic，则其外部安全检查可能不会执行。这很可能导致类似 C/C++ 中 未初始化（Uninitialized ）或双重释放（Double Free）的内存不安全问题。</p>
<p>想要正确的推理在 Unsafe 代码中的恐慌安全，是非常困难且易于出错的。即便如此，在编写代码的时候也要刻意注意此类问题发生的可能性。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 标准库 `String::retain()` 曝出的 CVE-2020-36317 Panic safety bug

pub fn retain&lt;F&gt;(&amp;mut self, mut f: F)
where 
    F: FnMut(char) -&gt; bool
{
    let len = self.len();
    let mut del_bytes = 0;
 	let mut idx = 0;
 
    unsafe { self.vec.set_len(0); }    // + 修复bug 的代码
 	while idx &lt; len {
 		let ch = unsafe {
  			self.get_unchecked(idx..len).chars().next().unwrap()
 		};
 		let ch_len = ch.len_utf8();
 
 		// self is left in an inconsistent state if f() panics
        // 此处如果 f() 发生了 Panic，self 的长度就会不一致
 		if !f(ch) {
 			del_bytes += ch_len;
 		} else if del_bytes &gt; 0 {
 			unsafe {
 				ptr::copy(self.vec.as_ptr().add(idx),
 				self.vec.as_mut_ptr().add(idx - del_bytes),
 				ch_len);
 			}
 		}
 		idx += ch_len; // point idx to the next char
 	}
 	unsafe { self.vec.set_len(len - del_bytes); } // + 修复bug 的代码 ，如果 while 里发生 Panic，则将返回长度设置为 0 
}

fn main(){
    // PoC: creates a non-utf-8 string in the unwinding path
    // 此处传入一个 非 UTF-8 编码字符串引发 Panic
    &quot;0è0&quot;.to_string().retain(|_| {
        match the_number_of_invocation() {
            1 =&gt; false,
            2 =&gt; true,
            _ =&gt; panic!(),
        }
    });
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punssas02--unsafe-代码编写者有义务检查代码是否满足安全不变式"><a class="header" href="#punssas02--unsafe-代码编写者有义务检查代码是否满足安全不变式">P.UNS.SAS.02  Unsafe 代码编写者有义务检查代码是否满足安全不变式</a></h2>
<p><strong>【描述】</strong></p>
<p>安全不变式（见 <a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/./glossary.html">Unsafe 代码术语指南</a> ）是 Rust 里的安全函数，在任何有效输入的情况下，都不应该发生任何未定义行为。</p>
<p>可以从以下三个方面来检查：</p>
<ol>
<li>逻辑一致性。</li>
<li>纯洁性。相同的输入总是要返回相同的输出。</li>
<li>语义约束。传入的参数要合法，满足数据类型。</li>
</ol>
<p><strong>【正例】</strong></p>
<p>该代码是为 <code>Borrow&lt;str&gt;</code> 实现 join 方法内部调用的一个函数 <code>join_generic_copy</code> 的展示。 在 <code>join_generic_copy</code> 内部，会对 <code>slice</code> 进行两次转换，而在 <code>spezialize_for_lengths!</code> 宏内部，调用了 <code>.borrow()</code> 方法，如果第二次转换和第一次不一样，而会返回一个未初始化字节的字符串。</p>
<p>这里， <code>Borrow&lt;B&gt;</code> 是高阶类型，它内部 <code>borrow</code> 的一致性其实并没有保证，可能会返回不同的 slice，如果不做处理，很可能会暴露出未初始化的字节给调用者。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// CVE-2020-36323: a higher-order invariant bug in join()
fn join_generic_copy&lt;B, T, S&gt;(slice: &amp;[S], sep: &amp;[T]) -&gt; Vec&lt;T&gt; 
where T: Copy, B: AsRef&lt;[T]&gt; + ?Sized, S: Borrow&lt;B&gt;
{
    let mut iter = slice.iter();

    // `slice`is converted for the first time
    // during the buffer size calculation.
    let len = ...;  // `slice` 在这里第一次被转换	
    let mut result = Vec::with_capacity(len);
    // ...
    unsafe {
        let pos = result.len();
        let target = result.get_unchecked_mut(pos..len);
 
        // `slice`is converted for the second time in macro
        // while copying the rest of the components.
        spezialize_for_lengths!(sep, target, iter; // `slice` 第二次被转换
        0, 1, 2, 3, 4);
 
        // Indicate that the vector is initialized
        result.set_len(len);
    }
    result
}

// PoC: a benign join() can trigger a memory safety issue
impl Borrow&lt;str&gt; for InconsistentBorrow {
    fn borrow(&amp;self) -&gt; &amp;str {
        if self.is_first_time() {
            &quot;123456&quot;
        } else {
            &quot;0&quot;
        }
    }
}

let arr: [InconsistentBorrow; 3] = Default::default();
arr.join(&quot;-&quot;);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punssas03--不要随便在公开的-api-中暴露未初始化内存"><a class="header" href="#punssas03--不要随便在公开的-api-中暴露未初始化内存">P.UNS.SAS.03  不要随便在公开的 API 中暴露未初始化内存</a></h2>
<p><strong>【描述】</strong></p>
<p>在公开的API中暴露未初始化内存可能导致 未定义行为。
关于未定义行为，可以参考<a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/./glossary.html">Unsafe 代码术语指南</a>。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 以下是有安全风险的代码示例：
impl&lt;R&gt; BufRead for GreedyAccessReader&lt;R&gt;
    where
        R: Read,
{
    fn fill_buf(&amp;mut self) -&gt; IoResult&lt;&amp;[u8]&gt; {
        if self.buf.capacity() == self.consumed {
            self.reserve_up_to(self.buf.capacity() + 16);
        }

        let b = self.buf.len();
        let buf = unsafe {
            // safe because it's within the buffer's limits
            // and we won't be reading uninitialized memory
            // 这里虽然没有读取未初始化内存，但是会导致用户读取
            std::slice::from_raw_parts_mut(
                self.buf.as_mut_ptr().offset(b as isize),
                self.buf.capacity() - b)
        };

        match self.inner.read(buf) {
            Ok(o) =&gt; {
                unsafe {
                    // reset the size to include the written portion,
                    // safe because the extra data is initialized
                    self.buf.set_len(b + o);
                }

                Ok(&amp;self.buf[self.consumed..])
            }
            Err(e) =&gt; Err(e),
        }
    }

    fn consume(&amp;mut self, amt: usize) {
        self.consumed += amt;
    }
}

// 另外一个漏洞代码
fn read_vec(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let len: u32 = de::Deserialize::deserialize(&amp;mut *self)?;
    // 创建了未初始化buf
    let mut buf = Vec::with_capacity(len as usize);
    unsafe { buf.set_len(len as usize) }
    self.read_size(u64::from(len))?;
    // 将其传递给了用户提供的`Read`实现
    self.reader.read_exact(&amp;mut buf[..])?;
    Ok(buf)
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 修正以后的代码示例，去掉了未初始化的buf：
impl&lt;R&gt; BufRead for GreedyAccessReader&lt;R&gt;
    where
        R: Read,
{
    fn fill_buf(&amp;mut self) -&gt; IoResult&lt;&amp;[u8]&gt; {
        if self.buf.capacity() == self.consumed {
            self.reserve_up_to(self.buf.capacity() + 16);
        }

        let b = self.buf.len();
        self.buf.resize(self.buf.capacity(), 0);
        let buf = &amp;mut self.buf[b..];
        let o = self.inner.read(buf)?;

        // truncate to exclude non-written portion
        self.buf.truncate(b + o);

        Ok(&amp;self.buf[self.consumed..])
    }

    fn consume(&amp;mut self, amt: usize) {
        self.consumed += amt;
    }
}

// 另外一个已修正漏洞的代码
fn read_vec(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let len: u32 = de::Deserialize::deserialize(&amp;mut *self)?;
    // 创建了未初始化buf
    let mut buf = Vec::with_capacity(len as usize);
    // 初始化为 0；
    buf.resize(len as usize, 0);
    self.read_size(u64::from(len))?;
    // 将其传递给了用户提供的`Read`实现
    self.reader.read_exact(&amp;mut buf[..])?;
    Ok(buf)
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punssas04--要考虑-panic-safety-的情况"><a class="header" href="#punssas04--要考虑-panic-safety-的情况">P.UNS.SAS.04  要考虑 Panic Safety 的情况</a></h2>
<p><strong>【描述】</strong></p>
<p>要注意 Panic Safety 的情况，避免双重释放（double free）的问题发生。</p>
<p>在使用 <code>std::ptr</code> 模块中接口需要注意，容易产生 UB 问题，要多多查看 API 文档。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//case 1
macro_rules! from_event_option_array_into_event_list(
    ($e:ty, $len:expr) =&gt; (
        impl&lt;'e&gt; From&lt;[Option&lt;$e&gt;; $len]&gt; for EventList {
                fn from(events: [Option&lt;$e&gt;; $len]) -&gt; EventList {
                    let mut el = EventList::with_capacity(events.len());
                    for idx in 0..events.len() {
                    // 这个 unsafe 用法在 `event.into()`调用 panic 的时候会导致双重释放
                        let event_opt = unsafe { ptr::read(events.get_unchecked(idx)) };
                        if let Some(event) = event_opt { el.push::&lt;Event&gt;(event.into()); }
                    }
                    // 此处 mem::forget 就是为了防止 `dobule free`。
                    // 因为 `ptr::read` 也会制造一次 drop。
                    // 所以上面如果发生了 panic，那就相当于注释了 `mem::forget`，导致 `dobule free`
                    mem::forget(events);
                    el
                }
        }
    )
);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! from_event_option_array_into_event_list(
    ($e:ty, $len:expr) =&gt; (
        impl&lt;'e&gt; From&lt;[Option&lt;$e&gt;; $len]&gt; for EventList {
            fn from(events: [Option&lt;$e&gt;; $len]) -&gt; EventList {
                let mut el = ManuallyDrop::new(
                    EventList::with_capacity(events.len())
                );

                for idx in 0..events.len() {
                    let event_opt = unsafe {
                        ptr::read(events.get_unchecked(idx))
                    };

                    if let Some(event) = event_opt {
                        // Use `ManuallyDrop` to guard against
                        // potential panic within `into()`.
                        // 当 into 方法发生 panic 当时候，这里 ManuallyDrop 可以保护其不会`double free`
                        let event = ManuallyDrop::into_inner(
                            ManuallyDrop::new(event)
                            .into()
                        );
                        el.push(event);
                    }
                }
                mem::forget(events);
                ManuallyDrop::into_inner(el)
            }
        }
    )
);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunssas01--在公开的-unsafe-函数的文档中必须增加-safety-注释"><a class="header" href="#gunssas01--在公开的-unsafe-函数的文档中必须增加-safety-注释">G.UNS.SAS.01  在公开的 unsafe 函数的文档中必须增加 Safety 注释</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>在公开（pub）的 unsafe 函数文档中，必须增加 <code># Safety</code> 注释来解释该函数的安全边界，这样使用该函数的用户才可以安全地使用它。</p>
<p>说明： 该规则通过 cargo clippy 来检测。默认会发出警告。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Creates a `Vec&lt;T&gt;` directly from the raw components of another vector.
    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -&gt; Self {
        unsafe { Self::from_raw_parts_in(ptr, length, capacity, Global) }
    }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>示例来自于标准库文档： <a href="https://doc.rust-lang.org/stable/src/alloc/vec/mod.rs.html#1167">https://doc.rust-lang.org/stable/src/alloc/vec/mod.rs.html#1167</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Creates a `Vec&lt;T&gt;` directly from the raw components of another vector.
    ///
    /// # Safety
    ///
    /// This is highly unsafe, due to the number of invariants that aren't
    /// checked:
    ///
    /// * `ptr` needs to have been previously allocated via [`String`]/`Vec&lt;T&gt;`
    ///   (at least, it's highly likely to be incorrect if it wasn't).
    /// * `T` needs to have the same size and alignment as what `ptr` was allocated with.
    ///   (`T` having a less strict alignment is not sufficient, the alignment really
    ///   needs to be equal to satisfy the [`dealloc`] requirement that memory must be
    ///   allocated and deallocated with the same layout.)
    /// * `length` needs to be less than or equal to `capacity`.
    /// * `capacity` needs to be the capacity that the pointer was allocated with.
    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -&gt; Self {
        unsafe { Self::from_raw_parts_in(ptr, length, capacity, Global) }
    }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>默认 level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_safety_doc">missing_safety_doc</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunssas02--在-unafe-函数中应该使用-assert-而非-debug_assert-去校验边界条件"><a class="header" href="#gunssas02--在-unafe-函数中应该使用-assert-而非-debug_assert-去校验边界条件">G.UNS.SAS.02  在 Unafe 函数中应该使用 <code>assert!</code> 而非 <code>debug_assert!</code> 去校验边界条件</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p><code>assert!</code> 宏在 Release 和 Debug 模式下都会被检查，并且不能被禁用。它通常用来在 unsafe 函数中判断传入的参数是否满足某种边界条件，以此来防止不合法的参数传入导致未定义行为。</p>
<p>但是 <code>debug_assert!</code> 则可以通过配置 <code>-C debug-assertions</code> 来禁用它， 而且 <code>debug_assert!</code> 在 Release 模式下也会被编译器优化。所以，一旦使用了 <code>debug_assert!</code> 在 unsafe 函数中用来防范不合法参数，那有可能会失效。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	// 使用了 debug_assert! 那就说明这个校验在 Release 模式不一定有效
    // 那么该函数就要被标记为  unsafe
	pub unsafe fn split_at_mut(&amp;mut self, mid: usize) -&gt; (&amp;mut [T], &amp;mut [T]) {
        debug_assert!(mid &lt;= self.len()); // 注意，这里是 debug_assert!
        // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which
        // fulfills the requirements of `from_raw_parts_mut`.
        unsafe { self.split_at_mut_unchecked(mid) }
    }

   // or
   // 在 debug_assert_eq! 中包含可变引用的调用，
   // 也会因为 debug_assert_ 系列的断言宏在 Release 下产生不可预料的结果，它是 unsafe 的
   debug_assert_eq!(vec![3].pop(), Some(3));
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>来自标准库 <code>slice</code> 的代码示例。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	pub fn split_at_mut(&amp;mut self, mid: usize) -&gt; (&amp;mut [T], &amp;mut [T]) {
        assert!(mid &lt;= self.len()); // 判断边界条件，杜绝非法参数
        // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which
        // fulfills the requirements of `from_raw_parts_mut`.
        unsafe { self.split_at_mut_unchecked(mid) }
    }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>默认 level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#debug_assert_with_mut_call">debug_assert_with_mut_call</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
</tbody></table>
<p>注意该 lint 当前是 Nursery Group，意味着可能会产生误报 Bug。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunssas03--unsafe-代码中手动实现-auto-trait-需要注意"><a class="header" href="#gunssas03--unsafe-代码中手动实现-auto-trait-需要注意">G.UNS.SAS.03  Unsafe 代码中手动实现 auto trait 需要注意</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>所谓 auto trait 是指 Safe Rust中由编译器自动实现的 trait，比如 <code>Send/Sync</code> 。在 Unsafe Rust中就需要手动实现这俩 trait 了。</p>
<p>所以，在手动实现的时候要充分考虑其安全性。</p>
<p><strong>【正例】</strong></p>
<p>Rust futures 库中发现的问题，错误的手工 <code>Send/Sync</code> 实现 破坏了线程安全保证。</p>
<p>受影响的版本中，<code>MappedMutexGuard</code> 的 <code>Send/Sync</code> 实现只考虑了 <code>T</code> 上的差异，而 <code>MappedMutexGuard</code> 则取消了对 <code>U</code> 的引用。</p>
<p>当 <code>MutexGuard::map()</code> 中使用的闭包返回与 <code>T</code> 无关的 <code>U</code> 时，这可能导致安全 Rust 代码中的数据竞争。</p>
<p>这个问题通过修正 <code>Send/Sync</code> 的实现，以及在 <code>MappedMutexGuard</code> 类型中添加一个 <code>PhantomData&lt;&amp;'a mut U&gt;</code> 标记来告诉编译器，这个防护也是在 U 之上。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// CVE-2020-35905: incorrect uses of Send/Sync on Rust's futures
pub struct MappedMutexGuard&lt;'a, T: ?Sized, U: ?Sized&gt; {
    mutex: &amp;'a Mutex&lt;T&gt;,
    value: *mut U,
    _marker: PhantomData&lt;&amp;'a mut U&gt;, // + 修复代码
}

impl&lt;'a, T: ?Sized&gt; MutexGuard&lt;'a, T&gt; {
    pub fn map&lt;U: ?Sized, F&gt;(this: Self, f: F)
        -&gt; MappedMutexGuard&lt;'a, T, U&gt;
        where F: FnOnce(&amp;mut T) -&gt; &amp;mut U {
            let mutex = this.mutex;
            let value = f(unsafe { &amp;mut *this.mutex.value.get() });
                mem::forget(this);
                // MappedMutexGuard { mutex, value }
                MappedMutexGuard { mutex, value, _marker: PhantomData } //  + 修复代码
    }
}

// unsafe impl&lt;T: ?Sized + Send, U: ?Sized&gt; Send
unsafe impl&lt;T: ?Sized + Send, U: ?Sized + Send&gt; Send // + 修复代码
for MappedMutexGuard&lt;'_, T, U&gt; {}
//unsafe impl&lt;T: ?Sized + Sync, U: ?Sized&gt; Sync
unsafe impl&lt;T: ?Sized + Sync, U: ?Sized + Sync&gt; Sync // + 修复代码
for MappedMutexGuard&lt;'_, T, U&gt; {}

// PoC: this safe Rust code allows race on reference counter
* MutexGuard::map(guard, |_| Box::leak(Box::new(Rc::new(true))));
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制参考】</p>
<p>Lint 需要检测 手工实现 auto trait 的行为，比如 <code>Sync/Send</code>，对开发者发出警告，要注意考虑其安全性</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunssas04--不要随便在公开的-api-中暴露裸指针"><a class="header" href="#gunssas04--不要随便在公开的-api-中暴露裸指针">G.UNS.SAS.04  不要随便在公开的 API 中暴露裸指针</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>在公开的API中暴露裸指针，可能会被用户修改为空指针，从而有段错误风险。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use cache;


/**

    `cache crate` 内部代码：

    ```rust
    pub enum Cached&lt;'a, V: 'a&gt; {
        /// Value could not be put on the cache, and is returned in a box
        /// as to be able to implement `StableDeref`
        Spilled(Box&lt;V&gt;),
        /// Value resides in cache and is read-locked.
        Cached {
            /// The readguard from a lock on the heap
            guard: RwLockReadGuard&lt;'a, ()&gt;,
            /// A pointer to a value on the heap
            // 漏洞风险
            ptr: *const ManuallyDrop&lt;V&gt;,
        },
        /// A value that was borrowed from outside the cache.
        Borrowed(&amp;'a V),
    }
**/
fn main() {
    let c = cache::Cache::new(8, 4096);
    c.insert(1, String::from(&quot;test&quot;));
    let mut e = c.get::&lt;String&gt;(&amp;1).unwrap();

    match &amp;mut e {
        cache::Cached::Cached { ptr, .. } =&gt; {
            // 将 ptr 设置为 空指针，导致段错误
            *ptr = std::ptr::null();
        },
        _ =&gt; panic!(),
    }
    // 输出：3851，段错误
    println!(&quot;Entry: {}&quot;, *e);
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制参考】</p>
<p>Lint需要检测在 pub 的结构体、枚举等类型中有裸指针字段或变体，对开发者发出警告，要注意考虑其安全性</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunssas05--在抽象安全方法的同时也建议为性能考虑而增加相应的-unsafe-方法"><a class="header" href="#gunssas05--在抽象安全方法的同时也建议为性能考虑而增加相应的-unsafe-方法">G.UNS.SAS.05  在抽象安全方法的同时，也建议为性能考虑而增加相应的 Unsafe 方法</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在 Rust 标准库中有很多后缀有 <code>_unchecked</code> 的方法，都对应一个没有该后缀的同名方法，比如 <code>get() / get_unchecked()</code>。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 假如调用环境可以保证地址是非空，那么可以使用这个 &quot;_unchecked&quot; 的函数
#[inline(always)]
pub unsafe fn io_read_u32_unchecked(ioaddr: usize) -&gt; u32 {
    let val = ptr::read_volatile(ioaddr as *const u32);
    trace!(&quot;io_read_u32 {:#x}={:#x}&quot;, ioaddr, val);
    val
}

/// 安全抽象版本
#[inline(always)]
pub unsafe fn io_read_u32() -&gt; Result&lt;u32, MyError&gt; {
    let ioaddr = ioaddr as * const u32;
    if ioaddr.is_null() {
        return Err(MyError::Content(&quot;io_read_u32 addr is null!&quot;));
    }
    unsafe {
        let val = ptr::read_volatile(ioaddr);
        trace!(&quot;io_read_u32 {:#x}={:#x}&quot;, ioaddr, val);
        ok(val)
    }
}   
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunssas06--函数参数是不可变借用的时候返回值不应该是可变借用"><a class="header" href="#gunssas06--函数参数是不可变借用的时候返回值不应该是可变借用">G.UNS.SAS.06  函数参数是不可变借用的时候，返回值不应该是可变借用</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>即便函数签名中没有 <code>unsafe</code>，但开发者无法保证它函数头部实现中不含 Unsafe代码。</p>
<p>当通过 Unsafe 安全抽象一个函数的时候，要注意符合规则中描述的签名约定：不能输入一个不可变借用，返回一个可变的，这是违反 Rust安全准则的。</p>
<p>当然，当函数被标识为 <code>unsafe</code> 时，是允许这种情况的。</p>
<p><strong>【反例】</strong></p>
<p>这个来自 Rust 官方的一个示例，这样的签名导致 Rust 出现了一个严重 bug，<a href="https://github.com/rust-lang/rust/issues/39465">来源</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 该函数未加 unsafe，被认为是安全的
// 但是函数签名违反了 Rust 的安全规则，不应该不可变借用进去，可变借用返回
pub fn as_mut_slice(&amp;self) -&gt; &amp;mut [T] {
    unsafe {
        slice::from_raw_parts_mut(self.ptr as *mut T, self.len())
    }
}    
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 修正以后的代码：https://github.com/rust-lang/rust/pull/39466/files
pub fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T] {
    unsafe {
        slice::from_raw_parts_mut(self.ptr as *mut T, self.len())
    }
} 
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://docs.rs/crate/wasmer/2.0.0/source/src/externals/memory.rs

/// Retrieve a mutable slice of the memory contents.
///
/// # Safety
///
/// This method provides interior mutability without an UnsafeCell. Until
/// the returned value is dropped, it is undefined behaviour to read or
/// write to the pointed-to memory in any way except through this slice,
/// including by calling a wasm function that reads the memory contents or
/// by resizing this Memory.
// 这里为 unsafe 函数，则允许这种情况
#[allow(clippy::mut_from_ref)]
pub unsafe fn data_unchecked_mut(&amp;self) -&gt; &amp;mut [u8] {
	let definition = self.vm_memory.from.vmmemory();
	let def = definition.as_ref();
	slice::from_raw_parts_mut(def.base, def.current_length.try_into().unwrap())
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="裸指针操作"><a class="header" href="#裸指针操作">裸指针操作</a></h1>
<p>Rust提供了<code>*const T</code>（不变）和<code>*mut T</code>（可变）两种指针类型。因为这两种指针和C语言中的指针十分相近，所以叫其原生指针（Raw Pointer）。</p>
<p>原生指针具有以下特点：</p>
<ul>
<li>并不保证指向合法的内存。比如很可能是一个空指针。</li>
<li>不能像智能指针那样自动清理内存。需要像 C 语言那样手动管理内存。</li>
<li>没有生命周期的概念，也就是说，编译器不会对其提供借用检查。</li>
<li>不能保证线程安全。</li>
</ul>
<p>可见，原生指针并不受Safe Rust提供的那一层“安全外衣”保护，所以也被称为“裸指针”。</p>
<h2 id="列表-43"><a class="header" href="#列表-43">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/unsafe_rust/./raw_ptr/P.UNS.PTR.01.html">P.UNS.PTR.01 不要将裸指针在多线程间共享</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./raw_ptr/G.UNS.PTR.01.html">G.UNS.PTR.01 当指针类型被强转为和当前内存对齐不一致的指针类型时，禁止对其解引用</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./raw_ptr/G.UNS.PTR.02.html">G.UNS.PTR.02 禁止将不可变指针手工转换为可变指针</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./raw_ptr/G.UNS.PTR.03.html">G.UNS.PTR.03 尽量使用 pointer::cast 来代替 使用 as 强转指针</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./raw_ptr/G.UNS.PTR.04.html">G.UNS.PTR.04 建议使用 <code>NonNull&lt;T&gt;</code> 来替代 <code>*mut T</code></a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./raw_ptr/G.UNS.PTR.05.html">G.UNS.PTR.05 使用指针类型构造泛型结构体时，需要使用 PhantomData<T> 来指定 T上的协变和所有权</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsptr01--不要将裸指针在多线程间共享"><a class="header" href="#punsptr01--不要将裸指针在多线程间共享">P.UNS.PTR.01  不要将裸指针在多线程间共享</a></h2>
<p><strong>【描述】</strong></p>
<p>裸指针在 Rust 中不是线程安全的，将裸指针在多线程传递编译器也会编译出错。如果需要在多线程间共享裸指针，则考虑使用 <code>NewType</code> 模式来包装它。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyBox(*mut u8);

unsafe impl Send for MyBox {}
unsafe impl Sync for MyBox {}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunsptr01--当指针类型被强转为和当前内存对齐不一致的指针类型时禁止对其解引用"><a class="header" href="#gunsptr01--当指针类型被强转为和当前内存对齐不一致的指针类型时禁止对其解引用">G.UNS.PTR.01  当指针类型被强转为和当前内存对齐不一致的指针类型时，禁止对其解引用</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>对于指针类型被强转为和当前内存对齐不一致的指针类型的情况，要注意不要对这类强转后的指针进行解引用操作，否则会有未定义行为。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = (&amp;1u8 as *const u8) as *const u16;
    let b = (&amp;mut 1u8 as *mut u8) as *mut u16;

    let c =  (&amp;1u8 as *const u8).cast::&lt;u16&gt;();

    // Undefined Behavior: dereferencing pointer failed: alloc1411 has size 1, so pointer to 2 bytes starting at offset 0 is out-of-bounds
    unsafe { *a }; 
    // Undefined Behavior: dereferencing pointer failed: alloc1411 has size 1, so pointer to 2 bytes starting at offset 0 is out-of-bounds
    unsafe { *b }; 
    // Undefined Behavior: dereferencing pointer failed: alloc1411 has size 1, so pointer to 2 bytes starting at offset 0 is out-of-bounds
    unsafe { *c }; 
}

</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = (&amp;1u8 as *const u8) as *const u8;
    let b = (&amp;mut 1u8 as *mut u8) as *mut u8;

    let c =  (&amp;1u8 as *const u8).cast::&lt;u8&gt;();
   
    // safe
    unsafe { *a }; 
    // safe
    unsafe { *b }; 
    // safe
    unsafe { *c }; 
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_ptr_alignment">cast_ptr_alignment</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunsptr02--禁止将不可变指针手工转换为可变指针"><a class="header" href="#gunsptr02--禁止将不可变指针手工转换为可变指针">G.UNS.PTR.02  禁止将不可变指针手工转换为可变指针</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>因为将不可变指针手工转换为可变指针可能会引发未定义行为。通常有这种需求，合法的手段是使用 <code>UnsafeCell&lt;T&gt;</code>。</p>
<p><strong>【 反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn x(r: &amp;i32) {
    unsafe {
        *(r as *const _ as *mut _) += 1;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::UnsafeCell;

fn x(r: &amp;UnsafeCell&lt;i32&gt;) {
   unsafe {
       *r.get() += 1;
   }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>也有例外情况，当明确知道这种转换会出现什么风险的时候，可以使用，或者在找到合适的解决办法之前 作为一种临时方案，但要加上注释。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// https://docs.rs/crate/solana-runtime/1.7.11/source/src/append_vec.rs
#[allow(clippy::cast_ref_to_mut)]
fn set_data_len_unsafe(&amp;self, new_data_len: u64) {
    // UNSAFE: cast away &amp; (= const ref) to &amp;mut to force to mutate append-only (=read-only) AppendVec
    unsafe {
        *(&amp;self.meta.data_len as *const u64 as *mut u64) = new_data_len;
    }
}

// https://docs.rs/crate/mmtk/0.6.0/source/src/policy/space.rs
// This is a temporary solution to allow unsafe mut reference. We do not want several occurrence
// of the same unsafe code.
// FIXME: We need a safe implementation.
#[allow(clippy::cast_ref_to_mut)]
#[allow(clippy::mut_from_ref)]
unsafe fn mut_self(&amp;self) -&gt; &amp;mut Self {
    &amp;mut *(self as *const _ as *mut _)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="lint-检测-3"><a class="header" href="#lint-检测-3">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_ref_to_mut">cast_ref_to_mut</a></td><td>yes</td><td>no</td><td><strong>correctness</strong></td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunsptr03--尽量使用-pointercast-来代替-使用-as-强转指针"><a class="header" href="#gunsptr03--尽量使用-pointercast-来代替-使用-as-强转指针">G.UNS.PTR.03  尽量使用 <code>pointer::cast</code> 来代替 使用 <code>as</code> 强转指针</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>使用 <code>pointer::cast</code> 方法转换更加安全，它不会意外地改变指针的可变性，也不会将指针转换为其他类型。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ptr: *const u32 = &amp;42_u32;
let mut_ptr: *mut u32 = &amp;mut 42_u32;
let _ = ptr as *const i32;
let _ = mut_ptr as *mut i32;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ptr: *const u32 = &amp;42_u32;
let mut_ptr: *mut u32 = &amp;mut 42_u32;
let _ = ptr.cast::&lt;i32&gt;();
let _ = mut_ptr.cast::&lt;i32&gt;();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#ptr_as_ptr">ptr_as_ptr</a></td><td>yes</td><td>no</td><td><strong>correctness</strong></td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunsptr04--建议使用-nonnullt-来替代-mut-t"><a class="header" href="#gunsptr04--建议使用-nonnullt-来替代-mut-t">G.UNS.PTR.04  建议使用 <code>NonNull&lt;T&gt;</code> 来替代 <code>*mut T</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>尽量使用 <a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html"><code>NonNull</code></a> 来包装 <code>*mut T</code>。</p>
<p><code>NonNull</code> 的优势：</p>
<ol>
<li>非空指针。会自动检查包装的指针是否为空。</li>
<li>协变。方便安全抽象。如果用裸指针，则需要配合 <code>PhantomData</code>类型来保证协变。</li>
</ol>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ptr::NonNull;

let mut x = 0u32;
let ptr = NonNull::&lt;u32&gt;::new(&amp;mut x as *mut _).expect(&quot;ptr is null!&quot;);

if let Some(ptr) = NonNull::&lt;u32&gt;::new(std::ptr::null_mut()) {
    unreachable!();
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制参考】</p>
<p>检测到包含 <code>*mut T</code>类型的结构体，应该给予开发者警告或建议去使用 <code>NonNull</code> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunsptr05--使用指针类型构造泛型结构体时需要使用-phantomdatat-来指定-t上的协变和所有权"><a class="header" href="#gunsptr05--使用指针类型构造泛型结构体时需要使用-phantomdatat-来指定-t上的协变和所有权">G.UNS.PTR.05  使用指针类型构造泛型结构体时，需要使用 <code>PhantomData&lt;T&gt;</code> 来指定 <code>T</code>上的协变和所有权</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p><code>PhantomData&lt;T&gt;</code> 是经常被用于 Unsafe Rust 中配合裸指针来指定协变和所有权的，为裸指针构建的类型保证安全性和有效性。否则，可能会产生未定义行为。</p>
<p>参考： <a href="https://doc.rust-lang.org/nomicon/phantom-data.html"><code>PhantomData&lt;T&gt;</code>  的型变（variance）模式表</a> </p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Vec&lt;T&gt; 不拥有类型 T，并且 data 字段的裸指针不支持协变
// 这样的话，是有风险的。
// 为 Vec&lt;T&gt; 实现的 Drop 可能导致 UB
struct Vec&lt;T&gt; {
    data: *const T, 
    len: usize,
    cap: usize,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker;

struct Vec&lt;T&gt; {
    data: *const T, // *const for variance!
    len: usize,
    cap: usize,
    _marker: marker::PhantomData&lt;T&gt;, // 让 Vec&lt;T&gt; 拥有 T，并且让 指针有了协变
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制参考】</p>
<p>检测使用指针类型构造泛型结构体时，如果没有 <code>PhantomData&lt;T&gt;</code> 类型的字段，则需要警告开发者，要考虑 为裸指针配合<code>PhantomData&lt;T&gt;</code>来指定协变和所有权</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="联合体union"><a class="header" href="#联合体union">联合体（Union）</a></h1>
<p>Union 是没有 tag 的 Enum，Enum 是有 tag 的Union 。</p>
<p>内存布局 Union 和 Enum 相似。</p>
<p>正因为没有 tag，Rust 编译器无法检查当前使用的正是哪个变体，所以，访问 Union 的变体是 Unsafe 的。</p>
<h2 id="列表-44"><a class="header" href="#列表-44">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/unsafe_rust/./union/G.UNS.UNI.01.html">G.UNS.UNI.01 除了与 C 交互，尽量不要使用 Union</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./union/G.UNS.UNI.02.html">G.UNS.UNI.02 不要把联合体的不同变体用在不同生命周期内</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunsuni01--除了与-c-交互尽量不要使用-union"><a class="header" href="#gunsuni01--除了与-c-交互尽量不要使用-union">G.UNS.UNI.01  除了与 C 交互，尽量不要使用 Union</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>Rust 支持 Union 就是为了调用 C 接口。如果不是 FFi ，就避免使用 Union。</p>
<p>一般情况下请使用 枚举 或 结构体代替。</p>
<p>使用 Copy 类型的值和 <code>ManuallyDrop</code> 来初始化 Union 的变体，不需要使用 Unsafe 块。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union MyUnion {
    f1: u32,
    f2: f32,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
union MyUnion {
    f1: u32,
    f2: f32,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>这条规则如果需要定制 Lint，则可以检测 Union 联合体上方是否有 <code>#[repr(C)]</code>属性定义与C兼容的数据布局，如果没有则给予警告。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunsuni02--不要把联合体的不同变体用在不同生命周期内"><a class="header" href="#gunsuni02--不要把联合体的不同变体用在不同生命周期内">G.UNS.UNI.02  不要把联合体的不同变体用在不同生命周期内</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>对联合体的变体进行借用的时候，要注意其他变体也将在同一个生命周期内。抛开内存布局、安全性和所有权之外，联合体的行为和结构体完全一致，你可以将联合体当做结构体来进行判断。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ERROR: cannot borrow `u` (via `u.f2`) as mutable more than once at a time
fn test() {
    let mut u = MyUnion { f1: 1 };
    unsafe {
        let b1 = &amp;mut u.f1;
//                    ---- first mutable borrow occurs here (via `u.f1`)
        let b2 = &amp;mut u.f2;
//                    ^^^^ second mutable borrow occurs here (via `u.f2`)
        *b1 = 5;
    }
//  - first borrow ends here
    assert_eq!(unsafe { u.f1 }, 5);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制化参考】</p>
<p>检测函数内同一个联合体实例的不同变体被用于不同的生命周期内。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存"><a class="header" href="#内存">内存</a></h1>
<p>这里指 Unsafe Rust 下的数据布局、内存管理和使用相关规范。</p>
<h2 id="列表-45"><a class="header" href="#列表-45">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/unsafe_rust/./mem/P.UNS.MEM.01.html">P.UNS.MEM.01 要注意选择合适的结构体、元组、枚举的数据布局</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./mem/P.UNS.MEM.02.html">P.UNS.MEM.02 不能修改其它进程/动态库的内存变量</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./mem/P.UNS.MEM.03.html">P.UNS.MEM.03 不能让 <code>String/Vec</code> 自动 <code>Drop</code> 其它进程/动态库的内存数据</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./mem/P.UNS.MEM.04.html">P.UNS.MEM.04 尽量用可重入(reentrant)版本的 C-API 或系统调用</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./mem/P.UNS.MEM.05.html">P.UNS.MEM.05 如果需要使用位域，推荐使用第三方库</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./mem/G.UNS.MEM.01.html">G.UNS.MEM.01 使用 <code>MaybeUninit&lt;T&gt;</code> 来处理未初始化的内存</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsmem01--要注意选择合适的结构体元组枚举的数据布局"><a class="header" href="#punsmem01--要注意选择合适的结构体元组枚举的数据布局">P.UNS.MEM.01  要注意选择合适的结构体、元组、枚举的数据布局</a></h2>
<p><strong>【描述】</strong></p>
<p>对于 Rust 中结构体和元组，编译器会随意重排其字段来优化布局。请根据具体的场景来选择合适的数据布局。</p>
<p>可以通过以下 <code>#[repr]</code> 属性来控制结构体和元组的数据布局：</p>
<ul>
<li><code>#[repr(Rust)]</code> ，默认 Rust 数据布局</li>
<li><code>#[repr(C)]</code> ，与 C 兼容的布局</li>
<li><code>#[repr(align(N))]</code> ，指定对齐方式</li>
<li><code>#[repr(packed)]</code> ，指定字段将不在内部对齐</li>
<li><code>#[repr(transparent)]</code> ，让包含单个字段的结构体布局和其字段相同</li>
</ul>
<p>可以通过以下 <code>#[repr]</code> 属性来控制枚举体的数据布局：</p>
<ul>
<li>特定整数类型
<ul>
<li><code>#[repr(u8)]</code></li>
<li><code>#[repr(u16)]</code></li>
<li><code>#[repr(u32)]</code></li>
<li><code>#[repr(u64)]</code></li>
<li><code>#[repr(i8)]</code></li>
<li><code>#[repr(i16)]</code></li>
<li><code>#[repr(i32)]</code></li>
<li><code>#[repr(i64)]</code></li>
</ul>
</li>
<li>C 兼容布局
<ul>
<li><code>#[repr(C)]</code></li>
</ul>
</li>
<li>指定判别式大小的 C 兼容布局
<ul>
<li><code>#[repr(C, u8)]</code></li>
<li><code>#[repr(C, u16)]</code></li>
<li>以此类推</li>
</ul>
</li>
</ul>
<p>枚举需要注意的地方：</p>
<ul>
<li>枚举不允许通过 <code>#[repr(align)]</code> 手动指定对齐方式。</li>
<li>空枚举不能使用 <code>repr</code> 属性</li>
<li>无字段枚举不允许指定判别式大小的 C 兼容布局，比如 <code>[repr(C, Int)]</code></li>
<li>数据承载（有字段）枚举则允许所有类型的 <code>repr</code> 属性</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsmem02--不能修改其它进程动态库的内存变量"><a class="header" href="#punsmem02--不能修改其它进程动态库的内存变量">P.UNS.MEM.02  不能修改其它进程/动态库的内存变量</a></h2>
<p><strong>【描述】</strong></p>
<p>除非调用合法的API，否则不要尝试修改其它进程/动态库的内存数据，否则会出现内存段错误(SIGSEGV)。</p>
<p><strong>【反例】</strong></p>
<p><code>sqlite3_libversion()</code> 返回的 sqlite 版本信息指针指向 <code>/usr/lib/libsqlite3.so</code> 动态库的 static 字符串。</p>
<p>libsqlite3.so 中分配的静态字符串不属于进程的内存范围中。</p>
<p>当进程尝试修改 sqlite 动态库的静态字符串内容，操作系统就会发送 SIGSEGV 信号终止进程，以保证 sqlite 动态库的内存数据安全。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;sqlite3&quot;)]
extern &quot;C&quot; {
    fn sqlite3_libversion() -&gt; *mut std::os::raw::c_char;
}

fn edit_sqlite_version() {
    unsafe {
        let mut sqlite_version = sqlite3_libversion();
        // SIGSEGV: invalid memory reference
        *sqlite_version = 3;
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsmem03--不能让-stringvec-自动-drop-其它进程动态库的内存数据"><a class="header" href="#punsmem03--不能让-stringvec-自动-drop-其它进程动态库的内存数据">P.UNS.MEM.03  不能让 String/Vec 自动 Drop 其它进程/动态库的内存数据</a></h2>
<p><strong>【描述】</strong></p>
<p>使用 String/Vec 指向其它进程/动态库的内存数据时，一定要手动禁止 String/Vec 的 Drop 方法(析构函数)的调用，避免 free 其它进程/动态库的内存数据。</p>
<p><strong>【反例】</strong></p>
<p><code>sqlite3_libversion()</code> 返回的 sqlite 版本信息指针指向 <code>/usr/lib/libsqlite3.so</code> 动态库的 static 字符串。</p>
<p>当进程在 String drop 的时候尝试释放 sqlite 动态库的静态字符串内存时，操作系统就会发送 SIGABRT 信号终止进程，以保证 sqlite 动态库的内存数据安全。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;sqlite3&quot;)]
extern &quot;C&quot; {
    fn sqlite3_libversion() -&gt; *mut std::os::raw::c_char;
}

fn print_sqlite_version() {
    unsafe {
        let ptr = sqlite3_libversion();
        let len = libc::strlen(ptr);
        let version = String::from_raw_parts(ptr.cast(), len, len);
        println!(&quot;found sqlite3 version={}&quot;, version);
        // SIGABRT: invalid free
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>除了用 mem::forget 或者 ManualDrop 禁止 String drop 其它动态库的内存，也可以用标准库 ptr/slice 的 copy 或者 <code>libc::strdup</code> 将 sqlite 的版本信息字符串<strong>复制到当前进程的内存空间</strong>再进行操作</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_sqlite_version() {
    unsafe {
        let ptr = sqlite3_libversion();
        let len = libc::strlen(ptr);
        let version = String::from_raw_parts(ptr.cast(), len, len);
        println!(&quot;found sqlite3 version={}&quot;, version);
        // 手动禁止 String 的析构函数调用
        std::mem::forget(version);
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsmem04--尽量用可重入reentrant版本的-c-api-或系统调用"><a class="header" href="#punsmem04--尽量用可重入reentrant版本的-c-api-或系统调用">P.UNS.MEM.04  尽量用可重入(reentrant)版本的 C-API 或系统调用</a></h2>
<p><strong>【描述】</strong></p>
<p>以 Linux 系统为例，在 <strong>glibc</strong>(/usr/lib/libc.so) 等知名 C 语言库中，</p>
<p>很多 API 会既提供不可重入版本和**可重入(reentrant)**版本，例如 ctime 和 ctime_r 这对系统调用。</p>
<p>可重入版本的函数命名一般带 <strong>_r</strong> 的后缀，<em>_r</em> 也就是单词可重入 reentrant 的缩写。</p>
<p>libc 中不可重入函数的执行过程一般是将函数的输出写到动态库的某个 static 命令内，然后再返回指向该 static 变量的指针返回给调用方，因此是一种「有状态」的函数，多线程环境下可能有<strong>线程安全问题</strong>。</p>
<p>例如线程 A 正在将 glibc 动态库的 gmtime 数据逐个复制回来，结果复制到一半线程 B 调用 gmtime 把后半部分的 gmtime 输出数据给更新掉了，导致线程 A 得到的数据有误。</p>
<p>而无重入版本例如 libc::localtime_r 会比 libc::localtime 多一个入参叫 result，</p>
<p>允许调用方进程的内存空间内分配内存，再将调用方进程的可变指针传入到 glibc 中让 glibc 修改可变指针指向的数据。</p>
<p>应当通过工具搜索动态库的函数符号查找可重入版本的函数，或者通过 man 文档查询自己所用函数有没有可重入的版本。</p>
<pre><code>[w@ww repos]$ nm -D /usr/lib/libc.so.6 | grep &quot;_r@&quot;
00000000000bb030 W asctime_r@@GLIBC_2.2.5
00000000000bb100 T ctime_r@@GLIBC_2.2.5
0000000000040a30 T drand48_r@@GLIBC_2.2.5
</code></pre>
<p>使用不可重入函数的危害例如 P.UNS.MEM.02 和 P.UNS.MEM.03 规范的反例中的 sqlite3_libversion() 会导致开发人员带来很大的心智负担，需要人工 code review 确保没有线程安全和内存安全问题，因此必须尽量使用可重入版本的函数。</p>
<p><strong>【反例】</strong></p>
<p><code>ctime</code>, <code>gmtime</code>,<code> localtime</code>, <code>gethostbyname</code></p>
<p><strong>【正例】</strong></p>
<p><code>chrono</code> 库中用 <code>libc::localtime_r</code> 获取本地时间而不用 <code>libc::localtime</code></p>
<p><code>ctime_r</code>, <code>gmtime_r</code>,<code> localtime_r</code>, <code>gethostbyname_r</code></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsmem05--如果需要使用位域推荐使用第三方库"><a class="header" href="#punsmem05--如果需要使用位域推荐使用第三方库">P.UNS.MEM.05  如果需要使用位域，推荐使用第三方库</a></h2>
<p><strong>【描述】</strong></p>
<p>位域（或称“位段”， Bit field）为一种数据结构，可以把数据以位的形式紧凑的存储，并允许程序员对此结构的位进行寻址和操作。</p>
<p>这种数据结构的好处：</p>
<ul>
<li>可以使数据单元节省存储空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。</li>
<li>位域可以很方便的访问一个整数值的部分内容从而可以简化程序源代码。</li>
</ul>
<p>而位域这种数据结构的缺点在于，其内存分配与内存对齐的实现方式依赖于具体的机器和系统，在不同的平台可能有不同的结果，这导致了位域在本质上是不可移植的。所以目前 Rust 并未在语言内置位域支持。</p>
<p>Rust 中使用位域时推荐使用的第三方库：</p>
<ul>
<li><a href="https://github.com/bitvecto-rs/bitvec">bitvec</a>，是 Cpp 中 <code>std::vector&lt;bool&gt;</code>和<code>std::bitset</code> 数据结构的 Rust 实现。
在性能、功能性、API完整性和表现力方面，该库都非常优秀。</li>
<li><a href="https://github.com/bitflags/bitflags">bitflags</a>，提供了方便的宏语法来定义和处理位域。</li>
<li><a href="https://github.com/Robbepop/modular-bitfield">modular-bitfield</a>，提供了一些宏来定义和处理位域，并且是完全基于 Safe Rust。</li>
</ul>
<p>以上三个库都支持 <code>no-std</code>。</p>
<p><strong>【正例】</strong></p>
<p>以 <code>bitvec</code> 为例。 示例参考：<a href="https://myrrlyn.net/blog/misc/bitfields-in-rust">https://myrrlyn.net/blog/misc/bitfields-in-rust</a></p>
<p>C 语言中定义位域。</p>
<pre><code class="language-C">Struct SixFlags {
  uint16_t eins : 3;
  uint16_t zwei : 2;
  uint16_t drei : 3;
  uint16_t vier : 3;
  uint16_t funf : 2;
  uint16_t seid : 3;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">type SixFlagsBits = BitSlice&lt;Local, u16&gt;;

#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct SixFlags {
  inner: u16,
};

impl SixFlags {
  pub fn eins(&amp;self) -&gt; &amp;SixFlagsBits {
    &amp;self.inner.bits()[0 .. 3]
  }

  pub fn eins_mut(&amp;mut self) -&gt; &amp;mut SixFlagsBits {
    &amp;mut self.inner.bits()[0 .. 3]
  }

  pub fn zwei(&amp;self) -&gt; &amp;SixFlagsBits {
    &amp;self.inner.bits()[3 .. 5]
  }

  pub fn zwei_mut(&amp;mut self) -&gt; &amp;mut SixFlagsBits {
    &amp;mut self.inner.bits()[3 .. 5]
  }
}

fn main() {
    let mut flags = SixFlags::default();
    flags.eins_mut().store(2u8);
    flags.zwei_mut().store(0u8);
    flags.drei_mut().store(4u8);
    flags.vier_mut().store(5u8);
    flags.funf_mut().store(1u8);
    flags.seis_mut().store(7u8); 
}






</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunsmem01---使用-maybeuninitt-来处理未初始化的内存"><a class="header" href="#gunsmem01---使用-maybeuninitt-来处理未初始化的内存">G.UNS.MEM.01   使用 <code>MaybeUninit&lt;T&gt;</code> 来处理未初始化的内存</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Rust 编译器要求变量要根据其类型正确初始化。</p>
<p>比如引用类型的变量必须对齐且非空。这是一个必须始终坚持的不变量，即使在 Unsafe 代码中也是如此。因此，零初始化引用类型的变量会导致立即未定义行为，无论该引用是否访问过内存。</p>
<p>编译器利用这一点，进行各种优化，并且可以省略运行时检查。</p>
<p>使用前请仔细查看 <code>MaybeUninit&lt;T&gt;</code> 相关文档。</p>
<p><strong>【反例】</strong></p>
<p>由调用者来保证<code>MaybeUninit&lt;T&gt;</code>确实处于初始化状态。当内存尚未完全初始化时调用 <code>assume_init()</code> 会导致立即未定义的行为。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::{self, MaybeUninit};
// 零初始化引用
let x: &amp;i32 = unsafe { mem::zeroed() }; // undefined behavior! ⚠️
// The equivalent code with `MaybeUninit&lt;&amp;i32&gt;`:
let x: &amp;i32 = unsafe { MaybeUninit::zeroed().assume_init() }; // undefined behavior! 
// 布尔值必须初始化
let b: bool = unsafe { mem::uninitialized() }; // undefined behavior! ⚠️
// The equivalent code with `MaybeUninit&lt;bool&gt;`:
let b: bool = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior! 
// 整数类型也必须初始化
let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior! ⚠️
// The equivalent code with `MaybeUninit&lt;i32&gt;`:
let x: i32 = unsafe { MaybeUninit::uninit().assume_init() }; 

// Vec未初始化内存使用 set_len 是未定义行为
let mut vec: Vec&lt;u8&gt; = Vec::with_capacity(1000);
unsafe { vec.set_len(1000); }
reader.read(&amp;mut vec); // undefined behavior!
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::MaybeUninit;

let mut x = MaybeUninit::&lt;bool&gt;::uninit();
x.write(true); // 这里正确进行了初始化
let x_init = unsafe { x.assume_init() }; // 通过 assume_init 对 MaybeUninit 的内存取值
assert_eq!(x_init, true);

// 下面数组应该是可以的
let _: [MaybeUninit&lt;bool&gt;; 5] = unsafe {
    MaybeUninit::uninit().assume_init()
};

// Vec 未初始化内存正确处理
let mut vec: Vec&lt;u8&gt; = vec![0; 1000];
reader.read(&amp;mut vec);
// or
let mut vec: Vec&lt;MaybeUninit&lt;T&gt;&gt; = Vec::with_capacity(1000);
vec.set_len(1000);  // `MaybeUninit` can be uninitialized
// or
let mut vec: Vec&lt;u8&gt; = Vec::with_capacity(1000);
let remaining = vec.spare_capacity_mut();  // `&amp;mut [MaybeUninit&lt;u8&gt;]`
// perform initialization with `remaining`
vec.set_len(...);  // Safe to call `set_len()` on initialized part
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>在能保证<code> MaybeUninit</code> 不需要初始化的情况下使用 <code>assume_init</code> 是安全的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe trait Array: Sized {
  
    /// Same array but item is wrapped with
    /// [`MaybeUninit&lt;_&gt;`](core::mem::MaybeUninit).
    /// ```
    /// # use arraylib::Array; fn dummy&lt;T&gt;() where
    /// [T; 4]: Array&lt;Item = T, Maybe = [core::mem::MaybeUninit&lt;T&gt;; 4]&gt;
    /// # {}
    /// ```
    type Maybe: Array&lt;Item = MaybeUninit&lt;Self::Item&gt;&gt;;

    /// [`MaybeUninit&lt;T&gt;`]: core::mem::MaybeUninit
    #[inline]
    // Initializing generic type with uninitialized state seems insane, but is
    // unsafe trait and `Array` guarantees that it's an array. And `Array::Maybe`
    // is an array of `MaybeUninit` that doesn't require initialization, so
    // everything is ok
    // 这里是一个数组，可以保证不需要去初始化
    #[allow(clippy::uninit_assumed_init)]
    fn uninit() -&gt; Self::Maybe {
        unsafe {
            // ## Safety
            //
            // Completely safe as `MaybeUninit` don't require initialization
            MaybeUninit::uninit().assume_init()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#uninit_assumed_init">uninit_assumed_init</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#uninit_vec">uninit_vec</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffi-规范"><a class="header" href="#ffi-规范">FFi 规范</a></h1>
<p>Rust 可以通过C-ABI无缝与C语言打交道，也可以通过暴露 C-ABI 接口供其他语言调用。但是跨边界本质上是不安全的。</p>
<p>一般来说，FFi 是指在其他语言中调用 Rust 代码，Rust代码会按 C-ABI 来暴露接口。这类 Rust crate或模块，常以 <code>-ffi</code>后缀结尾。</p>
<p>另一类是 Rust 去调用 C-ABI 接口，相关代码通常被封装到以 <code>-sys</code> 为后缀命名的 crate 或 模块中。 </p>
<p>本小节内容，包含以上两种情况。</p>
<h2 id="列表-46"><a class="header" href="#列表-46">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/unsafe_rust/./ffi/P.UNS.FFI.01.html">P.UNS.FFI.01 避免从公开的 Rust API 直接传字符串到 C 中</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./ffi/P.UNS.FFI.02.html">P.UNS.FFI.02 在使用标准库 std::ffi 模块提供的类型时需要仔细查看其文档</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./ffi/P.UNS.FFI.03.html">P.UNS.FFI.03 当使用来自 C 的指针时，如果该指针需要管理内存，则需要为包装该指针的 Rust 类型实现 Drop 特质</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./ffi/P.UNS.FFI.04.html">P.UNS.FFI.04 如果一个函数正在跨越 FFi 边界，那么需要处理 Panic</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./ffi/P.UNS.FFI.05.html">P.UNS.FFI.05 建议使用诸如标准库或 <code>libc crate</code> 所提供的可移植类型别名，而不是特定平台的类型</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./ffi/P.UNS.FFI.06.html">P.UNS.FFI.06 Rust 和 C 之间传递字符或字符串时需要注意字符串要符合 C-ABI 以及 字符串的编码</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./ffi/P.UNS.FFI.07.html">P.UNS.FFI.07 不要为任何传入到外部的类型实现 Drop</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./ffi/P.UNS.FFI.08.html">P.UNS.FFI.08 FFi 中要进行合理的错误处理</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./ffi/P.UNS.FFI.09.html">P.UNS.FFI.09 当 Rust 调用外部 C 函数时，如果可以确认安全，可以通过引用来代替裸指针</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./ffi/P.UNS.FFI.10.html">P.UNS.FFI.10 当 Rust 函数导出外部函数时，必须从设计上保证被跨线程调用的安全性</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./unsafe_rust/ffi/P.UNS.FFI.11.html">P.UNS.FFI.11 如需引用指定为 <code>#[repr(packed)]</code> 内存布局的结构体成员字段要注意合理规避未定义行为</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./unsafe_rust/ffi/P.UNS.FFI.12.html">P.UNS.FFI.12 当依赖 C 端传入参数时，需要在文档注释中不变性声明，根据不同的调用场景选择合适的安全抽象方式</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./ffi/G.UNS.FFI.01.html">G.UNS.FFI.01 自定义数据类型要保证一致的数据布局</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./ffi/G.UNS.FFI.02.html">G.UNS.FFI.02 在 FFi 中使用的类型应该拥有稳定布局</a></li>
<li><a href="safe-guides/coding_practice/unsafe_rust/./ffi/G.UNS.FFI.03.html">G.UNS.FFI.03 从外部传入的不健壮类型的外部值要进行检查</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi01"><a class="header" href="#punsffi01">P.UNS.FFI.01</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi02"><a class="header" href="#punsffi02">P.UNS.FFI.02</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi03"><a class="header" href="#punsffi03">P.UNS.FFI.03</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi04"><a class="header" href="#punsffi04">P.UNS.FFI.04</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi05"><a class="header" href="#punsffi05">P.UNS.FFI.05</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi06"><a class="header" href="#punsffi06">P.UNS.FFI.06</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi07"><a class="header" href="#punsffi07">P.UNS.FFI.07</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi08"><a class="header" href="#punsffi08">P.UNS.FFI.08</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi09"><a class="header" href="#punsffi09">P.UNS.FFI.09</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi10"><a class="header" href="#punsffi10">P.UNS.FFI.10</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi11"><a class="header" href="#punsffi11">P.UNS.FFI.11</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsffi12-当依赖-c-端传入参数时需要在文档注释中不变性声明根据不同的调用场景选择合适的安全抽象方式"><a class="header" href="#punsffi12-当依赖-c-端传入参数时需要在文档注释中不变性声明根据不同的调用场景选择合适的安全抽象方式">P.UNS.FFI.12 当依赖 C 端传入参数时，需要在文档注释中不变性声明，根据不同的调用场景选择合适的安全抽象方式</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>当 Rust 代码中依赖 C 接口传入的参数时，比如指针或其他类型的参数，需要在文档注释中不变性声明。</p>
<p>如果在调用场景可以确定所传入的参数都是有效的，比如指针不会是空指针等情况时，我们可以通过文档注释中对该接口做不变性声明(type invariant)，来强调对依赖的 C 代码的信任，这样做的好处有两点：</p>
<ol>
<li>可以避免检查，而达到零成本安全抽象的目的。</li>
<li>可以减少 unsafe 函数声明。</li>
</ol>
<p>具体可以参考【正例】的代码注释。</p>
<p><strong>【正例】</strong></p>
<p>场景一：如果在调用场景上能确定所传入的参数都是有效时。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 表示 `struct clk *`
///
/// # Invariants （不变性说明）
///
/// 这个指针来自 C语言 端，这里默认 C 端来的是有效指针，信任 C 端
/// 这种信任对性能有益：零成本（没有检查开销）
pub struct CPtr(*mut bindings::cptr);

impl CPtr {
    /// # Safety
    ///
    /// 这里使用unsafe 函数，是因为确实无法保证传入的指针是否有效，
    /// 这是构造 CPtr结构体实例的入口方法，所以有必要声明为 unsafe
    pub unsafe fn new(cptr: *mut bindings::cptr) -&gt; Self {
        Self(cptr)
    }

    // 安全性说明：这个指针已经有上面结构体定义时注释中的不变性声明来承诺安全了
    // 所以这是个方法没必要加 unsafe，因为已经有 new 方法标记为 unsafe 足以
    // 这种做法可以消除很多 unsafe 函数了
    // 同时，也不需要去检查 self.0 这个指针是不是空指针了
    pub fn get(&amp;self) -&gt; usize {
        // SAFETY: The pointer is valid by the type invariant.
        unsafe { bindings::cptr_get(self.0) as usize }
    }

    // 同上
    pub fn enable(self) -&gt; Result&lt;EnabledCPtr&gt; {
        // SAFETY: The pointer is valid by the type invariant.
        to_result(|| unsafe { bindings::cptrenable(self.0) })?;
        Ok(EnabledCPtr(self))
    }

    impl Drop for CPtr {
        // 同上
        fn drop(&amp;mut self) {
            // SAFETY: The pointer is valid by the type invariant.
            unsafe { bindings::clk_put(self.0) };
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>场景二：如果在调用场景上能无法确定所传入的参数都是有效时。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>/// # Invariants （不变性说明）
///
/// 这个指针来自 C语言 端，这里默认 C 端来的是有效指针，信任 C 端
/// 这种信任对性能有益：零成本（没有检查开销）
pub struct CPtr(*mut bindings::cptr);

impl CPtr {
    // 这里对空指针进行判断
    // 虽然抽象为了安全方法，但是如果不能panic的情况就比较麻烦，比如用 Rust 写 Linux 内核驱动
    // 或者，还需要进行错误处理，增加针对空指针的错误类型，增加复杂性
    pub fn new(cptr: *mut bindings::cptr) -&gt; Self {
        if cptr.is_null() {
            panic!(&quot;CPtr should not be null!&quot;)
        }
        Self(cptr)
    }

    // 因为 new 已经安全了，所以这个方法也安全
    pub fn get(&amp;self) -&gt; usize {
        // SAFETY: The pointer is valid by the type invariant.
        unsafe { bindings::cptr_get(self.0) as usize }
    }

    // 同上
    pub fn enable(self) -&gt; Result&lt;EnabledCPtr&gt; {
        // SAFETY: The pointer is valid by the type invariant.
        to_result(|| unsafe { bindings::cptrenable(self.0) })?;
        Ok(EnabledCPtr(self))
    }

    impl Drop for CPtr {
        // 同上
        fn drop(&amp;mut self) {
            // SAFETY: The pointer is valid by the type invariant.
            unsafe { bindings::clk_put(self.0) };
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gunsffi01"><a class="header" href="#gunsffi01">G.UNS.FFI.01</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gunsffi02"><a class="header" href="#gunsffi02">G.UNS.FFI.02</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gunsffi03"><a class="header" href="#gunsffi03">G.UNS.FFI.03</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-io"><a class="header" href="#unsafe-io">Unsafe I/O</a></h1>
<p>Rust 标准库提供了 I/O 安全性，保证程序持有私有的原始句柄（raw handle），其他部分无法访问它。但是 <code>FromRawFd::from_raw_fd</code> 是 Unsafe 的，所以在 Safe Rust中无法做到 <code>File::from_raw(7)</code> 这种事。 在这个文件描述符上面进行<code> I/O</code> 操作，而这个文件描述符可能被程序的其他部分私自持有。</p>
<h2 id="列表-47"><a class="header" href="#列表-47">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/unsafe_rust/./io/G.UNS.FIO.01.html">G.UNS.FIO.01 在使用原始句柄的时候，要注意 I/O 安全性</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunsfio01--在使用原始句柄的时候要注意-io-安全性"><a class="header" href="#gunsfio01--在使用原始句柄的时候要注意-io-安全性">G.UNS.FIO.01  在使用原始句柄的时候，要注意 I/O 安全性</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>很多 API 通过接受原始句柄来进行 I/O 操作：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn do_some_io&lt;FD: AsRawFd&gt;(input: &amp;FD) -&gt; io::Result&lt;()&gt; {
    some_syscall(input.as_raw_fd())
}
<span class="boring">}
</span></code></pre></pre>
<p><code>AsRawFd</code>并没有限制<code>as_raw_fd</code>的返回值，所以<code>do_some_io</code>最终可以在任意的<code>RawFd</code>值上进行 <code>I/O </code>操作。甚至可以写<code>do_some_io(&amp;7)</code>，因为<code>RawFd</code>本身实现了<code>AsRawFd</code>。这可能会导致程序访问错误的资源。甚至通过创建在其他部分私有的句柄别名来打破封装边界，导致一些诡异的 远隔作用（Action at a distance）。</p>
<blockquote>
<p><strong>远隔作用</strong>（<strong>Action at a distance</strong>）是一种程式设计中的<a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E6%A8%A1%E5%BC%8F">反模式</a>，是指程式某一部分的行为会广泛的受到程式其他部分<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4">指令</a>的影响，而且要找到影响其他程式的指令很困难，甚至根本无法进行。</p>
</blockquote>
<p>在一些特殊的情况下，违反 I/O 安全甚至会导致内存安全。</p>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p>【定制参考】</p>
<p>检测在 IO 时使用  <code>as_raw_fd</code> 调用时，警告开发者这是 Unsafe 的，要对传入的原始文件描述符的安全性进行考察。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unsafe-代码术语指南"><a class="header" href="#unsafe-代码术语指南">Unsafe 代码术语指南</a></h2>
<p>来自于：<a href="https://rust-lang.github.io/unsafe-code-guidelines/glossary.html">Unsafe Code Guidelines Reference | Glossary</a></p>
<table><thead><tr><th>术语</th><th>中文</th><th>意义</th></tr></thead><tbody>
<tr><td>Alias</td><td>别名</td><td>当一个指针或引用指向的内存范围（Span）和另一个指针或引用指向的内存区域重叠时，就会产生别名</td></tr>
<tr><td>(Pointer) Provenance</td><td>指针来源</td><td>用于区分指向相同内存地址的指针</td></tr>
<tr><td>Interior mutability</td><td>内部可变性</td><td>意味着一块可变的内存，同时还拥有一个共享引用，并且对其执行内部可变还不会引起 UB</td></tr>
<tr><td>Validity and safety invariant</td><td>有效性和安全性不变量</td><td>数据必须是有效的，但它只在安全的代码中才能保证安全</td></tr>
<tr><td>Undefined Behavior</td><td>未定义行为</td><td>最终程序在实际硬件上的表现与源程序根据Rust抽象机的表现不同</td></tr>
<tr><td>Soundness</td><td>健全性</td><td>意味着类型系统是正确的，健全性是类型良好的程序所需的属性</td></tr>
<tr><td>Layout</td><td>数据布局</td><td>用于定义类型的大小和对齐方式，以及它的子对象的偏移量</td></tr>
<tr><td>Zero-sized type / ZST</td><td>零大小类型</td><td>不占用空间的类型，即对齐要求为 <code>1</code> 的类型</td></tr>
<tr><td>Niche</td><td>利基</td><td>一个类型的利基决定了布局优化将使用的 无效位模式（bit-pattern）</td></tr>
<tr><td>Padding</td><td>填充</td><td>指编译器在结构体或枚举变体的字段之间填充空间，以满足对齐要求</td></tr>
<tr><td>Place</td><td>位置</td><td>位置是对位置表达式的求值结果（C 语言中叫&quot;左值，lvalue&quot;，C++中叫 &quot;广义左值，glvalue&quot;）</td></tr>
<tr><td>Value</td><td>值</td><td>值是对值表达式的求值结果 （其他语言叫 “右值，rvalue”）</td></tr>
<tr><td>Representation</td><td>表征</td><td>用于描述一个类型的值和内存中存储这个值的字节序列之间的关系</td></tr>
</tbody></table>
<p>​	</p>
<h2 id="别名alias"><a class="header" href="#别名alias">别名（Alias）</a></h2>
<p>当一个指针或引用指向的内存区域（Span）和另一个指针或引用指向的内存区域重叠时，就会产生别名。</p>
<p>对零大小类型（ZST）的引用和指针从不互相别名，因为它们的内存范围长度总是<code>0</code>字节。</p>
<p>【示例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let u: u64 = 7_u64;
    let r: &amp;u64 = &amp;u;
    let s: &amp;[u8] = unsafe {
        core::slice::from_raw_parts(&amp;u as *const u64 as *const u8, 8)
    };
    let (head, tail) = s.split_first().unwrap();
}
</code></pre></pre>
<p>该示例中，<code>r</code>  和 <code>s</code> 是互为别名，因为它们都指向 <code>u</code> 的内存。</p>
<p>然而，<code>head</code> 和 <code>tail</code> 不是互为别名，<code>head</code> 指向 <code>u</code>  的第一个字节，<code>tail</code> 指向其余字节。但是  <code>head</code> 和 <code>tail</code>  共同与 <code>s</code>  互为别名。</p>
<p>内存范围（Span）是指 引用或指针 指向值（Value）的大小，主要依赖于类型，按以下方式确定：</p>
<ol>
<li>对于一个是 <code>Sized</code> 的类型<code>T</code>，用 <code>size_of::&lt;T&gt;()</code> 可以获取 <code>T</code>的引用或指针的 内存范围长度。</li>
<li>当 <code>T</code>不是 <code>Sized</code> 时，就有点麻烦：
<ol>
<li>如果你有一个引用<code>r</code>，你可以使用<code>size_of_val(r)</code>来确定该引用的内存范围。</li>
<li>如果你有一个指针<code>p</code>，你必须在使用<code>size_of_val</code>之前不安全地(unsafely)将其转换为一个引用。目前还没有一个安全的方法来确定一个非<code>Sized</code>类型的指针的内存范围。</li>
</ol>
</li>
</ol>
<h2 id="指针来源pointer-provenance"><a class="header" href="#指针来源pointer-provenance">指针来源（(Pointer) Provenance）</a></h2>
<p>用于区分指向相同内存地址的指针，即，当强转为 <code>usize</code> 时，会比较是否相等。指针来源只存在于 Rust 的抽象层，在转译以后的二进制文件中，将无法区分指针来源，但是它可以影响编译器对程序的转译。</p>
<pre><pre class="playground"><code class="language-rust">
#![allow(unused)]
fn main() {
// 我们假设这里的两个分配的基本地址是 0x100 和 0x200
// 我们把指针的出处写成`@N`，其中`N`是某种唯一的ID，用来识别该分配
let raw1 = Box::into_raw(Box::new(13u8));
let raw2 = Box::into_raw(Box::new(42u8));
let raw2_wrong = raw1.wrapping_add(raw2.wrapping_sub(raw1 as usize) as usize);
// 这些指针现在有以下值:
//   raw1指向地址 0x100，其出处为 @1
//   raw2指向地址 0x200，并有出处 @2
//   raw2_wrong 指向地址 0x200，并有出处 @1
// 换句话说，raw2和raw2_wrong有相同的地址 
assert_eq!(raw2 as usize, raw2_wrong as usize);
// ...但是对 raw2_wrong 解引用将是不合法的，因为它有错误的来源（provenance）:
// 它指向地址 0x200，这是在分配 @2中，但这个指针的出处是 @1
}
</code></pre></pre>
<h2 id="内部可变性interior-mutability"><a class="header" href="#内部可变性interior-mutability">内部可变性（Interior mutability）</a></h2>
<p>意味着一块可变的内存，同时还拥有一个共享引用，并且对其执行内部可变还不会引起 UB。</p>
<p>如果由<code>&amp;T</code>或<code>&amp;mut T</code>立即指向的数据被改变，这就是内部可变。如果由<code>*const T</code>或<code>&amp;*const T</code>直接指向的数据被改变，就不是内部可变性。</p>
<p>Rust中所有的内部可变都必须发生在<code>UnsafeCell</code>内部，所以，所有具有内部可变性的数据结构都必须（直接或间接）使用<code>UnsafeCell</code>来实现这一目的。</p>
<h2 id="有效性安全不变性validity-and-safety-invariant"><a class="header" href="#有效性安全不变性validity-and-safety-invariant">有效性安全不变性（Validity and safety invariant）</a></h2>
<p>有效性（Validity）是指提供的数据必须与其对应类型一致，在其类型下必须有效。</p>
<p>安全性（safety）是指，可能引起 UB。</p>
<p>有效但不安全的一个示例是 <code>&amp;str</code> 或 <code>String</code> 类型。在 Unsafe Rust 下，可能会出现违反 UTF-8 编码的字符串，而 <code>&amp;str</code> 或 <code>String</code>  假设字符串都是合法的 UTF-8 编码，所以可能会出现 UB。</p>
<p>数据必须是有效的，但它只在安全的代码中才能保证安全。</p>
<h2 id="未定义行为-undefined-behavior"><a class="header" href="#未定义行为-undefined-behavior">未定义行为 （Undefined Behavior）</a></h2>
<p>程序员承诺，代码不会出现未定义行为。作为回报，编译器承诺以这样的方式编译代码：最终程序在实际硬件上的表现与源程序根据Rust抽象机的表现相同。如果发现程序确实有未定义的行为，那么程序员和编译器之间的契约就无效了，编译器将无法生成正确的程序（特别是，它不受任何规范的约束；程序甚至不一定是格式良好的可执行代码）。</p>
<p>未定义行为列表：</p>
<ul>
<li>数据竞争。</li>
<li>解引用悬空指针或者是未对齐指针</li>
<li>打破指针别名规则（引用生命周期不能长于其引用的对象，可变引用不能被别名）。</li>
<li>使用错误的 调用 ABI</li>
<li>执行使用当前执行线程不支持的目标特性（target features）编译的代码</li>
<li>产生无效的值
<ul>
<li>非<code>0</code>和 <code>1</code> 表达的 bool </li>
<li>具有无效判别式的 枚举</li>
<li>在 <code>[0x0, 0xD7FF] </code>和 <code>[0xE000, 0x10FFFF]</code> 范围之外的 字符</li>
<li>来自于未初始化内存的整数、浮点数、指针读取或字符串</li>
<li>悬垂引用或 Box</li>
<li>宽引用、Box 或 裸指针有无效的元数据
<ul>
<li><code>dyn Trait</code> 元数据是指向一个 Trait 的 vtable 的指针，且该Trait需要与指针或引用实际指向的动态trait相匹配，否则元数据无效</li>
<li>如果长度无效，则切片数据无效</li>
</ul>
</li>
<li>具有自定义无效值的类型，比如 <code>NonNull</code></li>
</ul>
</li>
</ul>
<p>参考：<a href="https://doc.rust-lang.org/nomicon/what-unsafe-does.html">Nomicon Rust</a></p>
<h2 id="健全性soundness"><a class="header" href="#健全性soundness">健全性（Soundness）</a></h2>
<p>健全性是一个类型系统的概念，意味着类型系统是正确的，即，类型良好的程序实际上应该具有该属性。对于 Rust 来说，意味着类型良好的程序不会导致未定义行为。但是这个承诺只适用于 Safe Rust。对于 Unsafe Rust要有开发者/程序员来维护这个契约。</p>
<p>因此，如果Safe 代码的公开 API 不可能导致未定义行为，就可以说这个库是健全的。反之，如果安全代码导致未定义行为，那么这个库就是不健全的。</p>
<h2 id="数据布局layout"><a class="header" href="#数据布局layout">数据布局（Layout）</a></h2>
<p>一个类型的布局定义了它的大小和对齐方式，以及它的子对象的偏移量（例如，结构体/联合体/枚举体/...的字段或数组的元素）。此外，一个类型的布局记录了它的函数调用ABI（或简称ABI）。</p>
<p>注意：最初，布局和表征（representation ）被视为同义词，Rust语言的特性，如<code>#[repr]</code>属性反映了这一点。在本文档中，布局和表征不是同义词。</p>
<h2 id="零大小类型zst"><a class="header" href="#零大小类型zst">零大小类型（ZST）</a></h2>
<p>零大小类型是指不会占用实际内存空间的类型，其对齐要求是 <code>1</code>。 比如 单元类型 <code>()</code> 的对齐要求就是 <code>1</code>，而 <code>[u16;0]</code> 的对齐要求就是 <code>2</code> 。</p>
<h2 id="利基niche"><a class="header" href="#利基niche">利基（Niche）</a></h2>
<p>一个类型的利基决定了其布局优化将使用的无效位模式。</p>
<p>比如， <code>Option&lt;Nonull&gt;</code> 具有和 <code>*mut T</code>相同的大小。</p>
<h2 id="填充padding"><a class="header" href="#填充padding">填充（Padding）</a></h2>
<p>指编译器在结构体或枚举变体的字段之间填充空间，以满足对齐要求。</p>
<p>填充可以被认为是 <code>[Pad; N] </code>，其中 <code>Pad</code>  大小假设为<code>1</code>，具有以下属性：</p>
<ol>
<li>对任何字节都有效。与<code> MaybeUninit&lt;u8&gt;</code>具有相同有效性。</li>
<li>复制 Pad 时忽略源字节，并向目标字节写入任何值。</li>
<li>复制 Pad 标记目标为未初始化。</li>
</ol>
<h2 id="位置place"><a class="header" href="#位置place">位置（Place）</a></h2>
<p>位置是 对 位置表达式的求值结果。在其他语言中，一般将其称为左值。</p>
<p>位置基本上是一个指针，但可能包含更多信息，比如 大小、 对齐方式等。</p>
<p>关于位置的关键操作：</p>
<ol>
<li>在其中存储相同类型的值（当它用于赋值的左侧时，let 绑定）</li>
<li>从它那里加载一个相同类型的值</li>
<li>使用 <code>&amp;</code>  或 <code>*</code> 操作符在一个位置（<code>T</code>）和一个指针值（<code>&amp;T</code> / <code>&amp;mut T</code>/ <code>*const T</code>/ 或 <code>*mut T</code> ）之间转换。</li>
</ol>
<h2 id="值value"><a class="header" href="#值value">值（Value）</a></h2>
<p>值是对值表达式的求值结果，或是被存储在某个地方的东西。 在其他语言中，一般将其称为右值。</p>
<h2 id="表征representation"><a class="header" href="#表征representation">表征（Representation）</a></h2>
<p>表征，用于描述一个类型的值和内存中存储这个值的字节序列之间的关系。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="320-no-std"><a class="header" href="#320-no-std">3.20 no-std</a></h1>
<p><code>no-std</code> 是指 被标示为 <code>#![no_std]</code> 的 crate，意味着该 crate 将链接到 <code>core</code> crate 而非 <code>std</code> crate。</p>
<p><code>no-std</code>  代表 裸机编程，嵌入式 Rust。</p>
<p>Rust 也有 <code>#![no_core]</code> 属性，但是还未稳定，不建议使用。</p>
<blockquote>
<p>参考数据： <code>core</code> 在编译后文件大小中只占大约 3k 大小。</p>
</blockquote>
<h2 id="列表-48"><a class="header" href="#列表-48">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./no-std/P.EMB.01.html">P.EMB.01 <code>no-std</code> 下必须定义一个Panic行为以确保安全</a></li>
<li><a href="safe-guides/coding_practice/./no-std/P.EMB.02.html">P.EMB.02 要确保程序中的类型有正确的内存布局</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pemb01--no-std-下必须定义一个panic行为以确保安全"><a class="header" href="#pemb01--no-std-下必须定义一个panic行为以确保安全">P.EMB.01  <code>no-std</code> 下必须定义一个Panic行为以确保安全</a></h2>
<p><strong>【描述】</strong></p>
<p>鉴于<code>#![no_std]</code>应用程序没有标准输出，并且某些<code>#![no_std]</code>应用程序（例如嵌入式应用程序）需要不同的 Panic 行为来进行开发和发布。</p>
<p>因此，可以通过属性宏<code>#[panic_handler]</code>来定义 Panic 行为。</p>
<p><strong>【正例】</strong></p>
<p>定义 <code>panic-semihosting</code> Crate，将 Panic 消息记录到 Host 的 stderr :</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![no_std]

<span class="boring">fn main() {
</span>use core::fmt::{Write, self};
use core::panic::PanicInfo;

struct HStderr {
    // ..
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    let mut host_stderr = HStderr::new();
    
    // logs &quot;panicked at '$reason', src/main.rs:27:4&quot; to the host stderr
    writeln!(host_stderr, &quot;{}&quot;, info).ok();

    loop {}
}
<span class="boring">}
</span></code></pre></pre>
<p>定义 <code>panic-halt</code> Crate，将 Panic 消息丢弃。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![no_std]
<span class="boring">fn main() {
</span>use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &amp;PanicInfo) -&gt; ! {
    loop {}
}
<span class="boring">}
</span></code></pre></pre>
<p>在 <code>app</code> Crate 中， Debug 和 Release 编译模式调用不同的 Panic 行为。</p>
<pre><pre class="playground"><code class="language-rust">#![no_std]

// dev profile
#[cfg(debug_assertions)]
extern crate panic_semihosting;

// release profile
#[cfg(not(debug_assertions))]
extern crate panic_halt;

fn main() {
    // ..
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pemb02--要确保程序中的类型有正确的内存布局"><a class="header" href="#pemb02--要确保程序中的类型有正确的内存布局">P.EMB.02  要确保程序中的类型有正确的内存布局</a></h2>
<p><strong>【描述】</strong></p>
<p>链接器决定 no-std 程序的最终内存布局，但我们可以使用<a href="https://sourceware.org/binutils/docs/ld/Scripts.html">链接器脚本</a>对其进行一些控制。链接器脚本给我们的布局控制粒度是在 段（ Section） 级别。段是在连续内存中布置的 符号 集合。反过来，符号可以是数据（静态变量）或指令（Rust 函数）。</p>
<p>这些编译器生成的符号和段名称不能保证在 Rust 编译器的不同版本中保持不变。但是，Rust 允许我们通过以下属性控制符号名称和部分位置：</p>
<ul>
<li><code>#[export_name = &quot;foo&quot;]</code>将符号名称设置为 <code>foo</code>.</li>
<li><code>#[no_mangle]</code>意思是：使用函数或变量名（不是它的完整路径）作为它的符号名。 <code>#[no_mangle] fn bar()</code>将产生一个名为 <code>bar</code> 的符号。</li>
<li><code>#[link_section = &quot;.bar&quot;]</code>将符号放置在名为 <code>.bar</code> 的部分中。</li>
</ul>
<p>通过这些属性，我们可以公开程序的稳定 ABI 并在链接描述文件中使用它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="321-io"><a class="header" href="#321-io">3.21 I/O</a></h1>
<p>在标准库中也提供了标准 I/O 类型，在 Safe Rust 下，I/O 操作是足够安全的，但是对于 原生句柄 (Raw Fd) 的操作，则属于不安全。</p>
<p>在 Unsafe Rust 下也有相关 I/O  的规范，请参加 <a href="safe-guides/coding_practice/./unsafe_rust/io.html">Unsafe Rust - I/O</a>   部分。</p>
<p>本部分只关注 Safe Rust 下 I/O 相关规范。</p>
<h2 id="列表-49"><a class="header" href="#列表-49">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./io/P.FIO.01.html">P.FIO.01 使用<code>read_to_end/read_to_string</code>方法时注意文件的大小能否一次性读入内存中</a></li>
<li><a href="safe-guides/coding_practice/./io/G.FIO.01.html">G.FIO.01 文件读取建议使用 <code>BufReader/BufWriter</code> 来代替 <code>Reader/Write</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfio01--使用-read_to_endread_to_string方法时注意文件的大小能否一次性读入内存中"><a class="header" href="#pfio01--使用-read_to_endread_to_string方法时注意文件的大小能否一次性读入内存中">P.FIO.01  使用 <code>read_to_end/read_to_string</code>方法时注意文件的大小能否一次性读入内存中</a></h2>
<p><strong>【描述】</strong></p>
<p>对于内存可以一次性读完的文件，可以使用 <code>read_to_end/read_to_string</code>之类的方法。但是如果你想读任意大小的文件，则不适合使用它们。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfio01--文件读取建议使用-bufreaderbufwriter-来代替-readerwrite"><a class="header" href="#gfio01--文件读取建议使用-bufreaderbufwriter-来代替-readerwrite">G.FIO.01  文件读取建议使用 <code>BufReader/BufWriter</code> 来代替 <code>Reader/Write</code></a></h2>
<p><strong>【描述】</strong></p>
<p><code>BufReader/BufWriter</code> 使用缓冲区来减少 I/O 请求的次数，提升性能。访问磁盘一次读取 256 个字节显然比 访问磁盘256次每次一个字节 效率要更高。</p>
<p>【示例】</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::{BufReader, Read};

fn main() {
    let mut data = String::new();
    let f = File::open(&quot;/etc/hosts&quot;).expect(&quot;Unable to open file&quot;);
    let mut br = BufReader::new(f);
    br.read_to_string(&amp;mut data).expect(&quot;Unable to read string&quot;);
    println!(&quot;{}&quot;, data);
}
</code></pre></pre>
<p>写 I/O：</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::{BufWriter, Write};

fn main() {
    let data = &quot;Some data!&quot;;
    let f = File::create(&quot;/tmp/foo&quot;).expect(&quot;Unable to create file&quot;);
    let mut f = BufWriter::new(f);
    f.write_all(data.as_bytes()).expect(&quot;Unable to write data&quot;);
}
</code></pre></pre>
<p>逐行读： 注意返回的每行字符串都不含有换行字符。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{BufRead, BufReader};

pub fn scan() -&gt; Result&lt;(), io::Error&gt; {
    let mut file = BufReader::new(try!(File::open(&quot;foo.txt&quot;)));

    let mut line = String::new();
    while try!(file.read_line(&amp;mut line)) != 0 {
        if line.starts_with(&quot;x&quot;) {
            try!(file.seek(SeekFrom::Start(1000)));
        }
        do_stuff(&amp;line);
        line.clear();
    }

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="322-security"><a class="header" href="#322-security">3.22 Security</a></h1>
<p>Security 用于规范可能引起信息安全（Security）缺陷的代码实现，而非功能安全（ Safety）类问题。</p>
<h2 id="列表-50"><a class="header" href="#列表-50">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./security/G.SEC.01.html">G.SEC.01 代码中不要出现非法 Unicode 字符，也要防范非法 Unicode 字符</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gsec01--代码中不要出现非法-unicode-字符也要防范非法-unicode-字符"><a class="header" href="#gsec01--代码中不要出现非法-unicode-字符也要防范非法-unicode-字符">G.SEC.01  代码中不要出现非法 Unicode 字符，也要防范非法 Unicode 字符</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>非法 Unicode 字符可能引起安全问题。安全问题参见： <a href="https://blog.rust-lang.org/2021/11/01/cve-2021-42574.html">Rust 编译器安全公告（CVE-2021-42574）</a> </p>
<p>禁止的 Unicode 字符类别为：</p>
<ol>
<li>隐藏的 Unicode 字符</li>
<li>双向 Unicode 字符文本</li>
<li>同形 Unicode 字符</li>
</ol>
<p>Clippy Lint 目前只可以检测代码中出现的隐藏 Unicode 字符。</p>
<p>在 Rust 1.56.1 之后 新增两个 <code>lint</code> 拒绝代码中出现可以更改显示顺序的 <code>Unicode</code> 码点出现。并且特别禁止 <code>\u{202A}</code>，<code>\u{202B}</code>，<code>\u{202D}</code>，<code>\u{202E}</code>，<code>\u{2066}</code>， <code>\u{2067}</code>，<code>\u{2068}</code>，<code>\u{202C}</code> 和 <code>\u{2069}</code> 这几个特殊的 <code>Unicode</code> 码点。</p>
<p>Rust 的 <code>mixed_script_confusables</code> 和 <code>confusable_idents</code> 可以识别 同形字符。 </p>
<p>写代码的时候需要注意，尤其是开源代码，需要防范上述非法 Unicode 字符。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![deny(text_direction_codepoint_in_comment)]
// 这段代码不应该输出里面的打印语句，但实际上输出了。
// 因为开发者看上去条件表达式里 确实等于 &quot;user&quot;，但实际上不等于&quot;user&quot;，因为这个字符串里被加了隐藏字符。
fn main() {
    let access_level = &quot;user&quot;;
    let access_level != &quot;user&quot; { // Check if admin
        println!(&quot;You are an admin&quot;);
    }
}

#![deny(text_direction_codepoint_in_literal)]
// 该文件包含双向Unicode文本，其解释或编译方式可能与下面的内容不同。 要审查，请在一个能显示隐藏的Unicode字符的编辑器中打开该文件。
// 执行输出
fn main() {
    let is_admin = false;
    /* begin admins only */ if is_admin {
        println!(&quot;You are an admin.&quot;);
    /* end admins only */ }
}
</code></pre></pre>
<p>或者</p>
<pre><pre class="playground"><code class="language-rust">#![deny(text_direction_codepoint_in_comment)]
fn main() {
    println!(&quot;{:?}&quot;); // '‮');
}

#![deny(text_direction_codepoint_in_literal)]
fn main() {
    println!(&quot;{:?}&quot;, '‮');
}
</code></pre></pre>
<p><strong>【例外】</strong></p>
<p>但也有例外，比如你的代码恰好是要处理这些特殊Unicode字符的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://docs.rs/crate/lingo/0.1.2/source/src/generated.rs
#[allow(clippy::invisible_characters)]
pub fn get_embed_languages() -&gt; FileContent {
    let mut f = FileContent::from_vec(vec![
        (
            Language::Afrikaans.name(),
            vec![
                &quot;e&quot;, &quot;a&quot;, &quot;i&quot;, &quot;n&quot;, &quot;s&quot;, &quot;r&quot;, &quot;o&quot;, &quot;t&quot;, &quot;d&quot;, &quot;e_&quot;, &quot;l&quot;, &quot;k&quot;, &quot;g&quot;, &quot;ie&quot;, &quot;n_&quot;,
                // 省略很多字符，包括特殊的隐藏 unicode 字符
            ]
        )
    )
 }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#invisible_characters"><code>invisible_characters</code></a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/deny-by-default.html#text-direction-codepoint-in-comment"><code>text-direction-codepoint-in-comment</code></a></td><td>no</td><td>yes</td><td>-</td><td>deny</td></tr>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/deny-by-default.html#text-direction-codepoint-in-literal"><code>text_direction_codepoint_in_literal</code></a></td><td>no</td><td>yes</td><td>-</td><td>deny</td></tr>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#confusable-idents"><code>confusable_idents</code></a></td><td>no</td><td>yes</td><td>-</td><td>warn</td></tr>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#mixed-script-confusables"><code>mixed_script_confusables</code></a></td><td>no</td><td>yes</td><td>-</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="323-其他"><a class="header" href="#323-其他">3.23 其他</a></h1>
<h2 id="列表-51"><a class="header" href="#列表-51">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/./others/G.OTH.01.html">G.OTH.01 对于某些场景下不建议使用的方法可以通过配置 clippy.toml 来拒绝</a></li>
<li><a href="safe-guides/coding_practice/./others/G.OTH.02.html">G.OTH.01 使用标准库中对应的方法计算秒级、毫秒级、微秒级的时间</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="goth01--对于某些场景下不建议使用的方法可以通过配置-clippytoml-来拒绝"><a class="header" href="#goth01--对于某些场景下不建议使用的方法可以通过配置-clippytoml-来拒绝">G.OTH.01  对于某些场景下不建议使用的方法可以通过配置 <code>clippy.toml</code> 来拒绝</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>有些场合可能需要拒绝使用一些容易出错的方法或函数，可以在 <code>clippy.toml</code> 中通过配置 <code>disallowed_method</code> 来满足这个需求。</p>
<pre><code class="language-toml"># clippy.toml
disallowed-methods = [
    # Can use a string as the path of the disallowed method.
    &quot;std::boxed::Box::new&quot;,
    # Can also use an inline table with a `path` key.
    { path = &quot;std::time::Instant::now&quot; },
    # When using an inline table, can add a `reason` for why the method
    # is disallowed.
    { path = &quot;std::vec::Vec::leak&quot;, reason = &quot;no leaking memory&quot; },
]

# 允许 Lint 支持配置值对应的本地语言
# 配置时候从该列表获取别名 https://www.unicode.org/iso15924/iso15924-codes.html
allowed-locales = [&quot;Latin&quot;, &quot;Cyrillic&quot;] 
</code></pre>
<p><strong>【反例】</strong></p>
<p>当 <code>clippy.toml</code> 做了上面配置时，下面代码会曝出警告。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example code where clippy issues a warning
let xs = vec![1, 2, 3, 4];
xs.leak(); // Vec::leak is disallowed in the config.
// The diagnostic contains the message &quot;no leaking memory&quot;.

let _now = Instant::now(); // Instant::now is disallowed in the config.

let _box = Box::new(3); // Box::new is disallowed in the config.
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example code which does not raise clippy warning
let mut xs = Vec::new(); // Vec::new is _not_ disallowed in the
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#disallowed_method">disallowed_method</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#disallowed_script_idents">disallowed_script_idents</a></td><td>yes</td><td>no</td><td><strong>restriction</strong></td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#disallowed_type">disallowed_type</a></td><td>yes</td><td>no</td><td><strong>nursery</strong></td><td>allow</td></tr>
</tbody></table>
<p>这些 lint 作用相似，但注意 <code>nursery</code> 的lint 还未稳定。 </p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="goth02--使用标准库中对应的方法计算秒级毫秒级微秒级的时间"><a class="header" href="#goth02--使用标准库中对应的方法计算秒级毫秒级微秒级的时间">G.OTH.02  使用标准库中对应的方法计算秒级、毫秒级、微秒级的时间</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>略。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::time::Duration;
</span>let dur = Duration::new(5, 0);

// Bad
let _micros = dur.subsec_nanos() / 1_000;      // 用纳秒计算微秒
let _millis = dur.subsec_nanos() / 1_000_000;  // 用纳秒计算毫秒
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::time::Duration;
</span>let dur = Duration::new(5, 0);

// Good
let _micros = dur.subsec_micros(); // 通过标准库函数得到微秒
let _millis = dur.subsec_millis(); // 通过标准库函数得到毫秒
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#duration_subsec">duration_subsec</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录"><a class="header" href="#附录">附录</a></h1>
<ul>
<li><a href="safe-guides/Appendix/./dev_env.html">A.开发环境</a></li>
<li><a href="safe-guides/Appendix/./test.html">B.测试</a>
<ul>
<li><a href="safe-guides/Appendix/./test/unit_test.html">单元测试</a></li>
<li><a href="safe-guides/Appendix/./test/benchmark.html">基准测试</a></li>
<li><a href="safe-guides/Appendix/./test/fuzz.html">模糊测试</a></li>
</ul>
</li>
<li><a href="safe-guides/Appendix/./terms.html">C.术语解释</a></li>
<li><a href="safe-guides/Appendix/./templates/intro.html">D.模板</a>
<ul>
<li><a href="safe-guides/Appendix/./templates/rustfmt.toml.html">rustfmt 模板</a></li>
<li><a href="safe-guides/Appendix/./templates/clippy.toml.html">clippy 模板</a></li>
<li><a href="safe-guides/Appendix/./templates/deny.toml.html">deny 模板</a></li>
</ul>
</li>
<li><a href="safe-guides/Appendix/./tools/intro.html">E.工具链</a>
<ul>
<li><a href="safe-guides/Appendix/./tools/rustfmt.html">rustfmt</a></li>
<li><a href="safe-guides/Appendix/./tools/noisy-clippy.html">noisy-clippy</a></li>
<li><a href="safe-guides/Appendix/./tools/cargo-udeps.html">cargo-udeps</a> </li>
</ul>
</li>
<li><a href="safe-guides/Appendix/./cheat-sheet/README.html">F.Cheat Sheet</a>
<ul>
<li><a href="safe-guides/Appendix/./cheat-sheet/Numbers/float.html">浮点数</a></li>
</ul>
</li>
<li><a href="safe-guides/Appendix/./optimizing/intro.html">G.优化指南</a></li>
<li><a href="safe-guides/Appendix/./rustc-flag.html">H.编译参数说明</a></li>
<li><a href="safe-guides/Appendix/./best-practice/intro.html">I.最佳实践</a>
<ul>
<li><a href="safe-guides/Appendix/./best-practice/qa.html">初学者常见问题Q&amp;A</a></li>
<li><a href="safe-guides/Appendix/./best-practice/tips.html">Rust 编程技巧</a></li>
</ul>
</li>
<li><a href="safe-guides/Appendix/./contribution.html">J.贡献说明</a></li>
<li><a href="safe-guides/Appendix/./old_guidelines.html">K.淘汰的规则</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a开发环境"><a class="header" href="#a开发环境">A.开发环境</a></h1>
<h2 id="编辑器推荐"><a class="header" href="#编辑器推荐">编辑器推荐</a></h2>
<p>VSCode + Rust Analyzer 扩展 </p>
<p>其他辅助vscode 扩展：</p>
<p><a href="https://github.com/willcrichton/flowistry">flowistry</a> ，可以帮助开发者理解 Rust 程序。</p>
<h2 id="ide-推荐"><a class="header" href="#ide-推荐">IDE 推荐</a></h2>
<p>Clion</p>
<h2 id="工具链安装"><a class="header" href="#工具链安装">工具链安装</a></h2>
<p>使用<a href="https://github.com/rust-lang/rustup"> <code>Rustup</code></a>。 如需替代安装方式，为了保证安全，最好选择官方推荐的替代安装方式。</p>
<h2 id="rust--版次edition-说明"><a class="header" href="#rust--版次edition-说明"><strong>Rust  版次（Edition）</strong> <strong>说明</strong></a></h2>
<p>Rust从2015开始，每三年发布一个 Edition 版次：</p>
<blockquote>
<ol>
<li>Rust 2015 edition （Rust 0.1.0 ~ Rust 1.0.0）</li>
<li>Rust 2018 edition （Rust 1.0.0 ~ Rust 1.31.0）</li>
<li>Rust 2021 edition (Rust 1.31.0 ~ Rust 1.56.0 )</li>
</ol>
</blockquote>
<p>以此类推。Edition是向前兼容的。Edition 和语义化版本是正交的，不冲突。</p>
<p>关于 Edition 更详细的内容可以查看：<a href="https://doc.rust-lang.org/edition-guide/">https://doc.rust-lang.org/edition-guide/</a></p>
<h2 id="稳定版-开发版和测试版工具链"><a class="header" href="#稳定版-开发版和测试版工具链"><strong>稳定版、 开发版和测试版工具链</strong></a></h2>
<p>Rust 工具链提供三种不同的发布渠道：</p>
<blockquote>
<ol>
<li>Nightly（开发版），每晚发布（release）一次。</li>
<li>Beta（测试版），每六周发布一次，基于Nightly版本。</li>
<li>Stable（稳定版），每六周发布一次，基于 beta版本。</li>
</ol>
</blockquote>
<p>注意：</p>
<blockquote>
<ol>
<li>推荐使用 Stable Rust。</li>
<li>在基于Nightly Rust 开发项目的时候，最好通过在项目中增加 rust-toolchain 文件来指定一个固定的版本，避免因为Nightly Rust 的频繁变更而导致项目编译问题。</li>
<li>当在稳定版工作的时候，如果需要Nightly工具链，不需要整体上去切换工具链到Nightly，只需要再命令中指明Nightly就可以了。比如 <code>cargo +nightly fmt</code>。</li>
</ol>
</blockquote>
<h2 id="包管理器-cargo"><a class="header" href="#包管理器-cargo"><strong>包管理器 Cargo</strong></a></h2>
<p>Cargo 是 Rust 项目必不可少的包管理器，除此之外，它也是一种工作流：</p>
<blockquote>
<ol>
<li>可以用Cargo创建一个项目（bin/lib）</li>
<li>可以用它编译项目</li>
<li>可以用它生产项目的文档（依据文档注释）</li>
<li>可以用它运行单元测试（test）和基准测试（bench）</li>
<li>可以用它下载和管理crate依赖</li>
<li>可以用它分发软件包，默认分发到 <a href="http://crates.io/">crates.io</a> 上面</li>
<li>可以为它编写插件，使用子命令的方式，扩展它的功能。</li>
</ol>
</blockquote>
<p>Cargo 通过 Cargo.toml 配置文件来管理 crate。</p>
<p>Toml 配置文件是一种最小化且无歧义的文件格式，Rust社区最常用Toml。可以通过 <a href="http://toml.io/">toml.io</a> 进一步了解 Toml 的细节。</p>
<p>值得说明的是，在配置文件中如果有 [profile.*] 这种配置，需要引起注意，因为这类配置决定了编译器的调用方式，比如：</p>
<blockquote>
<ol>
<li>debug-assertions ，决定了是否开启debug断言。</li>
<li>overflow-checks，决定了是否检查整数运算溢出。</li>
</ol>
</blockquote>
<p>关于Cargo的更多细节可以查看：<a href="https://doc.rust-lang.org/cargo/index.html">https://doc.rust-lang.org/cargo/index.html</a></p>
<h2 id="常用cargo插件"><a class="header" href="#常用cargo插件">常用Cargo插件</a></h2>
<p><strong>Clippy</strong></p>
<p>Clippy 是一个静态分析工具，它提供了很多检查，比如错误、 样式、 性能问题、 Unsafe UB问题等等。从1.29版本开始，Clippy可以用于 Stable Rust中。</p>
<p>可以通过 <code>rustup component add clippy</code> 来安装此 Cargo 插件。</p>
<p>细节参考：<a href="https://github.com/rust-lang/rust-clippy">https://github.com/rust-lang/rust-clippy</a></p>
<p>Clippy 的全部 lint 检查建议列表： <a href="https://rust-lang.github.io/rust-clippy/master/">https://rust-lang.github.io/rust-clippy/master/</a></p>
<p><strong>Rustfmt</strong></p>
<p>Rustfmt 是一个根据风格指南原则来格式化代码的工具。</p>
<p>可以通过 Rustup 来安装它： <code>rustup component add rustfmt</code></p>
<p>Rustfmt 依赖的社区维护的 Rust风格指南：<a href="https://github.com/rust-dev-tools/fmt-rfcs/tree/master/guide">https://github.com/rust-dev-tools/fmt-rfcs/tree/master/guide</a></p>
<p>开发者也可以通过 <code>rustfmt.toml</code> 或 <code>.rustfmt.toml</code> 来定制团队统一的代码风格，比如：</p>
<pre><code class="language-toml"># Set the maximum line width to 120
max_width = 120
# Maximum line length for single line if-else expressions
single_line_if_else_max_width = 40
</code></pre>
<p><strong>Rustfix</strong></p>
<p>从 Rust 2018 edition开始，Rustfix就被包含在 Rust 中。它可以用来修复编译器警告。</p>
<p>需要注意的是，在使用 cargo fix 进行自动修复警告的时候，需要开发者确认这个警告是否真的需要修复，并且要验证修复的是否正确。</p>
<p><strong>Cargo Edit</strong></p>
<p>Cargo Edit插件为Cargo扩展了三个命令：</p>
<blockquote>
<ol>
<li>Cargo add，在命令行增加新的依赖，而不需要去知道这个依赖的语义版本。</li>
<li>Cargo rm，在命令行删除一个指定依赖。</li>
<li>Cargo upgrade，在命令行升级一个指定依赖。</li>
</ol>
</blockquote>
<p>Cargo-edit地址：<a href="https://github.com/killercup/cargo-edit">https://github.com/killercup/cargo-edit</a></p>
<p><strong>Cargo Audit</strong></p>
<p>Cargo Audit 可以根据 Rust安全警报数据库（RestSec Advisory Database ）的漏洞数据，扫描crate以及它的所有依赖库，然后给出一份安全报告。</p>
<p>更多细节：<a href="https://github.com/RustSec/cargo-audit">https://github.com/RustSec/cargo-audit</a></p>
<p>Rust 安全警报数据库：<a href="https://rustsec.org/">https://rustsec.org/</a></p>
<p><strong>Cargo Outdated</strong></p>
<p>该插件可以检测依赖库是否有新版本可用。</p>
<p>更多细节：<a href="https://github.com/kbknapp/cargo-outdated">https://github.com/kbknapp/cargo-outdated</a></p>
<p><strong>Cargo Deny</strong></p>
<p>该插件可以检测依赖中的软件许可证（License），如果和开发者配置的不符合，则会拒绝使用该依赖。</p>
<p>更多细节：<a href="https://github.com/EmbarkStudios/cargo-deny">https://github.com/EmbarkStudios/cargo-deny</a></p>
<p>Cargo Deny Book： <a href="https://embarkstudios.github.io/cargo-deny/">https://embarkstudios.github.io/cargo-deny/</a></p>
<h2 id="rustup-和-crates-国内镜像"><a class="header" href="#rustup-和-crates-国内镜像">Rustup 和 crates 国内镜像</a></h2>
<h3 id="加速-rustup"><a class="header" href="#加速-rustup">加速 Rustup</a></h3>
<p>我们需要指定 <code>RUSTUP_DIST_SERVER</code>（默认指向 https://static.rust-lang.org）和 <code>RUSTUP_UPDATE_ROOT</code> （默认指向https://static.rust-lang.org/rustup），这两个网站均在中国大陆境外，因此在中国大陆访问会很慢，需要配置成境内的镜像。</p>
<p>以下<code> RUSTUP_DIST_SERVER</code> 和 <code>RUSTUP_UPDATE_ROOT</code> 可以组合使用。</p>
<pre><code class="language-toml"># 清华大学
RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup

# 中国科学技术大学
RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static
RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup

# 上海交通大学
RUSTUP_DIST_SERVER=https://mirrors.sjtug.sjtu.edu.cn/rust-static/


# 字节跳动
RUSTUP_DIST_SERVER=&quot;https://rsproxy.cn&quot;
RUSTUP_UPDATE_ROOT=&quot;https://rsproxy.cn/rustup&quot;
</code></pre>
<h3 id="加速-crates"><a class="header" href="#加速-crates">加速 crates</a></h3>
<p>将如下配置写入 <code>$HOME/.cargo/config</code> 文件：</p>
<pre><code class="language-toml">
# 放到 `$HOME/.cargo/config` 文件中
[source.crates-io]
registry = &quot;https://github.com/rust-lang/crates.io-index&quot;

# 替换成你偏好的镜像源，比如 字节跳动的
replace-with = 'rsproxy'

# 清华大学
[source.tuna]
registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;

# 中国科学技术大学
[source.ustc]
registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;

# 上海交通大学
[source.sjtu]
registry = &quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;

# rustcc社区
[source.rustcc]
registry = &quot;git://crates.rustcc.cn/crates.io-index&quot;

# 字节跳动 https://rsproxy.cn/
[source.rsproxy]
registry = &quot;https://rsproxy.cn/crates.io-index&quot;

[registries.rsproxy]
index = &quot;https://rsproxy.cn/crates.io-index&quot;

[net]
git-fetch-with-cli = true

</code></pre>
<h3 id="安装-rust"><a class="header" href="#安装-rust">安装 Rust</a></h3>
<p>使用 字节跳动源：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">export the env above first
</span>curl --proto '=https' --tlsv1.2 -sSf https://rsproxy.cn/rustup-init.sh | sh
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="b测试"><a class="header" href="#b测试">B.测试</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="单元测试"><a class="header" href="#单元测试">单元测试</a></h1>
<p>Rust 支持单元测试。</p>
<h2 id="测试代码组织"><a class="header" href="#测试代码组织">测试代码组织</a></h2>
<p>对于内部函数，单元测试代码最好放到业务代码的同一个模块下。</p>
<p>对于外部接口，单元测试最好放到独立的 <code>tests</code> 目录。</p>
<h2 id="文档测试"><a class="header" href="#文档测试">文档测试</a></h2>
<p>对所有对外接口进行文档测试是一个不错的开始。</p>
<h2 id="编译测试"><a class="header" href="#编译测试">编译测试</a></h2>
<p>通过 <code>compiletest</code> 来测试某些代码可能无法编译。 参考： <a href="https://rustc-dev-guide.rust-lang.org/tests/adding.html#ui">Rustc开发指南</a></p>
<h2 id="随机测试"><a class="header" href="#随机测试">随机测试</a></h2>
<p>使用 第三方库<code>proptest</code> 来进行随机测试。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proptest::prelude::*;

proptest! {
    #[test]
    fn check_count_correct(haystack: Vec&lt;u8&gt;, needle: u8) {
        prop_assert_eq!(count(&amp;haystack, needle), naive_count(&amp;haystack, needle));
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="代码测试率覆盖检测工具"><a class="header" href="#代码测试率覆盖检测工具">代码测试率覆盖检测工具</a></h2>
<p><a href="https://github.com/xd009642/tarpaulin">tarpaulin</a> 是 Cargo 构建系统的代码覆盖率报告工具，目前 <strong>仅支持运行 Linux 的 x86_64 处理器</strong>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基准测试"><a class="header" href="#基准测试">基准测试</a></h1>
<p>说明： 借用 MogoDB 工程师 Patrick 的文章来了解 Rust 里做基准测试基本姿势。</p>
<blockquote>
<p>原文： <a href="https://patrickfreed.github.io/rust/2021/10/15/making-slow-rust-code-fast.html">https://patrickfreed.github.io/rust/2021/10/15/making-slow-rust-code-fast.html</a></p>
</blockquote>
<h2 id="使用-criterionrs-和-火焰图flamegraphs-进行性能调优"><a class="header" href="#使用-criterionrs-和-火焰图flamegraphs-进行性能调优">使用 Criterion.rs 和 火焰图（flamegraphs） 进行性能调优</a></h2>
<p>性能是开发者为其应用程序选择 Rust 的首要原因之一。事实上，它是 <code>rust-lang.org</code> 主页上 <a href="https://www.rust-lang.org/#:%7E:text=Version%201.55.0-,Why%20Rust%3F,-Performance">&quot;为什么选择Rust？&quot;</a>一节中列出的第一个原因，甚至在内存安全之前。这也是有原因的，许多基准测试表明，用Rust编写的软件速度很快，有时甚至是<a href="https://www.techempower.com/benchmarks/#section=data-r18&amp;hw=ph&amp;test=fortune">最快</a>的。但这并不意味着所有用Rust编写的软件都能保证快速。事实上，写低性能的Rust代码是很容易的，特别是当试图通过Clone 或<code>Arc</code>替代借用来&quot;&quot;安抚&quot;&quot;借用检查器时，这种策略通常被推荐给 Rust 新手。这就是为什么对 Rust 代码进行剖析和基准测试是很重要的，可以看到任何瓶颈在哪里，并修复它们，就像在其他语言中那样。在这篇文章中，我将根据最近的工作经验，展示一些基本的工具和技术，以提高 <code>mongodb</code>  crate 的性能。</p>
<p>注意：本帖中使用的所有示例代码都可以在<a href="https://github.com/patrickfreed/benchmark-example">这里</a>找到。</p>
<h2 id="索引"><a class="header" href="#索引">索引</a></h2>
<ul>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90">性能剖析(Profiling)</a>
<ul>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95">基准测试(Benchmarking)</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E7%81%AB%E7%84%B0%E5%9B%BE%E7%94%9F%E6%88%90">火焰图生成</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E8%AF%86%E5%88%AB%E7%81%AB%E7%84%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E7%93%B6%E9%A2%88">识别火焰图中的瓶颈</a></li>
</ul>
</li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%60Clone%60%E7%9A%84%E2%80%9C%E8%A2%AD%E5%87%BB%E2%80%9D"> <code>Clone</code> 的 “袭击”</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E5%8A%A0%E9%80%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">加速反序列化</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E5%88%86%E6%9E%90%E7%BB%93%E6%9E%9C">分析结果</a>
<ul>
<li><a href="safe-guides/Appendix/test/%E6%9F%A5%E7%9C%8BCriterion%E7%9A%84HTML%E6%8A%A5%E5%91%8A">查看Criterion的HTML报告</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E4%BD%BF%E7%94%A8%60wrk%60%E8%BF%9B%E8%A1%8C%E5%8E%8B%E6%B5%8B">使用<code>wrk</code>进行压测</a></li>
</ul>
</li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E4%B8%8B%E4%B8%80%E6%AD%A5">下一步</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E5%B9%BF%E5%91%8A%E6%97%B6%E9%97%B4">广告时间</a></li>
</ul>
<h2 id="性能剖析"><a class="header" href="#性能剖析">性能剖析</a></h2>
<p>在进行任何性能调优工作时，在试图修复任何东西之前，绝对有必要对代码进行性能剖析（profiling），因为瓶颈往往位于意想不到的地方，而且怀疑的瓶颈往往不如你想的那样对性能有足够影响。如果不遵守这一原则，就会导致<a href="https://wiki.c2.com/?PrematureOptimization">过早优化</a>，这可能会不必要地使代码复杂化并浪费开发时间。这也是为什么建议新人在开始的时候自由地 Clone ，这样可以帮助提高可读性，而且可能不会对性能产生严重的影响，但是如果他们这样做了，以后的性能剖析会发现这一点，所以在那之前没有必要担心。</p>
<blockquote>
<p>过早优化（Premature Optimization）</p>
<p>Premature optimization is the root of all evil.  --  DonaldKnuth</p>
<p>在 DonaldKnuth 的论文 《 Structured Programming With GoTo Statements 》中，他写道：&quot;程序员浪费了大量的时间去考虑或担心程序中非关键部分的速度，而当考虑到调试和维护时，这些对效率的尝试实际上会产生强烈的负面影响。我们应该忘记这种微小的效率，比如说因为过早优化而浪费的大约97%的时间。然而，我们不应该放弃那关键的 3% 的机会&quot;。</p>
</blockquote>
<h3 id="基准测试-1"><a class="header" href="#基准测试-1">基准测试</a></h3>
<p>剖析的第一步是建立一套一致的基准，可以用来确定性能的基线水平，并衡量任何渐进的改进。在 <code>mongodb</code> 的案例中，标准化的<a href="https://github.com/mongodb/specifications/blob/master/source/benchmarking/benchmarking.rst"><code>MongoDB</code> 驱动微基准集</a>在这方面发挥了很好的作用，特别是因为它允许在用其他编程语言编写的<code>MongoDB</code>驱动之间进行比较。由于这些是 &quot;微 &quot;基准，它们还可以很容易地测量单个组件的变化（例如，读与写），这在专注于在特定领域进行改进时是非常有用的。</p>
<p>一旦选择了基准，就应该建立一个稳定的环境，可以用来进行所有的定时测量。确保环境不发生变化，并且在分析时不做其他 &quot;工作&quot;（如浏览猫的图片），这对减少基准测量中的噪音很重要。</p>
<h4 id="用-cargo-bench-和-criterionrs-来执行基准测试"><a class="header" href="#用-cargo-bench-和-criterionrs-来执行基准测试">用 <code>cargo bench</code> 和 <code>Criterion.rs</code> 来执行基准测试</a></h4>
<p>Rust 提供的基准测试只能在 Nightly 下使用，因为它还未稳定。它对简单的基准测试比较有用，但是功能有限，而且没有很好的文档。另一个选择是<a href="https://crates.io/crates/criterion"> <code>criterion</code></a> crate。它为基准测试提供了更多的可配置性和丰富的功能支持，同时支持稳定的Rust ！我将详细介绍基本的 criterion crate。</p>
<p>我将在这里详细介绍一个基本的 criterion 设置，但如果想了解更多信息，我强烈推荐你查看优秀的<a href="https://bheisler.github.io/criterion.rs/book/index.html"> Criterion.rs 用户指南</a>。</p>
<p>在对<code>mongodb</code>进行基准测试时，我首先使用<code>cargo new &lt;my-benchmark-project&gt;</code>创建了一个新项目，并在<code>Cargo.toml</code>中添加了以下几行。</p>
<pre><code class="language-toml">[dependencies]
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }
futures = { version = &quot;0.3&quot;, default-features = false }
mongodb = { path = &quot;/home/patrick/mongo-rust-driver&quot; }

[dev-dependencies]
criterion = { version = &quot;0.3.5&quot;, features = [&quot;async_tokio&quot;, &quot;html_reports&quot;] }

[[bench]]
name = &quot;find&quot;
harness = false
</code></pre>
<p>在我的基准测试中，使用了<code> tokio</code> 异步运行时，所以我需要把它指定为一个依赖项，并启用<code>async_tokio</code>的 <code>criterion </code> features，但如果你不使用<code>tokio</code>，这不是必需的。我还需要使用<code>futures</code> crate提供的一些功能，但这对于运行一个<code>criterion</code>  基准来说也是没有必要的。对于我的<code>mongodb</code>依赖，我指定了一个本地克隆库的路径，这样我就可以对我做的任何改动进行基准测试。另外，在这个例子中，我将专注于对<code>mongodb</code> crate的<a href="https://docs.rs/mongodb/2.0.0/mongodb/struct.Collection.html#method.find"><code>Collection::find</code></a>方法进行基准测试，所以我对基准进行了相应的命名，但你可以对你的基准测试进行任意命名。</p>
<p>接下来，需要创建一个<code>benches/find.rs</code>文件来包含基准测试。文件名需要与<code>Cargo.toml</code>中的名称字段中指定的值相匹配。下面是一个测试<code>Collection::find</code>性能的简单基准测试的例子。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use criterion::{criterion_group, criterion_main, Criterion};
use futures::TryStreamExt;
use mongodb::{
    bson::{doc, Document},
    Client,
};

pub fn find_bench(c: &amp;mut Criterion) {
    // begin setup

    // create the tokio runtime to be used for the benchmarks
    let rt = tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .unwrap();

    // seed the data server side, get a handle to the collection
    let collection = rt.block_on(async {
        let client = Client::with_uri_str(&quot;mongodb://localhost:27017&quot;)
            .await
            .unwrap();

        let collection = client.database(&quot;foo&quot;).collection(&quot;bar&quot;);
        collection.drop(None).await.unwrap();

        let doc = doc! {
            &quot;hello&quot;: &quot;world&quot;,
            &quot;anotherKey&quot;: &quot;anotherValue&quot;,
            &quot;number&quot;: 1234
        };
        let docs = vec![&amp;doc; 10_000];
        collection.insert_many(docs, None).await.unwrap();
        collection
    });
    // end setup

    c.bench_function(&quot;find&quot;, |b| {
        b.to_async(&amp;rt).iter(|| {
            // begin measured portion of benchmark
            async {
                collection
                    .find(doc! {}, None)
                    .await
                    .unwrap()
                    .try_collect::&lt;Vec&lt;Document&gt;&gt;()
                    .await
                    .unwrap();
            }
        })
    });
}

criterion_group!(benches, find_bench);
criterion_main!(benches);
<span class="boring">}
</span></code></pre></pre>
<p><code>find_bench</code>函数包含设置和运行基准的所有代码。该函数可以被任意命名，但是它需要接收一个<code>&amp;mut Criterion</code>作为参数。该函数的第一部分包含设置代码，在基准运行前只执行一次，其运行时间根本不被测量。实际测量的部分是稍后被传入<code>Bencher::iter</code>的闭包。该闭包将被多次运行，每次运行的时间将被记录、分析，并包含在一个HTML报告中。</p>
<p>在这个特定的例子中，设置涉及到创建<code>tokio</code>运行时，该运行时将用于基准测试的其余部分。通常，这是在幕后通过<code>tokio::main</code>宏完成的，或者，在库的情况下，根本就不需要。然而，我们需要在这里手动创建一个运行时，以便我们以后可以通过<code>Bencher::to_async</code>方法将其传递给<code>criterion</code>。一旦运行时被创建，设置就会继续进行，即填充我们在实际基准中要查询的<code>MongoDB</code>集合。由于这涉及到异步<code>API</code>的使用，我们需要通过<code>Runtime::block_on</code>确保它们在异步运行时的上下文中执行。在实际测量部分，我们对设置时创建的集合中的所有文档进行查询。</p>
<p>所有这些都准备好了（并且我们的<code>MongoDB</code>实例正在运行），我们可以运行<code>cargo bench</code>来建立我们的基线。输出结果将如下。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>~/benchmark-example$ cargo bench
    Finished bench [optimized] target(s) in 0.07s
     Running unittests (target/release/deps/benchmark_example-b9c25fd0639c5e9c)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests (target/release/deps/find-e1f66bfc9cf31158)
Gnuplot not found, using plotters backend
Benchmarking find: Warming up for 3.0000 s
find                    time:   [55.442 ms 55.663 ms 55.884 ms]
<span class="boring">}
</span></code></pre></pre>
<p>这里最重要的信息是时间： <code>[55.442 ms 55.663 ms 55.884 ms]</code>。中间的值是对每次迭代所花时间的最佳估计，第一个和最后一个值定义了置信区间（Confidence interval）的上界和下界。默认情况下，使用的置信度是<code>95%</code>，这意味着该区间有<code>95%</code>的机会包含迭代的实际平均运行时间。关于这些值以及如何计算的更多信息，请查看<code>Criterion.rs</code>用户指南。</p>
<p>现在，如果我们再次执行<code>cargo bench</code>，它将记录更多的时间，并与之前的时间进行比较（之前的数据存储在目标/标准中），报告任何变化。鉴于我们根本没有改变代码，这应该报告说没有任何变化。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>find                    time:   [55.905 ms 56.127 ms 56.397 ms]
                        change: [+0.3049% +0.8337% +1.4904%] (p = 0.01 &lt; 0.05)
                        Change within noise threshold.
Found 5 outliers among 100 measurements (5.00%)
  1 (1.00%) low mild
  2 (2.00%) high mild
  2 (2.00%) high severe
<span class="boring">}
</span></code></pre></pre>
<p>正如预期的那样，criterion  报告说，与上次运行相比，任何性能的变化都可能是由于噪音造成的。现在我们已经建立了一个基线，现在是时候对代码进行剖析，看看它哪里慢。</p>
<h3 id="火焰图生成"><a class="header" href="#火焰图生成">火焰图生成</a></h3>
<p><a href="https://perf.wiki.kernel.org/index.php/Main_Page">perf</a> 是一个Linux命令行工具，可以用来获取一个应用程序的性能信息。我们不会直接使用它，而是通过<a href="https://crates.io/crates/flamegraph"><code>flamegraph</code> </a> crate，它是一个基于Rust的flamegraph生成器，可以与<code>cargo</code>一起工作。</p>
<p>火焰图（<a href="https://github.com/brendangregg/FlameGraph"><code>Flamegraphs</code></a>）是程序在每个函数中花费时间的有用的可视化数据。在被测量的执行过程中调用的每个函数被表示为一个矩形，每个调用栈被表示为一个矩形栈。一个给定的矩形的宽度与在该函数中花费的时间成正比，更宽的矩形意味着更多的时间。火焰图对于识别程序中的慢速部分非常有用，因为它们可以让你快速识别代码库中哪些部分花费的时间不成比例。</p>
<p>要使用<code>cargo</code>生成<code>flamegraphs</code>，首先我们需要安装<code>perf</code>和<code>flamegraph </code>crate。这在<code>Ubuntu</code>上可以通过以下方式完成。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>sudo apt-get install linux-tools-common linux-tools-`uname -r`
cargo install flamegraph
<span class="boring">}
</span></code></pre></pre>
<p>一旦安装完成，我们就可以生成我们的基线的第一个<code>flamegraph</code>! 要做到这一点，请运行以下程序。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo flamegraph --bench find -o find-baseline.svg -- --bench
<span class="boring">}
</span></code></pre></pre>
<p>然后你可以在浏览器中打开<code>find-baseline.svg</code>来查看火焰图。如果你在运行<code>cargo flamegraph</code>时遇到权限问题，请参阅<code>flamegraph</code> crate的<code>README</code>中的说明。</p>
<p>生成 criterion 基准的<code>flamegraph</code>可能会有噪音，因为很多时间都花在了 criterion（例如测量时间）和设置上，而不是在被基准测试的部分。为了减少火焰图中的一些噪音，你可以写一个与基准的测量部分行为类似的程序，然后生成另一个火焰图来代替。</p>
<p>例如，我用下面的命令从一个普通的二进制程序中生成一个火焰图，该程序使用我的本地<code>mongodb</code> crate副本来执行没有criterion的查找。</p>
<pre><code>cargo flamegraph --bin my-binary -o find-baseline.svg
</code></pre>
<p>这里是生成的火焰图（在新的浏览器标签页中打开它来探索）。</p>
<p><img src="https://patrickfreed.github.io/resources/making-slow-rust-code-fast/find-baseline.svg" alt="`" /></p>
<p>现在我们可以看到时间花在哪里了，现在是时候深入研究，看看我们是否能找到瓶颈。</p>
<h3 id="识别火焰图中的瓶颈"><a class="header" href="#识别火焰图中的瓶颈">识别火焰图中的瓶颈</a></h3>
<p>火焰图中的栈从底部开始，随着调用栈的加深而向上移动（左右无所谓），通常这是开始阅读它们的最佳方式。看一下上面火焰图的底部，最宽的矩形是<code>Future::poll</code>，但这并不是因为Rust 的 <code>Future</code> 超级慢，而是因为每个<code>.await</code>都涉及轮询（poll）<code>Future</code>。考虑到这一点，我们可以跳过任何轮询矩形，直到我们可以在<code>mongodb</code>中看到我们关心的信息的函数。下面火焰图的注释版本，突出了需要注意的部分。</p>
<p><img src="https://patrickfreed.github.io/resources/making-slow-rust-code-fast/flamegraph-annotated.png" alt="2" /></p>
<p>蓝色方块包含了调用<code>CommandResponse::body</code>所花费的时间，它显示几乎所有的时间都花在了<code>clone()</code>上。各个紫色矩形对应的是将<code>BSON</code>（MongoDB使用的二进制格式）解析到<code>Document</code>中所花费的时间，绿色矩形对应的是<code>Document</code>的<code>serde::Deserialize</code>实现中所花费的时间。最后，黑色虚线矩形对应的是释放内存的时间，黑色实线对应的是将命令序列化为<code>BSON</code>的时间。</p>
<p>现在我们知道了大部分时间花在哪里（只在少数几个地方），我们可以集中精力实际改变代码，使其更快。</p>
<h2 id="clone的袭击"><a class="header" href="#clone的袭击"><code>Clone</code>的“袭击”</a></h2>
<p>无论做任何事，从最容易实现的地方开始，往往可以产生最好的回报。在这个例子中，只是  <code>clone</code> 就花费了一大块时间，所以我们能简单地消除 <code>clone</code>。从火焰图里知道，最昂贵的<code>clone</code> 就是 <code>CommandResponse::body</code> 中调用的那个，所以我们去看看这个<a href="https://github.com/mongodb/mongo-rust-driver/blob/v2.0.0-beta/src/cmap/conn/command.rs#L138">方法</a>。</p>
<p>在 <code>command.rs:149</code> 行，我们看到如下定义：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Deserialize the body of the response.
pub(crate) fn body&lt;T: DeserializeOwned&gt;(&amp;self) -&gt; Result&lt;T&gt; {
    match bson::from_bson(Bson::Document(self.raw_response.clone())) {
        Ok(body) =&gt; Ok(body),
        Err(e) =&gt; Err(ErrorKind::ResponseError {
            message: format!(&quot;{}&quot;, e),
        }
        .into()),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们可以看到，这里确实有一个对<code>clone</code>的调用，所以它很可能是我们在火焰图中看到的耗费大量时间的那个。<code>clone</code>是必须的，因为我们需要从<code>self</code>所拥有的<code>raw_response</code>中反序列化，但我们只有对<code>self</code>的引用，所以我们不能从其中移出(move out)。我们也不能通过引用来使用<code>raw_response</code>，因为<code>bson::from_bson</code>期望一个有所有权的值。让我们研究一下 <code>body</code> 本身被调用的地方，看看我们是否可以改变它以获得 <code>self </code>的所有权，从而避免<code>clone</code>。</p>
<p>具体来看这个基准的使用情况，在<code>Find::handle_response</code>中，查找操作使用它来反序列化服务端上的<code>response</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_response(&amp;self, response: CommandResponse) -&gt; Result&lt;Self::O&gt; {    let body: CursorBody = response.body()?;    Ok(CursorSpecification::new(        self.ns.clone(),        response.source_address().clone(),        body.cursor.id,        self.options.as_ref().and_then(|opts| opts.batch_size),        self.options.as_ref().and_then(|opts| opts.max_await_time),        body.cursor.first_batch,    ))}
<span class="boring">}
</span></code></pre></pre>
<p>正如我们在这里看到的，<code>response</code>只在调用<code>body</code>后使用了一次，而且这一次的使用可以在它之前没有问题，所以如果 <code>body</code> 取得了<code>self</code>的所有权，这个调用点至少还能工作。对其余的调用点重复这个过程，我们看到<code>body</code>实际上可以取得<code>self</code>的所有权，从而避免<code>clone</code>，所以让我们做这个改变，看看它对性能有什么影响。</p>
<p>在做了这个改变之后，重新运行<code>cargo bench</code>的结果如下。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>find                    time:   [47.495 ms 47.843 ms 48.279 ms]                        change: [-15.488% -14.760% -13.944%] (p = 0.00 &lt; 0.05)                        Performance has improved.Found 4 outliers among 100 measurements (4.00%)  4 (4.00%) high severe
<span class="boring">}
</span></code></pre></pre>
<p>很好! 即使在这样一个简单的改变之后，我们已经观察到了性能上的明显改善。既然一些简单的问题已经被解决了，让我们调查一下其他花费大量时间的地方。</p>
<h2 id="加速反序列化"><a class="header" href="#加速反序列化">加速反序列化</a></h2>
<p>回顾一下火焰图，我们可以看到很大一部分时间都花在了解析来自 <code>MongoDB Wire</code> 协议（紫色）的响应上，然后通过<code>serde</code>（绿色）将它们反序列化为 Rust 数据结构。尽管每一个步骤都在执行类似的任务，但这两个步骤是需要的，因为<code>bson</code> crate只支持从<code>Bson</code>和<code>Document</code> Rust类型反序列化，而不是实际的<code>BSON</code>，即<code>MongoDB wire</code> 协议中使用的二进制格式。火焰图表明，这个过程消耗了大量的时间，因此如果这两个步骤可以合并为一个，有可能会带来显著的性能优势。</p>
<p>本质上，我们想从以下几个方面入手。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bytes = socket.read(&amp;mut bytes).await?; // read message from databaselet document = Document::from_reader(bytes.as_slice())?; // parse into Documentlet rust_data_type: MyType = bson::from_document(document)?; // deserialize via serde
<span class="boring">}
</span></code></pre></pre>
<p>合并为：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bytes = socket.read(&amp;mut bytes).await?; // read message from databaselet rust_data_type: MyType = bson::from_slice(bytes.as_slice())?; // deserialize via serde
<span class="boring">}
</span></code></pre></pre>
<p>要做到这一点，我们需要实现一个新的<code>serde</code> 的 <code>Deserializer</code>，它可以与原始<code>BSON</code>一起工作。这方面的工作相当广泛，而且相当复杂，所以我就不说细节了。<code>serde</code>文档中的 &quot; <a href="https://serde.rs/impl-deserializer.html">实现 Deserializer</a> &quot;部分为那些感兴趣的人提供了一个实现<code>JSON</code>的优秀例子。</p>
<p>那么，现在我们<a href="https://github.com/mongodb/bson-rust/commit/7ccf82b3dc66141d8292a5c1e253362abaa13d5c">实现了 Deserializer</a>并 <a href="https://github.com/mongodb/mongo-rust-driver/commit/0fa2a905c1f5411a6f0109debe18c3cfa35c94be">更新了驱动程序</a> 以使用它，让我们重新运行<code>cargo bench</code>，看看它是否对性能有任何影响。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>find                    time:   [30.624 ms 30.719 ms 30.822 ms]                        change: [-36.409% -35.791% -35.263%] (p = 0.00 &lt; 0.05)                        Performance has improved.Found 5 outliers among 100 measurements (5.00%)  1 (1.00%) low mild  1 (1.00%) high mild  3 (3.00%) high severe
<span class="boring">}
</span></code></pre></pre>
<p>棒极了! 平均迭代时间比上一次大约减少了36%，这与最初的基线相比已经有了很大的减少。现在我们已经实施了一些改进，让我们仔细看看结果。</p>
<h2 id="分析结果"><a class="header" href="#分析结果">分析结果</a></h2>
<h3 id="查看criterion的html报告"><a class="header" href="#查看criterion的html报告">查看Criterion的HTML报告</a></h3>
<p><code>Criterion</code>支持生成一个<code>HTML</code>报告，总结最近的运行情况，并与之前的运行情况进行比较。要访问该报告，只需在浏览器中打开<code>target/criterion/report/index.html</code>。</p>
<p>作为一个例子，<a href="https://patrickfreed.github.io/resources/making-slow-rust-code-fast/criterion/find/report/index.html">这里</a>是比较基线和最优化的报告。</p>
<p>在报告的顶部，我们可以看到最优化运行的总结，包括一个说明平均执行时间的图表和一个显示所有样本标准的散点图，以及一些其他图表的链接。下面是最近一次查找基准运行的该部分的屏幕截图。</p>
<p><img src="https://patrickfreed.github.io/resources/making-slow-rust-code-fast/report-summary.png" alt="3" /></p>
<p>在报告的底部，有一个最近两次运行的比较，较旧的运行（基线）为红色，较新的运行（优化后的）为蓝色。下面是优化后的<code>mongodb</code>版本与未优化的基线比较的部分的截图。在其中，我们可以看到，未优化的基线显然要比优化的慢得多。从分布的广度来看，我们也可以看到，优化版的性能比基线版的更稳定。</p>
<p><img src="https://patrickfreed.github.io/resources/making-slow-rust-code-fast/report-comparison.png" alt="4" /></p>
<p>这些报告是超级有用的工具，可以直观地看到因性能调优而发生的变化，而且对于向他人介绍结果特别有用。它们还可以作为过去性能数据的记录，消除了手动记录结果的需要。</p>
<h3 id="使用wrk进行压测"><a class="header" href="#使用wrk进行压测">使用<code>wrk</code>进行压测</a></h3>
<p>虽然微基准对隔离行为和识别瓶颈非常有用，但它们并不总是代表真实的工作负载。为了证明所做的改变确实提高了性能，并且没有过度适应微基准，在真实世界的场景中进行测量也是很有用的。</p>
<p>对于像<code>mongodb</code>这样的异步数据库驱动来说，这意味着有大量并发请求的情况。一个生成这种请求的有用工具是<code>wrk</code>工作负载生成器。</p>
<p>要安装<code>wrk</code>，你需要<code>clone repo</code>并从源代码中构建它。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>git clone https://github.com/wg/wrkcd wrkmake./wrk --version
<span class="boring">}
</span></code></pre></pre>
<p>如果成功了，你应该看到<code>wrk</code>的版本信息。关于更具体的安装说明，请看 <code>wrk</code> 的 <code>INSTALL</code> 页面。</p>
<p>在启动了一个<code>actix-web</code>服务器（在release 模式下运行），它将对每个<code>GET</code>请求执行查找，我用下面的调用将<code>wrk</code>指向它。</p>
<pre><code>./wrk -t8 -c100 -d10s http://127.0.0.1:8080
</code></pre>
<p>这将在<code>10</code>秒内运行一个基准，使用<code>8</code>个线程，并保持<code>100</code>个HTTP连接开放。</p>
<p>使用未经优化的驱动程序，我看到了以下结果。</p>
<pre><code>Running 10s test @ http://127.0.0.1:8080  8 threads and 100 connections  Thread Stats   Avg      Stdev     Max   +/- Stdev    Latency     7.83ms    2.06ms  26.52ms   73.81%    Req/Sec     1.54k   379.64     7.65k    91.02%  122890 requests in 10.10s, 205.45MB readRequests/sec:  12168.39Transfer/sec:     20.34MB
</code></pre>
<p>优化后，我看到的却是这样的结果。</p>
<pre><code>Running 10s test @ http://127.0.0.1:8080  8 threads and 100 connections  Thread Stats   Avg      Stdev     Max   +/- Stdev    Latency     4.03ms    1.31ms  52.06ms   97.77%    Req/Sec     3.03k   292.52     6.00k    92.41%  242033 requests in 10.10s, 404.63MB readRequests/sec:  23964.39Transfer/sec:     40.06MB
</code></pre>
<p>.这意味着吞吐量几乎增加了<code>100％</code>，真棒！这意味着我们基于微基准的优化对实际工作负载有非常显著改善。</p>
<h2 id="下一步"><a class="header" href="#下一步">下一步</a></h2>
<p>在这篇文章中，我们已经看到了如何只用一些基本的性能技术（生成火焰图、基准测试）就能在你的Rust应用程序中实现显著的性能改进。这方面的过程可以总结为以下步骤。</p>
<ol>
<li>使用 <code>criterion </code> 运行一个基准，以建立一个基线</li>
<li>通过<code>cargo flamegraph</code>识别瓶颈</li>
<li>尝试解决瓶颈问题</li>
<li>重新运行基准测试，看看瓶颈是否得到解决</li>
<li>重复进行以上步骤</li>
</ol>
<p>这个过程可以反复进行，直到达到一个令人满意的性能水平。然而，随着你的迭代，改进可能会变得不那么显著，需要更多的努力来实现。例如，在<code>mongodb</code>的例子中，第一个大的改进来自于更明智地使用<code>clone()</code>，但为了达到类似的改进水平，需要实现整个<code>serde</code> 的  <code>Deserializer</code> 。这就引出了性能剖析如此重要的另一个原因：除了识别需要优化的地方外，它还可以帮助确定何时需要优化（或者反过来说，何时应该停止优化）。如果剩下的改进不值得努力，性能剖析可以表明这一点，让你把精力集中在其他地方。这一点很重要，因为无论某件事情如何优化，总是有改进的余地，而且很容易陷入过度优化的无底洞中。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>我希望这个关于 Rust 中性能剖析和基准测试的概述是有帮助的。请注意，将你的 Rust 应用程序或库，优化到技术上尽可能快，并不总是必须的。因为优化的代码往往比简单但缓慢的代码更难理解和维护。</p>
<p>更重要的是，你的应用程序或库要满足其性能预期。例如，如果一个<code>CLI</code>工具的自我更新需要<code>50</code>毫秒或<code>100</code>毫秒，尽管有可能减少<code>50%</code>的运行时间，这并没有什么区别，因为<code>100</code>毫秒完全在这种功能的预期性能水平之内。然而，对于那些性能没有达到预期的情况，这篇文章中所概述的过程可以非常有效地产生优化，正如我们最近对<code>mongodb </code>crate所做的改进中所看到的。</p>
<h2 id="广告时间"><a class="header" href="#广告时间">广告时间</a></h2>
<p>我们最近发布了<a href="https://crates.io/crates/mongodb"><code>mongodb</code></a> crate的<a href="https://github.com/mongodb/mongo-rust-driver/releases/tag/v2.0.0"> <code>v2.0.0</code></a>版本，其中包含了这篇文章中提到的性能改进，以及大量的新功能，包括对事务的支持。如果你对用Rust编写Web应用程序感兴趣，如果你需要一个数据库，请查看<code>MongoDB</code> Rus t驱动。</p>
<h2 id=""><a class="header" href="#"></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模糊测试"><a class="header" href="#模糊测试">模糊测试</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Fuzz_testing">模糊测试（Fuzz testing）</a>是一种软件测试技术，用于通过向软件提供伪随机数据作为输入来发现安全性和稳定性问题。</p>
<p>关于模糊测试可以参考：</p>
<ul>
<li><a href="https://rust-fuzz.github.io/book/introduction.html">Rust Fuzz Book</a> </li>
<li><a href="https://github.com/rust-fuzz">https://github.com/rust-fuzz</a> </li>
<li><a href="https://about.gitlab.com/blog/2020/12/03/how-to-fuzz-rust-code/">How to fuzz Rust code continuously</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c术语解释"><a class="header" href="#c术语解释">C.术语解释</a></h1>
<h2 id="语言元素术语表"><a class="header" href="#语言元素术语表">语言元素术语表</a></h2>
<table><thead><tr><th>术语</th><th>中文翻译</th><th>备注</th></tr></thead><tbody>
<tr><td><strong>A</strong></td><td></td><td></td></tr>
<tr><td>Abstract Syntax Tree</td><td>抽象语法树</td><td></td></tr>
<tr><td>ABI</td><td>应用程序二进制接口</td><td>Application Binary Interface 缩写</td></tr>
<tr><td>accumulator</td><td>累加器</td><td></td></tr>
<tr><td>accumulator variable</td><td>累加器变量</td><td></td></tr>
<tr><td>ahead-of-time compiled</td><td>预编译</td><td></td></tr>
<tr><td>ahead-of-time compiled language</td><td>预编译语言</td><td></td></tr>
<tr><td>alias</td><td>别名</td><td></td></tr>
<tr><td>aliasing</td><td>别名使用</td><td>参见 <a href="https://en.wikipedia.org/wiki/Pointer_aliasing">Wikipedia</a></td></tr>
<tr><td>angle brackets</td><td>尖括号，“&lt;”和“&gt;”</td><td></td></tr>
<tr><td>annotate</td><td>标注，注明（动词）</td><td></td></tr>
<tr><td>annotation</td><td>标注，注明（名词）</td><td></td></tr>
<tr><td>Arc</td><td>原子引用计数器</td><td>Atomic Referecne Counter</td></tr>
<tr><td>anonymity</td><td>匿名</td><td></td></tr>
<tr><td>argument</td><td>参数，实参，实际参数</td><td>不严格区分的话， argument（参数）和 <br> parameter（参量）可以互换地使用</td></tr>
<tr><td>argument type</td><td>参数类型</td><td></td></tr>
<tr><td>assignment</td><td>赋值</td><td></td></tr>
<tr><td>associated functions</td><td>关联函数</td><td></td></tr>
<tr><td>associated items</td><td>关联项</td><td></td></tr>
<tr><td>associated types</td><td>关联类型</td><td></td></tr>
<tr><td>asterisk</td><td>星号（*)</td><td></td></tr>
<tr><td>atomic</td><td>原子的</td><td></td></tr>
<tr><td>attribute</td><td>属性</td><td></td></tr>
<tr><td>automated building</td><td>自动构建</td><td></td></tr>
<tr><td>automated test</td><td>自动测试，自动化测试</td><td></td></tr>
<tr><td><strong>B</strong></td><td></td><td></td></tr>
<tr><td>baroque macro</td><td>巴洛克宏</td><td></td></tr>
<tr><td>benchmark</td><td>基准</td><td></td></tr>
<tr><td>binary</td><td>二进制的</td><td></td></tr>
<tr><td>binary executable</td><td>二进制的可执行文件</td><td></td></tr>
<tr><td>bind</td><td>绑定</td><td></td></tr>
<tr><td>block</td><td>语句块，代码块</td><td></td></tr>
<tr><td>boolean</td><td>布尔型，布尔值</td><td></td></tr>
<tr><td>borrow check</td><td>借用检查</td><td></td></tr>
<tr><td>borrower</td><td>借用者，借入者</td><td></td></tr>
<tr><td>borrowing</td><td>借用</td><td></td></tr>
<tr><td>bound</td><td>约束，限定，限制</td><td>此词和 constraint 意思相近，<br>constraint 在 C# 语言中翻译成“约束”</td></tr>
<tr><td>box</td><td>箱子，盒子，装箱类型</td><td>一般不译，作动词时翻译成“装箱”，<br>具有所有权的智能指针</td></tr>
<tr><td>boxed</td><td>装箱，装包</td><td></td></tr>
<tr><td>boxing</td><td>装箱，装包</td><td></td></tr>
<tr><td>brace</td><td>大括号，“{”或“}”</td><td></td></tr>
<tr><td>buffer</td><td>缓冲，缓冲区，缓冲器，缓存</td><td></td></tr>
<tr><td>build</td><td>构建</td><td></td></tr>
<tr><td>builder pattern</td><td>创建者模式</td><td></td></tr>
<tr><td><strong>C</strong></td><td></td><td></td></tr>
<tr><td>call</td><td>调用</td><td></td></tr>
<tr><td>caller</td><td>调用者</td><td></td></tr>
<tr><td>capacity</td><td>容器</td><td></td></tr>
<tr><td>capture</td><td>捕获</td><td></td></tr>
<tr><td>cargo</td><td>(Rust 包管理器，不译)</td><td>该词作名词时意思是“货物”，<br>作动词时意思是“装载货物”</td></tr>
<tr><td>cargo-fy</td><td>Cargo 化，使用 Cargo 创建项目</td><td></td></tr>
<tr><td>case analysis</td><td>事例分析</td><td></td></tr>
<tr><td>cast</td><td>类型转换，转型</td><td></td></tr>
<tr><td>casting</td><td>类型转换</td><td></td></tr>
<tr><td>chaining method call</td><td>链式方法调用</td><td></td></tr>
<tr><td>channel</td><td>信道，通道</td><td></td></tr>
<tr><td>closure</td><td>闭包</td><td></td></tr>
<tr><td>coercion</td><td>强制类型转换，强制转换</td><td>coercion 原意是“强制，胁迫”</td></tr>
<tr><td>collection</td><td>集合</td><td>参见 <a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">Wikipedia</a></td></tr>
<tr><td>combinator</td><td>组合算子，组合器</td><td></td></tr>
<tr><td>comma</td><td>逗号，“,”</td><td></td></tr>
<tr><td>command</td><td>命令</td><td></td></tr>
<tr><td>command line</td><td>命令行</td><td></td></tr>
<tr><td>comment</td><td>注释</td><td></td></tr>
<tr><td>compile</td><td>编译（动词）</td><td></td></tr>
<tr><td>compile time</td><td>编译期，编译期间，编译时</td><td></td></tr>
<tr><td>compilation</td><td>编译（名词）</td><td></td></tr>
<tr><td>compilation unit</td><td>编译单元</td><td></td></tr>
<tr><td>compiler</td><td>编译器</td><td></td></tr>
<tr><td>compiler intrinsics</td><td>编译器固有功能</td><td></td></tr>
<tr><td>compound</td><td>复合（类型，数据）</td><td></td></tr>
<tr><td>concurrency</td><td>并发</td><td></td></tr>
<tr><td>conditional compilation</td><td>条件编译</td><td></td></tr>
<tr><td>configuration</td><td>配置</td><td></td></tr>
<tr><td>constructor</td><td>构造器</td><td></td></tr>
<tr><td>consumer</td><td>消费者</td><td></td></tr>
<tr><td>container</td><td>容器</td><td></td></tr>
<tr><td>container type</td><td>容器类型</td><td></td></tr>
<tr><td>convert</td><td>转换，转化，转</td><td></td></tr>
<tr><td>copy</td><td>复制，拷贝</td><td></td></tr>
<tr><td>crate</td><td>包，包装箱，装包</td><td>一般不译，crate 是 Rust 的基本编译单元</td></tr>
<tr><td>curly braces</td><td>大括号，包含“{”和“}”</td><td></td></tr>
<tr><td>custom type</td><td>自定义类型</td><td></td></tr>
<tr><td><strong>D</strong></td><td></td><td></td></tr>
<tr><td>dangling pointer</td><td>悬垂指针</td><td>use after free 在释放后使用</td></tr>
<tr><td>data race</td><td>数据竞争</td><td></td></tr>
<tr><td>dead code</td><td>死代码，无效代码，不可达代码</td><td></td></tr>
<tr><td>deallocate</td><td>释放，重新分配</td><td></td></tr>
<tr><td>declare</td><td>声明</td><td></td></tr>
<tr><td>deep copy</td><td>深拷贝，深复制</td><td></td></tr>
<tr><td>dependency</td><td>依赖</td><td></td></tr>
<tr><td>deref coercions</td><td>强制多态</td><td></td></tr>
<tr><td>dereference</td><td>解引用</td><td>Rust  文章中有时简写为 Deref</td></tr>
<tr><td>derive</td><td>派生</td><td></td></tr>
<tr><td>designator</td><td>指示符</td><td></td></tr>
<tr><td>destruction</td><td>销毁，毁灭</td><td></td></tr>
<tr><td>destructor</td><td>析构器，析构函数</td><td></td></tr>
<tr><td>destructure</td><td>解构</td><td></td></tr>
<tr><td>destructuring</td><td>解构，解构赋值</td><td></td></tr>
<tr><td>desugar</td><td>脱糖</td><td></td></tr>
<tr><td>diverge function</td><td>发散函数</td><td></td></tr>
<tr><td>device drive</td><td>设备驱动</td><td></td></tr>
<tr><td>directory</td><td>目录</td><td></td></tr>
<tr><td>dispatch</td><td>分发</td><td></td></tr>
<tr><td>diverging functions</td><td>发散函数</td><td></td></tr>
<tr><td>documentation</td><td>文档</td><td></td></tr>
<tr><td>dot operator</td><td>点运算符</td><td></td></tr>
<tr><td>DST</td><td>动态大小类型</td><td>dynamic sized type，一般不译，<br>使用英文缩写形式</td></tr>
<tr><td>dynamic language</td><td>动态类型语言</td><td></td></tr>
<tr><td>dynamic trait type</td><td>动态特质类型</td><td></td></tr>
<tr><td><strong>E</strong></td><td></td><td></td></tr>
<tr><td>enumeration</td><td>枚举</td><td></td></tr>
<tr><td>encapsulation</td><td>封装</td><td></td></tr>
<tr><td>equality test</td><td>相等测试</td><td></td></tr>
<tr><td>elision</td><td>省略</td><td></td></tr>
<tr><td>exhaustiveness checking</td><td>穷尽性检查，无遗漏检查</td><td></td></tr>
<tr><td>expression</td><td>表达式</td><td></td></tr>
<tr><td>expression-oriented language</td><td>面向表达式的语言</td><td></td></tr>
<tr><td>explicit</td><td>显式</td><td></td></tr>
<tr><td>explicit discriminator</td><td>显式的辨别值</td><td></td></tr>
<tr><td>explicit type conversion</td><td>显式类型转换</td><td></td></tr>
<tr><td>extension</td><td>扩展名</td><td></td></tr>
<tr><td>extern</td><td>外，外部</td><td>作关键字时不译</td></tr>
<tr><td><strong>F</strong></td><td></td><td></td></tr>
<tr><td>fat pointer</td><td>胖指针</td><td></td></tr>
<tr><td>feature gate</td><td>功能开关</td><td></td></tr>
<tr><td>field</td><td>字段</td><td></td></tr>
<tr><td>field-level mutability</td><td>字段级别可变性</td><td></td></tr>
<tr><td>file</td><td>文件</td><td></td></tr>
<tr><td>fmt</td><td>格式化，是 format 的缩写</td><td></td></tr>
<tr><td>formatter</td><td>格式化程序，格式化工具，格式器</td><td></td></tr>
<tr><td>floating-point number</td><td>浮点数</td><td></td></tr>
<tr><td>flow control</td><td>流程控制</td><td></td></tr>
<tr><td>Foreign Function Interface（FFI）</td><td>外部语言函数接口</td><td></td></tr>
<tr><td>fragment specifier</td><td>片段分类符</td><td></td></tr>
<tr><td>free variables</td><td>自由变量</td><td></td></tr>
<tr><td>freeze</td><td>冻结</td><td></td></tr>
<tr><td>function</td><td>函数</td><td></td></tr>
<tr><td>function declaration</td><td>函数声明</td><td></td></tr>
<tr><td>functional</td><td>函数式</td><td></td></tr>
<tr><td><strong>G</strong></td><td></td><td></td></tr>
<tr><td>garbage collector</td><td>垃圾回收</td><td></td></tr>
<tr><td>generalize</td><td>泛化，泛型化</td><td></td></tr>
<tr><td>generator</td><td>生成器</td><td></td></tr>
<tr><td>generic</td><td>泛型</td><td></td></tr>
<tr><td>generic type</td><td>泛型类型</td><td></td></tr>
<tr><td>growable</td><td>可增长的</td><td></td></tr>
<tr><td>guard</td><td>守卫</td><td></td></tr>
<tr><td><strong>H</strong></td><td></td><td></td></tr>
<tr><td>handle error</td><td>句柄错误</td><td></td></tr>
<tr><td>hash</td><td>哈希，哈希值，散列</td><td></td></tr>
<tr><td>hash map</td><td>散列映射，哈希表</td><td></td></tr>
<tr><td>heap</td><td>堆</td><td></td></tr>
<tr><td>hierarchy</td><td>层次，分层，层次结构</td><td></td></tr>
<tr><td>higher rank lifetime</td><td>高阶生命周期</td><td></td></tr>
<tr><td>higher rank trait bound</td><td>高阶特质约束</td><td></td></tr>
<tr><td>higher tank type</td><td>高阶类型</td><td></td></tr>
<tr><td>hygiene</td><td>卫生</td><td></td></tr>
<tr><td>hygienic macro system</td><td>卫生宏系统</td><td></td></tr>
<tr><td><strong>I</strong></td><td></td><td></td></tr>
<tr><td>ICE</td><td>编译内部错误</td><td>internal comppiler error 的缩写</td></tr>
<tr><td>immutable</td><td>不可变的</td><td></td></tr>
<tr><td>implement</td><td>实现</td><td></td></tr>
<tr><td>implementor</td><td>实现者</td><td></td></tr>
<tr><td>implicit</td><td>隐式</td><td></td></tr>
<tr><td>implicit discriminator</td><td>隐式的辨别值</td><td></td></tr>
<tr><td>implicit type conversion</td><td>隐式类型转换</td><td></td></tr>
<tr><td>import</td><td>导入</td><td></td></tr>
<tr><td>in assignment</td><td>在赋值（语句）</td><td></td></tr>
<tr><td>index</td><td>索引</td><td>英语复数形式：indices</td></tr>
<tr><td>infer</td><td>推导（动词）</td><td></td></tr>
<tr><td>inference</td><td>推导（名词）</td><td></td></tr>
<tr><td>inherited mutability</td><td>承袭可变性</td><td></td></tr>
<tr><td>inheritance</td><td>继承</td><td></td></tr>
<tr><td>integrated development <br>environment(IDE)</td><td>集成开发环境</td><td>中文著作中通常直接写成 IDE</td></tr>
<tr><td>integration-style test</td><td>集成测试</td><td></td></tr>
<tr><td>interior mutability</td><td>内部可变性</td><td></td></tr>
<tr><td>installer</td><td>安装程序，安装器</td><td></td></tr>
<tr><td>instance</td><td>实例</td><td></td></tr>
<tr><td>instance method</td><td>实例方法</td><td></td></tr>
<tr><td>integer</td><td>整型，整数</td><td></td></tr>
<tr><td>interact</td><td>相互作用，相互影响</td><td></td></tr>
<tr><td>interior mutability</td><td>内部可变性</td><td></td></tr>
<tr><td>intrinsic</td><td>固有的</td><td></td></tr>
<tr><td>invoke</td><td>调用</td><td></td></tr>
<tr><td>item</td><td>项，条目，项目</td><td></td></tr>
<tr><td>iterate</td><td>重复</td><td></td></tr>
<tr><td>iteration</td><td>迭代</td><td></td></tr>
<tr><td>iterator</td><td>迭代器</td><td></td></tr>
<tr><td>iterator adaptors</td><td>迭代器适配器</td><td></td></tr>
<tr><td>iterator invalidation</td><td>迭代器失效</td><td></td></tr>
<tr><td><strong>L</strong></td><td></td><td></td></tr>
<tr><td>LHS</td><td>左操作数</td><td>left-hand side 的非正式缩写，<br>与 RHS 相对</td></tr>
<tr><td>lender</td><td>借出者</td><td></td></tr>
<tr><td>library</td><td>库</td><td></td></tr>
<tr><td>lifetime</td><td>生存期/ 寿命 / 生命周期</td><td></td></tr>
<tr><td>lifetime elision</td><td>生命周期省略</td><td></td></tr>
<tr><td>link</td><td>链接</td><td></td></tr>
<tr><td>linked-list</td><td>链表</td><td></td></tr>
<tr><td>lint</td><td>（不译）</td><td>lint 英文本义是“纱布，绒毛”，此词在<br>计算机领域中表示程序代码中可疑和<br>不具结构性的片段，参见 <a href="https://en.wikipedia.org/wiki/Lint_%28software%29">Wikipedia</a></td></tr>
<tr><td>list</td><td>列表</td><td></td></tr>
<tr><td>listener</td><td>监听器</td><td></td></tr>
<tr><td>literal</td><td>数据，常量数据，字面值，字面量，<br>字面常量，字面上的</td><td>英文意思：字面意义的（内容）</td></tr>
<tr><td>LLVM</td><td>（不译）</td><td>Low Level Virtual Machine 的缩写，<br>是构建编译器的系统</td></tr>
<tr><td>loop</td><td>循环</td><td>作关键字时不译</td></tr>
<tr><td>low-level code</td><td>底层代码</td><td></td></tr>
<tr><td>low-level language</td><td>底层语言</td><td></td></tr>
<tr><td>l-value</td><td>左值</td><td></td></tr>
<tr><td><strong>M</strong></td><td></td><td></td></tr>
<tr><td>main function</td><td>main 函数，主函数</td><td></td></tr>
<tr><td>macro</td><td>宏</td><td></td></tr>
<tr><td>map</td><td>映射</td><td>一般不译</td></tr>
<tr><td>match guard</td><td>匹配守卫</td><td></td></tr>
<tr><td>memory</td><td>内存</td><td></td></tr>
<tr><td>memory leak</td><td>内存泄露</td><td></td></tr>
<tr><td>memory safe</td><td>内存安全</td><td></td></tr>
<tr><td>meta</td><td>原则，元</td><td></td></tr>
<tr><td>metadata</td><td>元数据</td><td></td></tr>
<tr><td>metaprogramming</td><td>元编程</td><td></td></tr>
<tr><td>metavariable</td><td>元变量</td><td></td></tr>
<tr><td>method call syntax</td><td>方法调用语法</td><td></td></tr>
<tr><td>method chaining</td><td>方法链</td><td></td></tr>
<tr><td>method definition</td><td>方法定义</td><td></td></tr>
<tr><td>modifier</td><td>修饰符</td><td></td></tr>
<tr><td>module</td><td>模块</td><td></td></tr>
<tr><td>monomorphization</td><td>单态</td><td>mono: one, morph: form</td></tr>
<tr><td>move</td><td>移动，转移</td><td>按照 Rust 所规定的内容，<br>英语单词 transfer 的意思<br>比 move 更贴合实际描述<br>参考：<a href="http://rustwiki.org/rust-by-example/scope/move.html">Rust by Example</a></td></tr>
<tr><td>move semantics</td><td>移动语义</td><td></td></tr>
<tr><td>mutability</td><td>可变性</td><td></td></tr>
<tr><td>mutable</td><td>可变</td><td></td></tr>
<tr><td>mutable reference</td><td>可变引用</td><td></td></tr>
<tr><td>multiple bounds</td><td>多重约束</td><td></td></tr>
<tr><td>mutiple patterns</td><td>多重模式</td><td></td></tr>
<tr><td><strong>N</strong></td><td></td><td></td></tr>
<tr><td>nest</td><td>嵌套</td><td></td></tr>
<tr><td>Nightly Rust</td><td>Rust 开发版</td><td>nightly本意是“每夜，每天晚上”，<br>指代码每天都更新</td></tr>
<tr><td>NLL</td><td>非词法生命周期</td><td>non lexical lifetime 的缩写，<br>一般不译</td></tr>
<tr><td>non-copy type</td><td>非复制类型</td><td></td></tr>
<tr><td>non-generic</td><td>非泛型</td><td></td></tr>
<tr><td>no-op</td><td>空操作，空运算</td><td>(此词出现在类型转换章节中）</td></tr>
<tr><td>non-commutative</td><td>非交换的</td><td></td></tr>
<tr><td>non-scalar cast</td><td>非标量转换</td><td></td></tr>
<tr><td>notation</td><td>符号，记号</td><td></td></tr>
<tr><td>numeric</td><td>数值，数字</td><td></td></tr>
<tr><td><strong>O</strong></td><td></td><td></td></tr>
<tr><td>optimization</td><td>优化</td><td></td></tr>
<tr><td>out-of-bounds accessing</td><td>越界访问</td><td></td></tr>
<tr><td>orphan rule</td><td>孤儿规则</td><td></td></tr>
<tr><td>overflow</td><td>溢出，越界</td><td></td></tr>
<tr><td>own</td><td>占有，拥有</td><td></td></tr>
<tr><td>owner</td><td>所有者，拥有者</td><td></td></tr>
<tr><td>ownership</td><td>所有权</td><td></td></tr>
<tr><td><strong>P</strong></td><td></td><td></td></tr>
<tr><td>package manager</td><td>包管理器，软件包管理器</td><td></td></tr>
<tr><td>panic</td><td>（不译）</td><td>此单词直接翻译是“恐慌”，<br>在 Rust 中用于不可恢复的错误处理</td></tr>
<tr><td>parameter</td><td>参量，形参，形式参量</td><td>不严格区分的话， argument（参数）和 <br> parameter（参量）可以互换地使用</td></tr>
<tr><td>parametric polymorphism</td><td>参数多态</td><td></td></tr>
<tr><td>parent scope</td><td>父级作用域</td><td></td></tr>
<tr><td>parentheses</td><td>小括号，包括“(”和“)”</td><td></td></tr>
<tr><td>parse</td><td>分析，解析</td><td></td></tr>
<tr><td>parser</td><td>（语法）分析器，解析器</td><td></td></tr>
<tr><td>pattern</td><td>模式</td><td></td></tr>
<tr><td>pattern match</td><td>模式匹配</td><td></td></tr>
<tr><td>phantom type</td><td>虚类型，虚位类型</td><td>phantom 相关的专有名词：<br>phantom bug 幻影指令<br>phantom power 幻象电源<br>参见：<a href="https://wiki.haskell.org/Phantom_type">Haskell</a>、<a href="https://en.wikibooks.org/wiki/Haskell/Phantom_types">Haskell/Phantom_type</a>、<br><a href="http://rustwiki.org/rust-by-example/generics/phantom.html">Rust/Phantom</a>、<a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">stdlib/PhantomData</a></td></tr>
<tr><td>platform</td><td>平台</td><td></td></tr>
<tr><td>polymorphism</td><td>多态</td><td></td></tr>
<tr><td>powershell</td><td>（不译）</td><td>Windows 系统的一种命令行外壳程序<br>和脚本环境</td></tr>
<tr><td>possibility of absence</td><td>不存在的可能性</td><td></td></tr>
<tr><td>precede</td><td>预先？，在...发生（或出现）</td><td></td></tr>
<tr><td>prelude</td><td>（不译）</td><td>预先导入模块，英文本意：序曲，前奏</td></tr>
<tr><td>primitive types</td><td>原生类型，基本类型，简单类型</td><td></td></tr>
<tr><td>print</td><td>打印</td><td></td></tr>
<tr><td>process</td><td>进程</td><td></td></tr>
<tr><td>procedural macros</td><td>过程宏，程序宏</td><td></td></tr>
<tr><td>project</td><td>项目，工程</td><td></td></tr>
<tr><td>prototype</td><td>原型</td><td></td></tr>
<tr><td><strong>R</strong></td><td></td><td></td></tr>
<tr><td>race condition</td><td>竞态条件</td><td></td></tr>
<tr><td>RAII</td><td>资源获取即初始化（一般不译）</td><td>resource acquisition is initialization 的缩写</td></tr>
<tr><td>range</td><td>区间，范围</td><td></td></tr>
<tr><td>range expression</td><td>区间表达式</td><td></td></tr>
<tr><td>raw identifier</td><td>原始标识符</td><td></td></tr>
<tr><td>raw pointer</td><td>原始指针，裸指针</td><td></td></tr>
<tr><td>RC</td><td>引用计数</td><td>reference counted</td></tr>
<tr><td>Reader</td><td>读取器</td><td></td></tr>
<tr><td>recursive macro</td><td>递归宏</td><td></td></tr>
<tr><td>reference</td><td>引用</td><td></td></tr>
<tr><td>reference cycle</td><td>引用循环</td><td></td></tr>
<tr><td>release</td><td>发布</td><td></td></tr>
<tr><td>resource</td><td>资源</td><td></td></tr>
<tr><td>resource leak</td><td>资源泄露</td><td></td></tr>
<tr><td>RHS</td><td>右操作数</td><td>right-hand side 的非正式缩写，<br>与 LHS 相对</td></tr>
<tr><td>root directory</td><td>根目录</td><td></td></tr>
<tr><td>runtime</td><td>运行时</td><td></td></tr>
<tr><td>runtime behavior</td><td>运行时行为</td><td></td></tr>
<tr><td>runtime overhead</td><td>运行时开销</td><td></td></tr>
<tr><td>Rust</td><td>（不译）</td><td>一种编程语言</td></tr>
<tr><td>Rustacean</td><td>（不译）</td><td>编写 Rust 的程序员或爱好者的通称</td></tr>
<tr><td>rustc</td><td>（不译）</td><td>Rust 语言编译器</td></tr>
<tr><td>r-value</td><td>右值</td><td></td></tr>
<tr><td><strong>S</strong></td><td></td><td></td></tr>
<tr><td>scalar</td><td>标量，数量</td><td></td></tr>
<tr><td>schedule</td><td>调度</td><td></td></tr>
<tr><td>scope</td><td>作用域</td><td></td></tr>
<tr><td>screen</td><td>屏幕</td><td></td></tr>
<tr><td>script</td><td>脚本</td><td></td></tr>
<tr><td>semicolon</td><td>分号，“;”</td><td></td></tr>
<tr><td>self</td><td>自身，作关键字时不译</td><td></td></tr>
<tr><td>shadow</td><td>遮蔽，隐蔽，隐藏，覆盖</td><td></td></tr>
<tr><td>shallow copy</td><td>浅拷贝，浅复制</td><td></td></tr>
<tr><td>signature</td><td>标记</td><td></td></tr>
<tr><td>slice</td><td>切片</td><td></td></tr>
<tr><td>snake case</td><td>蛇形命名</td><td>参见：<a href="https://en.wikipedia.org/wiki/Snake_case">Snake case</a></td></tr>
<tr><td>source file</td><td>源文件</td><td></td></tr>
<tr><td>source code</td><td>源代码</td><td></td></tr>
<tr><td>specialization</td><td>泛型特化</td><td></td></tr>
<tr><td>square</td><td>平方，二次方，二次幂</td><td></td></tr>
<tr><td>square brackets</td><td>中括号，“[”和“]”</td><td></td></tr>
<tr><td>src</td><td>（不译）</td><td>source 的缩写，指源代码</td></tr>
<tr><td>stack</td><td>栈</td><td></td></tr>
<tr><td>stack unwind</td><td>栈解开、栈展开</td><td></td></tr>
<tr><td>statement</td><td>语句</td><td></td></tr>
<tr><td>statically allocated</td><td>静态分配</td><td></td></tr>
<tr><td>statically allocated string</td><td>静态分配的字符串</td><td></td></tr>
<tr><td>statically dispatch</td><td>静态分发</td><td></td></tr>
<tr><td>static method</td><td>静态方法</td><td></td></tr>
<tr><td>string</td><td>字符串</td><td></td></tr>
<tr><td>string literal</td><td>字符串常量</td><td></td></tr>
<tr><td>string slices</td><td>字符串片段</td><td></td></tr>
<tr><td>stringify</td><td>字符串化</td><td></td></tr>
<tr><td>subscript notation</td><td>下标</td><td></td></tr>
<tr><td>sugar</td><td>糖</td><td></td></tr>
<tr><td>super</td><td>父级，作关键字时不译</td><td></td></tr>
<tr><td>syntax context</td><td>语法上下文</td><td></td></tr>
<tr><td>systems programming language</td><td>系统级编程语言</td><td></td></tr>
<tr><td><strong>T</strong></td><td></td><td></td></tr>
<tr><td>tagged union</td><td>标记联合</td><td></td></tr>
<tr><td>target triple</td><td>多层次指标，三层/重 指标/目标</td><td>triple 本义是“三”，但此处虚指“多”，<br>此词翻译需要更多讨论</td></tr>
<tr><td>terminal</td><td>终端</td><td></td></tr>
<tr><td>testing</td><td>测试</td><td></td></tr>
<tr><td>testsuit</td><td>测试套件</td><td></td></tr>
<tr><td>the least significant bit (LSB)</td><td>最低数字位</td><td></td></tr>
<tr><td>the most significant bit (MSB)</td><td>最高数字位</td><td></td></tr>
<tr><td>thread</td><td>线程</td><td></td></tr>
<tr><td>TOML</td><td>（不译）</td><td>Tom's Obvious, Minimal Language <br>的缩写，一种配置语言</td></tr>
<tr><td>token tree</td><td>令牌树？</td><td>待进一步斟酌</td></tr>
<tr><td>trait</td><td>特质</td><td>其字面上有“特性，特征”之意</td></tr>
<tr><td>trait bound</td><td>特质约束</td><td>bound 有“约束，限制，限定”之意</td></tr>
<tr><td>trait object</td><td>特质对象</td><td></td></tr>
<tr><td>transmute</td><td>（不译）</td><td>其字面上有“变化，变形，变异”之意，<br>不作翻译</td></tr>
<tr><td>trivial</td><td>平凡的</td><td></td></tr>
<tr><td>troubleshooting</td><td>疑难解答，故障诊断，<br>故障排除，故障分析</td><td></td></tr>
<tr><td>tuple</td><td>元组</td><td></td></tr>
<tr><td>two's complement</td><td>补码，二补数</td><td></td></tr>
<tr><td>two-word object</td><td>双字对象</td><td></td></tr>
<tr><td>type annotation</td><td>类型标注</td><td></td></tr>
<tr><td>type erasure</td><td>类型擦除</td><td></td></tr>
<tr><td>type inference</td><td>类型推导</td><td></td></tr>
<tr><td>type inference engine</td><td>类型推导引擎</td><td></td></tr>
<tr><td>type parameter</td><td>类型参量</td><td></td></tr>
<tr><td>type placeholder</td><td>类型占位符</td><td></td></tr>
<tr><td>type signature</td><td>类型标记</td><td></td></tr>
<tr><td><strong>U</strong></td><td></td><td></td></tr>
<tr><td>undefined behavior</td><td>未定义行为</td><td></td></tr>
<tr><td>uninstall</td><td>卸载</td><td></td></tr>
<tr><td>unit-like struct</td><td>类单元结构体</td><td></td></tr>
<tr><td>unit struct</td><td>单元结构体</td><td></td></tr>
<tr><td>&quot;unit-style&quot; tests</td><td>单元测试</td><td></td></tr>
<tr><td>unit test</td><td>单元测试</td><td></td></tr>
<tr><td>unit type</td><td>单元类型</td><td></td></tr>
<tr><td>universal function call syntax <br>(UFCS)</td><td>通用函数调用语法</td><td></td></tr>
<tr><td>unsized types</td><td>不定长类型</td><td></td></tr>
<tr><td>unwind</td><td>展开</td><td></td></tr>
<tr><td>unwrap</td><td>解包</td><td>暂译！</td></tr>
<tr><td><strong>V</strong></td><td></td><td></td></tr>
<tr><td>variable binding</td><td>变量绑定</td><td></td></tr>
<tr><td>variable shadowing</td><td>变量遮蔽，变量隐蔽,<br>变量隐藏，变量覆盖</td><td></td></tr>
<tr><td>variable capture</td><td>变量捕获</td><td></td></tr>
<tr><td>variant</td><td>变量</td><td></td></tr>
<tr><td>vector</td><td>（动态数组，一般不译）</td><td>vector 本义是“向量”</td></tr>
<tr><td>visibility</td><td>可见性</td><td></td></tr>
<tr><td>vtable</td><td>虚表</td><td></td></tr>
<tr><td><strong>W</strong></td><td></td><td></td></tr>
<tr><td>where clause</td><td>where 子句，where 从句，where 分句</td><td>在数据库的官方手册中多翻译成“子句”，英语语法中翻译成“从句”</td></tr>
<tr><td>wrap</td><td>包裹</td><td>暂译！</td></tr>
<tr><td>wrapped</td><td>装包</td><td></td></tr>
<tr><td>wrapper</td><td>装包</td><td></td></tr>
<tr><td><strong>Y</strong></td><td></td><td></td></tr>
<tr><td>yield</td><td>产生(收益、效益等)，产出，提供</td><td></td></tr>
<tr><td><strong>Z</strong></td><td></td><td></td></tr>
<tr><td>zero-cost abstractions</td><td>零开销抽象</td><td></td></tr>
<tr><td>zero-width space(ZWSP)</td><td>零宽空格</td><td></td></tr>
</tbody></table>
<p><strong>参考</strong></p>
<p><a href="https://github.com/rust-lang-cn/english-chinese-glossary-of-rust/blob/master/rust-glossary.md">Rust 语言术语中英文对照表</a></p>
<h2 id="编译器相关术语表"><a class="header" href="#编译器相关术语表">编译器相关术语表</a></h2>
<table><thead><tr><th>术语</th><th>中文</th><th>意义</th></tr></thead><tbody>
<tr><td><span id="arena">arena/arena allocation</span>  </td><td><span id="arena">竞技场分配</span>  </td><td>arena 是一个大内存缓冲区，从中可以进行其他内存分配，这种分配方式称为竞技场分配。</td></tr>
<tr><td><span id="ast">AST</span>                       </td><td><span id="ast">抽象语法树</span>  </td><td>由<code>rustc_ast</code> crate 产生的抽象语法树。</td></tr>
<tr><td><span id="binder">binder</span>                 </td><td><span id="binder">绑定器</span>  </td><td>绑定器是声明变量和类型的地方。例如，<code>&lt;T&gt;</code> 是<code>fn foo&lt;T&gt;(..)</code>中泛型类型参数 <code>T</code>的绑定器，以及 |<code>a</code>|<code> ...</code>  是 参数<code>a</code>的绑定器。</td></tr>
<tr><td><span id="body-id">BodyId</span>                </td><td><span id="body-id"> 主体ID</span>  </td><td>一个标识符，指的是crate 中的一个特定主体（函数或常量的定义）。</td></tr>
<tr><td><span id="bound-var">bound variable</span>      </td><td><span id="bound-var">绑定变量</span>      </td><td>&quot;绑定变量 &quot;是在表达式/术语中声明的变量。例如，变量<code>a</code>被绑定在闭包表达式中|<code>a</code>|<code> a * 2</code>。</td></tr>
<tr><td><span id="codegen">codegen</span>               </td><td><span id="codegen">代码生成</span>               </td><td>由 MIR 转译为 LLVM IR。</td></tr>
<tr><td><span id="codegen-unit">codegen unit</span>     </td><td><span id="codegen-unit">代码生成单元</span>     </td><td>当生成LLVM IR时，编译器将Rust代码分成若干个代码生成单元（有时缩写为CGU）。这些单元中的每一个都是由LLVM独立处理的，实现了并行化。它们也是增量编译的单位。</td></tr>
<tr><td><span id="completeness">completeness</span>     </td><td><span id="completeness">完整性</span>     </td><td>类型理论中的一个技术术语，它意味着每个类型安全的程序也会进行类型检查。同时拥有健全性（soundness）和完整性（completeness）是非常困难的，而且通常健全性（soundness）更重要。</td></tr>
<tr><td><span id="cfg">control-flow graph</span>        </td><td><span id="cfg">控制流图</span>        </td><td>程序的控制流表示。</td></tr>
<tr><td><span id="ctfe">CTFE</span>                     </td><td><span id="ctfe">编译时函数求值</span>                     </td><td>编译时函数求值（Compile-Time Function Evaluation）的简称，是指编译器在编译时计算 &quot;const fn &quot;的能力。这是编译器常量计算系统的一部分。</td></tr>
<tr><td><span id="cx">cx</span>                         </td><td><span id="cx">上下文</span>                         </td><td>Rust 编译器内倾向于使用 &quot;cx &quot;作为上下文的缩写。另见 &quot;tcx&quot;、&quot;infcx &quot;等。</td></tr>
<tr><td><span id="ctxt">ctxt</span>                     </td><td><span id="ctxt">上下文（另一个缩写）</span>                     </td><td>我们也使用 &quot;ctxt &quot;作为上下文的缩写，例如， <a href="safe-guides/Appendix/terms.html#TyCtxt"><code>TyCtxt</code></a>，以及 <a href="safe-guides/Appendix/terms.html#cx">cx</a> 或 <a href="safe-guides/Appendix/terms.html#tcx">tcx</a>。</td></tr>
<tr><td><span id="dag">DAG</span>                       </td><td><span id="dag">有向无环图</span>                       </td><td>在编译过程中，一个有向无环图被用来跟踪查询之间的依赖关系</td></tr>
<tr><td><span id="data-flow">data-flow analysis</span>  </td><td><span id="data-flow">数据流分析</span>  </td><td>静态分析，找出程序控制流中每一个点的属性。</td></tr>
<tr><td><span id="debruijn">DeBruijn Index</span>       </td><td><span id="debruijn">德布鲁因索引</span>       </td><td>一种只用整数来描述一个变量被绑定的绑定器的技术。它的好处是，在变量重命名下，它是不变的。</td></tr>
<tr><td><span id="def-id">DefId</span>                  </td><td><span id="def-id">定义Id</span>                  </td><td>一个识别定义的索引（见<code>rustc_middle/src/hir/def_id.rs</code>）。<code>DefPath</code>的唯一标识。</td></tr>
<tr><td><span id="discriminant">discriminant</span>     </td><td><span id="discriminant">判别式</span>     </td><td>与枚举变体或生成器状态相关的基础值，以表明它是 &quot;激活的（avtive）&quot;（但不要与它的<a href="safe-guides/Appendix/terms.html#variant-idx">&quot;变体索引&quot;</a>混淆）。在运行时，激活变体的判别值被编码在<a href="safe-guides/Appendix/terms.html#tag">tag</a>中。</td></tr>
<tr><td><span id="double-ptr">double pointer</span>     </td><td><span id="double-ptr">双指针</span>     </td><td>一个带有额外元数据的指针。同指「胖指针」。</td></tr>
<tr><td><span id="drop-glue">drop glue</span>           </td><td><span id="drop-glue">drop胶水</span>           </td><td>(内部）编译器生成的指令，处理调用数据类型的析构器（<code>Drop</code>）。</td></tr>
<tr><td><span id="dst">DST</span>                       </td><td><span id="dst">DST</span>                       </td><td>Dynamically-Sized Type的缩写，这是一种编译器无法静态知道内存大小的类型（例如：<code>str'或</code>[u8]<code>）。这种类型没有实现</code>Sized<code>，不能在栈中分配。它们只能作为结构中的最后一个字段出现。它们只能在指针后面使用（例如：</code>&amp;str<code>或</code>&amp;[u8]`）。</td></tr>
<tr><td><span id="ebl">early-bound lifetime</span>      </td><td><span id="ebl">早绑定生存期</span>      </td><td>一个在其定义处被替换的生存期区域（region）。绑定在一个项目的<code>Generics'中，并使用</code>Substs'进行替换。与<strong>late-bound lifetime</strong>形成对比。</td></tr>
<tr><td><span id="empty-type">empty type</span>         </td><td><span id="empty-type">空类型</span>         </td><td>参考 &quot;uninhabited type&quot;.</td></tr>
<tr><td><span id="fat-ptr">fat pointer</span>           </td><td><span id="fat-ptr">胖指针</span>           </td><td>一个两字（word）的值，携带着一些值的地址，以及一些使用该值所需的进一步信息。Rust包括两种 &quot;胖指针&quot;：对切片（slice）的引用和特质（trait）对象。对切片的引用带有切片的起始地址和它的长度。特质对象携带一个值的地址和一个指向适合该值的特质实现的指针。&quot;胖指针 &quot;也被称为 &quot;宽指针&quot;，和 &quot;双指针&quot;。</td></tr>
<tr><td><span id="free-var">free variable</span>        </td><td><span id="free-var">自由变量</span>        </td><td>自由变量 是指没有被绑定在表达式或术语中的变量；</td></tr>
<tr><td><span id="generics">generics</span>             </td><td><span id="generics">泛型</span>             </td><td>通用类型参数集。</td></tr>
<tr><td><span id="hir">HIR</span>                       </td><td><span id="hir">高级中间语言</span>                       </td><td>高级中间语言，通过对AST进行降级（lowering）和去糖（desugaring）而创建。</td></tr>
<tr><td><span id="hir-id">HirId</span>                  </td><td><span id="hir-id">HirId</span>                  </td><td>通过结合“def-id”和 &quot;intra-definition offset&quot;来识别HIR中的一个特定节点。</td></tr>
<tr><td><span id="hir-map">HIR map</span>               </td><td><span id="hir-map">HIR map</span>               </td><td>通过<code>tcx.hir()</code>访问的HIR Map，可以让你快速浏览HIR并在各种形式的标识符之间进行转换。</td></tr>
<tr><td><span id="ice">ICE</span>                       </td><td><span id="ice">ICE</span>                       </td><td>内部编译器错误的简称，这是指编译器崩溃的情况。</td></tr>
<tr><td><span id="ich">ICH</span>                       </td><td><span id="ich">ICH</span>                       </td><td>增量编译哈希值的简称，它们被用作HIR和crate metadata等的指纹，以检查是否有变化。这在增量编译中是很有用的，可以查看crate的一部分是否发生了变化，应该重新编译。</td></tr>
<tr><td><span id="infcx">infcx</span>                   </td><td><span id="infcx">类型推导上下文</span>                   </td><td>类型推导上下文（<code>InferCtxt</code>）。</td></tr>
<tr><td><span id="inf-var">inference variable</span>    </td><td><span id="inf-var">推导变量</span>    </td><td>在进行类型或区域推理时，&quot;推导变量 &quot;是一种特殊的类型/区域，代表你试图推理的内容。想想代数中的X。例如，如果我们试图推断一个程序中某个变量的类型，我们就创建一个推导变量来代表这个未知的类型。</td></tr>
<tr><td><span id="intern">intern</span>                 </td><td><span id="intern">intern</span>                 </td><td>intern是指存储某些经常使用的常量数据，如字符串，然后用一个标识符（如`符号'）而不是数据本身来引用这些数据，以减少内存的使用和分配的次数。</td></tr>
<tr><td><span id="intrinsic">intrinsic</span>           </td><td><span id="intrinsic">内部函数</span>           </td><td>内部函数是在编译器本身中实现的特殊功能，但向用户暴露（通常是不稳定的）。它们可以做神奇而危险的事情。</td></tr>
<tr><td><span id="ir">IR</span>                         </td><td><span id="ir">IR</span>                         </td><td>Intermediate Representation的简称，是编译器中的一个通用术语。在编译过程中，代码被从原始源码（ASCII文本）转换为各种IR。在Rust中，这些主要是HIR、MIR和LLVM IR。每种IR都适合于某些计算集。例如，MIR非常适用于借用检查器，LLVM IR非常适用于codegen，因为LLVM接受它。</td></tr>
<tr><td><span id="irlo">IRLO</span>                     </td><td><span id="irlo">IRLO</span>                     </td><td><code>IRLO</code>或<code>irlo</code>有时被用作<a href="https://internals.rust-lang.org">internals.rust-lang.org</a>的缩写。</td></tr>
<tr><td><span id="item">item</span>                     </td><td><span id="item">语法项</span>                     </td><td>语言中的一种 &quot;定义&quot;，如静态、常量、使用语句、模块、结构等。具体来说，这对应于 &quot;item&quot;类型。</td></tr>
<tr><td><span id="lang-item">lang item</span>           </td><td><span id="lang-item">语言项</span>           </td><td>代表语言本身固有的概念的项目，如特殊的内置特质，如<code>同步</code>和<code>发送</code>；或代表操作的特质，如<code>添加</code>；或由编译器调用的函数。</td></tr>
<tr><td><span id="lbl">late-bound lifetime</span>       </td><td><span id="lbl">晚绑定生存期</span>       </td><td>一个在其调用位置被替换的生存期区域。绑定在HRTB中，由编译器中的特定函数替代，如<code>liberate_late_bound_regions</code>。与<strong>早绑定的生存期</strong>形成对比。</td></tr>
<tr><td><span id="local-crate">local crate</span>       </td><td><span id="local-crate">本地crate</span>       </td><td>目前正在编译的crate。这与 &quot;上游crate&quot;相反，后者指的是本地crate的依赖关系。</td></tr>
<tr><td><span id="lto">LTO</span>                       </td><td><span id="lto">LTO</span>                       </td><td>链接时优化（Link-Time Optimizations）的简称，这是LLVM提供的一套优化，在最终二进制文件被链接之前进行。这些优化包括删除最终程序中从未使用的函数，例如。_<a href="https://clang.llvm.org/docs/ThinLTO.html">ThinLTO</a>_是LTO的一个变种，旨在提高可扩展性和效率，但可能牺牲了一些优化。</td></tr>
<tr><td><span id="llvm">LLVM</span>                   </td><td><span id="llvm">LLVM</span>                   </td><td>(实际上不是一个缩写 :P) 一个开源的编译器后端。它接受LLVM IR并输出本地二进制文件。然后，各种语言（例如Rust）可以实现一个编译器前端，输出LLVM IR，并使用LLVM编译到所有LLVM支持的平台。</td></tr>
<tr><td><span id="memoization">memoization</span>       </td><td><span id="memoization">memoization</span>       </td><td>储存（纯）计算结果（如纯函数调用）的过程，以避免在未来重复计算。这通常是执行速度和内存使用之间的权衡。</td></tr>
<tr><td><span id="mir">MIR</span>                       </td><td><span id="mir">中级中间语言</span>                       </td><td>在类型检查后创建的中级中间语言，供borrowck和codegen使用。</td></tr>
<tr><td><span id="miri">miri</span>                     </td><td><span id="miri">mir解释器</span>                     </td><td>MIR的一个解释器，用于常量计算。</td></tr>
<tr><td><span id="mono">monomorphization</span>         </td><td><span id="mono">单态化</span>         </td><td>采取类型和函数的通用实现并将其与具体类型实例化的过程。例如，在代码中可能有<code>Vec&lt;T&gt;</code>，但在最终的可执行文件中，将为程序中使用的每个具体类型有一个<code>Vec</code>代码的副本（例如，<code>Vec&lt;usize&gt;</code>的副本，<code>Vec&lt;MyStruct&gt;</code>的副本，等等）。</td></tr>
<tr><td><span id="normalize">normalize</span>           </td><td><span id="normalize">归一化</span>           </td><td>转换为更标准的形式的一般术语，但在rustc的情况下，通常指的是关联类型归一化。</td></tr>
<tr><td><span id="newtype">newtype</span>               </td><td><span id="newtype">newtype</span>               </td><td>对其他类型的封装（例如，<code>struct Foo(T)</code>是<code>T</code>的一个 &quot;新类型&quot;）。这在Rust中通常被用来为索引提供一个更强大的类型。</td></tr>
<tr><td><span id="niche">niche</span>                   </td><td><span id="niche">利基</span>                   </td><td>一个类型的无效位模式<em>可用于</em>布局优化。有些类型不能有某些位模式。例如，&quot;非零*&quot;整数或引用&quot;&amp;T &quot;不能用0比特串表示。这意味着编译器可以通过利用无效的 &quot;利基值 &quot;来进行布局优化。这方面的一个应用实例是<a href="https://rust-lang.github.io/unsafe-code-guidelines/layout/enums.html#discriminant-elision-on-option-like-enums"><em>Discriminant elision on <code>Option</code>-like enums</em></a>，它允许使用一个类型的niche作为一个<code>enum</code>的<a href="safe-guides/Appendix/terms.html#tag">&quot;标签&quot;</a>，而不需要一个单独的字段。</td></tr>
<tr><td><span id="nll">NLL</span>                       </td><td><span id="nll">NLL</span>                       </td><td>这是非词法作用域生存期的简称，它是对Rust的借用系统的扩展，使其基于控制流图。</td></tr>
<tr><td><span id="node-id">node-id or NodeId</span>     </td><td><span id="node-id">node-id or NodeId</span>     </td><td>识别AST或HIR中特定节点的索引；逐渐被淘汰，被<code>HirId</code>取代。</td></tr>
<tr><td><span id="obligation">obligation</span>         </td><td><span id="obligation">obligation</span>         </td><td>必须由特质系统证明的东西。</td></tr>
<tr><td><span id="placeholder">placeholder</span>       </td><td><span id="placeholder">placeholder</span>       </td><td><strong>注意：skolemization被placeholder废弃</strong>一种处理围绕 &quot;for-all &quot;类型的子类型的方法（例如，<code>for&lt;'a&gt; fn(&amp;'a u32)</code>），以及解决更高等级的trait边界（例如，<code>for&lt;'a&gt; T: Trait&lt;'a&gt;</code>）。</td></tr>
<tr><td><span id="point">point</span>                   </td><td><span id="point">point</span>                   </td><td>在NLL分析中用来指代MIR中的某个特定位置；通常用来指代控制流图中的一个节点。</td></tr>
<tr><td><span id="polymorphize">polymorphize</span>     </td><td><span id="polymorphize">多态化</span>     </td><td>一种避免不必要的单态化的优化。</td></tr>
<tr><td><span id="projection">projection</span>         </td><td><span id="projection">投影</span>         </td><td>一个 &quot;相对路径 &quot;的一般术语，例如，<code>x.f</code>是一个 &quot;字段投影&quot;，而<code>T::Item</code>是一个&quot;关联类型投影&quot;</td></tr>
<tr><td><span id="pc">promoted constants</span>         </td><td><span id="pc">常量提升</span>         </td><td>从函数中提取的常量，并提升到静态范围</td></tr>
<tr><td><span id="provider">provider</span>             </td><td><span id="provider">provider</span>             </td><td>执行查询的函数。</td></tr>
<tr><td><span id="quantified">quantified</span>         </td><td><span id="quantified">量化</span>         </td><td>在数学或逻辑学中，存在量词和普遍量词被用来提出诸如 &quot;是否有任何类型的T是真的？&quot;或 &quot;这对所有类型的T都是真的吗？&quot;这样的问题</td></tr>
<tr><td><span id="query">query</span>                   </td><td><span id="query">查询</span>                   </td><td>编译过程中的一个子计算。查询结果可以缓存在当前会话中，也可以缓存到磁盘上，用于增量编译。</td></tr>
<tr><td><span id="recovery">recovery</span>             </td><td><span id="recovery">恢复</span>             </td><td>恢复是指在解析过程中处理无效的语法（例如，缺少逗号），并继续解析AST。这可以避免向用户显示虚假的错误（例如，当结构定义包含错误时，显示 &quot;缺少字段 &quot;的错误）。</td></tr>
<tr><td><span id="region">region</span>                 </td><td><span id="region">区域</span>                 </td><td>和生存期精彩使用的另一个术语。</td></tr>
<tr><td><span id="rib">rib</span>                       </td><td><span id="rib">rib</span>                       </td><td>名称解析器中的一个数据结构，用于跟踪名称的单一范围。</td></tr>
<tr><td><span id="scrutinee">scrutinee</div>            </td><td><span id="scrutinee">审查对象</div>            </td><td>审查对象是在<code>match</code>表达式和类似模式匹配结构中被匹配的表达式。例如，在<code>match x { A =&gt; 1, B =&gt; 2 }</code>中，表达式<code>x</code>是被审查者。</td></tr>
<tr><td><span id="sess">sess</span>                     </td><td><span id="sess">sess</span>                     </td><td>编译器会话，它存储了整个编译过程中使用的全局数据</td></tr>
<tr><td><span id="side-tables">side tables</span>       </td><td><span id="side-tables">side tables</span>       </td><td>由于AST和HIR一旦创建就不可改变，我们经常以哈希表的形式携带关于它们的额外信息，并以特定节点的ID为索引。</td></tr>
<tr><td><span id="sigil">sigil</span>                   </td><td><span id="sigil">符号</span>                   </td><td>就像一个关键词，但完全由非字母数字的标记组成。例如，<code>&amp;</code>是引用的标志。</td></tr>
<tr><td><span id="soundness">soundness</span>           </td><td><span id="soundness">健全性</span>           </td><td>类型理论中的一个技术术语。粗略的说，如果一个类型系统是健全的，那么一个进行类型检查的程序就是类型安全的。也就是说，人们永远不可能（在安全的Rust中）把一个值强加到一个错误类型的变量中。</td></tr>
<tr><td><span id="span">span</span>                     </td><td><span id="span">span</span>                     </td><td>用户的源代码中的一个位置，主要用于错误报告。这就像一个文件名/行号/列的立体元组：它们携带一个开始/结束点，也跟踪宏的扩展和编译器去糖。所有这些都被装在几个字节里（实际上，它是一个表的索引）。</td></tr>
<tr><td><span id="substs">substs</span>                 </td><td><span id="substs">替换</span>                 </td><td>给定的通用类型或项目的替换（例如，<code>HashMap&lt;i32, u32&gt;</code>中的<code>i32'、</code>u32'）。</td></tr>
<tr><td><span id="sysroot">sysroot</span>               </td><td><span id="sysroot">sysroot</span>               </td><td>用于编译器在运行时加载的构建工件的目录。</td></tr>
<tr><td><span id="tag">tag</span>                       </td><td><span id="tag">tag</span>                       </td><td>枚举/生成器的 &quot;标签 &quot;编码激活变体/状态的判别式(discriminant)。 标签可以是 &quot;直接的&quot;（简单地将判别式存储在一个字段中）或使用&quot;利基&quot;。</td></tr>
<tr><td><span id="tcx">tcx</span>                       </td><td><span id="tcx">tcx</span>                       </td><td>&quot;类型化上下文&quot;（<code>TyCtxt</code>），编译器的主要数据结构。</td></tr>
<tr><td><span id="lifetime-tcx">'tcx</span>           </td><td><span id="lifetime-tcx">'tcx</span>           </td><td><code>TyCtxt'所使用的分配区域的生存期。在编译过程中，大多数数据都会使用这个生存期，但HIR数据除外，它使用</code>'hir`生存期。</td></tr>
<tr><td><span id="token">token</span>                   </td><td><span id="token">词条</span>                   </td><td>解析的最小单位。词条是在词法运算后产生的</td></tr>
<tr><td><span id="tls">TLS</span>                     </td><td><span id="tls">TLS</span>                     </td><td>线程本地存储。变量可以被定义为每个线程都有自己的副本（而不是所有线程都共享该变量）。这与LLVM有一些相互作用。并非所有平台都支持TLS。</td></tr>
<tr><td><span id="trait-ref">trait reference</span>     </td><td><span id="trait-ref">trait 引用</span>     </td><td>一个特质的名称，以及一组合适的输入类型/生存期。</td></tr>
<tr><td><span id="trans">trans</span>                   </td><td><span id="trans">trans</span>                   </td><td>是 &quot;转译&quot;的简称，是将MIR转译成LLVM IR的代码。已经重命名为codegen。</td></tr>
<tr><td><span id="ty">Ty</span>                       </td><td><span id="ty">Ty</span>                       </td><td>一个类型的内部表示。</td></tr>
<tr><td><span id="tyctxt">TyCtxt</span>                 </td><td><span id="tyctxt">TyCtxt</span>                 </td><td>在代码中经常被称为tcx的数据结构，它提供对会话数据和查询系统的访问。</td></tr>
<tr><td><span id="ufcs">UFCS</span>                     </td><td><span id="ufcs">UFCS</span>                     </td><td>通用函数调用语法（Universal Function Call Syntax）的简称，这是一种调用方法的明确语法。</td></tr>
<tr><td><span id="ut">uninhabited type</span>           </td><td><span id="ut">孤类型</span>           </td><td>一个没有值的类型。这与ZST不同，ZST正好有一个值。一个孤类型的例子是<code>enum Foo {}</code>，它没有变体，所以，永远不能被创建。编译器可以将处理孤类型的代码视为死代码，因为没有这样的值可以操作。<code>！</code>（从未出现过的类型）是一个孤类型。孤类型也被称为 &quot;空类型&quot;。</td></tr>
<tr><td><span id="upvar">upvar</span>                   </td><td><span id="upvar">upvar</span>                   </td><td>一个闭合体从闭合体外部捕获的变量</td></tr>
<tr><td><span id="variance">variance</span>             </td><td><span id="variance">型变</span>             </td><td>确定通用类型/寿命参数的变化如何影响子类型；例如，如果<code>T</code>是<code>U</code>的子类型，那么<code>Vec&lt;T&gt;</code>是<code>Vec&lt;U&gt;</code>的子类型，因为<code>Vec</code>在其通用参数中是协变的。</td></tr>
<tr><td><span id="variant-idx">variant index</span>     </td><td><span id="variant-idx">变体索引</span>     </td><td>在一个枚举中，通过给它们分配从0开始的索引来识别一个变体。这纯粹是内部的，不要与&quot;判别式&quot;相混淆，后者可以被用户覆盖（例如，<code>enum Bool { True = 42, False = 0 }</code>）。</td></tr>
<tr><td><span id="wide-ptr">wide pointer</span>         </td><td><span id="wide-ptr">宽指针</span>         </td><td>一个带有额外元数据的指针。</td></tr>
<tr><td><span id="zst">ZST</span>                       </td><td><span id="zst">ZST</span>                       </td><td>零大小类型。这种类型，其值的大小为0字节。由于<code>2^0 = 1</code>，这种类型正好有一个值。例如，<code>()</code>（单位）是一个ZST。<code>struct Foo;</code>也是一个ZST。编译器可以围绕ZST做一些很好的优化。</td></tr>
</tbody></table>
<p><strong>参考</strong></p>
<p><a href="https://rustcrustc.github.io/rustc-dev-guide-zh/appendix/glossary.html">Rust 编译器内部术语中英文对照表</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="d模版"><a class="header" href="#d模版">D.模版</a></h1>
<p>这里记录一些 rustfmt 和 clippy 等相关工具等配置文件模版。</p>
<ul>
<li><a href="safe-guides/Appendix/templates/./rustfmt.toml.html">rustfmt</a></li>
<li><a href="safe-guides/Appendix/templates/./clippy.toml.html">clippy</a></li>
<li><a href="safe-guides/Appendix/templates/./deny.toml.html">deny</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustfmt-模板"><a class="header" href="#rustfmt-模板">Rustfmt 模板</a></h1>
<p>为了方便 Rust 开发者，这里提供一个 Rustfmt 的模板，以供参考。</p>
<p>以下内容可以放到 <code>rustfmt.toml</code> 或 <code>.rustfmt.toml</code> 文件中。因为部分选项还未稳定，所以要使用 <code>cargo +nightly fmt</code> 执行。</p>
<p>很多选项都是默认的，无需配置。以下配置的都不是默认值。</p>
<pre><code class="language-toml"># 万一你要使用 rustfmt 2.0 就需要指定这个·
version = &quot;Two&quot;

# 统一管理宽度设置，但不包含 comment_width
use_small_heuristics=&quot;MAX&quot;
# 使多个标识符定义保持对齐风格，代码看上去可以非常工整
indent_style=&quot;Visual&quot; 
# 设置让自定义具有判别式的枚举体按等号对齐的宽度
enum_discrim_align_threshold = 10 
# 在match分支中，如果包含了块，也需要加逗号以示分隔
match_block_trailing_comma=true
# 自动将同一个 crate 的模块导入合并到一起
imports_granularity=&quot;Crate&quot; 
# StdExternalCrate 导入模块分组规则
# 1. 导入来自 std、core 和 alloc 的模块需要置于前面一组。
# 2. 导入来自 第三方库的模块 应该置于中间一组。
# 3. 导入来自本地 self、super和crate前缀的模块，置于后面一组。
group_imports=&quot;StdExternalCrate&quot; 
# format_macro_matchers 规则说明：
# 声明宏 模式匹配分支（=&gt; 左侧）中要使用紧凑格式
# 默认声明宏分支代码体（=&gt; 右侧） 使用宽松格式
format_macro_matchers=true 
# 当使用 extern 指定外部函数时，不需要显式指定 C-ABI ，默认就是 C-ABI
force_explicit_abi=false 
# 指定一行注释允许的最大宽度
comment_width=100
# wrap_comments 配合 comment_width 使用，自动将一行超过宽带限制的注释切分为多行注释
wrap_comments=true
# 将 /**/ 注释转为 //
normalize_comments=true
# 会报告注释中的 FIXIME
report_fixme=&quot;Unnumbered&quot;
# 元组模式匹配的时候允许使用 `..` 来匹配剩余元素
condense_wildcard_suffixes=true
# 如果项目只在 Unix 平台下跑，可以设置该项为 Unix，表示换行符只依赖 Unix
newline_style=&quot;Unix&quot;
# 不要将多个 Derive 宏合并为同一行
merge_derives = false

# 指定 fmt 忽略的目录
ignore = [
     &quot;src/test&quot;,
     &quot;test&quot;,
     &quot;docs&quot;,
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clippy-模板"><a class="header" href="#clippy-模板">Clippy 模板</a></h1>
<p>有些 Clippy 的 Lint，依赖于一些配置项，如果不想要默认值，可以在 <code>clippy.toml</code> 中进行设置。</p>
<pre><code class="language-toml"># for `disallowed_method`:
# https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_method
disallowed-methods = []

# 函数参数最长不要超过5个
too-many-arguments-threshold=5
</code></pre>
<h2 id="clippy-lint-配置模板"><a class="header" href="#clippy-lint-配置模板">Clippy lint 配置模板</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 参考： https://github.com/serde-rs/serde/blob/master/serde/src/lib.rs
#![allow(unknown_lints, bare_trait_objects, deprecated)]
#![cfg_attr(feature = &quot;cargo-clippy&quot;, allow(renamed_and_removed_lints))]
#![cfg_attr(feature = &quot;cargo-clippy&quot;, deny(clippy, clippy_pedantic))]
// Ignored clippy and clippy_pedantic lints
#![cfg_attr(
    feature = &quot;cargo-clippy&quot;,
    allow(
        // clippy bug: https://github.com/rust-lang/rust-clippy/issues/5704
        unnested_or_patterns,
        // clippy bug: https://github.com/rust-lang/rust-clippy/issues/7768
        semicolon_if_nothing_returned,
        // not available in our oldest supported compiler
        checked_conversions,
        empty_enum,
        redundant_field_names,
        redundant_static_lifetimes,
        // integer and float ser/de requires these sorts of casts
        cast_possible_truncation,
        cast_possible_wrap,
        cast_sign_loss,
        // things are often more readable this way
        cast_lossless,
        module_name_repetitions,
        option_if_let_else,
        single_match_else,
        type_complexity,
        use_self,
        zero_prefixed_literal,
        // correctly used
        enum_glob_use,
        let_underscore_drop,
        map_err_ignore,
        result_unit_err,
        wildcard_imports,
        // not practical
        needless_pass_by_value,
        similar_names,
        too_many_lines,
        // preference
        doc_markdown,
        unseparated_literal_suffix,
        // false positive
        needless_doctest_main,
        // noisy
        missing_errors_doc,
        must_use_candidate,
    )
)]
// Rustc lints.
#![deny(missing_docs, unused_imports)]
<span class="boring">}
</span></code></pre></pre>
<h2 id="embark-studios-的标准-lint-配置"><a class="header" href="#embark-studios-的标准-lint-配置">Embark Studios 的标准 Lint 配置</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BEGIN - Embark standard lints v5 for Rust 1.55+
// do not change or add/remove here, but one can add exceptions after this section
// for more info see: &lt;https://github.com/EmbarkStudios/rust-ecosystem/issues/59&gt;
#![deny(unsafe_code)]
#![warn(
    clippy::all,
    clippy::await_holding_lock,
    clippy::char_lit_as_u8,
    clippy::checked_conversions,
    clippy::dbg_macro,
    clippy::debug_assert_with_mut_call,
    clippy::disallowed_method,
    clippy::disallowed_type,
    clippy::doc_markdown,
    clippy::empty_enum,
    clippy::enum_glob_use,
    clippy::exit,
    clippy::expl_impl_clone_on_copy,
    clippy::explicit_deref_methods,
    clippy::explicit_into_iter_loop,
    clippy::fallible_impl_from,
    clippy::filter_map_next,
    clippy::flat_map_option,
    clippy::float_cmp_const,
    clippy::fn_params_excessive_bools,
    clippy::from_iter_instead_of_collect,
    clippy::if_let_mutex,
    clippy::implicit_clone,
    clippy::imprecise_flops,
    clippy::inefficient_to_string,
    clippy::invalid_upcast_comparisons,
    clippy::large_digit_groups,
    clippy::large_stack_arrays,
    clippy::large_types_passed_by_value,
    clippy::let_unit_value,
    clippy::linkedlist,
    clippy::lossy_float_literal,
    clippy::macro_use_imports,
    clippy::manual_ok_or,
    clippy::map_err_ignore,
    clippy::map_flatten,
    clippy::map_unwrap_or,
    clippy::match_on_vec_items,
    clippy::match_same_arms,
    clippy::match_wild_err_arm,
    clippy::match_wildcard_for_single_variants,
    clippy::mem_forget,
    clippy::mismatched_target_os,
    clippy::missing_enforced_import_renames,
    clippy::mut_mut,
    clippy::mutex_integer,
    clippy::needless_borrow,
    clippy::needless_continue,
    clippy::needless_for_each,
    clippy::option_option,
    clippy::path_buf_push_overwrite,
    clippy::ptr_as_ptr,
    clippy::rc_mutex,
    clippy::ref_option_ref,
    clippy::rest_pat_in_fully_bound_structs,
    clippy::same_functions_in_if_condition,
    clippy::semicolon_if_nothing_returned,
    clippy::single_match_else,
    clippy::string_add_assign,
    clippy::string_add,
    clippy::string_lit_as_bytes,
    clippy::string_to_string,
    clippy::todo,
    clippy::trait_duplication_in_bounds,
    clippy::unimplemented,
    clippy::unnested_or_patterns,
    clippy::unused_self,
    clippy::useless_transmute,
    clippy::verbose_file_reads,
    clippy::zero_sized_map_values,
    future_incompatible,
    nonstandard_style,
    rust_2018_idioms
)]
// END - Embark standard lints v0.5 for Rust 1.55+
// crate-specific exceptions:
#![allow()]

<span class="boring">}
</span></code></pre></pre>
<h2 id="clippy-配置的相关问题"><a class="header" href="#clippy-配置的相关问题">Clippy 配置的相关问题</a></h2>
<p>目前 Clippy 不支持配置文件来配置Lint ，目前 像 Embark 公司有两种解决方法：</p>
<ol>
<li>将 lint 放到一个<a href="https://github.com/EmbarkStudios/rust-ecosystem/blob/main/lints.rs">统一文件</a>中，然后复制粘贴到使用的地方。</li>
<li>通过 <code>.cargo/config.toml</code> 来配置 <code>rustflags</code>  ，参考： <a href="https://github.com/EmbarkStudios/rust-ecosystem/blob/main/lints.toml">lints.toml</a> </li>
</ol>
<p>Embark 也在跟踪和推动在 Cargo 中支持 Lint 配置的功能，相关 issues：</p>
<ul>
<li><a href="https://github.com/EmbarkStudios/rust-ecosystem/issues/22">Be able to disable/enable Clippy lints globally</a></li>
<li><a href="https://github.com/rust-lang/cargo/issues/5034">Support defining enabled and disabled lints in a configuration file</a></li>
<li><a href="https://github.com/rust-lang/rust-clippy/issues/6625">[Roadmap] Configuration file for lints</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-deny-配置模板"><a class="header" href="#cargo-deny-配置模板">Cargo Deny 配置模板</a></h1>
<p><a href="https://github.com/EmbarkStudios/cargo-deny">cargo-deny</a>  是检查 Cargo 依赖的一个 Lint 工具。它检查的范围包括：</p>
<ul>
<li>Licenses，检查依赖crate许可证是否合规。</li>
<li>Bans， 检查被禁止使用的依赖 crate。</li>
<li>Advisories ，检查有安全缺陷漏洞或停止维护的 依赖 crate。</li>
<li>Source，检查依赖crate 的来源，确保只来自于可信任的来源。</li>
</ul>
<p>以下是模板（参考 <a href="https://github.com/vectordotdev/vector/blob/master/deny.toml">vectordotdev/vector  的 deny.toml</a>）：</p>
<pre><code class="language-toml">[licenses]
allow = [
  &quot;MIT&quot;,
  &quot;CC0-1.0&quot;,
  &quot;ISC&quot;,
  &quot;OpenSSL&quot;,
  &quot;Unlicense&quot;,
  &quot;BSD-2-Clause&quot;,
  &quot;BSD-3-Clause&quot;,
  &quot;Apache-2.0&quot;,
  &quot;Apache-2.0 WITH LLVM-exception&quot;,
  &quot;Zlib&quot;,
]

unlicensed = &quot;warn&quot;
default = &quot;warn&quot;

private = { ignore = true }

[[licenses.clarify]]
name = &quot;ring&quot;
version = &quot;*&quot;
expression = &quot;MIT AND ISC AND OpenSSL&quot;
license-files = [
    { path = &quot;LICENSE&quot;, hash = 0xbd0eed23 }
]

[advisories]
ignore = [
    # term is looking for a new maintainer
    # https://github.com/timberio/vector/issues/6225
    &quot;RUSTSEC-2018-0015&quot;,

    # `net2` crate has been deprecated; use `socket2` instead
    # https://github.com/timberio/vector/issues/5582
    &quot;RUSTSEC-2020-0016&quot;,

    # Type confusion if __private_get_type_id__ is overriden
    # https://github.com/timberio/vector/issues/5583
    &quot;RUSTSEC-2020-0036&quot;,

    # stdweb is unmaintained
    # https://github.com/timberio/vector/issues/5585
    &quot;RUSTSEC-2020-0056&quot;,
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="e工具链"><a class="header" href="#e工具链">E.工具链</a></h1>
<p>这里介绍一些检测工具，比如 Cargo fmt 和 Cargo Clippy.</p>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ol>
<li><a href="https://doc.rust-lang.org/rustc/lints/groups.html">https://doc.rust-lang.org/rustc/lints/groups.html</a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html">https://rust-lang.github.io/rust-clippy/master/index.html</a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html">https://rust-lang.github.io/rust-clippy/master/index.html</a></li>
<li><a href="https://github.com/dtolnay/noisy-clippy">Dtolnay 对 crates.io 中 clippy lint 应用统计</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustfmt-配置相关说明"><a class="header" href="#rustfmt-配置相关说明">Rustfmt 配置相关说明</a></h1>
<h2 id="在-stable-rust-下使用未稳定配置项的方法"><a class="header" href="#在-stable-rust-下使用未稳定配置项的方法">在 Stable Rust 下使用未稳定配置项的方法</a></h2>
<ol>
<li>CI Job 可以分为 <code>Stable</code> 和 <code>Nightly</code>。在 <code>Stable CI</code> 下进行编译，在<code>Nightly CI</code>下执行<code>cargo fmt</code> 和 <code>cargo clippy</code>。</li>
<li>在项目本地可以使用 <code>cargo +nightly fmt</code> 代替 <code>cargo fmt</code>。</li>
</ol>
<p>注意： 一定要在文件保存之后再运行 rustfmt`，否则容易出错。</p>
<h2 id="真实项目中的配置案例"><a class="header" href="#真实项目中的配置案例">真实项目中的配置案例</a></h2>
<ol>
<li>来自 <a href="https://github.com/rust-lang/rust/blob/master/rustfmt.toml">Rust 语言自身项目</a>。</li>
</ol>
<pre><code class="language-toml"># Run rustfmt with this config (it should be picked up automatically).
version = &quot;Two&quot;
use_small_heuristics = &quot;Max&quot;
merge_derives = false

# by default we ignore everything in the repository
# tidy only checks files which are not ignored, each entry follows gitignore style
ignore = [
    &quot;/build/&quot;,
    &quot;/*-build/&quot;,
    &quot;/build-*/&quot;,
    &quot;/vendor/&quot;,

    # tests for now are not formatted, as they are sometimes pretty-printing constrained
    # (and generally rustfmt can move around comments in UI-testing incompatible ways)
    &quot;src/test&quot;,

    # do not format submodules
    &quot;library/backtrace&quot;,
    &quot;library/stdarch&quot;,
    &quot;compiler/rustc_codegen_cranelift&quot;,
    &quot;src/doc/book&quot;,
    &quot;src/doc/edition-guide&quot;,
    &quot;src/doc/embedded-book&quot;,
    &quot;src/doc/nomicon&quot;,
    &quot;src/doc/reference&quot;,
    &quot;src/doc/rust-by-example&quot;,
    &quot;src/doc/rustc-dev-guide&quot;,
    &quot;src/llvm-project&quot;,
    &quot;src/tools/cargo&quot;,
    &quot;src/tools/clippy&quot;,
    &quot;src/tools/miri&quot;,
    &quot;src/tools/rls&quot;,
    &quot;src/tools/rust-analyzer&quot;,
    &quot;src/tools/rustfmt&quot;,
    &quot;src/tools/rust-installer&quot;,
]

</code></pre>
<ol>
<li>来自 <a href="https://cs.opensource.google/fuchsia/fuchsia/+/main:rustfmt.toml">Google Fuchsia 操作系统</a>。</li>
</ol>
<pre><code class="language-toml"># Fuchsia Format Style
# last reviewed: Jan 29, 2019

# Fuchsia uses 2018 edition only
edition = &quot;2018&quot;

# The &quot;Default&quot; setting has a heuristic which splits lines too aggresively.
# We are willing to revisit this setting in future versions of rustfmt.
# Bugs:
#   * https://github.com/rust-lang/rustfmt/issues/3119
#   * https://github.com/rust-lang/rustfmt/issues/3120
use_small_heuristics = &quot;Max&quot;

# Prevent carriage returns
newline_style = &quot;Unix&quot;
</code></pre>
<ol start="2">
<li>来自 <a href="https://github.com/tikv/tikv/blob/master/rustfmt.toml">Tikv</a> 。</li>
</ol>
<pre><code class="language-toml">version = &quot;Two&quot;
unstable_features = true

condense_wildcard_suffixes = true
license_template_path = &quot;etc/license.template&quot;
newline_style = &quot;Unix&quot;
use_field_init_shorthand = true
use_try_shorthand = true
</code></pre>
<pre><code class="language-toml">
edition = &quot;2018&quot;
newline_style = &quot;unix&quot;
# comments
normalize_comments=true
wrap_comments=true
# imports 
imports_granularity=&quot;Crate&quot;
group_imports=&quot;StdExternalCrate&quot;

</code></pre>
<h2 id="一些全局配置项"><a class="header" href="#一些全局配置项">一些全局配置项</a></h2>
<h3 id="rustfml-格式化版本"><a class="header" href="#rustfml-格式化版本">rustfml 格式化版本</a></h3>
<p>【描述】</p>
<p><code>Version::One</code> 向后兼容 Rustfmt 1.0。 其他版本仅在主要版本号内向后兼容。目前 <code>version</code> 可选值只有 <code>One</code> 和 <code>Two</code>。</p>
<p>【对应配置项】</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#version"><code>version</code></a></td><td>One（默认）</td><td>No</td><td>指定 rustfmlt 格式化版本</td></tr>
</tbody></table>
<p>【示例】</p>
<pre><code class="language-toml"># Run rustfmt with this config (it should be picked up automatically).
version = &quot;Two&quot;
</code></pre>
<h3 id="指定文件或目录跳过格式化"><a class="header" href="#指定文件或目录跳过格式化">指定文件或目录跳过格式化</a></h3>
<p>【描述】</p>
<p>跳过与指定模式匹配的格式化文件和目录。 模式格式与 <code>.gitignore</code> 相同。 一定要使用 <code>Unix/forwardslash/style</code> 路径，此路径样式适用于所有平台。 不支持带有反斜杠 <code>\</code> 的 Windows 样式路径。</p>
<p>【对应配置项】</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#ignore"><code>ignore</code></a></td><td>格式化每一个Rust文件（默认）</td><td>No</td><td>指定文件或目录跳过格式化</td></tr>
</tbody></table>
<p>【示例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 跳过指定文件
ignore = [
    &quot;src/types.rs&quot;,
    &quot;src/foo/bar.rs&quot;,
]
// 跳过指定目录
ignore = [
    &quot;examples&quot;,
]
// 跳过项目内所有文件
ignore = [&quot;/&quot;]
<span class="boring">}
</span></code></pre></pre>
<h3 id="禁用格式化"><a class="header" href="#禁用格式化">禁用格式化</a></h3>
<p>【描述】</p>
<p>可以通过 <code>disable_all_formatting=true</code> 配置来禁用格式化。默认是开启的。</p>
<p>【对应配置项】</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#disable_all_formatting"><code>disable_all_formatting</code></a></td><td>false（默认）</td><td>No</td><td>禁止格式化</td></tr>
</tbody></table>
<h3 id="配置-edition-版次"><a class="header" href="#配置-edition-版次">配置 edition 版次</a></h3>
<p>【描述】</p>
<p>如果通过 Cargo 的格式化工具 cargo fmt 执行，Rustfmt 能够通过读取 Cargo.toml 文件来获取使用的版本。 否则，需要在配置文件中指定版本。</p>
<p>【对应配置项】</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#edition"><code>edition</code></a></td><td>2015（默认）</td><td>No</td><td>配置 edition 版次</td></tr>
</tbody></table>
<p>【示例】</p>
<pre><code class="language-toml">edition = &quot;2018&quot;
</code></pre>
<h3 id="开启未稳定特性"><a class="header" href="#开启未稳定特性">开启未稳定特性</a></h3>
<p>【描述】</p>
<p>默认未启用，但是可以通过配置此功能在 Nightly 上启用此功能。</p>
<p>【对应配置项】</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#unstable_features"><code>unstable_features</code></a></td><td>false（默认）</td><td>No</td><td>开启未稳定特性</td></tr>
</tbody></table>
<h2 id="每行最大宽度为-100-个字符"><a class="header" href="#每行最大宽度为-100-个字符">每行最大宽度为 100 个字符</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>代码行宽不宜过长，否则不利于阅读。
建议每行字符数不要超过 100 个字符。</p>
<p><code>rustfmt</code> 还提供很多其他宽度设置：</p>
<ul>
<li>fn_call_width, 函数调用最大宽度设置，其默认值是 <code>max_width</code>的 <code>60%</code>。</li>
<li>attr_fn_like_width, 像函数那样使用的属性宏最大宽度，其默认值是 <code>max_width</code>的 <code>70%</code>。</li>
<li>struct_lit_width,  结构体字面量最大宽度，其默认值是 <code>max_width</code>的 <code>18%</code>。</li>
<li>struct_variant_width, 结构体变量最大宽度，其默认值是 <code>max_width</code>的 <code>35%</code>。</li>
<li>array_width, 数组最大宽度，其默认值是 <code>max_width</code>的 <code>60%</code>。</li>
<li>chain_width, 链式结构最大宽度，其默认值是 <code>max_width</code>的 <code>60%</code>。</li>
<li>single_line_if_else_max_width，单行 <code>if-else</code> 最大宽度，其默认值是 <code>max_width</code>的 <code>50%</code>。</li>
</ul>
<p>这么多宽度设置管理起来比较麻烦，所以使用 <code>use_small_heuristics</code> 来管理更好。</p>
<p><strong>【反例】</strong></p>
<p>当<code>use_small_heuristics</code> 配置为 <code>Off</code> :</p>
<pre><pre class="playground"><code class="language-rust">enum Lorem {
    Ipsum,
    Dolor(bool),
    Sit {
        amet: Consectetur,
        adipiscing: Elit,
    },
}

fn main() {
    lorem(&quot;lorem&quot;, &quot;ipsum&quot;, &quot;dolor&quot;, &quot;sit&quot;, &quot;amet&quot;, &quot;consectetur&quot;, &quot;adipiscing&quot;);

    let lorem = Lorem {
        ipsum: dolor,
        sit: amet,
    };

    let lorem = if ipsum {
        dolor
    } else {
        sit
    };
}
</code></pre></pre>
<p>当<code>use_small_heuristics</code> 配置为 <code>Max</code> :</p>
<pre><pre class="playground"><code class="language-rust">enum Lorem {
    Ipsum,
    Dolor(bool),
    Sit { amet: Consectetur, adipiscing: Elit },
}

fn main() {
    lorem(&quot;lorem&quot;, &quot;ipsum&quot;, &quot;dolor&quot;, &quot;sit&quot;, &quot;amet&quot;, &quot;consectetur&quot;, &quot;adipiscing&quot;);

    let lorem = Lorem { ipsum: dolor, sit: amet };

    let lorem = if ipsum { dolor } else { sit };
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<p><code>use_small_heuristics</code> 默认配置示例。</p>
<pre><pre class="playground"><code class="language-rust">enum Lorem {
    Ipsum,
    Dolor(bool),
    Sit { amet: Consectetur, adipiscing: Elit },
}

fn main() {
    lorem(
        &quot;lorem&quot;,
        &quot;ipsum&quot;,
        &quot;dolor&quot;,
        &quot;sit&quot;,
        &quot;amet&quot;,
        &quot;consectetur&quot;,
        &quot;adipiscing&quot;,
    );

    let lorem = Lorem {
        ipsum: dolor,
        sit: amet,
    };
    let lorem = Lorem { ipsum: dolor };

    let lorem = if ipsum { dolor } else { sit };
}
</code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#max_width"><code>max_width</code></a></td><td>100</td><td>yes（默认）</td><td>行最大宽度默认值</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#error_on_line_overflow"><code>error_on_line_overflow</code></a></td><td>false（默认）</td><td>No (tracking issue: #3391)</td><td>如果超过最大行宽设置则报错</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#use_small_heuristics"><code>use_small_heuristics</code></a></td><td>Default（默认）Max（推荐）</td><td>Yes</td><td>统一管理宽度设置</td></tr>
</tbody></table>
<h2 id="单行规则"><a class="header" href="#单行规则">单行规则</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>当语言项内容为空时，即空函数，空结构体，空实现等，要保持单独一行。但是，当函数中只有一个表达式时，请不要保持单行。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn lorem() {
}

impl Lorem {
}

fn lorem() -&gt; usize { 42 }

fn main() {
    let lorem = Lorem {
        foo: bar,
        baz: ofo,
    };
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn lorem() {}

impl Lorem {}

fn lorem() -&gt; usize {
    42
}

fn main() {
    let lorem = Lorem { foo: bar, baz: ofo };
}
</code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>默认值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#empty_item_single_line"><code>empty_item_single_line</code></a></td><td>true（默认）</td><td>No</td><td>当语言项内容为空时，要保持单行</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#fn_single_line"><code>fn_single_line</code></a></td><td>false（默认）</td><td>No</td><td>当函数中只有一个表达式时，不要保持单行</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#struct_lit_single_line"><code>struct_lit_single_line</code></a></td><td>true（默认）</td><td>No</td><td>当结构体字面量中只有少量表达式时，要保持单行</td></tr>
</tbody></table>
<h2 id="换行样式以文件自动检测为主"><a class="header" href="#换行样式以文件自动检测为主">换行样式以文件自动检测为主</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>换行样式是基于每个文件自动检测的。 具有混合行尾的文件将转换为第一个检测到的行尾样式。</p>
<p>不同平台换行符不同：</p>
<ul>
<li><code>Windows</code> 以 <code>\r\n</code>结尾。</li>
<li><code>Unix</code> 以 <code>\n</code> 结尾。</li>
</ul>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#newline_style"><code>newline_style</code></a></td><td>Auto（默认）</td><td>Yes</td><td>换行样式以文件自动检测为主</td></tr>
</tbody></table>
<h2 id="结尾逗号规则"><a class="header" href="#结尾逗号规则">结尾逗号规则</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<ol>
<li>当多个字段在不同行时，在最后一个字段结尾添加逗号，如果在同一行，则不加逗号。</li>
<li>在match分支中，如果包含了块，则不需要加逗号，否则需要加。</li>
</ol>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 当 `trailing_comma=&quot;Always&quot;`
fn main() {
    let Lorem { ipsum, dolor, sit, } = amet;
    let Lorem {
        ipsum,
        dolor,
        sit,
        amet,
        consectetur,
        adipiscing,
    } = elit;
}

// 当 `trailing_comma=&quot;Never&quot;`
fn main() {
    let Lorem { ipsum, dolor, sit } = amet;
    let Lorem {
        ipsum,
        dolor,
        sit,
        amet,
        consectetur,
        adipiscing
    } = elit;
}

// 当 `match_block_trailing_comma=true`
fn main() {
    match lorem {
        Lorem::Ipsum =&gt; {
            println!(&quot;ipsum&quot;);
        },
        Lorem::Dolor =&gt; println!(&quot;dolor&quot;),
    }
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 当 `trailing_comma=&quot;Vertical&quot;`
fn main() {
    let Lorem { ipsum, dolor, sit } = amet;
    let Lorem {
        ipsum,
        dolor,
        sit,
        amet,
        consectetur,
        adipiscing,
    } = elit;
}

// 当 `match_block_trailing_comma=false`
fn main() {
    match lorem {
        Lorem::Ipsum =&gt; {
            println!(&quot;ipsum&quot;);
        }
        Lorem::Dolor =&gt; println!(&quot;dolor&quot;),
    }
}
</code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#trailing_comma"><code>trailing_comma</code></a></td><td>&quot;Vertical&quot;（默认）</td><td>No</td><td>当多个字段在不同行时，在最后一个字段结尾添加逗号，如果在同一行，则不加逗号</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#match_block_trailing_comma"><code>match_block_trailing_comma</code></a></td><td>false（默认）</td><td>No</td><td>在match分支中，如果包含了块，则不需要加逗号，否则需要加</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在-rust-生态中被拒绝的一些默认开启的lint"><a class="header" href="#在-rust-生态中被拒绝的一些默认开启的lint">在 Rust 生态中被拒绝的一些默认开启的lint</a></h1>
<p>来源：<a href="https://github.com/dtolnay/noisy-clippy">https://github.com/dtolnay/noisy-clippy</a></p>
<p>以下按字母顺序排列。</p>
<h2 id="absurd_extreme_comparisons"><a class="header" href="#absurd_extreme_comparisons"><code>absurd_extreme_comparisons</code></a></h2>
<p><a href="https://rust-lang.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons">https://rust-lang.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons</a></p>
<p>【描述】</p>
<p>默认为 <code>Deny</code>，但在实际应用中，多被设置为 <code>allow</code>。</p>
<h2 id="blacklisted_name"><a class="header" href="#blacklisted_name"><code>blacklisted_name</code></a></h2>
<p><a href="https://rust-lang.github.io/rust-clippy/master/index.html#blacklisted_name">https://rust-lang.github.io/rust-clippy/master/index.html#blacklisted_name</a></p>
<p>【描述】</p>
<p>该 lint 不允许代码中出现 「内置黑名单」中定义的命名，比如 <code>foo</code>、<code>baz</code>。</p>
<p>默认为 <code>Warn</code>，但在实际应用中，可能被设置为<code>allow</code>，因为在某些样板代码、文档或测试代码中可能需要使用 <code>foo</code>。</p>
<h2 id="blanket_clippy_restriction_lints"><a class="header" href="#blanket_clippy_restriction_lints"><code>blanket_clippy_restriction_lints</code></a></h2>
<p><a href="https://rust-lang.github.io/rust-clippy/master/index.html#blanket_clippy_restriction_lints">https://rust-lang.github.io/rust-clippy/master/index.html#blanket_clippy_restriction_lints</a></p>
<p>【描述】</p>
<p>用于检查针对整个 <code>clippy::restriction</code> 类别的警告/拒绝/禁止属性。Restriction lint 有时与其他 lint 形成对比，甚至与惯用的 Rust 背道而驰。 这些 lint 应仅在逐个 lint 的基础上启用并仔细考虑。</p>
<p>默认为 <code>suspicious/warn</code>，但实际有些项目中会将其设置为 <code>allow</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-udeps"><a class="header" href="#cargo-udeps">Cargo Udeps</a></h1>
<p><a href="https://github.com/est31/cargo-udeps">cargo-udeps</a> 检查 <code>Cargo.toml</code> 中未使用的依赖。</p>
<p><code>cargo udeps</code> 对标的是<code> rustc</code> 的<code> unused_crate_dependencies lint</code></p>
<p>虽然 rustc 也能检查一些未使用依赖，但是在 lib 和 bin 混合的项目中误报率高</p>
<pre><code>RUSTFLAGS=&quot;-Dunused_crate_dependencies&quot; cargo c
</code></pre>
<p><code>cargo udeps</code> 的最大优点就是<strong>几乎没有误报</strong>。</p>
<p>但是检查力度不如<code>rustc unused_crate_dependencies lint</code>仔细，建议二者搭配使用</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fcheat-sheet"><a class="header" href="#fcheat-sheet">F.Cheat Sheet</a></h1>
<p>这里用于梳理 Rust 相关的 Cheat Sheet。</p>
<ul>
<li><a href="safe-guides/Appendix/cheat-sheet/">数字</a>
<ul>
<li><a href="safe-guides/Appendix/cheat-sheet/./safe-guides/Appendix/cheat-sheet/Numbers/float.html">浮点数</a></li>
</ul>
</li>
</ul>
<h2 id="资源"><a class="header" href="#资源">资源</a></h2>
<p><a href="https://cheats.rs/">https://cheats.rs/</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="float-cheat-sheet"><a class="header" href="#float-cheat-sheet">Float Cheat Sheet</a></h1>
<blockquote>
<p>From: <a href="https://github.com/brazzy/floating-point-gui.de">https://github.com/brazzy/floating-point-gui.de</a></p>
</blockquote>
<h2 id="浮点数类型"><a class="header" href="#浮点数类型">浮点数类型</a></h2>
<p>Rust 有  <a href="https://floating-point-gui.de/formats/fp/">IEEE 754</a> 单精度  (32-bit) 和  双精度 (64-bit) 类型:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let x: f32 = 0.1; // 32-bit float
	let y: f64 = 0.1; // 64-bit float
<span class="boring">}
</span></code></pre></pre>
<p>默认的浮点数类型是 <code>f64</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let z = 0.1; // 64-bit float
<span class="boring">}
</span></code></pre></pre>
<h2 id="decimal-types"><a class="header" href="#decimal-types">Decimal Types</a></h2>
<p>Rust 没有内建的 Decimal 类型，但是有第三方库  <a href="https://crates.io/crates/rust-decimal">rust_decimal</a> 来支持 Decimal 类型。该库实现了 128-bit <a href="https://floating-point-gui.de/formats/exact/">有限精度的（limited-precision）</a>  关键字  <code>Decimal</code> 表示 Decimal 类型:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_decimal::prelude::*;

let a = Decimal::new(1, 1); // second param is the number of fractional digits
let b = Decimal::new(2, 1); // a Decimal representing exactly 0.2
let c = a + b; // a Decimal representing exactly 0.3
<span class="boring">}
</span></code></pre></pre>
<h2 id="如何四舍五入"><a class="header" href="#如何四舍五入">如何四舍五入</a></h2>
<p>生成字符串:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>format!(&quot;{:.2}&quot;, 1.2399); // returns &quot;1.24&quot;
format!(&quot;{:.3}&quot;, 1.2399); // returns &quot;1.240&quot;
format!(&quot;{:.2}&quot;, 1.2); // returns &quot;1.20&quot;
<span class="boring">}
</span></code></pre></pre>
<p>打印标准输出:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{:.2}&quot;, 1.2399); // prints &quot;1.24&quot;
<span class="boring">}
</span></code></pre></pre>
<p>这个 <code>round</code> 方法返回与数字最接近的整数。它使用  <a href="https://floating-point-gui.de/errors/rounding/">四舍五入模式（rounding mode）</a> ，&quot;从零开始四舍五入&quot;，并且对<code>f32</code>和<code>f64</code>类型都有效。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f: f64 = 3.3;
let g: f64 = -3.3;

f.round(); // returns 3.0
g.round(); // returns -3.0
<span class="boring">}
</span></code></pre></pre>
<p><code>rust_decimal</code> crate 包含<code>round_dp</code>方法，它使用Banker的<a href="https://floating-point-gui.de/errors/rounding/">舍入模式</a>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pi = Decimal::from_str(&quot;3.1415926535897932384626433832&quot;).unwrap();
println!(&quot;{}&quot;, pi.round_dp(2).to_string()); // prints &quot;3.14&quot;
<span class="boring">}
</span></code></pre></pre>
<p><code>rust_decimal</code> crate 还包含<code>round_dp_with_strategy</code>方法，允许你指定一个四舍五入策略。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let i = Decimal::from_str(&quot;1.25&quot;).unwrap();
println!(
    &quot;{}&quot;,
    i.round_dp_with_strategy(1, RoundingStrategy::RoundDown)
        .to_string()
) // prints &quot;1.2&quot;
<span class="boring">}
</span></code></pre></pre>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li><a href="https://crates.io/crates/rust-decimal">rust_decimal crate</a> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="g优化指南"><a class="header" href="#g优化指南">G.优化指南</a></h1>
<hr />
<h2 id="内容介绍"><a class="header" href="#内容介绍">内容介绍</a></h2>
<ul>
<li>Rust 性能优化总则</li>
<li>Rust 性能优化准备工作</li>
<li>Rust 性能剖析工具介绍</li>
<li>日常 Rust 开发性能优化的技巧总结</li>
<li>Rust 编译大小和编译时间优化技巧</li>
</ul>
<p>本次分享将围绕 Rust 性能评估和调优主题，比较系统地介绍 Rust 代码的性能优化经验。先从大的总原则出发，介绍在编写 Rust 过程中应该遵循哪些原则对后续优化有帮助。接下来会分享一些代码优化的方法和技巧，然后介绍可以用于 Rust 代码性能评估的工具，也会包括 Rust专用的一些异步并发测试工具介绍。</p>
<h2 id="引子"><a class="header" href="#引子">引子</a></h2>
<p>Rust 语言天生为并发和安全而设计，并且借鉴了面向过程/面向对象/函数式等语言的特点。Rust 的目标在性能方面对标 C 语言，但在安全和生产力方面则比 C 更胜一筹。</p>
<p>虽说 Rust 语言性能对标 C 语言，但开发者写出的Rust 代码如果不经任何优化，也有可能比 Python 更慢。导致 Rust 代码性能慢的因素有很多种，本文就是尝试来梳理这些情况，并且给出一套方法论和一些工具集，来帮助开发者编写高性能的 Rust 代码。</p>
<h2 id="rust-性能优化总则"><a class="header" href="#rust-性能优化总则">Rust 性能优化总则</a></h2>
<h3 id="原则一-不要过早优化性能"><a class="header" href="#原则一-不要过早优化性能">原则一： 不要过早优化性能</a></h3>
<blockquote>
<p>过早优化（Premature Optimization）</p>
<p>Premature optimization is the root of all evil. -- DonaldKnuth</p>
<p>在 DonaldKnuth 的论文 《 Structured Programming With GoTo Statements 》中，他写道：&quot;程序员浪费了大量的时间去考虑或担心程序中非关键部分的速度，而当考虑到调试和维护时，这些对效率的尝试实际上会产生强烈的负面影响。我们应该忘记这种微小的效率，比如说因为过早优化而浪费的大约97%的时间。然而，我们不应该放弃那关键的 3% 的机会&quot;。</p>
</blockquote>
<p>想把代码优化到最佳，需要花很多精力。不应该在开发的时候去想着优化的事情，不需要一步到位。先完成再完美。</p>
<p>但是并非所有优化过早。在编写代码的过程中，优化代码的可读性是你持续要做的。Rust 是一门讲究显式语义的语言，在命名上体现出类型的语义，对于提升可读性非常重要。</p>
<h3 id="原则二-不要过度优化性能"><a class="header" href="#原则二-不要过度优化性能">原则二： 不要过度优化性能</a></h3>
<p>RustConf 2021 一个演讲就举了一个过度优化例子：</p>
<p>某个用户只是想写一些比 Python 程序性能更好的代码。第一版 Rust 实现的代码已经达到了这个要求，比 Python 代码快 20倍。但是他们花了九牛二虎之力写的第二个 Rust 版本，和第一个版本差距并不大。</p>
<p><img src="safe-guides/Appendix/optimizing/./image/perf/1.png" alt="1" /></p>
<p>性能够用就好，否则就容易浪费不必要的时间。</p>
<h3 id="原则三-rust-代码的性能安全编译速度和编译大小之间需要权衡"><a class="header" href="#原则三-rust-代码的性能安全编译速度和编译大小之间需要权衡">原则三： Rust 代码的性能、安全、编译速度和编译大小之间需要权衡</a></h3>
<p>Rust 是同时注重安全和性能的语言。但是在优化性能的同时，是有可能损失安全性的。比如使用 Unsafe Rust 来提升性能，而忽略安全检查在某些调用环境比较安全的地方是允许的，但是并非通用的做法。所以在优化性能之前，要考虑是否要牺牲安全性。</p>
<p>另外 Rust 优化性能的同时，可能会导致编译速度变慢 和 编译文件大小膨胀。这也是需要权衡的地方。</p>
<h2 id="rust-优化准备工作"><a class="header" href="#rust-优化准备工作">Rust 优化准备工作</a></h2>
<p>在性能优化之前，你还需要做一些准备工作，用于测量你的优化是否有效。</p>
<h4 id="基准测试-2"><a class="header" href="#基准测试-2">基准测试</a></h4>
<p>第一步是建立一套一致的基准，可以用来确定性能的基线水平，并衡量任何渐进的改进。</p>
<blockquote>
<p>参考：</p>
<p><code>mongodb</code> 的案例中，标准化的<a href="https://github.com/mongodb/specifications/blob/master/source/benchmarking/benchmarking.rst"><code>MongoDB</code> 驱动微基准集</a>在这方面发挥了很好的作用，特别是因为它允许在用其他编程语言编写的<code>MongoDB</code>驱动之间进行比较。由于这些是 &quot;微 &quot;基准，它们还可以很容易地测量单个组件的变化（例如，读与写），这在专注于在特定领域进行改进时是非常有用的。</p>
</blockquote>
<p>一旦选择了基准，就应该建立一个稳定的环境，可以用来进行所有的定时测量。确保环境不发生变化，并且在分析时不做其他 &quot;工作&quot;（如浏览猫的图片），这对减少基准测量中的噪音很重要。</p>
<p>推荐工具：</p>
<p>使用 cargo bench 和 <a href="https://crates.io/crates/criterion"><code>criterion</code></a>  来进行基准测试</p>
<pre><code class="language-toml">[dev-dependencies]
criterion = { version = &quot;0.3.5&quot;, features = [&quot;async_tokio&quot;, &quot;html_reports&quot;] }

[[bench]]
name = &quot;find&quot;
harness = false
</code></pre>
<p>因为 Rust 自带的基准测试只能用于Nightly Rust ，所以需要使用这个第三方库 criterion 在 Stable Rust 下进行基准测试。</p>
<p>Criterion 会将每次运行的时间记录、分析到一个 HTML 报告中。</p>
<p><img src="safe-guides/Appendix/optimizing/./image/perf/2.png" alt="2" /></p>
<p>在报告的底部，有两个最近的运行之间的比较，较早的运行（基线）为红色，最近的运行（优化的）为蓝色。这些报告是非常有用的工具，用于可视化由于性能调整而发生的变化，并且它们对于向其他人展示结果特别有用。</p>
<p>它们还可以作为过去性能数据的记录，无需手动记录结果。如果有性能回归的情况，也会得到及时的反映。</p>
<h4 id="压力负载测试"><a class="header" href="#压力负载测试">压力/负载测试</a></h4>
<p>基准测试是开发过程中对程序性能的一种预判。而项目最终发布之后，还需要在实际环境对其进行真正的负载测试，来判断系统的延时和吞吐量。</p>
<p>常用的负载测试工具基本都可以使用，比如 locust，wrk之类。这里介绍一个 Rust 基金会成员公司的一个用 Rust 实现的开源分布式负载测试工具 ：<a href="https://github.com/tag1consulting/goose">goose</a>。</p>
<p>Goose 每 CPU 核产生的流量至少是 Locust 的 11 倍，对于更复杂的负载测试（例如使用第三方库抓取表单内容的负载测试），收益甚至更大。虽然 Locust 要求您管理分布式负载测试，只是为了在单个服务器上使用多个 CPU 内核，但 Goose 使用单个进程利用所有可用的 CPU 内核，从而大大简化了运行更大负载测试的过程。对代码库的持续改进继续带来新功能和更快的性能。Goose 的扩展性远远优于 Locust，可以有效地利用可用资源来实现其目标。它还支持异步流程，使更多的同步流程能够轻松且一致地从单个服务器上增加数千名用户。</p>
<p>Goose 拥有许多其他负载测试工具所没有的独特<a href="https://book.goose.rs/logging/overview.html">调试和日志记录机制</a>，简化了负载测试的编写和结果的分析。Goose 还通过对数据的多个简单视图提供了更<a href="https://book.goose.rs/getting-started/metrics.html">全面的指标</a>，并且可以轻松地确认负载测试在您按比例放大或缩小时按照您的预期执行。它公开了用于分配任务和任务集的算法，对操作的顺序和一致性进行<a href="https://book.goose.rs/config/scheduler.html">更精细的控制</a>，这对于易于重复的测试很重要。</p>
<p><img src="safe-guides/Appendix/optimizing/./image/perf/3.png" alt="3" /></p>
<h4 id="明白高性能系统的标准"><a class="header" href="#明白高性能系统的标准">明白高性能系统的标准</a></h4>
<p>在进行性能剖析之前，还应该明白高性能系统的一个标准。</p>
<p>性能 = 产出 / 资源消耗</p>
<p>产出 = 事务次数（比如，qps）和 吞吐的数据量</p>
<p>消耗资源 = cpu时间片，磁盘/网络 I/O 次数、流量 等</p>
<p>而高性能的系统是要求在固定资源消耗之下来提高产出。</p>
<p>对于高性能系统的设计一般遵循两个标准：</p>
<ol>
<li>最大化地利用资源。</li>
<li>使用流水线技术减少程序中任务总耗时。比如 Rust 编译器优化编译时间，也使用了流水线技术来对crate进行并行编译。</li>
</ol>
<p>常见瓶颈类型：</p>
<ol>
<li>CPU :
<ol>
<li>CPU 占用过高，那么就需要减少计算的开销。</li>
<li>CPU 负载过高，那么就需要查看是否线程过多，以及多个线程的切换太过频繁，多线程交互是否有必要。</li>
</ol>
</li>
<li>I/O:
<ol>
<li>磁盘 IOPS(Input/Output Operations Per Second) 达到了上限。那么需要减少读写次数，提高 cache命中率。</li>
<li>IO 带宽（bandwidth） 上限。那么就需要减少磁盘的读写流量，比如使用更紧凑的数据存储格式，更小的读写放大（本来只需要读取100字节，结果触发了好多个page的读写，产生了放大的效果）。</li>
<li>I/O 并发达到上限。那么就需要考虑使用 异步I/O。</li>
<li>锁、计时器、分页/交换等被阻塞。</li>
</ol>
</li>
</ol>
<h2 id="rust-性能剖析工具介绍"><a class="header" href="#rust-性能剖析工具介绍">Rust 性能剖析工具介绍</a></h2>
<p>在做好准备工作之后，就可以开启我们的性能剖析工作了。</p>
<p>性能剖析，就是要发现程序中真正存在的性能瓶颈。而不是你自以为的想象中的性能瓶颈。如果不遵守这点，就会导致过早优化或过度优化。</p>
<p>因为常见的性能瓶颈一般都是两类，CPU 和 I/O 。所以工具也基本面向这两类。</p>
<h3 id="on-cpu-性能剖析"><a class="header" href="#on-cpu-性能剖析">On-CPU 性能剖析</a></h3>
<h4 id="使用-perf-寻找热点"><a class="header" href="#使用-perf-寻找热点">使用 Perf 寻找“热点”</a></h4>
<p>做cpu性能剖析有很多常用的 Linux 命令行工具，比如 linux 命令行工具 perf。它功能强大：它可以检测 CPU 性能计数器、跟踪点、kprobes 和 uprobes（动态跟踪）。</p>
<p>你可以使用 perf 工具对 CPU 进行采样分析。以一个指定的频率对CPU进行采样，进而拿到正在CPU上运行的指令乃至整个函数调用栈的快照，最后对采样的数据分析。比如说在100次采样中有20次在运行A指令或者A函数，那么<code>perf</code>就会认为A函数的CPU使用率为20%。</p>
<p>可以在 Cargo.toml  中加入：</p>
<pre><code class="language-toml">[profile.release]
debug = true
</code></pre>
<p>然后执行:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>$ cargo build --release
$ perf record -g target/release/perf-test
$ perf report
<span class="boring">}
</span></code></pre></pre>
<p>就可以看到报告了。</p>
<h4 id="火焰图工具"><a class="header" href="#火焰图工具">火焰图工具</a></h4>
<p>但我们 Rust 程序中要通过<a href="https://crates.io/crates/flamegraph"><code>flamegraph</code> </a>crate，来生成 火焰图（flamegraph），它可以与<code>cargo</code>一起工作，非常方便。</p>
<p>因为火焰图有助于阅读源码，它以可视化的图案非常明确地展示调用栈之间的关系。火焰图可以让开发者从整体上看出各个线程的开销比例和子函数占有的比例，指引我们从整体上找到优化的优先级。</p>
<p>火焰图中，在被测量的执行过程中调用的每个函数会被表示为一个矩形，每个调用栈被表示为一个矩形栈。一个给定的矩形的宽度与在该函数中花费的时间成正比，更宽的矩形意味着更多的时间。火焰图对于识别程序中的慢速部分非常有用，因为它们可以让你快速识别代码库中哪些部分花费的时间不成比例。</p>
<p>用 Mongodb 调优的示例来说：</p>
<p><img src="safe-guides/Appendix/optimizing/./image/perf/4.png" alt="4" /></p>
<p><img src="safe-guides/Appendix/optimizing/./image/perf/5.png" alt="5" /></p>
<p>火焰图中的栈从底部开始，随着调用栈的加深而向上移动（左右无所谓），通常这是开始阅读它们的最佳方式。看一下上面火焰图的底部，最宽的矩形是<code>Future::poll</code>，但这并不是因为Rust 的 <code>Future</code> 超级慢，而是因为每个<code>.await</code>都涉及轮询（poll）<code>Future</code>。考虑到这一点，我们可以跳过任何轮询矩形，直到我们在<code>mongodb</code>中看到我们关心的信息的函数。</p>
<p>蓝色方块包含了调用<code>CommandResponse::body</code>所花费的时间，它显示几乎所有的时间都花在了<code>clone()</code>上。各个紫色矩形对应的是将<code>BSON</code>（MongoDB使用的二进制格式）解析到<code>Document</code>中所花费的时间，绿色矩形对应的是<code>Document</code>的<code>serde::Deserialize</code>实现中所花费的时间。最后，黑色虚线矩形对应的是释放内存的时间，黑色实线对应的是将命令序列化为<code>BSON</code>的时间。</p>
<p>所以从火焰图中反映出性能瓶颈在于：</p>
<ol>
<li>Clone 过多。</li>
<li>序列化 bson 耗费更多时间</li>
</ol>
<p>修复完这些性能瓶颈之后，再使用基准测试测试一次。</p>
<p>如果可能的话，再使用 goose 这样的压测工具进行一次负载测试更好。</p>
<h4 id="perf-适合测试-rust-异步代码"><a class="header" href="#perf-适合测试-rust-异步代码">perf 适合测试 Rust 异步代码</a></h4>
<p>对于异步 Rust 程序而言，火焰图的效果可能并不是很好，因为异步调度器和执行器几乎会出现在火焰图中每一块地方，看不出瓶颈所在。这个时候使用 perf 工具会更加清晰。</p>
<h4 id="检查内存泄露和不必要的内存分配"><a class="header" href="#检查内存泄露和不必要的内存分配">检查内存泄露和不必要的内存分配</a></h4>
<p>可以使用 <strong><a href="https://www.valgrind.org/">Valgrind</a></strong> 工具来检查程序是否存在内存泄露，或者在关键的调用路径上存在不必要的内存分配。 </p>
<p>不仅仅要考察堆分配，也需要考虑栈上的分配，特别是异步操作时。</p>
<p>有一个非常有用的 Rust 编译标志（仅在 Rust nightly 中可用）来验证数据结构有多大及其缓存对齐。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>$ RUSTFLAGS=-Zprint-type-sizes cargo build --release
<span class="boring">}
</span></code></pre></pre>
<p>除了通常的 Cargo 输出之外，包括异步 Future 在内的每个数据结构都以相应的大小和缓存对齐方式打印出来。比如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print-type-size type: `net::protocol::proto::msg::Data`: 304 bytes, alignment: 8 bytes
print-type-size     field `.key`: 40 bytes
print-type-size     field `.data_info`: 168 bytes
print-type-size     field `.payload`: 96 bytes
<span class="boring">}
</span></code></pre></pre>
<p>Rust 异步编程非常依赖栈空间，异步运行时和库需要把所有东西放到栈上来保证执行的正确性。如果你的异步程序占用了过多的栈空间，可以考虑将其进行优化为 平衡的同步和异步代码组合，把特定的异步代码隔离出来也是一种优化手段。</p>
<h4 id="其他性能剖析监控工具"><a class="header" href="#其他性能剖析监控工具">其他性能剖析/监控工具</a></h4>
<p>如果允许，可以使用 英特尔出品的 <a href="https://www.intel.com/content/www/us/en/develop/documentation/vtune-help/top.html">VTune </a> 工具进行 CPU 性能剖析。</p>
<p>或者使用在线的性能监控平台，比如 <a href="https://logrocket.com/">Logrocket</a>，支持 Rust 程序，可以监控应用程序的性能，报告客户端 CPU 负载、客户端内存使用等指标。</p>
<p>也可以使用开源的链路追踪工具来监控你自己的 Rust 项目：使用 OpenTelemetry 标准。OpenTelemetry 也支持 Rust 。</p>
<p>opentelemetry是一款数据收集中间件。我们可以使用它来生成，收集和导出监测数据（Metrics,Logs and traces），这些数据可供支持OpenTelemetry的中间件存储，查询和显示，用以实现数据观测，性能分析，系统监控，服务告警等能力。</p>
<p>PingCAP 也开源了一款高性能的 tracing 库 : <a href="https://github.com/tikv/minitrace-rust">minitrace-rust</a></p>
<h3 id="off-cpu-性能剖析"><a class="header" href="#off-cpu-性能剖析">Off-CPU 性能剖析</a></h3>
<p>Off-CPU 是指在 I/O、锁、计时器、分页/交换等被阻塞的同时等待的时间。</p>
<p>Off-CPU 的性能剖析通常可以在程序运行过程中进行采用链路跟踪来进行分析。</p>
<p>还有就是使用 offcpu 火焰图进行可视化观察。</p>
<p><img src="safe-guides/Appendix/optimizing/./image/perf/6.png" alt="6" /></p>
<p>这里推荐的工具是 <code>eBPF</code>的前端工具包<a href="https://github.com/iovisor/bcc">bcc</a>中的<code>offcputime-bpfcc</code>工具。</p>
<p>这个工具的原理是在每一次内核调用<code>finish_task_switch()</code>函数完成任务切换的时候记录上一个进程被调度离开<code>CPU</code>的时间戳和当前进程被调度到<code>CPU</code>的时间戳，那么一个进程离开<code>CPU</code>到下一次进入<code>CPU</code>的时间差即为<code>Off-CPU</code>的时间。</p>
<p>比如这里一段代码：</p>
<pre><pre class="playground"><code class="language-rust">use std::io::Read;
fn test1() {
    std::thread::sleep(std::time::Duration::from_nanos(200));
}
fn test2() {
    let mut f = std::fs::File::open(&quot;./1.txt&quot;).unwrap();
    let mut buffer = Vec::new();
    f.read_to_end(&amp;mut buffer).unwrap();
}
fn main() {
    loop {
        test1();
        test2();
    }
}
</code></pre></pre>
<p>程序中一共有两种会导致进程被调度出<code>CPU</code>的任务，一个是<code>test1()</code>函数中的<code>sleep()</code>，一个是在<code>test2()</code>函数中的读文件操作。</p>
<p>这里需要使用debug编译，因为<code>offcputime-bpfcc</code>依赖于<code>frame pointer</code>来进行栈展开，所以我们需要开启<code>RUSTFLAGS=&quot;-C force-frame-pointers=yes&quot;</code>的编译选项以便打印出用户态的函数栈。我们使用如下的命令获取<code>Off-CPU</code>的分析数据。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>$ ./target/debug/mytest &amp; sudo offcputime-bpfcc -p `pgrep -nx mytest` 5
<span class="boring">}
</span></code></pre></pre>
<p>然后使用 火焰图工具将其生成 off-cpu 火焰图：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>$ git clone https://github.com/brendangregg/FlameGraph
$ cd FlameGraph
$ sudo offcputime-bpfcc -df -p `pgrep -nx mytest` 3 &gt; out.stacks
$ ./flamegraph.pl --color=io --title=&quot;Off-CPU Time Flame Graph&quot; --countname=us &lt; out.stacks &gt; out.svg
<span class="boring">}
</span></code></pre></pre>
<p>得到下面火焰图：</p>
<p><img src="safe-guides/Appendix/optimizing/./image/perf/7.png" alt="7" /></p>
<p>与<code>On-CPU</code>的火焰图相同，纵轴代表了函数调用栈，横轴代表了<code>Off-CPU</code>时间的比例，跨度越大代表<code>Off-CPU</code>的时间越长。</p>
<h3 id="其他适合-rust-性能剖析的工具介绍"><a class="header" href="#其他适合-rust-性能剖析的工具介绍">其他适合 Rust 性能剖析的工具介绍</a></h3>
<p>除了 perf 和 火焰图 工具，下面还有一些 Rust 程序适用的工具。</p>
<ul>
<li><a href="https://github.com/KDAB/hotspot">Hotspot</a>和<a href="https://profiler.firefox.com/">Firefox Profiler</a>是查看perf记录的数据的好工具。</li>
<li><a href="https://www.valgrind.org/docs/manual/cg-manual.html">Cachegrind</a>和<a href="https://www.valgrind.org/docs/manual/cl-manual.html">Callgrind</a>给出了全局的、每个函数的、每个源线的指令数以及模拟的缓存和分支预测数据。</li>
<li><a href="https://www.valgrind.org/docs/manual/dh-manual.html">DHAT</a>可以很好的找到代码中哪些部分会造成大量的分配，并对峰值内存使用情况进行深入了解。</li>
<li><a href="https://github.com/KDE/heaptrack">heaptrack</a>是另一个堆分析工具。</li>
<li><a href="https://github.com/nnethercote/counts/"><code>counts</code></a>支持即席（<em>Ad Hoc</em>）剖析，它将<code>eprintln！</code>语句的使用与基于频率的后处理结合起来，这对于了解代码中特定领域的部分内容很有帮助。</li>
<li><a href="https://github.com/plasma-umass/coz">Coz</a>执行<em>因果分析</em>以衡量优化潜力。它通过<a href="https://github.com/plasma-umass/coz/tree/master/rust">coz-rs</a>支持Rust。因果分析技术可以找到程序的瓶颈并显示对其进行优化的效果。</li>
</ul>
<h2 id="日常-rust-开发性能优化技巧总结"><a class="header" href="#日常-rust-开发性能优化技巧总结">日常 Rust 开发性能优化技巧总结</a></h2>
<p>虽然我们需要通过完善的性能测试方法来剖析系统中存在的瓶颈，保证不会过早优化和过度优化。但是在日常编码过程中，Rust 社区内也总结出来一些优化技巧来供参考：</p>
<h3 id="1-对于只被调用一次的函数可能并不需要进行优化"><a class="header" href="#1-对于只被调用一次的函数可能并不需要进行优化">1. 对于只被调用一次的函数可能并不需要进行优化。</a></h3>
<p>比如读取配置文件，这种多慢都没有关系。</p>
<p>不要只优化程序中最慢的函数，要优化占用大部分运行时间的函数。</p>
<p>在一个被调用 1000 次的函数上得到 2 毫秒的改进，那比在一个被调用一次的函数上获得 1 秒的改进要好。</p>
<h3 id="2-优先改进你的算法"><a class="header" href="#2-优先改进你的算法">2. 优先改进你的算法</a></h3>
<p>很多时候性能不佳，很可能是由于算法不佳而不是实现不佳。请检查你的代码中循环的使用，只需尝试尽可能少的循环。</p>
<ol>
<li>记住每次使用<code>collect</code>必须至少会迭代整个集合一次，所以最好只 collect 一次。</li>
<li>警惕你使用的标准库方法和第三方库方法内部实现中隐藏的循环。</li>
</ol>
<h3 id="3-要充分理解-rust-中数据结构的内存布局"><a class="header" href="#3-要充分理解-rust-中数据结构的内存布局">3. 要充分理解 Rust 中数据结构的内存布局</a></h3>
<p>要学会区分 Rust 中数据类型的内存布局，它们在栈上和堆上如何分配的。</p>
<p>比如 <code>String</code>，<code>Vec</code>，<code>HashMap</code>和<code>Box&lt;Trait&gt;</code>/<code>Box&lt;[T]&gt;</code>所有分配都在堆上。</p>
<p>在栈上分配的数据，移动的时候只能是 按位复制的方式。所以即便内存是在栈上分配，也要考虑这个 Copy 的成本。</p>
<p>堆上的数据，要尽可能地避免深拷贝（显式 Clone） 。</p>
<p>并且要尽可能地缓存数据，而避免频繁的内存分配发生。比如可以使用诸如 slab 之类的第三方库，可以合理复用内存。</p>
<h3 id="4-避免-boxtrait-动态分发"><a class="header" href="#4-避免-boxtrait-动态分发">4. 避免 <code>Box&lt;Trait&gt;</code> 动态分发</a></h3>
<p>创建 trait 对象的规范方法是<code>Box&lt;Trait&gt;</code>，但大多数代码都可以使用<code>&amp;mut Trait</code>，它也具有动态分派但节省了分配。如果您绝对需要所有权，请使用<code>Box</code>，但大多数用例都可以使用<code>&amp;Trait</code>或<code>&amp;mut Trait</code>。</p>
<p>有些场景也可以使用 Enum 来代替 trait 对象。参见 <a href="https://docs.rs/enum_dispatch/latest/enum_dispatch/"><code>enum_dispatch</code></a>。</p>
<h3 id="5-使用基于栈的可变长度数据类型"><a class="header" href="#5-使用基于栈的可变长度数据类型">5. 使用基于栈的可变长度数据类型</a></h3>
<p>定长度的数据类型可以简单地存储在堆栈上，但对于动态大小的数据，它并不是那么简单。但是，<a href="https://github.com/servo/rust-smallvec"><code>smallvec</code></a>, <a href="https://github.com/jFransham/smallstring"><code>smallstring</code></a>和<a href="https://github.com/servo/tendril"><code>tendril</code></a>都是可变长度数据类型，允许在栈上存储少量元素。像<code>smallvec</code>这样的库非常适合缓存局部性，可以减少分配。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is a gross oversimplification of how this type is implemented in the// crate, but it's enough to explain how it works.enum SmallVec&lt;T&gt; {    Small([T; 4]),    Big(Vec&lt;T&gt;),}type Matrix&lt;T&gt; = SmallVec&lt;SmallVec&lt;T&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<h3 id="6-合理使用断言避免数组越界检查"><a class="header" href="#6-合理使用断言避免数组越界检查">6. 合理使用断言避免数组越界检查</a></h3>
<p>Safe Rust 会被编译器自动塞入数组越界检查，比如下面代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_something_with_array(array: &amp;[u8]) -&gt; u8 {    array[0] + array[1] + array[2] + array[3] + array[4] + array[5]}
<span class="boring">}
</span></code></pre></pre>
<p>可以通过编译输出 MIR 看到，编译器会给数组索引访问插入断言检查：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert(move _9, &quot;index out of bounds: the length is {} but the index is {}&quot;, move _8, _7) 
<span class="boring">}
</span></code></pre></pre>
<p>有几个数组索引访问就会被插入几次，上面的代码会被插入 6 次，这极大影响性能。</p>
<p><img src="safe-guides/Appendix/optimizing/./image/perf/8.png" alt="8" /></p>
<p>所以我们可以手工插入一次断言检查，就可以消除编译器的自动插入。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_something_with_array(array: &amp;[u8]) -&gt; u8 {    assert!(array.len &gt;= 5);    array[0] + array[1] + array[2] + array[3] + array[4] + array[5]}
<span class="boring">}
</span></code></pre></pre>
<p>这一条也是可以举一反三的，比如 Rust 也会为普通的加法操作添加防止计算溢出的断言，但是你如何手工使用了 wrapped_add 之类的方法，那就可以避免编译器自动插入这类断言。</p>
<h3 id="7-使用链接时优化lto"><a class="header" href="#7-使用链接时优化lto">7. 使用链接时优化（LTO）</a></h3>
<p>链接时优化允许编译器跨 crate 进行内联，但是这样做的代价是减慢编译时间。但我认为，编译时间如何能换取性能提升，那么这个时间值得牺牲。</p>
<h3 id="8-不要使用-inlinealways"><a class="header" href="#8-不要使用-inlinealways">8. 不要使用 <code>#[inline(always)]</code></a></h3>
<p>Rust 编译器自身的优化可以计算出何时需要内联一些函数，不需要你手工明确指定。除非这个函数调用十分频繁。</p>
<p>因为这种显式的指定会导致编译大小的膨胀，如果你的硬件资源不受限可能不太重要。但是对于资源受限的环境，比如嵌入式，则需要进行权衡。</p>
<p>对于一些小的函数，如果没有使用 LTO，但是需要跨 crate 内联的话，也可以显式指定 <code>#[inline]</code>。</p>
<h3 id="9-避免显式-clone"><a class="header" href="#9-避免显式-clone">9. 避免显式 Clone</a></h3>
<p>尽可能地使用引用，避免过多的 Clone 。因为Clone 可能伴随内存分配。</p>
<h3 id="10-使用-unsafe-方法消除一些不必要的安全检查"><a class="header" href="#10-使用-unsafe-方法消除一些不必要的安全检查">10. 使用 Unsafe 方法消除一些不必要的安全检查</a></h3>
<p>在 Rust 标准库中，你可以看到很多 <code>_unchecked</code>后缀的方法。</p>
<p>比如 <code>String::from_utf8</code> 和 <code>String::from_utf8_unchecked</code>，是一对 Safe 和 Unsafe 的方法。</p>
<p>一般情况下，应该使用 <code>String::from_utf8</code>  将 <code>u8</code>序列转换为合法的字符串，这个方法对 <code>u8</code>序列进行了合法 utf8编码的检查。但是这个检查也会有一定开销。</p>
<p>如果开发者能确保调用环境的 <code>u8</code>序列来源是完全合法的 utf8 编码，那么这个安全检查就完全可以忽略。此时就可以使用  <code>String::from_utf8_unchecked</code> 来替换  <code>String::from_utf8</code> 用来提升性能。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn from_utf8(vec: Vec&lt;u8&gt;) -&gt; Result&lt;String, FromUtf8Error&gt; {    match str::from_utf8(&amp;vec) {        Ok(..) =&gt; Ok(String { vec }),        Err(e) =&gt; Err(FromUtf8Error { bytes: vec, error: e }),    }}pub unsafe fn from_utf8_unchecked(bytes: Vec&lt;u8&gt;) -&gt; String {    String { vec: bytes }}
<span class="boring">}
</span></code></pre></pre>
<h3 id="11-并发并行化你的程序"><a class="header" href="#11-并发并行化你的程序">11. 并发/并行化你的程序</a></h3>
<p>用 Rust 写多线程和异步并发程序是非常便利的。</p>
<p>推荐的库有很多：</p>
<ul>
<li><a href="https://github.com/rayon-rs/rayon">rayon</a>，并行迭代器</li>
<li><a href="https://docs.rs/crossbeam/latest/crossbeam/">crossbeam</a> / <a href="https://github.com/zesterer/flume">flume</a>，多线程channel/ 无锁并发结构</li>
<li><a href="https://github.com/tokio-rs/tokio">Tokio</a> ，高性能异步运行时
<ul>
<li><a href="https://github.com/tokio-rs/loom">loom</a>， Tokio 提供的并发代码测试工具，支持 C11 内存模型。</li>
<li><a href="https://github.com/tokio-rs/console">console</a>，Tokio 提供的 Rust 异步诊断和调试工具，可以将其视为异步代码的 Clippy。通过监控应用程序中任务的运行时操作，可以检测<em>可能</em>暗示错误或性能问题的行为模式，并突出显示它们以供用户分析。</li>
</ul>
</li>
<li>跨平台 SIMD，并行化你的计算。</li>
</ul>
<h3 id="12--并发程序中合理使用锁或替换无锁数据结构"><a class="header" href="#12--并发程序中合理使用锁或替换无锁数据结构">12.  并发程序中，合理使用锁，或替换无锁数据结构</a></h3>
<p>在某些场景中，可能读并发访问要比写并发更频繁，那么可以用 读写锁来替换互斥锁。另外，使用第三方库 parking_lot 中定义的并发锁来代替标准库中的锁。</p>
<p>或者合理选择无锁数据结构来替换用锁来同步的数据结构，并不是说无锁一定比锁同步性能更好，也是需要看场景和选择高质量的第三方实现。</p>
<h3 id="13-使用-clippy"><a class="header" href="#13-使用-clippy">13. 使用 Clippy</a></h3>
<p>使用 Clippy 工具对代码进行静态分析，它可以针对性能改进提供一些建议。</p>
<p>关于 Clippy 性能改进 lint 可以在这里找到：<a href="https://rust-lang.github.io/rust-clippy/master/index.html">https://rust-lang.github.io/rust-clippy/master/index.html</a></p>
<p>同样可以遵循 <a href="https://rust-coding-guidelines.github.io/rust-coding-guidelines-zh/"> Rust 编码规范 </a> 中的一些规范，也会包括 Clippy 的一些建议。如果你有什么性能优化的小技巧，欢迎提交贡献。</p>
<h2 id="编译大小和编译时间的优化总结"><a class="header" href="#编译大小和编译时间的优化总结">编译大小和编译时间的优化总结</a></h2>
<h3 id="1-优化编译大小"><a class="header" href="#1-优化编译大小">1. 优化编译大小</a></h3>
<ul>
<li>设置 codegen-units=1 ，codegen-units 叫做代码生成单元，Rust 编译器会把crate 生成的 LLVMIR进行分割，默认分割为16个单元，每个单元就叫 codegen-units，如果分割的太多，就不利于 Rust编译器使用内联优化一些函数调用，分割单元越大，才越容易判断需要内联的地方。但是这也有可能增大编译文件大小，需要大小和性能间寻找平衡。</li>
<li>设置panic=abort。可以缩减编译文件的大小。</li>
<li>设置编译优化等级为 <code>z</code>，意为最小二进制体积。编译器的优化级别对应的是<code>LLVM</code>函数内联的阈值，<code>z</code> 对应的是 25，而 级别 <code>3</code>则对应 275 。</li>
<li>评估代码中泛型和宏的使用，是否可以精简</li>
<li>其他参考：https://github.com/johnthagen/min-sized-rust</li>
</ul>
<h3 id="2-优化编译大小的一些技巧"><a class="header" href="#2-优化编译大小的一些技巧">2. 优化编译大小的一些技巧</a></h3>
<ul>
<li>
<p>使用 cargo check 代替 cargo build</p>
</li>
<li>
<p>使用最新 Rust 工具链</p>
</li>
<li>
<p>使用 Rust Analyzer 而不是 Rust Language Server (RLS)</p>
</li>
<li>
<p>删除未使用的依赖项</p>
</li>
<li>
<p>替换依赖过多的第三方库</p>
</li>
<li>
<p>使用 workspace，将项目拆分为多个crate，方便并行编译</p>
</li>
<li>
<p>将针对模块的测试单独拆分为一个测试文件</p>
</li>
<li>
<p>将所有集成测试组合在一个文件中</p>
</li>
<li>
<p>禁止 crate 依赖未使用功能</p>
</li>
<li>
<p>使用 ssd或Ramdisk（虚拟内存盘） 进行编译</p>
</li>
<li>
<p>使用 <a href="https://github.com/mozilla/sccache">sccache</a> 缓存依赖项</p>
</li>
<li>
<p>切换到更快的链接器：<a href="https://github.com/rui314/mold">mold</a> （Linux）/ <a href="https://github.com/michaeleisel/zld">zld</a> (MacOS) /  🤷 (Windows)，可以使用以下命令检查链接所花时间：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo cleancargo +nightly rustc --bin &lt;your_binary_name&gt; -- -Z time-passes
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Rust 针对 MacOS 用户也提升了增量编译性能，在 Cargo.toml 中进行以下配置：</p>
</li>
<li>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[profile.dev]split-debuginfo = &quot;unpacked&quot;
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>调整更多 Codegen 选项/编译器标志。这是<a href="https://doc.rust-lang.org/rustc/codegen-options">完整的 codegen 选项列表</a> 。为了获得灵感，这里是<a href="https://github.com/bevyengine/bevy/blob/3a2a68852c0a1298c0678a47adc59adebe259a6f/.cargo/config_fast_builds">bevy 的用于更快编译的配置</a>。</p>
</li>
<li>
<p>剖析文件编译时间。使用 <a href="https://blog.rust-lang.org/inside-rust/2020/02/25/intro-rustc-self-profile.html#profiling-the-compiler"><code>cargo rustc -- -Zself-profile</code></a>生成的跟踪文件可以使用火焰图或 Chromium 分析器进行可视化。还有一个<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#timings"><code>cargo -Z timings</code></a>功能可以提供有关每个编译步骤需要多长时间的一些信息，并随着时间的推移跟踪并发信息。</p>
</li>
<li>
<p>避免过程宏 Crates，主要是因为使用了 syn 。过程宏是 Rust 开发的热点：它们会消耗 CPU 周期，因此请谨慎使用。serde 库中包含了过程宏，它在很多地方都用到，所以需要注意是否一定需要serde 进行序列化和反序列化。</p>
</li>
<li>
<p>避免过多的泛型。过多的泛型单态化也会导致编译时间增加。</p>
</li>
<li>
<p>提升你的硬件，或者在云端（比如<a href="https://gitpod.io/">Gitpod.io</a>，可免费使用 16 核 Intel Xeon 2.80GHz，60GB RAM的主机）使用更好的硬件环境进行编译。</p>
</li>
<li>
<p>下载所有的依赖 crate。编译过程中有很大一部分时间用于下载，提前下载好crate是有帮助的。参考 https://github.com/the-lean-crate/criner</p>
</li>
<li>
<p>使用 docker 进行编译。<a href="https://www.lpalmieri.com/posts/fast-rust-docker-builds/"><code>cargo-chef</code></a>可用于充分利用 Docker 层缓存，从而大大加快 Rust 项目的 Docker 构建。</p>
</li>
<li>
<p>超频 cpu ？谨慎。</p>
</li>
<li>
<p>优化 CI 构建速度。参考 https://matklad.github.io/2021/09/04/fast-rust-builds.html。</p>
</li>
<li>
<p>你自己开发 crate 的时候尽量保持精简，利人利己。</p>
</li>
</ul>
<h2 id="参考-1"><a class="header" href="#参考-1">参考</a></h2>
<ol>
<li>
<p><a href="https://zenoh.io/blog/2021-07-13-zenoh-performance-async/">https://zenoh.io/blog/2021-07-13-zenoh-performance-async/</a></p>
</li>
<li>
<p><a href="https://bheisler.github.io/criterion.rs/book/getting_started.html">https://bheisler.github.io/criterion.rs/book/getting_started.html</a></p>
</li>
<li>
<p><a href="https://rust-coding-guidelines.github.io/rust-coding-guidelines-zh/safe-guides/Appendix/test/benchmark.html#%E7%94%A8-cargo-bench-%E5%92%8C-criterionrs-%E6%9D%A5%E6%89%A7%E8%A1%8C%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95">https://rust-coding-guidelines.github.io/rust-coding-guidelines-zh/safe-guides/Appendix/test/benchmark.html#%E7%94%A8-cargo-bench-%E5%92%8C-criterionrs-%E6%9D%A5%E6%89%A7%E8%A1%8C%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95</a></p>
</li>
<li>
<p><a href="https://gist.github.com/jFransham/369a86eff00e5f280ed25121454acec1">https://gist.github.com/jFransham/369a86eff00e5f280ed25121454acec1</a></p>
</li>
<li>
<p><a href="https://github.com/tag1consulting/goose">https://github.com/tag1consulting/goose</a></p>
</li>
<li>
<p><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_11/rust-profiling.html?search=">https://rustmagazine.github.io/rust_magazine_2021/chapter_11/rust-profiling.html?search=</a></p>
</li>
<li>
<p><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_7/paper-rust-vs-c.html">https://rustmagazine.github.io/rust_magazine_2021/chapter_7/paper-rust-vs-c.html</a></p>
</li>
<li>
<p><a href="https://blues-star.github.io/perf-book-zh/benchmarking_zh.html">https://blues-star.github.io/perf-book-zh/benchmarking_zh.html</a></p>
</li>
<li>
<p><a href="https://en.pingcap.com/blog/how-we-trace-a-kv-database-with-less-than-5-percent-performance-impact/">https://en.pingcap.com/blog/how-we-trace-a-kv-database-with-less-than-5-percent-performance-impact/</a></p>
</li>
<li>
<p><a href="https://rust-coding-guidelines.github.io/rust-coding-guidelines-zh/">https://rust-coding-guidelines.github.io/rust-coding-guidelines-zh/</a></p>
</li>
<li>
<p><a href="https://endler.dev/2020/rust-compile-times/">https://endler.dev/2020/rust-compile-times/</a></p>
</li>
<li>
<p><a href="https://github.com/johnthagen/min-sized-rust">https://github.com/johnthagen/min-sized-rust</a></p>
</li>
<li>
<p><a href="https://docs.rust-embedded.org/book/unsorted/speed-vs-size.html">https://docs.rust-embedded.org/book/unsorted/speed-vs-size.html</a></p>
</li>
<li>
<p><a href="https://fasterthanli.me/articles/why-is-my-rust-build-so-slow">https://fasterthanli.me/articles/why-is-my-rust-build-so-slow</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hrust编译器编译参数说明"><a class="header" href="#hrust编译器编译参数说明">H.Rust编译器编译参数说明</a></h1>
<h2 id="rustc-说明"><a class="header" href="#rustc-说明">Rustc 说明</a></h2>
<p>通过以下命令可以打印编译器相关参数选项：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>$ rustc -h 
// 或
$ rustc --help
// 在 Nightly Rust 下，比 Stable Rust 多一个 `-Z` 参数，用于传递 unstable compiler options
<span class="boring">}
</span></code></pre></pre>
<h2 id="参数功能"><a class="header" href="#参数功能">参数功能</a></h2>
<h3 id="-h----help"><a class="header" href="#-h----help"><code>-h</code> / <code>--help</code></a></h3>
<p>用于打印 <code>rustc</code> 的帮助信息</p>
<h3 id="--cfg"><a class="header" href="#--cfg"><code>--cfg</code></a></h3>
<p>用于打开或关闭 <code>#[cfg]</code> 变量中的各种条件编译设置。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>--cfg 'verbose'  // 对应 #[cfg(verbose)]
// or
--cfg 'feature=&quot;serde&quot;' // 对应 #[cfg(feature = &quot;serde&quot;)]
<span class="boring">}
</span></code></pre></pre>
<h3 id="-l"><a class="header" href="#-l"><code>-L</code></a></h3>
<p><code>-L</code> 用于将一个目录添加到外部搜索路径。命令格式如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>-L [KIND=]PATH
<span class="boring">}
</span></code></pre></pre>
<p>当 <code>KIND</code> 是以下情况之一时，可以使用 <code>-L KIND=PATH </code>这种形式指定搜索路径的类型：</p>
<ul>
<li><code>dependency</code> — 仅在该目录中搜索传递依赖项。</li>
<li><code>crate</code> — 仅在该目录中搜索此 crate 的直接依赖项。</li>
<li><code>native</code> — 仅在该目录中搜索本地库。</li>
<li><code>framework</code> — 仅用于在该目录中搜索 macOS 框架。</li>
<li><code>all</code> — 搜索此目录中的所有库类型。如果 KIND 没有指定，这将是默认值.</li>
</ul>
<h3 id="-l-1"><a class="header" href="#-l-1"><code>-l</code></a></h3>
<p>用于将生成的 crate 链接到本地库。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>-l [KIND[:MODIFIERS]=]NAME[:RENAME]
<span class="boring">}
</span></code></pre></pre>
<p>当 <code>KIND</code> 是以下情况之一时，库的种类可以使用 <code>-l KIND=lib</code> 这种形式指定:</p>
<ul>
<li><code>dylib</code> — 本地动态库</li>
<li><code>static</code> — 本地静态库 (例如 .a archive 文件)</li>
<li><code>framework</code> — macOS 框架</li>
</ul>
<p>可以用<code>#[link]</code>属性指定库的种类。 如果未在 <code>link </code>属性或命令行中指定 <code>KIND</code> ，它将链接到可用动态库，否则将使用静态库。 如果在命令行中指定了库类型，其将会覆盖 <code>link</code> 属性指定的库类型。</p>
<p><code>link</code> 属性中使用的名称可以使用形如<code> -l ATTR_NAME:LINK_NAME</code> 形式覆盖，其中 <code>ATTR_NAME</code> 是 <code>link</code> 属性中的名称，<code>LINK_NAME </code>是将要链接到的实际库的名称。</p>
<h4 id="--crate-type"><a class="header" href="#--crate-type"><code>--crate-type</code></a></h4>
<p>这将指示 rustc 以何种 crate type 去构建。该 Flag 接收逗号分隔的值列表，也可以多次指定。有效的 crate type 如下：</p>
<ul>
<li><code>lib</code> — 编译器生成的首选库类型， 目前默认为 rlib。</li>
<li><code>rlib</code> — Rust 静态库。</li>
<li><code>staticlib</code> — 本地静态库。</li>
<li><code>dylib</code> — Rust 动态库。</li>
<li><code>cdylib</code> — 本地动态库。</li>
<li><code>bin</code> — 可执行程序。</li>
<li><code>proc-macro</code> — 生成格式化且编译器可加载的过程宏库。</li>
</ul>
<p>可以使用 <code>crate_type</code>属性来指定 crate 类型，注意  <code>--crate-type</code> 命令行的值会覆盖 crate_type 属性的值。更多细节可以参阅 reference 中的<a href="https://doc.rust-lang.org/stable/reference/linkage.html"> 链接章节</a>。</p>
<h4 id="--crate-name"><a class="header" href="#--crate-name"><code>--crate-name</code></a></h4>
<p>用于指定正在构建的 crate 名称</p>
<h4 id="--edition"><a class="header" href="#--edition"><code>--edition</code></a></h4>
<p>用于指定编译器使用哪个 版次（edition），可选项 <code>2015|2018|2021</code>。</p>
<h4 id="--emit"><a class="header" href="#--emit"><code>--emit</code></a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> --emit [asm|llvm-bc|llvm-ir|obj|metadata|link|dep-info|mir]
<span class="boring">}
</span></code></pre></pre>
<p>该 Flag 控制编译器生成的输出文件的类型。其接收以逗号分隔的值列表，也可以多次指定。有效的生成类型有：</p>
<ul>
<li><code>asm</code> — 生成在 crate 中的一个汇编代码文件。 默认的输出文件是 CRATE_NAME.s。</li>
<li><code>dep-info</code> — 生成一个包含 Makefile 语法的文件，指示加载以生成 crate 的所有源文件。 默认输出文件是 CRATE_NAME.d。</li>
<li><code>link</code> — 生成由 --crate-type 指定的 crates 。 默认输出文件取决于平台和 crate 类型。 如果未指定 --emit 这将是默认值。</li>
<li><code>llvm-bc</code> — 生成一个包含 LLVM bitcode 的二进制文件。默认输出文件是 CRATE_NAME.bc。</li>
<li><code>llvm-ir</code> — 生成一个包含 LLVM IR（ LLVM 中间语言）的文件。默认的输出文件是 CRATE_NAME.ll。</li>
<li><code>metadata</code> — 生成一个关于该 crate 的元数据的文件。 默认输出文件是 CRATE_NAME.rmeta。</li>
<li><code>mir</code> — 生成一个包含 Rust 中级中间表示（即中级中间语言）的文件。默认输出文件名是 <code>CRATE_NAME.mir</code>。</li>
<li><code>obj</code> — 生成一个本地对象文件，默认输出文件是 <code>CRATE_NAME.o</code>。</li>
</ul>
<p>输出文件名可以用 <code>-o flag</code> 进行设置。使用<code> -C extra-filename</code>。Flag 可以添加文件名后缀。文件将被写入当前目录除非使用<code>--out-dir flag</code> 标签。 每一个生成类型也可以使用 <code>KIND=PATH </code>的形式指定输出文件名，它优先于 <code>-o </code>标签。</p>
<h3 id="--print"><a class="header" href="#--print"><code>--print</code></a></h3>
<p>用于打印有关编译器的各种信息。指定<code>--print</code>标签通常会禁用 <code>--emit </code>步骤且只打印请求的信息。打印的有效值类型为：</p>
<ul>
<li><code>crate-name</code> — crate 的名称。</li>
<li><code>file-names</code> — 文件名由 link 命令执行的种类所决定。</li>
<li><code>sysroot</code> — 系统根目录路径，即<code>.rustup</code> 下的 <code>toolchains</code> 文件夹。</li>
<li><code>target-libdir</code> - 目标<code>lib</code>文件夹路径（同上）。</li>
<li><code>cfg</code> — 条件编译值列表。 了解更多条件编译值信息，请参阅 条件编译。</li>
<li><code>target-list</code> — 已知目标列表。 可以使用<code>--target </code>标签选择目标。</li>
<li><code>target-cpus </code>— 当前目标的可用 CPU 值列表。可以使用 <code>-C target-cpu=val</code>  Flag 选择目标。</li>
<li><code>target-features</code>— 当前目标的可用 目标 <code>features</code> 列表。目标 <code>features</code> 可以使用<code>-C target-feature=val</code>flag 启用。该Flag是不安全（ unsafe ）的。</li>
<li><code>relocation-models</code> — 重定位模型列表。重定位模型可以用 <code>-C relocation-model=val </code> Flag 选择。</li>
<li><code>code-models</code> — 代码模型列表。代码模型可以用<code> -C code-model=val</code> flag 进行设置。</li>
<li><code>tls-models</code> — 支持的线程本地存储模型列表。 模型可以用<code>-Z tls-model=val</code> Flag 来选择（仅限 Nightly Rust）。</li>
<li><code>native-static-libs</code> — 当创建一个<code> staticlib crate</code> 类型时可以使用此选项。 如果这是唯一的标志，它将执行一个完整的编译，并包含一个指出链接生成静态库时要使用的链接器 Flag 的诊断说明。该说明以文本 <code>native-static-libs:</code> 开始，以便更容易获取输出信息。</li>
</ul>
<h3 id="-g"><a class="header" href="#-g"><code>-g</code></a></h3>
<p>等价于 <code>-C debuginfo=2</code>，用于输出调试信息。</p>
<p><strong>调试信息说明：</strong></p>
<ul>
<li><code>0</code>：根本没有调试信息（默认）。</li>
<li><code>1</code>: 仅行表。</li>
<li><code>2</code>：完整的调试信息。</li>
</ul>
<h3 id="-o-大写的字母o优化"><a class="header" href="#-o-大写的字母o优化"><code>-O</code> （大写的字母o，优化）</a></h3>
<p>等价于 <code>-C opt-level=2</code>，用于编译优化，level为2。</p>
<p><strong>优化级别说明：</strong></p>
<ul>
<li><code>0</code>：没有优化，也打开 <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#debug-assertions"><code>cfg(debug_assertions)</code></a>（默认）。</li>
<li><code>1</code>: 基本优化。</li>
<li><code>2</code>: 一些优化。</li>
<li><code>3</code>: 所有优化。</li>
<li><code>s</code>:  优化二进制大小。</li>
<li><code>z</code>：优化二进制大小，但也关闭循环向量化。 </li>
</ul>
<p>默认值为<code>0</code>.</p>
<h3 id="-o"><a class="header" href="#-o"><code>-o</code></a></h3>
<p>用于控制输出的文件名。</p>
<h4 id="--out-dir-dir"><a class="header" href="#--out-dir-dir"><code>--out-dir DIR</code></a></h4>
<p>用于指定输出目录位置。</p>
<h4 id="--explain-opt"><a class="header" href="#--explain-opt"><code>--explain OPT</code></a></h4>
<p>用于提供错误消息的详细说明。<code>rustc</code> 对于每一个（检测到的）错误都会返回一个错误码，这将打印给定错误的更详细说明。</p>
<h4 id="--test"><a class="header" href="#--test"><code>--test</code></a></h4>
<p>构建测试工具。</p>
<h4 id="--target-target"><a class="header" href="#--target-target"><code>--target TARGET</code></a></h4>
<p>指定编译的<code> target triple</code> 。</p>
<h3 id="设置-lint"><a class="header" href="#设置-lint">设置 lint</a></h3>
<h4 id="-w"><a class="header" href="#-w"><code>-W</code></a></h4>
<p>等价于 <code>--warn LINT</code> ，设置给定 lint 为 warning 级别。</p>
<h4 id="-a"><a class="header" href="#-a"><code>-A</code></a></h4>
<p>等价于 <code>--allow LINT</code> ，设置给定 lint 为 allow 级别。</p>
<h4 id="-d"><a class="header" href="#-d"><code>-D</code></a></h4>
<p>等价于 <code>--deny LINT</code> ，设置给定 lint 为 deny 级别。</p>
<h4 id="-f"><a class="header" href="#-f"><code>-F</code></a></h4>
<p>等价于 <code>--forbid LINT</code> ，设置给定 lint 为 forbid 级别。</p>
<h3 id="-c"><a class="header" href="#-c"><code>-C</code></a></h3>
<p>用于设置 <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html">代码生成</a> 选项。可以通过 <code>rustc -C help</code> 进一步查看其选项。</p>
<h4 id="已弃用参数"><a class="header" href="#已弃用参数">已弃用参数</a></h4>
<ul>
<li><code>ar=val</code>，废弃。</li>
<li><code>no-stack-check=val</code>，废弃。</li>
</ul>
<h4 id="code-model-优化相关"><a class="header" href="#code-model-优化相关"><code>code-model</code> （优化相关）</a></h4>
<p><code>code-model=val</code>，支持的值为：</p>
<ul>
<li><code>tiny</code> - 微小的代码模型。</li>
<li><code>small</code>- 小代码模型。这是大多数受支持目标的默认模型。</li>
<li><code>kernel</code> - 内核代码模型。</li>
<li><code>medium</code> - 中等代码模型。</li>
<li><code>large</code> - 大型代码模型。比如 x86 平台上，告诉编译器不要进行任何假设，使用64位绝对取址模型访问代码及数据。</li>
</ul>
<p>可以通过命令 <code>rustc --print code-models</code> 查看。</p>
<p>代码模型对程序及其符号可能使用的地址范围施加了限制。对于较小的地址范围，机器指令可能能够使用更紧凑的寻址模式。具体范围取决于目标架构和可用的寻址模式。</p>
<p>代码模型是程序员与编译器间的一个正式的协议，其中程序员表达其对最终程序将进入的当前正在编译的目标文件大小的意愿。比如，“不要担心，这个对象只会进入不那么大的程序，因此你可以使用快速的RIP相对取址模式”，相反，“这个对象期望链接进巨大的程序，因此请使用慢但安全的，带有完整64位偏移的绝对取址模式”。</p>
<h4 id="codegen-units-优化-性能-vs-编译速度"><a class="header" href="#codegen-units-优化-性能-vs-编译速度"><code>codegen-units</code> （优化： 性能 vs 编译速度）</a></h4>
<p><code>codegen-units=val</code>，这个值表示控制 crate 分成多少个代码生成单元（codegen units），它需要一个大于 0 的整数。</p>
<p>当一个 crate 被拆分为多个代码生成单元时，LLVM 能够并行处理它们。增加并行度可能会<strong>加快编译时间</strong>，但也可能会<strong>产生更慢的代码</strong>，因为可能会影响内联（inline）优化。</p>
<p>将此设置为 <code>1</code> 可能会提高生成代码的性能，但编译速度可能会变慢。</p>
<p>如果未指定，则默认值为 16，用于非增量构建。对于增量构建，默认值为 256，这允许缓存更细粒度。</p>
<h4 id="control-flow-guard-安全"><a class="header" href="#control-flow-guard-安全"><code>control-flow-guard</code> （安全）</a></h4>
<p>此Flag 控制 LLVM 是否启用 Windows <a href="https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard">控制流保护（Control Flow Guard）</a> 平台安全功能。对于非 Windows 目标，此标志当前被忽略。它采用以下值之一：</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>checks</code>, 或无值：表示启用控制流防护。</li>
<li><code>nochecks</code>：在没有运行时强制检查的情况下发出控制流保护元数据（这应该只用于测试目的，因为它不提供安全强制）。</li>
<li><code>n</code>, <code>no</code>, <code>off</code>: 不启用控制流保护（默认）。</li>
</ul>
<p>关于 Rust 和 CFG 的更详细说明参考：</p>
<ul>
<li><a href="https://msrc-blog.microsoft.com/2020/08/17/control-flow-guard-for-clang-llvm-and-rust/">Control Flow Guard for Clang/LLVM and Rust</a> </li>
<li><a href="https://doc.rust-lang.org/beta/unstable-book/compiler-flags/control-flow-guard.html">UnStable book: control-flow-guard</a></li>
</ul>
<h4 id="debug-assertions"><a class="header" href="#debug-assertions"><code>debug-assertions</code></a></h4>
<p><code>debug-assertions=val</code>，用于打开或关闭 <code>cfg(debug_assertions)</code> 条件编译。采用以下的值：</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：启用调试断言。</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: 禁用调试断言。</li>
</ul>
<p>如果无指定，调试断言会在 <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#opt-level">opt-level</a> 为 0 的优化级别下默认开启。所以这里需要注意优化级别，debug_assertions 在 release 编译时最好不要开启。这个和 <code>debug_assert!</code> 宏相关。</p>
<h4 id="default-linker-libraries"><a class="header" href="#default-linker-libraries"><code>default-linker-libraries</code></a></h4>
<p><code>default-linker-libraries=val</code>，用于设置链接器是否可以链接它的默认库，可以设置的值为：</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：包括默认库（默认）。</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: 排除默认库。</li>
</ul>
<h4 id="embed-bitcode-优化编译大小--编译时间"><a class="header" href="#embed-bitcode-优化编译大小--编译时间"><code>embed-bitcode</code> （优化：编译大小 &amp;&amp; 编译时间）</a></h4>
<p><code>embed-bitcode=val</code>，控制编译器是否将 LLVM 位码嵌入到目标文件中。它采用以下值之一：</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：将位码放入 rlibs（默认）。</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: 从 rlibs 中省略位码。</li>
</ul>
<p><code>rustc</code> 执行链接时优化 (LTO) 时需要 LLVM 位码（bitcode）。嵌入的位码将出现在 rustc 生成的目标文件中，该文件的名称由目标平台定义。大多数时候是这样 <code>.llvmbc</code>。</p>
<p>如果你的编译实际不需要位码，使用<code>-C embed-bitcode=no</code> 可以显著提高编译时间并减少生成的文件大小（例如，如果你不为iOS编译或者你不执行LTO）。由于这些原因，Cargo尽可能地使用<code>-C embed-bitcode=no</code>。同样地，如果你直接用 rustc 构建，我们建议在不使用 LTO 时使用 <code>-C embed-bitcode=no</code>。</p>
<p>如果与<code>-C lto</code>结合，<code>-C embed-bitcode=no</code>将导致<code>rustc</code>在启动时中止，因为这种结合是无效的。</p>
<blockquote>
<p>bitcode是由LLVM引入的一种中间代码(Intermediate Representation，简称IR)，它是源代码被编译为二进制机器码过程中的中间表示形态，它既不是源代码，也不是机器码。从代码组织结构上看它比较接近机器码，但是在函数和指令层面使用了很多高级语言的特性。LLVM 优化器负责对bitcode进行各种类型的优化，将bitcode代码进行一些逻辑等价的转换，使得代码的执行效率更高，体积更小，比如DeadStrip/SimplifyCFG，LLVM 后端负责把优化后的bitcode编译为指定目标架构的机器码。</p>
<p>来源：<a href="https://xelz.info/blog/2018/11/24/all-you-need-to-know-about-bitcode/">https://xelz.info/blog/2018/11/24/all-you-need-to-know-about-bitcode/</a></p>
</blockquote>
<h4 id="force-frame-pointers-优化性能"><a class="header" href="#force-frame-pointers-优化性能"><code>force-frame-pointers</code> （优化：性能）</a></h4>
<p><code>force-frame-pointers=val</code>，用于设置是否强制启用 帧指针（frame-pointers）。相当于 Clang 的<code>-fno-omit-frame-pointer</code>，</p>
<p>它采用以下值之一：</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：强制启用帧指针。</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: 不要强制启用帧指针。这并不一定意味着将删除帧指针。</li>
</ul>
<p>如果未强制启用帧指针，则默认行为取决于 target。</p>
<p>一般情况下，如果设置 <code>force-frame-pointers=no</code> 是一种帧指针省略优化。它造成的弊大于利，默认情况下不应启用。</p>
<h4 id="force-unwind-tables-优化编译大小"><a class="header" href="#force-unwind-tables-优化编译大小"><code>force-unwind-tables</code> （优化：编译大小）</a></h4>
<p><code>force-unwind-tables=val</code>，强制生成 unwind 表。它采用以下值之一：</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：强制生成 unwind 表。</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: 不强制生成 unwind 表。如果目标需要 unwind 表，则会发出错误。</li>
</ul>
<p>如果未指定，则默认值取决于 target 。</p>
<p>打开 <code>force-unwind-tables=on</code> 可能会导致二进制编译大小膨胀，对于移动和嵌入式这种二进制大小很重要的场景下，建议启用该选项。</p>
<h4 id="incremental优化编译时间"><a class="header" href="#incremental优化编译时间"><code>incremental</code>（优化：编译时间）</a></h4>
<p><code>incremental=val</code> ，用于启用增量编译。</p>
<h4 id="inline-threshold-优化性能"><a class="header" href="#inline-threshold-优化性能"><code>inline-threshold</code> （优化：性能）</a></h4>
<p><code>inline-threshold=val</code>， 允许您设置内联函数的默认阈值。它接受一个无符号整数作为值。内联基于成本模型（cost model），其中较高的阈值将允许更多内联。</p>
<p>默认值取决于<a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#opt-level">opt-level</a>：</p>
<table><thead><tr><th>选择级别</th><th>临界点</th></tr></thead><tbody>
<tr><td>0</td><td>不适用，仅内联始终内联函数</td></tr>
<tr><td>1</td><td>不适用，仅内联始终内联函数和 LLVM 生命周期内在函数</td></tr>
<tr><td>2</td><td>225</td></tr>
<tr><td>3</td><td>275</td></tr>
<tr><td>s</td><td>75</td></tr>
<tr><td>z</td><td>25</td></tr>
</tbody></table>
<h4 id="链接相关参数"><a class="header" href="#链接相关参数">链接相关参数</a></h4>
<ul>
<li><code>link-arg=val</code>，将单个额外参数附加到链接器调用。</li>
<li><code>link-args=val</code>，将多个额外参数附加到链接器调用。选项应该用空格分隔。</li>
<li><code>link-dead-code=val</code>，控制链接器是否保留死代码，尝试构建代码覆盖率指标时，此标志可能有用。它采用以下值之一：
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：保留死代码。</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: 删除死代码（默认）。</li>
</ul>
</li>
<li><code> link-self-contained=val</code>，控制链接器是使用 Rust 附带的库和对象还是系统中的库和对象。</li>
<li><code>linker=val </code>，控制链接器<code>rustc</code>调用哪个链接器来链接您的代码。它采用链接器可执行文件的路径。如果未指定此标志，则将根据目标推断链接器。选择特定的链接器，有助于<strong>优化编译时间</strong>。</li>
<li><code>linker-flavor=val</code>，链接器带有<a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#linker"><code>-C linker</code>标志</a>，则链接器风格是从提供的值中推断出来的。如果没有给出链接器，则使用链接器风格来确定要使用的链接器。每个<code>rustc</code>目标都默认为某种链接器风格。选项参考:<a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#linker-flavor">linker-flavor</a> 。</li>
<li><code>linker-plugin-lto=val</code>，允许将 LTO 优化推迟到实际的链接步骤，如果所有被链接的目标文件都是由基于 LLVM 的工具链创建的，那么这反过来又允许跨编程语言边界执行过程间<strong>优化</strong>。详细介绍参见<a href="https://doc.rust-lang.org/rustc/linker-plugin-lto.html">Linker-plugin-LTO</a>。它采用以下值之一：
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：启用链接器插件 LTO。</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: 禁用链接器插件 LTO（默认）。</li>
<li>链接器插件的路径。</li>
</ul>
</li>
</ul>
<h4 id="lto-优化性能"><a class="header" href="#lto-优化性能"><code>lto</code> （优化：性能）</a></h4>
<p><code>lto=val</code>，这个标志控制LLVM是否使用链接时优化（link-time optimizations），以产生更好的优化代码，使用整个程序分析，代价是延长链接时间，所以，会减慢编译时间。它取以下值之一：</p>
<ul>
<li><code>y</code>, <code>yes</code>,<code> on</code>,<code> fat</code>, or <code>no</code>值：执行 &quot;fat &quot;LTO，试图在依赖图中的所有crate中进行优化。</li>
<li><code>n</code>,<code> no</code>,<code> of</code>f: 禁用LTO。</li>
<li><code>thin</code>：执行 &quot;Thin &quot;LTO。这与 &quot;fat &quot;类似，但运行时间大大减少，同时仍能实现与 &quot;fat &quot;类似的性能提升。</li>
</ul>
<p>如果没有指定<code>-C lto</code>，那么编译器将尝试执行 &quot;thin local LTO&quot;，它只在本地的crate上对其代码单元执行 &quot;thin &quot;LTO。当没有指定<code>-C lto</code>时，如果代码单元是<code>1</code>或者优化被禁用（<code>-C opt-level=0</code>），LTO将被禁用。</p>
<p>即：</p>
<ul>
<li>当没有指定<code>-C lto</code>时:
<ul>
<li><code>codegen-units=1</code>: 禁用LTO</li>
<li><code>opt-level=0</code>: 禁用LTO。</li>
</ul>
</li>
<li>当<code>-C lto</code>被指定时：
<ul>
<li><code>lto</code>：16个代码生成单元，在整个crate 中执行 fat LTO。</li>
<li><code>codegen-units=1</code> +<code> lto</code>:  <code>1</code>个编码生成单元，跨 crate 进行fat LTO。</li>
</ul>
</li>
</ul>
<p>跨语言的LTO 参见<a href="https://doc.rust-lang.org/rustc/linker-plugin-lto.html">Linker-plugin-LTO</a> 。</p>
<h4 id="passes-优化性能"><a class="header" href="#passes-优化性能"><code>passes</code> （优化：性能）</a></h4>
<p><code>passes=val</code>，设置额外的 LLVM passes 列表，使用空格分隔。</p>
<blockquote>
<p>LLVM Pass 是LLVM代码优化（optimization）中的一个重要组成部分。为便于理解，可以将Pass看作一个又一个的模块，各个Pass可以通过IR获取信息为下一个Pass做好准备，又或者直接对中间代码进行优化。</p>
<p>总的来说，所有的pass大致可以分为两类：</p>
<ul>
<li>分析(<code>analysis</code>)和转换分析类的pass以提供信息为主</li>
<li>转换类(<code>transform</code>)的pass优化中间代码</li>
</ul>
<p>详细参考：<a href="https://kiprey.github.io/2020/06/LLVM-IR-pass/">代码优化与LLVM IR pass</a></p>
</blockquote>
<p>相关选项：<code>no-prepopulate-passes=val</code>，使用空的 Pass 列表。</p>
<h4 id="no-redzone"><a class="header" href="#no-redzone"><code>no-redzone</code></a></h4>
<p><code>no-redzone=val</code>，允许禁用<a href="https://en.wikipedia.org/wiki/Red_zone_(computing)">红区</a>。它采用以下值之一：</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：禁用红色区域。</li>
<li><code>n</code>, <code>no</code>, 或<code>off</code>: 启用红色区域。</li>
</ul>
<blockquote>
<p><strong>红区</strong>（redzone）是System V ABI提供的一种优化的产物，它允许函数无需调整<strong>栈指针</strong>（stack pointer），便能临时使用其<strong>栈帧</strong>（stack frame）下方的128个字节。红区被定义为调整过的栈指针下方128个字节的区域——函数将会使用这个区域，来存放一些无需跨越函数调用的临时数据。因此，在一些情况下，比如在小的<strong>叶函数</strong>（leaf function）[1]中，我们可以优化掉调整栈指针所需的两条指令。(</p>
<p><strong>叶函数</strong>（leaf function）指的是不调用其它函数的函数；可以理解为，是函数调用图的叶子节点。特别地，<strong>尾递归函数</strong>（tail recursive function）的尾部可以看作是叶函数。</p>
<p>然而，当<strong>异常</strong>（exception）或<strong>硬件中断</strong>（hardware interrupt）发生时，这种优化却可能产生严重的问题。</p>
<p>参考：<a href="https://github.com/rustcc/writing-an-os-in-rust/blob/master/appendix-b-red-zone.md">使用Rust编写操作系统（附录二）：禁用红区</a></p>
</blockquote>
<h4 id="no-vectorize-loops-优化性能"><a class="header" href="#no-vectorize-loops-优化性能"><code>no-vectorize-loops</code> （优化：性能）</a></h4>
<p><code>no-vectorize-loops=val</code>，禁用循环矢量化（loop vectorization optimization passes）。等价于 Clang 的 <code>-fno-vectorize</code>。</p>
<p>LLVM Loop Vectorizer 具有许多功能，可以对复杂的循环进行矢量化（向量化即“批量操作”，数据并行）。循环矢量化器使用成本模型来决定最佳矢量化因子和展开因子。但是，矢量化器的用户可以强制矢量化器使用特定值。许多循环无法向量化，包括具有复杂控制流、不可向量化类型和不可向量化调用的循环。对于更复杂的情况，我们则需要手动进行SIMD编程。</p>
<p>是否禁用，取决于你的使用场景。</p>
<p>相关：<code>no-vectorize-slp=val</code>，禁用 SLP 向量化。</p>
<h4 id="overflow-checks-安全"><a class="header" href="#overflow-checks-安全"><code> overflow-checks</code> （安全）</a></h4>
<p><code>overflow-checks=val</code>，控制<a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow">运行时整数溢出检查</a>，启用溢出检查时，溢出时会发生恐慌。取值为：</p>
<p>采用以下值之一：</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：启用溢出检查。</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: 禁用溢出检查。</li>
</ul>
<p>如果未指定，则在启用 <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#debug-assertions">调试断言</a>时启用溢出检查，否则禁用。</p>
<h4 id="panic"><a class="header" href="#panic"><code>panic</code></a></h4>
<p>控制代码恐慌时发生的情况:</p>
<ul>
<li><code>abort</code>: 恐慌时终止进程，不能执行析构函数。</li>
<li><code>unwind</code>: 恐慌时展开堆栈，可以执行析构函数，以及 catch_unwind 。</li>
</ul>
<p>如果未指定，则默认值取决于目标。</p>
<h4 id="prefer-dynamic"><a class="header" href="#prefer-dynamic"><code> prefer-dynamic</code></a></h4>
<p><code> prefer-dynamic=val</code>，默认情况下，<code>rustc</code>更喜欢静态链接依赖项。如果库的静态和动态版本都可用，此选项将指示应尽可能使用动态链接。有一个内部算法用于确定是否可以静态或动态地与依赖项链接。例如，<code>cdylib</code> crate类型可能只使用静态链接。此标志采用以下值之一：</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：使用动态链接。</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: 使用静态链接（默认）。</li>
</ul>
<h4 id="profile-generate-优化"><a class="header" href="#profile-generate-优化"><code>profile-generate</code> （优化）</a></h4>
<p><code>profile-generate=val</code>，允许创建检测二进制文件，这些二进制文件将收集分析数据以用于 Profile Guided Optimization (PGO)。该Flag 采用一个可选参数，该参数是已检测二进制文件将向其中发出收集的数据的目录的路径。有关详细信息，请参阅 <a href="https://doc.rust-lang.org/rustc/profile-guided-optimization.html">profile-guided optimization</a> 。</p>
<p>相关：<code>profile-use=val</code>。</p>
<h4 id="split-debuginfo-调试"><a class="header" href="#split-debuginfo-调试"><code>split-debuginfo</code> （调试）</a></h4>
<p><code>split-debuginfo=val </code>，控制<code>rustc</code>生成的调试信息的“split debuginfo”的发射。此选项的默认行为是特定于平台的，并非此选项的所有可能值都适用于所有平台。可能的值为：</p>
<ul>
<li><code>off</code>- 这是具有 ELF 二进制文件和 windows-gnu（不是 Windows MSVC 和 macOS）的平台的默认设置。这通常意味着可以在可执行文件部分的最终工件中找到 DWARF 调试信息。Windows MSVC 不支持此选项。在 macOS 上，此选项可防止最终执行<code>dsymutil</code>生成调试信息。</li>
<li><code>packed</code>- 这是 Windows MSVC 和 macOS 的默认设置。这里的“packed”一词意味着所有调试信息都打包到与主可执行文件不同的文件中。在 Windows MSVC 上这是一个<code>*.pdb</code>文件，在 macOS 上这是一个<code>*.dSYM</code>文件夹，而在其他平台上这是一个<code>*.dwp</code> 文件。</li>
<li><code>unpacked</code>- 这意味着调试信息将在每个编译单元（目标文件）的单独文件中找到。Windows MSVC 不支持此功能。在 macOS 上，这意味着原始目标文件将包含调试信息。在其他 Unix 平台上，这意味着<code>*.dwo</code>文件将包含调试信息。</li>
</ul>
<p>请注意，此时<code>packed</code>和<code>unpacked</code>在<code>-Z unstable-options</code>非 macOS 平台上被关闭。</p>
<h4 id="strip-优化编译大小"><a class="header" href="#strip-优化编译大小"><code>strip</code> （优化：编译大小）</a></h4>
<p><code>strip=val</code>，控制在链接期间从二进制文件中剥离调试信息和类似的辅助数据。可用于减少编译文件大小。</p>
<p>此选项支持的值为：</p>
<ul>
<li><code>none</code>- 根据目标将调试信息和符号（如果存在）复制到生成的二进制文件或单独的文件中（例如<code>.pdb</code>，MSVC 中的文件）。</li>
<li><code>debuginfo</code> - debuginfo 部分和符号表部分中的 debuginfo 符号在链接时被剥离，并且不会复制到生成的二进制文件或单独的文件中。</li>
<li><code>symbols</code>- 与 相同<code>debuginfo</code>，但如果链接器支持，符号表部分的其余部分也会被剥离。</li>
</ul>
<h3 id="-z"><a class="header" href="#-z"><code>-Z</code></a></h3>
<p><code>-Z</code> Flag 只允许在 Nightly Rust 下使用，因为它包含了 未稳定的编译器选项。</p>
<p>在该 Flag 下面有许多未稳定的子参数，这里就不一一列举。只挑选几个和安全相关的展示一下：</p>
<ul>
<li><code>stack-protector=val</code> ，用于控制栈粉碎保护策略，用于缓冲溢出保护。通过命令 <code>rustc --print stack-protector-strategies</code>可以看到详细设置值。</li>
<li><code>sanitizer=val</code>，sanitizers（CFI 除外）的实现几乎完全依赖于 LLVM，将来增加 GCC 后端应该可以多一些支持。用于支持 内存错误检测器（<a href="https://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer</a>）、LLVM 控制流完整性 (CFI) 提供前沿控制流保护（<a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">ControlFlowIntegrity</a> ）、运行时内存泄漏检测器（<a href="https://clang.llvm.org/docs/LeakSanitizer.html">LeakSanitizer</a>）、未初始化读取的检测器（<a href="https://clang.llvm.org/docs/MemorySanitizer.html">MemorySanitizer</a>）、数据竞争检测器（<a href="https://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer</a>）等。</li>
</ul>
<h2 id="参考-2"><a class="header" href="#参考-2">参考</a></h2>
<p>https://doc.rust-lang.org/rustc/command-line-arguments.html</p>
<p>https://doc.rust-lang.org/rustc/codegen-options/index.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i最佳实践"><a class="header" href="#i最佳实践">I.最佳实践</a></h1>
<h2 id="列表-52"><a class="header" href="#列表-52">列表</a></h2>
<ul>
<li><a href="safe-guides/Appendix/best-practice/./qa.html">Q&amp;A</a></li>
<li><a href="safe-guides/Appendix/best-practice/./tips.html">Tips</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="初学者常见问题qa"><a class="header" href="#初学者常见问题qa">初学者常见问题Q&amp;A</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-编程技巧"><a class="header" href="#rust-编程技巧">Rust 编程技巧</a></h1>
<h3 id="设计模式之构建者模式"><a class="header" href="#设计模式之构建者模式">设计模式之构建者模式</a></h3>
<p>当需要很多构造函数，或构造含有很多可选配置项时，宜使用构建者模式</p>
<p><strong>【描述】</strong></p>
<p>Rust 中没有默认的构造函数，都是自定义构造函数。</p>
<p>如果需要多个构造函数，或者构造时需要很多可选配置的复杂场景，那么构建者模式是适合你的选择。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq)]
pub struct Foo {
    // Lots of complicated fields.
    bar: String,
}

impl Foo {
    // This method will help users to discover the builder
    pub fn builder() -&gt; FooBuilder {
        FooBuilder::default()
    }
}

#[derive(Default)]
pub struct FooBuilder {
    // Probably lots of optional fields.
    bar: String,
}

impl FooBuilder {
    pub fn new(/* ... */) -&gt; FooBuilder {
        // Set the minimally required fields of Foo.
        FooBuilder {
            bar: String::from(&quot;X&quot;),
        }
    }

    pub fn name(mut self, bar: String) -&gt; FooBuilder {
        // Set the name on the builder itself, and return the builder by value.
        self.bar = bar;
        self
    }

    // If we can get away with not consuming the Builder here, that is an
    // advantage. It means we can use the FooBuilder as a template for constructing
    // many Foos.
    pub fn build(self) -&gt; Foo {
        // Create a Foo from the FooBuilder, applying all settings in FooBuilder
        // to Foo.
        Foo { bar: self.bar }
    }
}

#[test]
fn builder_test() {
    let foo = Foo {
        bar: String::from(&quot;Y&quot;),
    };
    let foo_from_builder: Foo = FooBuilder::new().name(String::from(&quot;Y&quot;)).build();
    assert_eq!(foo, foo_from_builder);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="善用标准库中提供的迭代器适配器方法来满足自己的需求"><a class="header" href="#善用标准库中提供的迭代器适配器方法来满足自己的需求">善用标准库中提供的迭代器适配器方法来满足自己的需求</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 标准库中提供了很多迭代器方法，要学会使用它们，选择合适的方法来满足自己的需求。</p>
<p>下面示例中，反例中的迭代器适配器方法，都可以用对应的正例中的方法代替。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// explicit_counter_loop
let v = vec![1];
fn bar(bar: usize, baz: usize) {}
let mut i = 0;
for item in &amp;v {
    bar(i, *item);
    i += 1;
}

// filter_map_identity
let iter = vec![Some(1)].into_iter();
iter.filter_map(|x| x);

// filter_next
let vec = vec![1];
vec.iter().filter(|x| **x == 0).next();

// flat_map_identity
let iter = vec![vec![0]].into_iter();
iter.flat_map(|x| x);

// flat_map_option
let nums: Vec&lt;i32&gt; = [&quot;1&quot;, &quot;2&quot;, &quot;whee!&quot;].iter().flat_map(|x| x.parse().ok()).collect();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// explicit_counter_loop
let v = vec![1];
fn bar(bar: usize, baz: usize) {}
for (i, item) in v.iter().enumerate() { bar(i, *item); }

// filter_map_identity
let iter = vec![Some(1)].into_iter();
iter.flatten();

// filter_next
let vec = vec![1];
vec.iter().find(|x| **x == 0);

// flat_map_identity
let iter = vec![vec![0]].into_iter();
iter.flatten();

// flat_map_option
let nums: Vec&lt;i32&gt; = [&quot;1&quot;, &quot;2&quot;, &quot;whee!&quot;].iter().filter_map(|x| x.parse().ok()).collect();

<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#explicit_counter_loop">explicit_counter_loop</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#filter_map_identity">filter_map_identity</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#filter_next">filter_next</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#flat_map_identity">flat_map_identity</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#flat_map_option">flat_map_option</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h2 id="可以使用cowstr来代替直接使用字符串它可以减少copy"><a class="header" href="#可以使用cowstr来代替直接使用字符串它可以减少copy">可以使用<code>Cow&lt;str&gt;</code>来代替直接使用字符串，它可以减少Copy</a></h2>
<p><strong>【描述】</strong></p>
<p>使用 <code>Cow&lt;str&gt;</code> 作为字符串处理函数参数和返回值，可以尽可能地减少数据Copy 和 内存分配。当字符串没有修改的时候，实际使用的是 <code>&amp;'a str</code>，只有当数据修改的时候才会使用<code>String</code>。对于读操作大于写操作的场景，使用 <code>Cow&lt;str&gt;</code> 比较合适。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 对输入的字符串进行转义
pub fn naive&lt;'a, S: Into&lt;Cow&lt;'a, str&gt;&gt;&gt;(input: S) -&gt; Cow&lt;'a, str&gt; {
    let input = input.into();
    fn is_trouble(c: char) -&gt; bool {
        c == '&lt;' || c == '&gt;' || c == '&amp;'
    }

    if input.contains(is_trouble) {
        let mut output = String::with_capacity(input.len());
        for c in input.chars() {
            match c {
                '&lt;' =&gt; output.push_str(&quot;&amp;lt;&quot;),
                '&gt;' =&gt; output.push_str(&quot;&amp;gt;&quot;),
                '&amp;' =&gt; output.push_str(&quot;&amp;amp;&quot;),
                _ =&gt; output.push(c)
            }
        }
        // 只有在字符串修改的时候才使用 String
        Cow::Owned(output)
    } else {
        //其他情况使用 &amp;str
        input
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="错误处理根据应用还是库来选择不同的错误处理方式"><a class="header" href="#错误处理根据应用还是库来选择不同的错误处理方式">错误处理：根据应用还是库来选择不同的错误处理方式</a></h2>
<p><strong>【描述】</strong></p>
<p>如果编写应用，建议使用<code> Error</code> trait对象；如果编写库，则建议返回自定义错误类型，方便下游处理</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 对于应用使用 Error trait 对象更加方便
pub fn print(&amp;self, languages: &amp;Languages) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {
     // do something
}

// 对于库，暴露自定义错误类型更加方便下游处理错误
#[derive(Debug)]
pub struct SendError&lt;T&gt;(pub T);

impl&lt;T&gt; fmt::Display for SendError&lt;T&gt; {
    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(fmt, &quot;channel closed&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="嵌入式no-std-将一些公用的类型函数宏等集中到一个自定义的-baremetal-std"><a class="header" href="#嵌入式no-std-将一些公用的类型函数宏等集中到一个自定义的-baremetal-std">嵌入式（no-std）: 将一些公用的类型、函数、宏等集中到一个自定义的 <code>baremetal-std</code></a></h2>
<p><strong>【描述】</strong></p>
<p>虽然 <code>no-std</code> 下不能用Rust 的标准库，但是可以自定义 <code>no-std</code> 下的标准库 <code>baremetal-std</code>，用于积累 <code>no-std</code> 下常用的公共库。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="j贡献说明"><a class="header" href="#j贡献说明">J.贡献说明</a></h1>
<p>欢迎直接提交 Issues 或 PR 直接参与评审和完善（包括精简、增补新的规则）编码规范。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="k淘汰的规则"><a class="header" href="#k淘汰的规则">K.淘汰的规则</a></h1>
<hr />
<h2 id="常量"><a class="header" href="#常量">常量</a></h2>
<h3 id="gcns03-不宜将量大的数据结构定义为常量"><a class="header" href="#gcns03-不宜将量大的数据结构定义为常量">G.CNS.03 不宜将量大的数据结构定义为常量</a></h3>
<p><strong>淘汰原因</strong></p>
<p>虽然常量本质上是会内联，但Rust 支持类似于复制消除（Copy Elision）的优化（非强制），而且在不断改进中，对于这种大的数据应该会有相关优化。这里建议用静态变量来代替常量，也许会引入使用的复杂性，所以这条规则被淘汰。只保留对固定长度数组相关的规则。</p>
<p>相应修改：[G.TYP.ARR.01] 的描述也有相对修改。</p>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>因为<a href="https://doc.rust-lang.org/reference/items/constant-items.html#constant-items">常量会到处内联</a>，即复制到各个使用到它的地方。而静态变量不会内联，它是全局的且有一个引用地址。
所以当要创建一个很大的常量数组时，应该考虑将其换成静态变量以提高程序运行效率。（详情可见：<a href="https://rust-lang.github.io/rfcs/0246-const-vs-static.html#motivation">const-vs-static</a>）</p>
<p>相关：[G.TYP.Array.01 ]</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    const MONTHS: [&amp;str; 12] = [&quot;January&quot;, &quot;Feburary&quot;, &quot;March&quot;, &quot;April&quot;,
                                &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;,
                                &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    static MONTHS: [&amp;str; 12] = [&quot;January&quot;, &quot;Feburary&quot;, &quot;March&quot;, &quot;April&quot;,
                                &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;,
                                &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p><strong>【定制化参考】</strong></p>
<p>这条规则如果需要定制Lint，则需要找出每个定义的常量再判断其空间占用，或可直接排除基础类型以外的数据类型。</p>
<h2 id="变量"><a class="header" href="#变量">变量</a></h2>
<h3 id="pvar02--禁止将局部变量的引用返回函数外"><a class="header" href="#pvar02--禁止将局部变量的引用返回函数外">P.VAR.02  禁止将局部变量的引用返回函数外</a></h3>
<p><strong>淘汰原因</strong></p>
<p>Rust 编译器可以检测到这种情况，之前考虑到编译器错误比较晦涩，列出该规则，但是进一步考虑到这个应该是 Rust 开发者最基本的认知，顾淘汰此规则。</p>
<p><strong>【描述】</strong></p>
<p>局部变量生命周期始于其声明终于其作用域结束。如果在其生命周期之外被引用，则程序的行为是未定义的。当然，Rust 编译器也会阻止你这么干。</p>
<p>*注： Rust 编译器可以检测到这种情况，但是编译器错误比较晦涩，本原则用来提示开发者注意这种情况。 *</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn makestr() -&gt; &amp;String {
    let a = &quot;test&quot;.to_string();
    &amp;a
}

pub fn main() {
    let a = makestr();
}
</code></pre></pre>
<h3 id="gvar01--交换两个变量的值应使用-swap-而非赋值"><a class="header" href="#gvar01--交换两个变量的值应使用-swap-而非赋值">G.VAR.01  交换两个变量的值应使用 <code>swap</code> 而非赋值</a></h3>
<p><strong>淘汰原因</strong></p>
<p>该条规则属于教程向，这应该是 Rust 开发者的基本认知。也不应该引导开发者使用swap。</p>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>对于包含 <code>swap</code> 方法的类型，如 <code>ptr</code>、<code>slice</code>、<code>Cell</code>、<code>RefCell</code>、<code>VecDeque</code> 等建议使用该类型的 <code>swap</code> 方法进行交换。</p>
<p>对其他类型可以使用函数 <code>std::mem::swap</code> 进行变量值的交换。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 1;
let mut b = 2;
let mut c = 0; // 辅助交换的变量
c = a;
a = b;
b = c;  
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 1;
let mut b = 2;
std::mem::swap(&amp;mut a, &amp;mut b);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p><strong>【定制化参考】</strong></p>
<p>这条规则如果需要定制Lint，则可以检测变量赋值操作，识别交换语义，推荐用户使用 <code>swap</code> 函数。</p>
<h2 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h2>
<h3 id="ptyp01-类型转换要尽量使用安全的方式"><a class="header" href="#ptyp01-类型转换要尽量使用安全的方式">P.TYP.01 类型转换要尽量使用安全的方式</a></h3>
<p><strong>淘汰原因</strong></p>
<p>和 G.TYP.01 有点重复。</p>
<p><strong>【描述】</strong></p>
<p>Rust 中的类型转换有多种方式，其中 <code>as</code> 强转、Unsafe 的 <code>std::mem::transmute</code> 为不安全转换。<code>From/Into</code>安全转换函数为安全转换。在使用类型转换时，应优先使用安全转换方式。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 产生数据截断
let a = i32::MAX;
let b = a as u16; 
println!(&quot;{}, {}&quot;, a, b); // 2147483647, 65535

// 产生精度损失
let a = std::f64::consts::PI;
let b = a as f32; 
println!(&quot;{}, {}&quot;, a, b); // 3.141592653589793, 3.1415927

// 结果不正确
let a: f64 = 123456.0;
let b: i64 = unsafe {
std::mem::transmute(a)
};
println!(&quot;{}, {}&quot;, a, b); // 123456, 4683220244930494464
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: f32 = 123456.0; 
let b: f64 = a.try_into().expect(&quot;trans failed&quot;); 
println!(&quot;{}, {}&quot;, a, b); // 123456, 123456
<span class="boring">}
</span></code></pre></pre>
<h3 id="ptyp02--对数组和集合容器进行索引要使用-usize-类型"><a class="header" href="#ptyp02--对数组和集合容器进行索引要使用-usize-类型">P.TYP.02  对数组和集合容器进行索引要使用 <code>usize</code> 类型</a></h3>
<p><strong>淘汰原因</strong></p>
<p>这属于 Rust 开发者必备基本认知，有点偏教程向，故淘汰。</p>
<p><strong>【描述】</strong></p>
<p>Rust 中只允许索引为 <code>usize</code> 类型，因为：</p>
<ol>
<li>负索引是无意义的。</li>
<li><code>usize</code>和 裸指针大小相同，意味着指针算法不会有任何隐藏的强制转换</li>
<li><code>std::mem::size_of()</code> 和 <code>std::mem::align_of()</code> 的函数返回 <code>usize</code> 类型。</li>
<li><code>usize</code> 不会因为平台架构的切换而导致索引值被截断的问题，比如 将<code>u32</code>类型的索引 用到 16位大小的嵌入式平台就会出问题。</li>
</ol>
<h3 id="gtypunt01---当函数不关心返回值但要处理错误时应使用单元类型"><a class="header" href="#gtypunt01---当函数不关心返回值但要处理错误时应使用单元类型">G.TYP.UNT.01   当函数不关心返回值但要处理错误时应使用单元类型</a></h3>
<p><strong>淘汰原因</strong></p>
<p>这属于 Rust 开发者必备基本认知，有点偏教程向，故淘汰。</p>
<p><strong>【级别】</strong> 建议</p>
<p>【定制化参考】</p>
<p>可以检测使用 <code>Option&lt;T&gt;</code> 包含 <code>Error</code> 类型的情况，发出警告。</p>
<p><strong>【描述】</strong></p>
<p>单元类型代表 <code>无返回值</code>。当返回类型无返回值但要处理错误时，应使用Result&lt;(), Error&gt;类型，</p>
<p>而非Option类型。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f() -&gt; Option&lt;Error&gt; {
    
    // ...
    
    None
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 表示该函数要么成功，要么返回各自错误
fn f() -&gt; Result&lt;(), Error&gt; {
    
    // ...
    
    // Error handle
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<h3 id="gtypint02-对于大整数字面量宜使用十六进制表示"><a class="header" href="#gtypint02-对于大整数字面量宜使用十六进制表示">G.TYP.INT.02 对于大整数字面量宜使用十六进制表示</a></h3>
<p><strong>淘汰原因</strong></p>
<p>这个不做限制了，因人而异。</p>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>略</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = `255` 
let b = `65_535`
let c =`4_042_322_160` 
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = `0xFF`
let b = `0xFFFF`
let c = `0xF0F0_F0F0
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#decimal_literal_representation">decimal_literal_representation</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<h3 id="ptypref01--使用引用的时候要注意其生命周期不要重合"><a class="header" href="#ptypref01--使用引用的时候要注意其生命周期不要重合">P.TYP.REF.01  使用引用的时候要注意其生命周期不要重合</a></h3>
<p><strong>淘汰原因</strong></p>
<p>偏教程向，这应该是 Rust 开发者基本认知，而且编译器会报错。</p>
<p><strong>【描述】</strong></p>
<p>在使用 引用的时候，要注意分析其生命周期，不可变借用和可变借用之间，以及可变借用之间不要有重叠。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main(){
    let mut s = String::from(&quot;hello&quot;);
    // r1 是不可变借用，其生命周期和 可变借用 r3 重叠，所以会出问题
    let r1 = &amp;s; // no problem    ---------------- lifetime r1 start
    let r2 = &amp;mut s; // no problem
    let r3 = &amp;mut s; // BIG PROBLEM -------------- lifetime r3 start 

    println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);  //  lifetime r1, r2, r3  end; 
    
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main(){
    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;mut s; // no problem
    let r3 = &amp;mut s; // no PROBLEM

    // println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
    
}
</code></pre></pre>
<h3 id="ptyptup01--宜使用元组解构来同时定义多个变量"><a class="header" href="#ptyptup01--宜使用元组解构来同时定义多个变量">P.TYP.TUP.01  宜使用元组解构来同时定义多个变量</a></h3>
<p><strong>淘汰原因</strong></p>
<p>偏教程向，这应该是 Rust 开发者基本认知。</p>
<p><strong>【描述】</strong></p>
<p>可以利用元组解构的特性，来更好地精简代码。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust">struct A(i32, i32);

fn hello( A(a, b): A){
    println!(&quot;{}, {}&quot;, a, b);
}

fn main(){
    let a = A(1, 2) ;
    hello(a);
}
</code></pre></pre>
<h3 id="ptyparr01-当数组长度在编译期就已经确定应优先使用固定长度数组而非动态数组-vect"><a class="header" href="#ptyparr01-当数组长度在编译期就已经确定应优先使用固定长度数组而非动态数组-vect">P.TYP.ARR.01 当数组长度在编译期就已经确定，应优先使用固定长度数组，而非动态数组（ <code>Vec&lt;T&gt;</code>）</a></h3>
<p><strong>淘汰原因</strong></p>
<p>偏教程向，这应该是 Rust 开发者基本认知。</p>
<p><strong>【描述】</strong></p>
<p>固定长度数组会根据元素类型，优先选择存储在栈上，可以优化内存分配。当然，过大的数组可以酌情考虑放到堆内存，这个依据具体场景来决定。</p>
<p>当编译期长度可以确定，但长度并不是唯一确定的，那么可以考虑使用常量泛型。注意：常量泛型特性从 Rust 1.51版稳定。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Grid {
    array: [u32; 5],
    width: usize,
    height: usize,
}
<span class="boring">}
</span></code></pre></pre>
<p>常量泛型：</p>
<pre><pre class="playground"><code class="language-rust">pub struct Grid&lt;T, const W: usize, const H: usize&gt;
where
{
    array: [[T; W]; H],
}

impl&lt;T, const W: usize, const H: usize&gt; Default for Grid&lt;T, W, H&gt;
where
    T: Default + Copy,
{
    fn default() -&gt; Self {
        Self {
            array: [[T::default(); W ]; H],
        }
    }
}

const WIDTH: usize = 300;
const HEIGHT: usize = 200;

fn main(){
    let _g = Grid::&lt;usize, 3, 4&gt;::default();  
    let _h = Grid::&lt;usize, WIDTH, HEIGHT&gt;::default();
}
</code></pre></pre>
<p>注意，常量泛型目前还有一些特性并未完善，比如下面示例中的 <code>#![feature(generic_const_exprs)]</code> 特性，需要在 Nightly Rust 下使用。</p>
<pre><pre class="playground"><code class="language-rust">#![feature(generic_const_exprs)]
pub struct Grid&lt;T, const W: usize, const H: usize&gt;
where
    [(); W * H]: Sized,
{
    array: [T; W * H],
}

impl&lt;T, const W: usize, const H: usize&gt; Default for Grid&lt;T, W, H&gt;
where
    [(); W * H]: Sized,
    T: Default + Copy,
{
    fn default() -&gt; Self {
        Self {
            array: [T::default(); W * H],
        }
    }
}

const WIDTH: usize = 300;
const HEIGHT: usize = 200;

fn main(){
    let _g = Grid::&lt;usize, 3, 4&gt;::default();  
    let _h = Grid::&lt;usize, WIDTH, HEIGHT&gt;::default();
}

</code></pre></pre>
<h3 id="ptypsct02--当需要很多构造函数或构造含有很多可选配置项时宜使用构建者模式"><a class="header" href="#ptypsct02--当需要很多构造函数或构造含有很多可选配置项时宜使用构建者模式">P.TYP.SCT.02  当需要很多构造函数，或构造含有很多可选配置项时，宜使用构建者模式</a></h3>
<p><strong>淘汰原因</strong></p>
<p>这条属于编程最佳实践，放到规范中有点臃肿，独立到最佳实践中。</p>
<p><strong>【描述】</strong></p>
<p>Rust 中没有默认的构造函数，都是自定义构造函数。</p>
<p>如果需要多个构造函数，或者构造时需要很多可选配置的复杂场景，那么构建者模式是适合你的选择。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq)]
pub struct Foo {
    // Lots of complicated fields.
    bar: String,
}

impl Foo {
    // This method will help users to discover the builder
    pub fn builder() -&gt; FooBuilder {
        FooBuilder::default()
    }
}

#[derive(Default)]
pub struct FooBuilder {
    // Probably lots of optional fields.
    bar: String,
}

impl FooBuilder {
    pub fn new(/* ... */) -&gt; FooBuilder {
        // Set the minimally required fields of Foo.
        FooBuilder {
            bar: String::from(&quot;X&quot;),
        }
    }

    pub fn name(mut self, bar: String) -&gt; FooBuilder {
        // Set the name on the builder itself, and return the builder by value.
        self.bar = bar;
        self
    }

    // If we can get away with not consuming the Builder here, that is an
    // advantage. It means we can use the FooBuilder as a template for constructing
    // many Foos.
    pub fn build(self) -&gt; Foo {
        // Create a Foo from the FooBuilder, applying all settings in FooBuilder
        // to Foo.
        Foo { bar: self.bar }
    }
}

#[test]
fn builder_test() {
    let foo = Foo {
        bar: String::from(&quot;Y&quot;),
    };
    let foo_from_builder: Foo = FooBuilder::new().name(String::from(&quot;Y&quot;)).build();
    assert_eq!(foo, foo_from_builder);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="ptypenm01-需要取出-enum-值的时候宜使用-stdmemtakeswapreplace"><a class="header" href="#ptypenm01-需要取出-enum-值的时候宜使用-stdmemtakeswapreplace">P.TYP.ENM.01 需要取出 Enum 值的时候宜使用 <code>std::mem::take/swap/replace</code></a></h3>
<p><strong>淘汰原因</strong></p>
<p>偏教程向。</p>
<p><strong>【描述】</strong></p>
<p>需要取出 Enum 中值的时候，可能会遇到所有权的限制，此时可以使用 <code>std::men::take</code> 获取当前的值，而将默认值替换原值，这样可以避免所有权的限制。</p>
<p>但是 <code>std::men::take</code> 只适合实现 <code>Default</code> 的类型，这样就有默认实现可以替换了。</p>
<p>如果没有实现 <code>Default</code> 的类型，可以使用 <code>std::men::swap</code> 或 <code>std::mem::replace</code> 用给定的值来替换原值。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

enum MultiVariateEnum {
    A { name: String },
    B { name: String },
    C,
    D
}

fn swizzle(e: &amp;mut MultiVariateEnum) {
    use MultiVariateEnum::*;
    *e = match e {
        // Ownership rules do not allow taking `name` by value, but we cannot
        // take the value out of a mutable reference, unless we replace it:
        A { name } =&gt; B { name: mem::take(name) },
        B { name } =&gt; A { name: mem::take(name) },
        C =&gt; D,
        D =&gt; C
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="表达式"><a class="header" href="#表达式">表达式</a></h2>
<h3 id="gexp04--不应使用无效表达式语句"><a class="header" href="#gexp04--不应使用无效表达式语句">G.EXP.04  不应使用无效表达式语句</a></h3>
<p><strong>淘汰原因</strong></p>
<p>属于代码逻辑问题，不应放到规范中。这类问题交给 Clippy 这类工具即可。</p>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>无效的表达式语句，虽然会执行，但实际并没有起到什么效果。</p>
<p>也有例外情况存在。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a+1;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 41;
let a = a+1;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>像在下面代码中，为了确保常量函数 <code>new</code> 可以在输入参数超出 MAX 限制的情况下 panic，使用了一个数组的技巧：<code> [&quot;tag number out of range&quot;][(byte &gt; Self::MAX) as usize];</code> 。因为目前 在常量上下文中还无法直接使用 <code>panic!</code>，等 <code>const_panic</code> 功能稳定就可以了。</p>
<p>如果不加 <code>#[allow(clippy::no_effect)]</code> ，Clippy 会有警告。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://docs.rs/crate/der/0.4.1/source/src/tag/number.rs

#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]
pub struct TagNumber(pub(super) u8);

impl TagNumber {
    /// Maximum tag number supported (inclusive).
    pub const MAX: u8 = 30;

    /// Create a new tag number (const-friendly).
    ///
    /// Panics if the tag number is greater than [`TagNumber::MAX`]. For a fallible
    /// conversion, use [`TryFrom`] instead.
    #[allow(clippy::no_effect)]
    pub const fn new(byte: u8) -&gt; Self {
        // TODO(tarcieri): hax! use const panic when available
        [&quot;tag number out of range&quot;][(byte &gt; Self::MAX) as usize];
        Self(byte)
    }
	// ...   
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#no_effect">no_effect</a></td><td>yes</td><td>no</td><td><strong>complexity</strong></td><td>warn</td></tr>
</tbody></table>
<h2 id="控制流程"><a class="header" href="#控制流程">控制流程</a></h2>
<h3 id="gctf01-避免在流程控制分支中使用重复代码"><a class="header" href="#gctf01-避免在流程控制分支中使用重复代码">G.CTF.01 避免在流程控制分支中使用重复代码</a></h3>
<p><strong>淘汰原因</strong></p>
<p>属于代码逻辑问题，不应放到规范中。这类问题交给 Clippy 这类工具即可。</p>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>略</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = if … {
    println!(&quot;Hello World&quot;);
    13
} else {
    println!(&quot;Hello World&quot;);
    42
};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Hello World&quot;);
let foo = if … {
    13
} else {
    42
};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#branches_sharing_code">branches_sharing_code</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
</tbody></table>
<h3 id="gctf02-控制流程的分支逻辑要保持精炼"><a class="header" href="#gctf02-控制流程的分支逻辑要保持精炼">G.CTF.02 控制流程的分支逻辑要保持精炼</a></h3>
<p><strong>淘汰原因</strong></p>
<p>属于代码逻辑问题，不应放到规范中。这类问题交给 Clippy 这类工具即可。</p>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>略</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>if x {
    …
} else {     // collapsible_else_if
    if y {
        …
    }
}

if x {  // collapsible_if
    if y {
        …
    }
}

// collapsible_match
fn func(opt: Option&lt;Result&lt;u64, String&gt;&gt;) {
    let n = match opt {
        Some(n) =&gt; match n {
            Ok(n) =&gt; n,
            _ =&gt; return,
        }
        None =&gt; return,
    };
}

// double_comparisons
<span class="boring">let x = 1;
</span><span class="boring">let y = 2;
</span>if x == y || x &lt; y {}

// wildcard_in_or_patterns    
match &quot;foo&quot; {
    &quot;a&quot; =&gt; {},
    &quot;bar&quot; | _ =&gt; {},
}

<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// else if
if x {
    …
} else if y {
    …
}

// Merge multiple conditions
if x &amp;&amp; y {
    …
}

// match 
fn func(opt: Option&lt;Result&lt;u64, String&gt;&gt;) {
    let n = match opt {
        Some(Ok(n)) =&gt; n,
        _ =&gt; return,
    };
}

// comparisons
<span class="boring">let x = 1;
</span><span class="boring">let y = 2;
</span>if x &lt;= y {}

// wildcard_in_or_patterns    
match &quot;foo&quot; {
    &quot;a&quot; =&gt; {},
    _ =&gt; {},
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#collapsible_else_if">collapsible_else_if</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#collapsible_if">collapsible_if</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#collapsible_match">collapsible_match</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#double_comparisons">double_comparisons</a></td><td>yes</td><td>no</td><td><strong>complexity</strong></td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#wildcard_in_or_patterns">wildcard_in_or_patterns</a></td><td>yes</td><td>no</td><td><strong>complexity</strong></td><td>warn</td></tr>
</tbody></table>
<h3 id="gctf06-善用标准库中提供的迭代器适配器方法来满足自己的需求"><a class="header" href="#gctf06-善用标准库中提供的迭代器适配器方法来满足自己的需求">G.CTF.06 善用标准库中提供的迭代器适配器方法来满足自己的需求</a></h3>
<p><strong>淘汰原因</strong></p>
<p>属于最佳实践编程技巧类。</p>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Rust 标准库中提供了很多迭代器方法，要学会使用它们，选择合适的方法来满足自己的需求。</p>
<p>下面示例中，反例中的迭代器适配器方法，都可以用对应的正例中的方法代替。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// explicit_counter_loop
let v = vec![1];
fn bar(bar: usize, baz: usize) {}
let mut i = 0;
for item in &amp;v {
    bar(i, *item);
    i += 1;
}

// filter_map_identity
let iter = vec![Some(1)].into_iter();
iter.filter_map(|x| x);

// filter_next
let vec = vec![1];
vec.iter().filter(|x| **x == 0).next();

// flat_map_identity
let iter = vec![vec![0]].into_iter();
iter.flat_map(|x| x);

// flat_map_option
let nums: Vec&lt;i32&gt; = [&quot;1&quot;, &quot;2&quot;, &quot;whee!&quot;].iter().flat_map(|x| x.parse().ok()).collect();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// explicit_counter_loop
let v = vec![1];
fn bar(bar: usize, baz: usize) {}
for (i, item) in v.iter().enumerate() { bar(i, *item); }

// filter_map_identity
let iter = vec![Some(1)].into_iter();
iter.flatten();

// filter_next
let vec = vec![1];
vec.iter().find(|x| **x == 0);

// flat_map_identity
let iter = vec![vec![0]].into_iter();
iter.flatten();

// flat_map_option
let nums: Vec&lt;i32&gt; = [&quot;1&quot;, &quot;2&quot;, &quot;whee!&quot;].iter().filter_map(|x| x.parse().ok()).collect();

<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#explicit_counter_loop">explicit_counter_loop</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#filter_map_identity">filter_map_identity</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#filter_next">filter_next</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#flat_map_identity">flat_map_identity</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#flat_map_option">flat_map_option</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h2 id="字符串"><a class="header" href="#字符串">字符串</a></h2>
<h3 id="pstr03--可以使用cowstr来代替直接使用字符串它可以减少copy"><a class="header" href="#pstr03--可以使用cowstr来代替直接使用字符串它可以减少copy">P.STR.03  可以使用<code>Cow&lt;str&gt;</code>来代替直接使用字符串，它可以减少Copy</a></h3>
<p><strong>淘汰原因</strong></p>
<p>最佳实践编程技巧类。</p>
<p><strong>【描述】</strong></p>
<p>使用 <code>Cow&lt;str&gt;</code> 作为字符串处理函数参数和返回值，可以尽可能地减少数据Copy 和 内存分配。当字符串没有修改的时候，实际使用的是 <code>&amp;'a str</code>，只有当数据修改的时候才会使用<code>String</code>。对于读操作大于写操作的场景，使用 <code>Cow&lt;str&gt;</code> 比较合适。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 对输入的字符串进行转义
pub fn naive&lt;'a, S: Into&lt;Cow&lt;'a, str&gt;&gt;&gt;(input: S) -&gt; Cow&lt;'a, str&gt; {
    let input = input.into();
    fn is_trouble(c: char) -&gt; bool {
        c == '&lt;' || c == '&gt;' || c == '&amp;'
    }

    if input.contains(is_trouble) {
        let mut output = String::with_capacity(input.len());
        for c in input.chars() {
            match c {
                '&lt;' =&gt; output.push_str(&quot;&amp;lt;&quot;),
                '&gt;' =&gt; output.push_str(&quot;&amp;gt;&quot;),
                '&amp;' =&gt; output.push_str(&quot;&amp;amp;&quot;),
                _ =&gt; output.push(c)
            }
        }
        // 只有在字符串修改的时候才使用 String
        Cow::Owned(output)
    } else {
        //其他情况使用 &amp;str
        input
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="集合容器"><a class="header" href="#集合容器">集合容器</a></h2>
<h3 id="pclt01--根据集合各自的特点选择合适的集合类型"><a class="header" href="#pclt01--根据集合各自的特点选择合适的集合类型">P.CLT.01  根据集合各自的特点选择合适的集合类型</a></h3>
<p><strong>淘汰原因</strong></p>
<p>文档教程向，不该放到规范中。</p>
<p><strong>【描述】</strong></p>
<p>Rust 标准库内置的集合类型，在安全和性能方面还是比较靠谱的。需要仔细阅读标准库中各类集合类型的优缺点来选择合适的类型。</p>
<p><strong>下列场景考虑 <code>Vec</code></strong></p>
<ul>
<li>你想要一个可动态增长大小（堆分配）的数组</li>
<li>你想要一个栈结构</li>
<li>你想要集合元素按特定顺序排序，并且仅需要在结尾追加新元素</li>
<li>你可能只是想临时收集一些元素，并且不关心它们的实际存储</li>
</ul>
<p><strong>下列场景考虑 <code>VecDeque</code></strong></p>
<ul>
<li>你想要一个可以在头尾两端插入元素的 <code>Vec</code></li>
<li>你想要一个队列，或双端队列</li>
</ul>
<p><strong>下列场景考虑<code>LinkedList</code></strong></p>
<ul>
<li>你非常确定你真的需要一个双向链表</li>
</ul>
<p><strong>下列场景考虑 <code>Hashmap</code></strong></p>
<ul>
<li>你需要一个 KV  集合</li>
<li>你想要一个缓存</li>
</ul>
<p><strong>下列场景考虑 <code>BTreeMap</code></strong></p>
<ul>
<li>你需要一个可以排序的 <code>HashMap</code></li>
<li>你希望可以按需获取一系列元素</li>
<li>你对最小或最大的 KV 感兴趣</li>
<li>你想要寻找比某个值更大或更小的键</li>
</ul>
<p><strong>下列场景考虑使用 <code>Set</code> 系列</strong></p>
<ul>
<li>你只是需要一个 Set 集合，而不需要键值对。</li>
</ul>
<p><strong>下列场景考虑使用 <code>BinaryHeap</code></strong></p>
<ul>
<li>你想存储一堆元素，但只想在任何给定时间内处理 最大 或 最重要的元素</li>
<li>你想要一个优先队列</li>
</ul>
<h2 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h2>
<h3 id="perr02--当函数的返回值或者结构体字段的值可能为空时请使用optiont"><a class="header" href="#perr02--当函数的返回值或者结构体字段的值可能为空时请使用optiont">P.ERR.02  当函数的返回值或者结构体字段的值可能为空时，请使用<code>Option&lt;T&gt;</code></a></h3>
<p><strong>淘汰原因</strong></p>
<p>教程向，不该放到规范中。</p>
<p><strong>【描述】</strong></p>
<p>在某些其他语言中，如果函数的返回值 或 结构体字段的值 可能为空时，通常会设置一个 “哨兵值（Sentinel Value）” 来应对这种问题，比如使用一个 <code>nil</code> 或 <code>-1</code> 等特殊值来判断这类情况。</p>
<p>但是，在 Rust 中不需要这样，Rust 提供了 <code>Option&lt;T&gt;</code> 类型就是专门用于应对这类情况。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">struct Config {
    must: String,
    opt: Option&lt;String&gt;,
}

// OR

fn main() {
    let sentence = &quot;The fox jumps over the dog&quot;;
    let index = sentence.find(&quot;fox&quot;);

    if let Some(fox) = index {
        let words_after_fox = &amp;sentence[fox..];
        println!(&quot;{}&quot;, words_after_fox);
    }
}
</code></pre></pre>
<h3 id="perr04---当程序中需要处理错误时应该使用-resultt-e-和--操作符"><a class="header" href="#perr04---当程序中需要处理错误时应该使用-resultt-e-和--操作符">P.ERR.04   当程序中需要处理错误时，应该使用 <code>Result&lt;T, E&gt;</code> 和 <code>?</code> 操作符</a></h3>
<p><strong>淘汰原因</strong></p>
<p>教程向，不该放到规范中。</p>
<p><strong>【描述】</strong></p>
<p>当需要处理错误时，为了保证 程序的健壮性，应该尽可能处理错误。</p>
<p><strong>【反例】</strong></p>
<p>在实现原型类项目的时候，可以“快、糙、猛”地使用 <code>expect</code>  。但是要进生产环境，需要合理地处理错误。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let res: Result&lt;usize, ()&gt; = Ok(1);
res.expect(&quot;one&quot;); // 如果有 Err， expect会 Panic ！

<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let res: Result&lt;usize, ()&gt; = Ok(1);
res?;   // Ok::&lt;(), ()&gt;(())
<span class="boring">}
</span></code></pre></pre>
<h3 id="perr06---根据应用还是库来选择不同的错误处理方式"><a class="header" href="#perr06---根据应用还是库来选择不同的错误处理方式">P.ERR.06   根据应用还是库来选择不同的错误处理方式</a></h3>
<p><strong>淘汰原因</strong></p>
<p>最佳实践向，不该放到规范中。</p>
<p><strong>【描述】</strong></p>
<p>如果编写应用，建议使用<code> Error</code> trait对象；如果编写库，则建议返回自定义错误类型，方便下游处理</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 对于应用使用 Error trait 对象更加方便
pub fn print(&amp;self, languages: &amp;Languages) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {
     // do something
}

// 对于库，暴露自定义错误类型更加方便下游处理错误
#[derive(Debug)]
pub struct SendError&lt;T&gt;(pub T);

impl&lt;T&gt; fmt::Display for SendError&lt;T&gt; {
    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(fmt, &quot;channel closed&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="perr03---当程序中有不可恢复的错误时应该让其-panic"><a class="header" href="#perr03---当程序中有不可恢复的错误时应该让其-panic">P.ERR.03   当程序中有不可恢复的错误时，应该让其 Panic</a></h3>
<p><strong>淘汰原因</strong></p>
<p>教程向，不该放到规范中。</p>
<p><strong>【描述】</strong></p>
<p>如果遇到无法恢复的错误，则需要让程序 Panic。</p>
<p>相关 Clippy Lint： <a href="https://rust-lang.github.io/rust-clippy/master/#if_then_panic">if_then_panic</a> </p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn boot(ptr: *const usize) {
	if ptr.is_null() {
        panic!(&quot;ptr is null! boot failed!&quot;)
    }
    // or
    assert!(ptr.is_null(), &quot;ptr is null! boot failed!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="多线程"><a class="header" href="#多线程">多线程</a></h2>
<h3 id="pmthlok01-根据场景选择使用互斥锁还是-channel"><a class="header" href="#pmthlok01-根据场景选择使用互斥锁还是-channel">P.MTH.LOK.01 根据场景选择使用互斥锁还是 Channel</a></h3>
<p><strong>淘汰原因</strong></p>
<p>教程向，不该放到规范中。</p>
<p><strong>【描述】</strong></p>
<p>不要从哪种方式更快的角度来考虑，而应该从使用场景。性能取决于开发者如何使用它们。</p>
<p>一个简单的指南：</p>
<table><thead><tr><th><strong>Channel</strong> 适用于</th><th><strong>Mutex</strong> 适用于</th></tr></thead><tbody>
<tr><td>传递数据所有权 <br /> 分发工作单元 <br /> 传递异步结果</td><td>修改共享缓存<br /> 修改共享状态</td></tr>
</tbody></table>
<h3 id="gmthlok02-多线程环境下宜使用-arc-代替-rc"><a class="header" href="#gmthlok02-多线程环境下宜使用-arc-代替-rc">G.MTH.LOK.02 多线程环境下宜使用 <code>Arc</code> 代替 <code>Rc</code></a></h3>
<p><strong>淘汰原因</strong></p>
<p>教程向，不该放到规范中。</p>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p><code>Rc</code> 是专门用于单线程的，多线程下应该用 <code>Arc</code> 。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use std::sync::Mutex;
fn foo(interned: Rc&lt;Mutex&lt;i32&gt;&gt;) { ... }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use std::sync::Arc;
use std::cell::RefCell
fn foo(interned: Rc&lt;RefCell&lt;i32&gt;&gt;) { ... }
// or
fn foo(interned: Arc&lt;Mutex&lt;i32&gt;&gt;) { ... }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#rc_mutex">rc_mutex</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<h2 id="no-std"><a class="header" href="#no-std">no-std</a></h2>
<h3 id="pemb03--将一些公用的类型函数宏等集中到一个自定义的-baremetal-std"><a class="header" href="#pemb03--将一些公用的类型函数宏等集中到一个自定义的-baremetal-std">P.EMB.03  将一些公用的类型、函数、宏等集中到一个自定义的 <code>baremetal-std</code></a></h3>
<p><strong>淘汰原因</strong></p>
<p>最佳实践向，不该放到规范中。</p>
<p><strong>【描述】</strong></p>
<p>虽然 <code>no-std</code> 下不能用Rust 的标准库，但是可以自定义 <code>no-std</code> 下的标准库 <code>baremetal-std</code>，用于积累 <code>no-std</code> 下常用的公共库。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
